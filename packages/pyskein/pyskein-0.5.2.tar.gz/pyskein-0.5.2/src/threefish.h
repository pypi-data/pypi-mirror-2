/* Definitions of unrolled rounds for Threefish encryption and decryption.

   Based on an implementation by Doug Whiting released to the public domain.
   Modified and extended by Hagen Fuerstenau.
*/


#define BLK_BITS        (WCNT*64)
#define ks              (kw+3)
#define ts              (kw)

void Threefish_256_encrypt(u64b_t *kw, const u64b_t *w, u64b_t *out, int feed);
void Threefish_512_encrypt(u64b_t *kw, const u64b_t *w, u64b_t *out, int feed);
void Threefish_1024_encrypt(u64b_t *kw, const u64b_t *w, u64b_t *out, int feed);

void Threefish_256_decrypt(u64b_t *kw, const u64b_t *w, u64b_t *out);
void Threefish_512_decrypt(u64b_t *kw, const u64b_t *w, u64b_t *out);
void Threefish_1024_decrypt(u64b_t *kw, const u64b_t *w, u64b_t *out);


/* Skein-256 */

#define R256(p0,p1,p2,p3,ROT)                                       \
    X##p0 += X##p1; X##p1 = RotL_64(X##p1,ROT##_0); X##p1 ^= X##p0; \
    X##p2 += X##p3; X##p3 = RotL_64(X##p3,ROT##_1); X##p3 ^= X##p2;

#define I256(R)                                                   \
    X0 += ks[((R)+1) % 5];    /* inject the key schedule value */ \
    X1 += ks[((R)+2) % 5] + ts[((R)+1) % 3];                      \
    X2 += ks[((R)+3) % 5] + ts[((R)+2) % 3];                      \
    X3 += ks[((R)+4) % 5] +     (R)+1;

#define R256_8_rounds(R)        \
        R256(0,1,2,3,R_256_0);  \
        R256(0,3,2,1,R_256_1);  \
        R256(0,1,2,3,R_256_2);  \
        R256(0,3,2,1,R_256_3);  \
        I256(2*(R));            \
        R256(0,1,2,3,R_256_4);  \
        R256(0,3,2,1,R_256_5);  \
        R256(0,1,2,3,R_256_6);  \
        R256(0,3,2,1,R_256_7);  \
        I256(2*(R)+1);

#define INV_R256(p0,p1,p2,p3,ROT)                           \
    X##p1 = RotR_64(X##p0^X##p1, ROT##_0); X##p0 -= X##p1; \
    X##p3 = RotR_64(X##p2^X##p3, ROT##_1); X##p2 -= X##p3;

#define INV_I256(R)                          \
    X0 -= ks[((R)+1) % 5];                   \
    X1 -= ks[((R)+2) % 5] + ts[((R)+1) % 3]; \
    X2 -= ks[((R)+3) % 5] + ts[((R)+2) % 3]; \
    X3 -= ks[((R)+4) % 5] +     (R)+1;

#define INV_R256_8_rounds(R)       \
        INV_I256(2*(R)+1);         \
        INV_R256(0,3,2,1,R_256_7); \
        INV_R256(0,1,2,3,R_256_6); \
        INV_R256(0,3,2,1,R_256_5); \
        INV_R256(0,1,2,3,R_256_4); \
        INV_I256(2*(R));           \
        INV_R256(0,3,2,1,R_256_3); \
        INV_R256(0,1,2,3,R_256_2); \
        INV_R256(0,3,2,1,R_256_1); \
        INV_R256(0,1,2,3,R_256_0);


/* Skein-512 */

#define R512(p0,p1,p2,p3,p4,p5,p6,p7,ROT)                           \
    X##p0 += X##p1; X##p1 = RotL_64(X##p1,ROT##_0); X##p1 ^= X##p0; \
    X##p2 += X##p3; X##p3 = RotL_64(X##p3,ROT##_1); X##p3 ^= X##p2; \
    X##p4 += X##p5; X##p5 = RotL_64(X##p5,ROT##_2); X##p5 ^= X##p4; \
    X##p6 += X##p7; X##p7 = RotL_64(X##p7,ROT##_3); X##p7 ^= X##p6; \

#define I512(R)                                                     \
    X0   += ks[((R)+1) % 9];   /* inject the key schedule value */  \
    X1   += ks[((R)+2) % 9];                                        \
    X2   += ks[((R)+3) % 9];                                        \
    X3   += ks[((R)+4) % 9];                                        \
    X4   += ks[((R)+5) % 9];                                        \
    X5   += ks[((R)+6) % 9] + ts[((R)+1) % 3];                      \
    X6   += ks[((R)+7) % 9] + ts[((R)+2) % 3];                      \
    X7   += ks[((R)+8) % 9] +     (R)+1;

#define R512_8_rounds(R)                 \
        R512(0,1,2,3,4,5,6,7,R_512_0);   \
        R512(2,1,4,7,6,5,0,3,R_512_1);   \
        R512(4,1,6,3,0,5,2,7,R_512_2);   \
        R512(6,1,0,7,2,5,4,3,R_512_3);   \
        I512(2*(R));                     \
        R512(0,1,2,3,4,5,6,7,R_512_4);   \
        R512(2,1,4,7,6,5,0,3,R_512_5);   \
        R512(4,1,6,3,0,5,2,7,R_512_6);   \
        R512(6,1,0,7,2,5,4,3,R_512_7);   \
        I512(2*(R)+1);

#define INV_R512(p0,p1,p2,p3,p4,p5,p6,p7,ROT)              \
    X##p1 = RotR_64(X##p0^X##p1, ROT##_0); X##p0 -= X##p1; \
    X##p3 = RotR_64(X##p2^X##p3, ROT##_1); X##p2 -= X##p3; \
    X##p5 = RotR_64(X##p4^X##p5, ROT##_2); X##p4 -= X##p5; \
    X##p7 = RotR_64(X##p6^X##p7, ROT##_3); X##p6 -= X##p7;

#define INV_I512(R)                          \
    X0 -= ks[((R)+1) % 9];                   \
    X1 -= ks[((R)+2) % 9];                   \
    X2 -= ks[((R)+3) % 9];                   \
    X3 -= ks[((R)+4) % 9];                   \
    X4 -= ks[((R)+5) % 9];                   \
    X5 -= ks[((R)+6) % 9] + ts[((R)+1) % 3]; \
    X6 -= ks[((R)+7) % 9] + ts[((R)+2) % 3]; \
    X7 -= ks[((R)+8) % 9] +     (R)+1;

#define INV_R512_8_rounds(R)               \
        INV_I512(2*(R)+1);                 \
        INV_R512(6,1,0,7,2,5,4,3,R_512_7); \
        INV_R512(4,1,6,3,0,5,2,7,R_512_6); \
        INV_R512(2,1,4,7,6,5,0,3,R_512_5); \
        INV_R512(0,1,2,3,4,5,6,7,R_512_4); \
        INV_I512(2*(R));                   \
        INV_R512(6,1,0,7,2,5,4,3,R_512_3); \
        INV_R512(4,1,6,3,0,5,2,7,R_512_2); \
        INV_R512(2,1,4,7,6,5,0,3,R_512_1); \
        INV_R512(0,1,2,3,4,5,6,7,R_512_0);


/* Skein-1024 */

#define R1024(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pA,pB,pC,pD,pE,pF,ROT) \
    X##p0 += X##p1; X##p1 = RotL_64(X##p1,ROT##_0); X##p1 ^= X##p0;   \
    X##p2 += X##p3; X##p3 = RotL_64(X##p3,ROT##_1); X##p3 ^= X##p2;   \
    X##p4 += X##p5; X##p5 = RotL_64(X##p5,ROT##_2); X##p5 ^= X##p4;   \
    X##p6 += X##p7; X##p7 = RotL_64(X##p7,ROT##_3); X##p7 ^= X##p6;   \
    X##p8 += X##p9; X##p9 = RotL_64(X##p9,ROT##_4); X##p9 ^= X##p8;   \
    X##pA += X##pB; X##pB = RotL_64(X##pB,ROT##_5); X##pB ^= X##pA;   \
    X##pC += X##pD; X##pD = RotL_64(X##pD,ROT##_6); X##pD ^= X##pC;   \
    X##pE += X##pF; X##pF = RotL_64(X##pF,ROT##_7); X##pF ^= X##pE;   \

#define I1024(R)                                                      \
    X00   += ks[((R)+ 1) % 17]; /* inject the key schedule value */   \
    X01   += ks[((R)+ 2) % 17];                                       \
    X02   += ks[((R)+ 3) % 17];                                       \
    X03   += ks[((R)+ 4) % 17];                                       \
    X04   += ks[((R)+ 5) % 17];                                       \
    X05   += ks[((R)+ 6) % 17];                                       \
    X06   += ks[((R)+ 7) % 17];                                       \
    X07   += ks[((R)+ 8) % 17];                                       \
    X08   += ks[((R)+ 9) % 17];                                       \
    X09   += ks[((R)+10) % 17];                                       \
    X10   += ks[((R)+11) % 17];                                       \
    X11   += ks[((R)+12) % 17];                                       \
    X12   += ks[((R)+13) % 17];                                       \
    X13   += ks[((R)+14) % 17] + ts[((R)+1) % 3];                     \
    X14   += ks[((R)+15) % 17] + ts[((R)+2) % 3];                     \
    X15   += ks[((R)+16) % 17] +     (R)+1;

#define R1024_8_rounds(R)                                           \
    R1024(00,01,02,03,04,05,06,07,08,09,10,11,12,13,14,15,R_1024_0); \
    R1024(00,09,02,13,06,11,04,15,10,07,12,03,14,05,08,01,R_1024_1); \
    R1024(00,07,02,05,04,03,06,01,12,15,14,13,08,11,10,09,R_1024_2); \
    R1024(00,15,02,11,06,13,04,09,14,01,08,05,10,03,12,07,R_1024_3); \
    I1024(2*(R));                                                   \
    R1024(00,01,02,03,04,05,06,07,08,09,10,11,12,13,14,15,R_1024_4); \
    R1024(00,09,02,13,06,11,04,15,10,07,12,03,14,05,08,01,R_1024_5); \
    R1024(00,07,02,05,04,03,06,01,12,15,14,13,08,11,10,09,R_1024_6); \
    R1024(00,15,02,11,06,13,04,09,14,01,08,05,10,03,12,07,R_1024_7); \
    I1024(2*(R)+1);

#define INV_R1024(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pA,pB,pC,pD,pE,pF,ROT) \
    X##p1 = RotR_64(X##p0^X##p1, ROT##_0); X##p0 -= X##p1;             \
    X##p3 = RotR_64(X##p2^X##p3, ROT##_1); X##p2 -= X##p3;             \
    X##p5 = RotR_64(X##p4^X##p5, ROT##_2); X##p4 -= X##p5;             \
    X##p7 = RotR_64(X##p6^X##p7, ROT##_3); X##p6 -= X##p7;             \
    X##p9 = RotR_64(X##p8^X##p9, ROT##_4); X##p8 -= X##p9;             \
    X##pB = RotR_64(X##pA^X##pB, ROT##_5); X##pA -= X##pB;             \
    X##pD = RotR_64(X##pC^X##pD, ROT##_6); X##pC -= X##pD;             \
    X##pF = RotR_64(X##pE^X##pF, ROT##_7); X##pE -= X##pF;

#define INV_I1024(R)                            \
    X00 -= ks[((R)+ 1) % 17];                   \
    X01 -= ks[((R)+ 2) % 17];                   \
    X02 -= ks[((R)+ 3) % 17];                   \
    X03 -= ks[((R)+ 4) % 17];                   \
    X04 -= ks[((R)+ 5) % 17];                   \
    X05 -= ks[((R)+ 6) % 17];                   \
    X06 -= ks[((R)+ 7) % 17];                   \
    X07 -= ks[((R)+ 8) % 17];                   \
    X08 -= ks[((R)+ 9) % 17];                   \
    X09 -= ks[((R)+10) % 17];                   \
    X10 -= ks[((R)+11) % 17];                   \
    X11 -= ks[((R)+12) % 17];                   \
    X12 -= ks[((R)+13) % 17];                   \
    X13 -= ks[((R)+14) % 17] + ts[((R)+1) % 3]; \
    X14 -= ks[((R)+15) % 17] + ts[((R)+2) % 3]; \
    X15 -= ks[((R)+16) % 17] +     (R)+1;

#define INV_R1024_8_rounds(R)                                           \
    INV_I1024(2*(R)+1);                                                 \
    INV_R1024(00,15,02,11,06,13,04,09,14,01,08,05,10,03,12,07,R_1024_7); \
    INV_R1024(00,07,02,05,04,03,06,01,12,15,14,13,08,11,10,09,R_1024_6); \
    INV_R1024(00,09,02,13,06,11,04,15,10,07,12,03,14,05,08,01,R_1024_5); \
    INV_R1024(00,01,02,03,04,05,06,07,08,09,10,11,12,13,14,15,R_1024_4); \
    INV_I1024(2*(R));                                                   \
    INV_R1024(00,15,02,11,06,13,04,09,14,01,08,05,10,03,12,07,R_1024_3); \
    INV_R1024(00,07,02,05,04,03,06,01,12,15,14,13,08,11,10,09,R_1024_2); \
    INV_R1024(00,09,02,13,06,11,04,15,10,07,12,03,14,05,08,01,R_1024_1); \
    INV_R1024(00,01,02,03,04,05,06,07,08,09,10,11,12,13,14,15,R_1024_0);
