PySkein 0.2
-----------

This software provides the family of Skein hashing algorithms
in a Python module.  I wrote it mainly to teach myself how to write
Python extension modules, and to enable convenient experimentation with
and analysis of these recently proposed algorithms.
(for information on Skein, see http://www.schneier.com/skein.html)

PySkein is based on the optimized implementation of Skein by Doug Whiting.
My own contribution is merely wrapping this C implementation into
a Python interface which is familiar from the Python standard library's
hashlib module.


Installation
------------

You need a Python version >= 3.0!
To install globally run e.g. (with appropriate permissions)

python3.0 setup.py install

To install locally (e.g. into your home directory) run something like

python3.0 setup.py install --user


Mini-documentation
------------------

After installation we can import three functions from the skein module:

>>> from skein import skein256, skein512, skein1024

The numbers indicate the internal state sizes of the algorithms in bits.
Let's continue with skein512, the other two work analogously.
We create a new hashing object with

>> hasher = skein512()

This sets the (output) digest length to its default value, which is the same
as the state size, i.e. 512 bits for skein512. To specify a different
digest length we can specify e.g.

>> hasher2 = skein512(digest_bits=256)

This creates an object implementing the Skein-512-256 algorithm, i.e. 512 bits
of internal state and 256 bits of digest output.  (Any multiple of 8 is
possible for the digest length.) The full signature of the constructor
functions is:

skein256(init=b"", digest_bits=256, mac=b"")
skein512(init=b"", digest_bits=512, mac=b"")
skein1024(init=b"", digest_bits=1024, mac=b"")

where "mac" is the optional message authentication code as implemented in Skein.
The rest of the interface is more or less the same as for the algorithms
in the standard library's hashlib module:

>>> hasher2.update(b"foo")
>>> hasher2.digest()
b'\xf9\xfc\xe6\xe5\x02J\xb0\n\xce[\x05+YfU\x0f\xfb\xe8\xe5Z\x85K\xe6\xec0W*\xd2\x90\xa7v\xd4'
>>> hasher2.hexdigest()
'f9fce6e5024ab00ace5b052b5966550ffbe8e55a854be6ec30572ad290a776d4'


The internally used Threefish block cipher is also accessible for encryption:

>>> from skein import threefish
>>> c = threefish(b"key of 32,64 or 128 bytes length", b"tweak: 16 bytes ")
>>> c.encrypt_block(b"block of data,same length as key")
b"\x96\xb9\x9f\xefk\xe6\x9d\xc2\x17\xd8d\xc1+\xa6\xe0\x87\xa9\xc7\xa0R\xdd\x9c'\x02\xee\\\r\xa0\xa7y\xba\xa9"


Changes
-------

0.2
* added support for message authentication codes
* added support for Threefish single block encryption
* fixed one or two reference leaks

0.1
* initial release
