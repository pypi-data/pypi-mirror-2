<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Demonstration Command Scripts in Python</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="athenaCL Tutorial Manual"
HREF="index.htm"><LINK
REL="PREVIOUS"
TITLE="OutputEngines"
HREF="x2956.htm"><LINK
REL="NEXT"
TITLE="Csound-based Output"
HREF="x3083.htm"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="manual.css"></HEAD
><BODY
CLASS="APPENDIX"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>athenaCL Tutorial Manual: Third Edition, Version 2.0.0a15</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x2956.htm"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x3083.htm"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="APPENDIX"
><H1
><A
NAME="AX06"
></A
>Appendix F. Demonstration Command Scripts in Python</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>F.1. <A
HREF="ax06.htm#AEN2988"
>MIDI-based Output</A
></DT
><DD
><DL
><DT
>F.1.1. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT01A.PY"
>script01a.py: Configuring Rhythms</A
></DT
><DT
>F.1.2. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT01B.PY"
>script01b.py: Configuring Time Range</A
></DT
><DT
>F.1.3. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT02A.PY"
>script02a.py: Building a Basic Beat</A
></DT
><DT
>F.1.4. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT02B.PY"
>script02b.py: Building a Basic Beat with a Complex Snare Part</A
></DT
><DT
>F.1.5. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT02C.PY"
>script02c.py: Building a Basic Beat with Canonic Snare Imitation</A
></DT
><DT
>F.1.6. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT02D.PY"
>script02d.py: Building an Extended Rhythmic Line with Canonic Imitation</A
></DT
><DT
>F.1.7. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT02E.PY"
>script02e.py: Creating Mensural Canons</A
></DT
><DT
>F.1.8. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT02F.PY"
>script02f.py: Building an Extended Rhythmic Line with Fixed Tempo Phasing</A
></DT
><DT
>F.1.9. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT02G.PY"
>script02g.py: Building an Extended Rhythmic Line with Dynamic Tempo Phasing</A
></DT
><DT
>F.1.10. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT03A.PY"
>script03a.py: Grouping Selection</A
></DT
><DT
>F.1.11. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT03B.PY"
>script03b.py: Tendency Mask: Random Values between Breakpoint Functions</A
></DT
><DT
>F.1.12. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT03C.PY"
>script03c.py: Tendency Mask: Random Values between Triangle Generators</A
></DT
><DT
>F.1.13. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT04A.PY"
>script04a.py: Large Scale Amplitude Behavior with Operators</A
></DT
><DT
>F.1.14. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT04B.PY"
>script04b.py: 1/f Noise in Melodic Generation: LineGroove</A
></DT
><DT
>F.1.15. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT04C.PY"
>script04c.py: 1/f Noise in Melodic Generation: HarmonicAssembly</A
></DT
><DT
>F.1.16. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT05A.PY"
>script05a.py: Self Similar Markovian Melody Generation and Transposition</A
></DT
><DT
>F.1.17. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT05B.PY"
>script05b.py: Markov-Based Proportional Rhythm Generation</A
></DT
><DT
>F.1.18. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT05C.PY"
>script05c.py: Markov-Based Value Generation</A
></DT
><DT
>F.1.19. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT06A.PY"
>script06a.py: Deploying Pitch Sieves with HarmonicAssembly</A
></DT
><DT
>F.1.20. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT07A.PY"
>script07a.py: The CA as a Generator of Melodies</A
></DT
><DT
>F.1.21. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT07B.PY"
>script07b.py: The CA as a Generator of Rhythms</A
></DT
><DT
>F.1.22. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT08A.PY"
>script08a.py: Evolving African Drum Patterns with a GA: Two Durations</A
></DT
><DT
>F.1.23. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT08B.PY"
>script08b.py: Evolving African Drum Patterns with a GA: Combinations of Rests and Silences</A
></DT
><DT
>F.1.24. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT08C.PY"
>script08c.py: Evolving African Drum Patterns with a GA: Multiple Rhythmic Values</A
></DT
><DT
>F.1.25. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT08D.PY"
>script08d.py: Evolving African Drum Patterns with a GA: Multiple Rhythmic Values</A
></DT
><DT
>F.1.26. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT09A.PY"
>script09a.py: Grammar States as Accent Patterns</A
></DT
><DT
>F.1.27. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT09B.PY"
>script09b.py: Grammar States as Pitch Values</A
></DT
><DT
>F.1.28. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT09C.PY"
>script09c.py: Grammar States as Pitch Transpositions</A
></DT
><DT
>F.1.29. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT09D.PY"
>script09d.py: Grammar States as Path Index Values</A
></DT
><DT
>F.1.30. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT10A.PY"
>script10a.py: Feedback System as Dynamic Contour</A
></DT
><DT
>F.1.31. <A
HREF="ax06.htm#PYSCRIPTMIDISCRIPT10B.PY"
>script10b.py: Feedback System as Path Index Values</A
></DT
></DL
></DD
><DT
>F.2. <A
HREF="x3083.htm"
>Csound-based Output</A
></DT
><DD
><DL
><DT
>F.2.1. <A
HREF="x3083.htm#PYSCRIPTCSOUNDSCRIPT01A.PY"
>script01a.py: Testing Csound</A
></DT
><DT
>F.2.2. <A
HREF="x3083.htm#PYSCRIPTCSOUNDSCRIPT01B.PY"
>script01b.py: A Noise Instrument</A
></DT
><DT
>F.2.3. <A
HREF="x3083.htm#PYSCRIPTCSOUNDSCRIPT01C.PY"
>script01c.py: A Sample Playback Instrument</A
></DT
><DT
>F.2.4. <A
HREF="x3083.htm#PYSCRIPTCSOUNDSCRIPT01D.PY"
>script01d.py: A Sample Playback Instrument with Variable Playback Rate</A
></DT
><DT
>F.2.5. <A
HREF="x3083.htm#PYSCRIPTCSOUNDSCRIPT02A.PY"
>script02a.py: Composing with Densities using TM TimeFill and a Noise Instrument</A
></DT
><DT
>F.2.6. <A
HREF="x3083.htm#PYSCRIPTCSOUNDSCRIPT02B.PY"
>script02b.py: Composing with Densities using TM TimeFill and a Single Sample</A
></DT
><DT
>F.2.7. <A
HREF="x3083.htm#PYSCRIPTCSOUNDSCRIPT03A.PY"
>script03a.py: Polyphonic Sine Grains LineGroove</A
></DT
><DT
>F.2.8. <A
HREF="x3083.htm#PYSCRIPTCSOUNDSCRIPT03B.PY"
>script03b.py: Polyphonic Sine Grains: DroneArticulate</A
></DT
><DT
>F.2.9. <A
HREF="x3083.htm#PYSCRIPTCSOUNDSCRIPT03C.PY"
>script03c.py: Polyphonic Sample Grains from a Single Audio File: LineGroove</A
></DT
><DT
>F.2.10. <A
HREF="x3083.htm#PYSCRIPTCSOUNDSCRIPT03D.PY"
>script03d.py: Polyphonic Sample Grains from a Multiple Audio Files: LineGroove</A
></DT
><DT
>F.2.11. <A
HREF="x3083.htm#PYSCRIPTCSOUNDSCRIPT03E.PY"
>script03e.py: Polyphonic Sample Grains from a Multiple Audio Files: LineGroove</A
></DT
></DL
></DD
></DL
></DIV
><P
>The following scripts provide both brief examples of how to programmatically send commands to the athenaCL Interpreter and also demonstrate numerous fundamental concepts and techniques. All .py files shown here are included in the athenaCL demo directory. Pre-rendered MIDI and Csound files are also included.</P
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN2988"
>F.1. MIDI-based Output</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT01A.PY"
>F.1.1. script01a.py: Configuring Rhythms</A
></H2
><PRE
CLASS="SCREEN"
># Configuring Rhythms
from athenaCL.libATH import athenaObj
cmd = [
'emo mp',   
'tin a 45', 
'tie a rb,.3,.3,.4,.8', 
'tie r pt,(c,4),(bg,oc,(3,3,2)),(c,1)', 
'tin b 65', 
'tie a re,15,.3,1', 
'tie r pt,(bg,rp,(2,1,1,1)),(c,1),(c,1)', 
'tin c 67', 
'tie a rb,.1,.1,.4,.6', 
'tie r cs,(rb,.2,.2,.01,1.5)', 
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT01B.PY"
>F.1.2. script01b.py: Configuring Time Range</A
></H2
><PRE
CLASS="SCREEN"
># Configuring Time Range
from athenaCL.libATH import athenaObj
ath = athenaObj.Interpreter()
cmd = [
'emo mp',
'tin a 45', 
'tie t 0,20', 
'tie a rb,.3,.3,.4,.8', 
'tie r pt,(c,4),(bg,oc,(3,3,2)),(c,1)', 
'tin b 65', 
'tie t 10,20', 
'tie a re,15,.3,1', 
'tie r pt,(bg,rp,(2,1,1,1)),(c,1),(c,1)', 
'tin c 67', 
'tie t 15,25', 
'tie a rb,.1,.1,.4,.6', 
'tie r cs,(rb,.2,.2,.01,1.5)', 
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT02A.PY"
>F.1.3. script02a.py: Building a Basic Beat</A
></H2
><PRE
CLASS="SCREEN"
># Building a Basic Beat
from athenaCL.libATH import athenaObj
cmd = [
'emo mp',
'tin a 36',
'tie r pt,(c,2),(bg,oc,(7,5,2,1,1)),(c,1)',
'tin b 37',
'tie r pt,(c,2),(bg,oc,(3,5)),(bg,oc,(0,1)) ',
'tin c 42',
'tie r pt,(c,2),(c,1),(bg,oc,(0,1))',
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT02B.PY"
>F.1.4. script02b.py: Building a Basic Beat with a Complex Snare Part</A
></H2
><PRE
CLASS="SCREEN"
># Building a Basic Beat with a Complex Snare Part
from athenaCL.libATH import athenaObj
cmd = [
'emo mp',
'tin a 36',
'tie r pt,(c,2),(bg,oc,(7,5,2,1,1)),(c,1)',
'tin b 37',
'tie r pt,(c,4),(bg,rp,(3,3,5,4,1)),(bg,oc,(0,1,1))',
'tin c 42',
'tie r pt,(c,2),(c,1),(bg,oc,(0,1))',
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT02C.PY"
>F.1.5. script02c.py: Building a Basic Beat with Canonic Snare Imitation</A
></H2
><PRE
CLASS="SCREEN"
># Building a Basic Beat with Canonic Snare Imitation
from athenaCL.libATH import athenaObj
cmd = [
'emo mp',
'tin a 36',
'tie r pt,(c,2),(bg,oc,(7,5,2,1,1)),(c,1)',
'tin b 37',
'tie r pt,(c,4),(bg,rp,(3,3,5,4,1)),(bg,oc,(0,1,1))',
'tin c 42',
'tie r pt,(c,2),(c,1),(bg,oc,(0,1))',
'tio b',
'ticp b b1',
'tie t .25, 20.25',
'tie i 76',
'ticp b b2',
'tie t .5, 20.5',
'tie i 77',
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT02D.PY"
>F.1.6. script02d.py: Building an Extended Rhythmic Line with Canonic Imitation</A
></H2
><PRE
CLASS="SCREEN"
># Building an Extended Rhythmic Line with Canonic Imitation
from athenaCL.libATH import athenaObj
cmd = [
'emo mp',
'tin a 77', 
'tie r pt,(c,1),(c,1),(c,1)', 
'tin b 67', 
'tie r pt,(bg,oc,(2,4,1)),(bg,oc,(3,5,1,7,1,3)),(c,1) ', 
'ticp b b1', 
'tie t 0.125,20.125', 
'tie i 60', 
'ticp b b2', 
'tie t 0.25,20.25', 
'tie i 68', 
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT02E.PY"
>F.1.7. script02e.py: Creating Mensural Canons</A
></H2
><PRE
CLASS="SCREEN"
># Creating Mensural Canons
from athenaCL.libATH import athenaObj
cmd = [
'emo mp',
'tin a 77', 
'tie r pt,(c,1),(c,1),(c,1)', 
'tin b 67', 
'tie r pt,(bg,oc,(2,4,1)),(bg,oc,(3,5,1,7,1,3)),(c,1) ', 
'ticp b b1', 
'tie t 0.125,20.125', 
'tie i 60', 
'ticp b b2', 
'tie t 0.25,20.25', 
'tie i 68', 
'tio b1', 
'tie b c,90',
'tio b2', 
'tie b c,180',
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT02F.PY"
>F.1.8. script02f.py: Building an Extended Rhythmic Line with Fixed Tempo Phasing</A
></H2
><PRE
CLASS="SCREEN"
># Building an Extended Rhythmic Line with Fixed Tempo Phasing
from athenaCL.libATH import athenaObj
cmd = [
'emo mp',
'tin a 70',
'tie r pt,(bg,oc,(2,4,4)),(bg,oc,(4,1,1,2,1)),(c,1) ',
'tie t 0,60',
'ticp a a1',
'tie b c,124',
'ticp a a2',
'tie b c,128',
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT02G.PY"
>F.1.9. script02g.py: Building an Extended Rhythmic Line with Dynamic Tempo Phasing</A
></H2
><PRE
CLASS="SCREEN"
># Building an Extended Rhythmic Line with Dynamic Tempo Phasing
from athenaCL.libATH import athenaObj
cmd = [
'emo mp',
'tin a 64',
'tie r pt,(bg,oc,(2,4,4)),(bg,oc,(4,1,1,2,1)),(c,1) ',
'tie t 0,60',
'ticp a a1',
'tie i 60',
'tie b ws,t,20,0,115,125',
'ticp a a2',
'tie i 69',
'tie b ws,t,30,0,100,140',
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT03A.PY"
>F.1.10. script03a.py: Grouping Selection</A
></H2
><PRE
CLASS="SCREEN"
># Grouping Selection
from athenaCL.libATH import athenaObj
ath = athenaObj.Interpreter()
cmd = [
'emo m',
'tin a 6', 
'tie r cs,(rb,.2,.2,.02,.25)', 
'tie f ig,(bg,rc,(2,4,7,9,11)),(bg,rp,(2,3,5,8,13))', 
'tie o ig,(bg,oc,(-2,-1,0,1)),(ru,20,30)', 
'ticp a b c d', 
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT03B.PY"
>F.1.11. script03b.py: Tendency Mask: Random Values between Breakpoint Functions</A
></H2
><PRE
CLASS="SCREEN"
># Tendency Mask: Random Values between Breakpoint Functions
from athenaCL.libATH import athenaObj
cmd = [
'emo m',
'tin a 15',
'tie r cs,(ig,(ru,.01,.25),(ru,4,12))',
'tie a ru,.2,(cg,u,.3,.9,.005)',
'tie f rb,.2,.2,(bpl,t,l,((0,-12),(30,12))),(ws,t,29,0,0,24)',
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT03C.PY"
>F.1.12. script03c.py: Tendency Mask: Random Values between Triangle Generators</A
></H2
><PRE
CLASS="SCREEN"
># Tendency Mask: Random Values between Triangle Generators
from athenaCL.libATH import athenaObj
cmd = [
'emo m',
'pin a d,e,g,a,b',
'tin a 107  ',
'tie r pt,(c,16),(ig,(bg,rc,(1,2,3,5,7)),(bg,rc,(3,6,9,12))),(c,1)',
'tie o ru,(wt,t,25,0,-2,4),(wt,t,20,0,-3,1)',
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT04A.PY"
>F.1.13. script04a.py: Large Scale Amplitude Behavior with Operators</A
></H2
><PRE
CLASS="SCREEN"
># Large Scale Amplitude Behavior with Operators
from athenaCL.libATH import athenaObj
ath = athenaObj.Interpreter()
cmd = [
'emo mp',
'tin a 64',
'tie r pt,(bg,rp,(16,16,8)),(bg,rp,(2,2,1,4)),(c,1)',
'tie a om,(ls,e,9,(ru,.2,1),(ru,.2,1)),(wp,e,23,0,0,1)',
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT04B.PY"
>F.1.14. script04b.py: 1/f Noise in Melodic Generation: LineGroove</A
></H2
><PRE
CLASS="SCREEN"
># 1/f Noise in Melodic Generation: LineGroove
from athenaCL.libATH import athenaObj
ath = athenaObj.Interpreter()
cmd = [
'emo m',
'tmo lg',
'tin a 108',
'tie r cs,(ls,e,10,(ru,.01,.2),(ru,.01,.2))',
'tie f bs,(2,4,7,9,11,14,16,19,21,23),(n,100,1,0,1)',
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT04C.PY"
>F.1.15. script04c.py: 1/f Noise in Melodic Generation: HarmonicAssembly</A
></H2
><PRE
CLASS="SCREEN"
># 1/f Noise in Melodic Generation: HarmonicAssembly
from athenaCL.libATH import athenaObj
ath = athenaObj.Interpreter()
cmd = [
'emo m',
'pin a d3,e3,g3,a3,b3,d4,e4,g4,a4,b4,d5,e5,g5,a5,b5',
'tmo ha',
'tin a 27',
'tie r pt,(c,16),(ig,(bg,rc,(1,2,3,5,7)),(bg,rc,(3,6,9,12))),(c,1)',
'tie a om,(ls,e,9,(ru,.2,1),(ru,.2,1)),(wp,e,23,0,0,1)',
'tie d0 c,0',
'tie d1 n,100,2,0,14',
'tie d2 c,1',
#'tie d3 c,1',
'tie d3 ru,1,4',
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT05A.PY"
>F.1.16. script05a.py: Self Similar Markovian Melody Generation and Transposition</A
></H2
><PRE
CLASS="SCREEN"
># Self Similar Markovian Melody Generation and Transposition
from athenaCL.libATH import athenaObj
cmd = [
'emo m',
'tin a 24',
'tie r cs,(n,100,1.5,.100,.180)',
'tie r cs,(om,(n,100,1.5,.100,.180),(ws,t,8,0,.5,1))',
# Markov weighted pitch transposition
'tie f mv,a{2}b{4}c{7}d{9}e{11}:{a=1|b=6|c=1|d=9|e=1}',
# self-similar pitch transposition combing a grouped version of the same Markov generator with OperatorAdd
'tie f oa,(mv,a{2}b{4}c{7}d{9}e{11}:{a=1|b=3|c=1|d=3|e=1}), (ig,(mv,a{2}b{4}c{7}d{9}e{11}:{a=1|b=3|c=1|d=3|e=1}),(ru,10,20))',
# Markov based octave shifting
'tie o mv,a{-2}b{0}c{-2}d{0}e{-1}:{a=1|b=3|c=1|d=3|e=1}',
# A widening beta distribution
'tie a rb,.2,.5,(ls,e,(ru,3,20),.5,1)',
# Modulated with a pulse wave (and random frequency modulation on the PulseWave)
'tie a om,(rb,.2,.5,(ls,e,(ru,3,20),.5,1)),(wp,e,(ru,25,30),0,0,1)',
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT05B.PY"
>F.1.17. script05b.py: Markov-Based Proportional Rhythm Generation</A
></H2
><PRE
CLASS="SCREEN"
># Markov-Based Proportional Rhythm Generation
from athenaCL.libATH import athenaObj
cmd = [
'emo mp',
'tin a 64',
# simple zero-order selection
'tie r mp,a{4,1}b{4,3}c{4,5}d{4,7}:{a=4|b=3|c=2|d=1}',
# first order generation that encourages movement toward the shortest duration
'tie r mp,a{8,1}b{4,3}c{4,7}d{4,13}a:{a=9|d=1}b:{a=5|c=1}c:{b=1}d:{c=1},(c,1)',
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT05C.PY"
>F.1.18. script05c.py: Markov-Based Value Generation</A
></H2
><PRE
CLASS="SCREEN"
># Markov-Based Value Generation
from athenaCL.libATH import athenaObj
cmd = [
'emo m',
'tin a 26',
# rhythm generated with absolute values via ConvertSecond and a dynamic WaveHalfPeriodSine generator
'tie r cs,(whps,e,(bg,rp,(5,10,15,20)),0,.200,.050)',
# first-order selection
#'tie f mv,a{2}b{4}c{7}d{9}e{11}:{a=1|b=3|c=1|d=3|e=1}a:{a=9|e=1}b:{a=3|c=1}c:{b=3|d=1}d:{c=3|e=1}e:{d=1},(c,1)',
# dynamic first and zero order selection
'tie f mv,a{2}b{4}c{7}d{9}e{11}:{a=1|b=3|c=1|d=3|e=1}a:{a=9|e=1}b:{a=3|c=1}c:{b=3|d=1}d:{c=3|e=1}e:{d=1},(wp,e,100,0,1,0)',
# zero-order Markov amplitude values
#'tie a mv,a{.4}b{.6}c{.8}d{1}:{a=6|b=4|c=3|d=1}',
# amplitude values scaled by a dynamic WaveHalfPeriodPulse
'tie a om,(mv,a{.4}b{.6}c{.8}d{1}:{a=6|b=4|c=3|d=1}),(whpp,e,(bg,rp,(5,15,10)))',
# octave values are provided by a first-order Markov chain
'tie o mv,a{0}b{-1}c{-2}d{-3}a:{a=9|d=1}b:{a=3|b=1}c:{b=3|c=1}d:{c=1},(c,1)',
'tie t 0,60',
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT06A.PY"
>F.1.19. script06a.py: Deploying Pitch Sieves with HarmonicAssembly</A
></H2
><PRE
CLASS="SCREEN"
># Deploying Pitch Sieves with HarmonicAssembly
from athenaCL.libATH import athenaObj
cmd = [
'emo m',
'pin a 11@1|13@2|23@5|25@6,c1,c7',
'tmo ha',
'tin a 0',
'tie t 0,30',
'tie a rb,.2,.2,.6,1',
'tie b c,120',
#zero-order Markov chains building pulse triples
'tie r pt,(c,4),(mv,a{1}b{3}:{a=12|b=1}),(mv,a{1}b{0}:{a=9|b=1}),(c,.8)',
#index position of multiset: there is only one at zero
'tie d0 c,0',
#selecting pitches from the multiset (indices 0-15) with a tendency mask
'tie d1 ru,(bpl,t,l,[(0,0),(30,12)]),(bpl,t,l,[(0,3),(30,15)])', 
#repetitions of each chord
'tie d2 c,1',
#chord size
'tie d3 bg,rc,(2,3)',
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT07A.PY"
>F.1.20. script07a.py: The CA as a Generator of Melodies</A
></H2
><PRE
CLASS="SCREEN"
># The CA as a Generator of Melodies
from athenaCL.libATH import athenaObj
cmd = [
'emo m',
# create a single, large Multiset using a sieve
'pin a 5@0|7@2,c2,c7',
'tmo ha',
'tin a 27',
'tie r pt,(c,8),(ig,(bg,rc,(2,3)),(bg,rc,(3,6,9))),(c,1)',
'tie a ls,e,9,(ru,.2,1),(ru,.2,1)',
# select only Multiset 0
'tie d0 c,0',
# select pitches from Multiset using CaList
'tie d1 cl,f{s}x{20},90,0,fria,oc',
# create only 1 simultaneity from each multiset
'tie d2 c,1',
# create only 1-element simultaneities
'tie d3 c,1',
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT07B.PY"
>F.1.21. script07b.py: The CA as a Generator of Rhythms</A
></H2
><PRE
CLASS="SCREEN"
># The CA as a Generator of Rhythms
from athenaCL.libATH import athenaObj
cmd = [
'emo mp',
'tin a 47',
# set the multiplier to the integer output of CaList
'tie r pt,(c,4),(cl,f{s}k{2}r{1}x{81}y{120}w{6}c{0}s{0},109,.05,sumRowActive,oc),(c,1)',
# set the amplitude to the floating point output of CaValue
'tie a cv,f{s}k{2}r{1}x{81}y{120}w{6}c{8}s{0},109,.05,sumRowActive,.2,1',
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT08A.PY"
>F.1.22. script08a.py: Evolving African Drum Patterns with a GA: Two Durations</A
></H2
><PRE
CLASS="SCREEN"
># Evolving African Drum Patterns with a GA: Two Durations
from athenaCL.libATH import athenaObj
cmd = [        
'emo mp',
'tmo lg',
'tin a 61',
# bell line, set to loop
'tie r l,[(4,4,1),(4,4,1),(4,2,1),(4,4,1),(4,4,1),(4,4,1),(4,2,1)]',
# accent the first of each articulation
'tie a bg,oc,(1,.5,.5,.5,.5,.5,.5)',
'tin b 68',
# create genetic variations using a high mutation rate
'tie r gr,[(4,4,1),(4,4,1),(4,2,1),(4,4,1),(4,4,1),(4,4,1),(4,2,1)],.7,.25,0',
'tie a bg,oc,(1,.5,.5,.5,.5,.5,.5)',
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT08B.PY"
>F.1.23. script08b.py: Evolving African Drum Patterns with a GA: Combinations of Rests and Silences</A
></H2
><PRE
CLASS="SCREEN"
># Evolving African Drum Patterns with a GA: Combinations of Rests and Silences
from athenaCL.libATH import athenaObj
ath = athenaObj.Interpreter()
cmd = [        
'emo mp',
'tmo lg',
'tin a 61',
# kagan line, set to loop
'tie r l,[(4,2,0),(4,2,1),(4,2,1),(4,2,0),(4,2,1),(4,2,1),(4,2,0), (4,2,1),(4,2,1),(4,2,0),(4,2,1),(4,2,1)]',
# accent the first of each articulation
'tie a bg,oc,(.5,1,.5, .5,.5,.5, .5,.5,.5, .5,.5,.5)',
# turning on silence mode will use parameters even for rests
'timode s on',
'tin b 68',
# create genetic variations using a high crossover, no mutation
'tie r gr,[(4,2,0),(4,2,1),(4,2,1),(4,2,0),(4,2,1),(4,2,1),(4,2,0), (4,2,1),(4,2,1),(4,2,0),(4,2,1),(4,2,1)],1,0,0',
'tie a bg,oc,(.5,1,.5, .5,.5,.5, .5,.5,.5, .5,.5,.5)',
# turning on silence mode will use parameters even for rests
'timode s on',
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT08C.PY"
>F.1.24. script08c.py: Evolving African Drum Patterns with a GA: Multiple Rhythmic Values</A
></H2
><PRE
CLASS="SCREEN"
># Evolving African Drum Patterns with a GA: Multiple Rhythmic Values
from athenaCL.libATH import athenaObj
ath = athenaObj.Interpreter()
cmd = [        
'emo mp',
'tmo lg',
'tin a 61',
# kroboto line, set to loop
'tie r l,[(4,3,1),(4,1,1),(4,2,1),(4,2,1),(4,1,1),(4,1,1),(4,2,1), (4,3,1),(4,1,1),(4,2,1),(4,2,1),(4,1,1),(4,1,1),(4,2,1)]',
# accent the first of each articulation
'tie a bg,oc,(1,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5)',
'tin b 68',
# create genetic variations using a high crossover and mutation rate and some elitism
'tie r gr,[(4,3,1),(4,1,1),(4,2,1),(4,2,1),(4,1,1),(4,1,1),(4,2,1), (4,3,1),(4,1,1),(4,2,1),(4,2,1),(4,1,1),(4,1,1),(4,2,1)],.9,.25,0.1',
'tie a bg,oc,(1,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5)',
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT08D.PY"
>F.1.25. script08d.py: Evolving African Drum Patterns with a GA: Multiple Rhythmic Values</A
></H2
><PRE
CLASS="SCREEN"
># Evolving African Drum Patterns with a GA: Multiple Rhythmic Values
from athenaCL.libATH import athenaObj
cmd = [        
'emo mp',
'tmo lg',
'tin a 45',
'tie r gr,[(4,4,1),(4,4,1),(4,2,1),(4,4,1),(4,4,1),(4,4,1),(4,2,1)],.7,.15,0',
'tie a bg,oc,(1,.5,.5,.5,.5,.5,.5)',
'tin b 60',
# create genetic variations using a high crossover, no mutation
'tie r gr,[(4,2,0),(4,2,1),(4,2,1),(4,2,0),(4,2,1),(4,2,1),(4,2,0), (4,2,1),(4,2,1),(4,2,0),(4,2,1),(4,2,1)],1,0,0',
'tie a bg,oc,(.5,1,.5, .5,.5,.5, .5,.5,.5, .5,.5,.5)',
# turning on silence mode will use parameters even for rests
'timode s on',
'tin c 68',  
# create genetic variations using a high crossover and mutation rate and some elitism
'tie r gr,[(4,3,1),(4,1,1),(4,2,1),(4,2,1),(4,1,1),(4,1,1),(4,2,1), (4,3,1),(4,1,1),(4,2,1),(4,2,1),(4,1,1),(4,1,1),(4,2,1)],.9,.25,0.1',
'tie a bg,oc,(1,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5)',
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT09A.PY"
>F.1.26. script09a.py: Grammar States as Accent Patterns</A
></H2
><PRE
CLASS="SCREEN"
># Grammar States as Accent Patterns
from athenaCL.libATH import athenaObj
cmd = [        
'emo mp',
'tmo lg',
'tin a 60',
# non deterministic binary algae generator applied to accent
'tie r pt,(c,8),(c,1),(gt,a{0}b{1}@a{ab}b{a|aaa}@b,10,oc)',
'tie a c,1',
# four state deterministic applied to pulse multiplier
'tie r pt,(c,8), (gt,a{1}b{2}c{4}d{8}@a{ab}b{cd}c{aadd}d{bc}@ac,10,oc),(c,1)',
# four state deterministic applied to amplitude with different start string
'tie a gt,a{.25}b{.5}c{.75}d{1}@a{ab}b{cd}c{aadd}d{bc}@bbc,6,oc',
# four state deterministic applied to transposition with different start string
'tie f gt,a{0}b{1}c{2}d{3}@a{ab}b{cd}c{aadd}d{bc}@dc,6,oc',
# four state non-deterministic applied to transposition with different start string
'tie f gt,a{0}b{1}c{2}d{3}@a{ab}b{cd|aa}c{aadd|cb}d{bc|a}@dc,6,oc',
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT09B.PY"
>F.1.27. script09b.py: Grammar States as Pitch Values</A
></H2
><PRE
CLASS="SCREEN"
># Grammar States as Pitch Values
from athenaCL.libATH import athenaObj
cmd = [        
'emo m',
'tmo lg',
'tin a 32',
# four state deterministic applied to pulse multiplier
'tie r pt,(c,8), (gt,a{1}b{2}c{4}d{8}@a{ab}b{cd}c{aadd}d{bc}@ac,8,oc),(c,1)',
'tie o c,-2',
# four state deterministic applied to transposition with different start string
'tie f gt,a{0}b{7}c{8}d{2}@a{ab}b{cd}c{aadd}d{bc}@ad,6,oc',
# four state deterministic applied to amplitude with different start string
'tie a gt,a{.25}b{.5}c{.75}d{1}@a{ab}b{cd}c{aadd}d{bc}@bbc,6,oc',
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT09C.PY"
>F.1.28. script09c.py: Grammar States as Pitch Transpositions</A
></H2
><PRE
CLASS="SCREEN"
># Grammar States as Pitch Transpositions
from athenaCL.libATH import athenaObj
cmd = [        
'emo m',
'tmo lg',
'tin a 15',
#four state deterministic applied to pulse multiplier
'tie r pt,(c,8), (gt,a{1}b{2}c{4}d{8}@a{ab}b{cd}c{aadd}d{bc}@ac,8,oc),(c,1)',
#four state deterministic applied to accumulated transposition with different start string
'tie f a,0,(gt,a{1}b{-1}c{7}d{-7}@a{ab}b{cd}c{ad}d{bc}@ac,10,oc)',
# four state deterministic applied to amplitude with different start string
'tie a gt,a{.25}b{.5}c{.75}d{1}@a{ab}b{cd}c{aadd}d{bc}@bbc,6,oc',
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT09D.PY"
>F.1.29. script09d.py: Grammar States as Path Index Values</A
></H2
><PRE
CLASS="SCREEN"
># Grammar States as Path Index Values
from athenaCL.libATH import athenaObj
cmd = [        
'emo m',
# create a single, large Multiset using a sieve
'pin a 5@0|7@2,c2,c7',
'tmo ha',
'tin a 6',
# constant rhythm
'tie r pt,(c,4),(c,1),(c,1)',
# select only Multiset 0
'tie d0 c,0',
# select pitches from Multiset using accumulated deterministic grammar starting at 12
'tie d1 a,12,(gt,a{1}b{-1}c{2}d{-2}@a{ab}b{cd}c{ad}d{bc}@ac,10,oc)',
# create only 1 simultaneity from each multiset; create only 1-element simultaneities
'tie d2 c,1',
'tie d3 c,1',
# four state deterministic applied to amplitude with different start string
'tie a gt,a{.25}b{.5}c{.75}d{1}@a{ab}b{cd}c{aadd}d{bc}@bbc,6,oc',
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT10A.PY"
>F.1.30. script10a.py: Feedback System as Dynamic Contour</A
></H2
><PRE
CLASS="SCREEN"
># Feedback System as Dynamic Contour
from athenaCL.libATH import athenaObj
ath = athenaObj.Interpreter()
cmd = [        
'emo mp',
'tmo lg',
'tin a 66',
# constant pulse
'tie r pt,(c,8),(c,1),(c,1)',
# amplitude controlled by Thermostat feedback
'tie a fml,t,(bg,rc,(1,1.5,2))',
# using convert second to set durations
'tie r cs,(fml,t,(c,1),(c,.7),.001,.400)',
# amplitude controlled by Climate Control feedback
'tie a fml,cc,(bg,rc,(.5,1,1.5)),(c,.7),0,1',
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PYSCRIPTMIDISCRIPT10B.PY"
>F.1.31. script10b.py: Feedback System as Path Index Values</A
></H2
><PRE
CLASS="SCREEN"
># Feedback System as Path Index Values
from athenaCL.libATH import athenaObj
cmd = [        
'emo m',
# create a single, large Multiset using a sieve
'pin a 5@1|7@4,c2,c7',
'tmo ha',
'tin a 107',
# constant rhythm
'tie r pt,(c,4),(c,1),(c,1)',
# select only Multiset 0
'tie d0 c,0',
# create only 1 simultaneity from each multiset; create only 1-element simultaneities
'tie d2 c,1',
'tie d3 c,1',
# select pitches from Multiset using Thermostat
'tie d1 fml,t,(bg,rc,(1,1.5,2)),(c,.7),0,18',
# select pitches from Multiset using Climate Control
'tie d1 fml,cc,(bg,rc,(.5,1,1.5)),(c,.7),0,18',
]
def main(cmdList=[], fp=None, hear=True):
    ath = athenaObj.Interpreter()
    for line in cmdList:
        ath.cmd(line)
    if fp == None:
        ath.cmd('eln') 
    else:
        ath.cmd('eln %s' % fp)
    if hear:
        ath.cmd('elh') 
if __name__ == '__main__':
    main(cmd)</PRE
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x2956.htm"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.htm"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x3083.htm"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>OutputEngines</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Csound-based Output</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>