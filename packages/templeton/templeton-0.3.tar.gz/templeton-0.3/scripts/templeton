#!python

import errno
import os
import shutil
import socket
import sys
import tempita
import templeton

TEMPLETOND_SOCK_FILENAME = '/var/run/templetond/templetond.sock'

data_dir = os.path.dirname(os.path.abspath(templeton.__file__))

def init(appname):
    if '/' in appname:
        print 'Slashes are not allowed in project names.'
        return errno.EINVAL
    if os.path.exists(appname):
        print 'Cannot initialize project "%s" over existing %s.' % \
            (appname, 'directory' if os.path.isdir(appname) else 'file')
        return errno.EEXIST
    templates_dir = os.path.join(data_dir, 'templates', 'project')
    shutil.copytree(templates_dir, appname)
    # special templatization for index.html
    html_dir = os.path.join(appname, 'html')
    tmpl = tempita.Template.from_filename(os.path.join(html_dir,
                                                       'index.html.tmpl'))
    f = file(os.path.join(html_dir, 'index.html'), 'w')
    f.write(tmpl.substitute(appname=appname))
    f.close()
    os.unlink(os.path.join(html_dir, 'index.html.tmpl'))
    return 0


def install(wwwdata):
    server_dir = os.path.join(data_dir, 'server')
    shutil.copytree(server_dir, os.path.join(wwwdata, 'templeton'))
    return 0


def socket_command(cmd_str):
    if not os.path.exists(os.path.join('server', 'server.py')):
        sys.stderr.write('This does not appear to be a templeton app.\n')
        return
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    try:
        sock.connect(TEMPLETOND_SOCK_FILENAME)
    except socket.error, e:
        if e.errno == 2:
            return (2, 'Could not connect to socket; is templetond running?')
    sock.send(cmd_str + '\n')
    rsp = ''
    while '\n' not in rsp:
        read = sock.recv(1024)
        if read:
            rsp += read
        else:
            break
    sock.close()
    err = 0
    errstr = ''
    rsp = rsp.rstrip('\n')
    if rsp[:5] == 'ERROR':
        s = rsp.split(' ')
        try:
            err = int(s[1])
        except ValueError:
            err = 255
            errstr = rsp
        else:
            errstr = ' '.join(s[2:])
    elif rsp[:2] != 'OK':
        err = 255
        errstr = rsp
    if errstr:
        sys.stderr.write('error: %s\n' % errstr)
    return err

    
def register():
    rc = socket_command('register %s %s' %
                        (os.path.basename(os.getcwd()), os.getcwd()))
    return rc


def unregister():
    rc = socket_command('unregister %s %s' %
                        (os.path.basename(os.getcwd()), os.getcwd()))
    return rc


def enable():
    rc = socket_command('enable %s' % os.path.basename(os.getcwd()))
    return rc


def disable():
    rc = socket_command('disable %s' % os.path.basename(os.getcwd()))
    return rc


def start():
    rc = socket_command('start %s' % os.path.basename(os.getcwd()))
    return rc


def stop():
    rc = socket_command('stop %s' % os.path.basename(os.getcwd()))
    return rc


if __name__ == '__main__':
    from optparse import OptionParser
    import errno
    import sys
    usage = '''%prog [options] <cmd> <parameters>

<cmd> and <parameters> should be one of
  init <appname>
    Create a new templeton app
  install <www-data-dir>
    Install support web files (standard JS & CSS files)'''

    parser = OptionParser(usage=usage)
    (options, args) = parser.parse_args()
    if len(args) < 1:
        parser.print_help()
        sys.exit(errno.EINVAL)
    cmd = args[0]
    if cmd == 'init':
        rc = init(args[1])
    elif cmd == 'install':
        rc = install(args[1])
    elif cmd == 'register':
        rc = register()
    elif cmd == 'unregister':
        rc = unregister()
    elif cmd == 'enable':
        rc = enable()
    elif cmd == 'disable':
        rc = disable()
    elif cmd == 'start':
        rc = start()
    elif cmd == 'stop':
        rc = stop()
    else:
        parser.print_help()
        rc = errno.EINVAL
    sys.exit(rc)
        
