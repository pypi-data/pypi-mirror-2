Version 1 of the problem:

Given a string S, find a sub string P(l,k) where l is the length of P and k is the number of non overlapping occurrences of P in S, such as k > 1 and k*l (the span of P) is the biggest. There may be more then one such P.

This is what *repeat_pattern2* solves - This is "old" algorithm.

Version 2 of the problem

Same as #1 but we can delete a set of characters F from S, as long as we delete all occurrences of a character.

*repeat_pattern* solves this problem in a simple way IF we assume that the
pattern P will have at least two unique characters in it.

For example:

S = "XYKaLbKcLdKeLXY"

Or with spaces "XY KaL b KcL d KeL XY"

For version one: P = "XY" with span of 4 (2*2)

For version two: F = "ace" and P = "KL" with span of 6 (2*3)

But if S = "XY KaL b KcL d KeL XY K", I do not know how to solve version two,
do you?

Moreover, for both versions, there might be strings S that does not have any P. I need to identify these strings.
