// This file has been generated by Py++.

#include "boost/python.hpp"
#include "__ctypes_integration.pypp.hpp"
#include "cxcore_hpp_vec_wrapper.hpp"
#include "ndarray.hpp"
#include "opencv_converters.hpp"
#include "cxcore_hpp_vec_ext_classes_7.pypp.hpp"

namespace bp = boost::python;

void register_classes_7(){

    { //::cv::Vec< double, 6 >
        typedef bp::class_< cv::Vec< double, 6 > > Vec6d_exposer_t;
        Vec6d_exposer_t Vec6d_exposer = Vec6d_exposer_t( "Vec6d", bp::init< >() );
        bp::scope Vec6d_scope( Vec6d_exposer );
        Vec6d_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::Vec< double, 6 > >() );
        bp::scope().attr("depth") = (int)cv::Vec<double, 6>::depth;
        bp::scope().attr("channels") = (int)cv::Vec<double, 6>::channels;
        bp::scope().attr("type") = (int)cv::Vec<double, 6>::type;
        Vec6d_exposer.def( bp::init< double >(( bp::arg("v0") )) );
        bp::implicitly_convertible< double, cv::Vec< double, 6 > >();
        Vec6d_exposer.def( bp::init< double, double >(( bp::arg("v0"), bp::arg("v1") )) );
        Vec6d_exposer.def( bp::init< double, double, double >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2") )) );
        Vec6d_exposer.def( bp::init< double, double, double, double >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3") )) );
        Vec6d_exposer.def( bp::init< double, double, double, double, double >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4") )) );
        Vec6d_exposer.def( bp::init< double, double, double, double, double, double >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4"), bp::arg("v5") )) );
        Vec6d_exposer.def( bp::init< double, double, double, double, double, double, double >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4"), bp::arg("v5"), bp::arg("v6") )) );
        Vec6d_exposer.def( bp::init< double, double, double, double, double, double, double, double >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4"), bp::arg("v5"), bp::arg("v6"), bp::arg("v7") )) );
        Vec6d_exposer.def( bp::init< double, double, double, double, double, double, double, double, double >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4"), bp::arg("v5"), bp::arg("v6"), bp::arg("v7"), bp::arg("v8") )) );
        Vec6d_exposer.def( bp::init< double, double, double, double, double, double, double, double, double, double >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4"), bp::arg("v5"), bp::arg("v6"), bp::arg("v7"), bp::arg("v8"), bp::arg("v9") )) );
        Vec6d_exposer.def( bp::init< cv::Vec< double, 6 > const & >(( bp::arg("v") )) );
        { //::cv::Vec< double, 6 >::all
        
            typedef cv::Vec< double, 6 > exported_class_t;
            typedef ::cv::Vec< double, 6 > ( *all_function_type )( double );
            
            Vec6d_exposer.def( 
                "all"
                , all_function_type( &::cv::Vec< double, 6 >::all )
                , ( bp::arg("alpha") ) );
        
        }
        { //::cv::Vec< double, 6 >::cross
        
            typedef cv::Vec< double, 6 > exported_class_t;
            typedef ::cv::Vec< double, 6 > ( exported_class_t::*cross_function_type )( ::cv::Vec< double, 6 > const & ) const;
            
            Vec6d_exposer.def( 
                "cross"
                , cross_function_type( &::cv::Vec< double, 6 >::cross )
                , ( bp::arg("v") ) );
        
        }
        { //::cv::Vec< double, 6 >::ddot
        
            typedef cv::Vec< double, 6 > exported_class_t;
            typedef double ( exported_class_t::*ddot_function_type )( ::cv::Vec< double, 6 > const & ) const;
            
            Vec6d_exposer.def( 
                "ddot"
                , ddot_function_type( &::cv::Vec< double, 6 >::ddot )
                , ( bp::arg("v") ) );
        
        }
        { //::cv::Vec< double, 6 >::dot
        
            typedef cv::Vec< double, 6 > exported_class_t;
            typedef double ( exported_class_t::*dot_function_type )( ::cv::Vec< double, 6 > const & ) const;
            
            Vec6d_exposer.def( 
                "dot"
                , dot_function_type( &::cv::Vec< double, 6 >::dot )
                , ( bp::arg("v") ) );
        
        }
        { //::cv::Vec< double, 6 >::operator[]
        
            typedef cv::Vec< double, 6 > exported_class_t;
            typedef double ( exported_class_t::*__getitem___function_type )( int ) const;
            
            Vec6d_exposer.def( 
                "__getitem__"
                , __getitem___function_type( &::cv::Vec< double, 6 >::operator[] )
                , ( bp::arg("i") )
                , "\nWrapped function:"
    "\n    operator[]" );
        
        }
        { //::cv::Vec< double, 6 >::operator[]
        
            typedef cv::Vec< double, 6 > exported_class_t;
            typedef double & ( exported_class_t::*__getitem___function_type )( int ) ;
            
            Vec6d_exposer.def( 
                "__getitem__"
                , __getitem___function_type( &::cv::Vec< double, 6 >::operator[] )
                , ( bp::arg("i") )
                , bp::return_value_policy< bp::copy_non_const_reference >()
                , "\nWrapped function:"
    "\n    operator[]" );
        
        }
        Vec6d_exposer.staticmethod( "all" );
        Vec6d_exposer.add_property("ndarray", &sdcpp::as_ndarray< cv::Vec<double,6> >);
        Vec6d_exposer.def("__iadd__", &__iadd__<cv::Vec6d, cv::Vec6f>, bp::return_self<>() );
        Vec6d_exposer.def("__isub__", &__isub__<cv::Vec6d, cv::Vec6f>, bp::return_self<>() );
        Vec6d_exposer.def("__iadd__", &__iadd__<cv::Vec6d, cv::Vec6d>, bp::return_self<>() );
        Vec6d_exposer.def("__isub__", &__isub__<cv::Vec6d, cv::Vec6d>, bp::return_self<>() );
        Vec6d_exposer.def("__add__", &__add__<cv::Vec6d, cv::Vec6d> );
        Vec6d_exposer.def("__sub__", &__sub__<cv::Vec6d, cv::Vec6d> );
        Vec6d_exposer.def("__eq__", &__eq__<cv::Vec6d, cv::Vec6d> );
        Vec6d_exposer.def("__ne__", &__ne__<cv::Vec6d, cv::Vec6d> );
        Vec6d_exposer.def("__neg__", &__neg__<cv::Vec6d> );
    }

    { //::cv::Vec< float, 2 >
        typedef bp::class_< cv::Vec< float, 2 > > Vec2f_exposer_t;
        Vec2f_exposer_t Vec2f_exposer = Vec2f_exposer_t( "Vec2f", bp::init< >() );
        bp::scope Vec2f_scope( Vec2f_exposer );
        Vec2f_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::Vec< float, 2 > >() );
        bp::scope().attr("depth") = (int)cv::Vec<float, 2>::depth;
        bp::scope().attr("channels") = (int)cv::Vec<float, 2>::channels;
        bp::scope().attr("type") = (int)cv::Vec<float, 2>::type;
        Vec2f_exposer.def( bp::init< float >(( bp::arg("v0") )) );
        bp::implicitly_convertible< float, cv::Vec< float, 2 > >();
        Vec2f_exposer.def( bp::init< float, float >(( bp::arg("v0"), bp::arg("v1") )) );
        Vec2f_exposer.def( bp::init< float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2") )) );
        Vec2f_exposer.def( bp::init< float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3") )) );
        Vec2f_exposer.def( bp::init< float, float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4") )) );
        Vec2f_exposer.def( bp::init< float, float, float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4"), bp::arg("v5") )) );
        Vec2f_exposer.def( bp::init< float, float, float, float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4"), bp::arg("v5"), bp::arg("v6") )) );
        Vec2f_exposer.def( bp::init< float, float, float, float, float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4"), bp::arg("v5"), bp::arg("v6"), bp::arg("v7") )) );
        Vec2f_exposer.def( bp::init< float, float, float, float, float, float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4"), bp::arg("v5"), bp::arg("v6"), bp::arg("v7"), bp::arg("v8") )) );
        Vec2f_exposer.def( bp::init< float, float, float, float, float, float, float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4"), bp::arg("v5"), bp::arg("v6"), bp::arg("v7"), bp::arg("v8"), bp::arg("v9") )) );
        Vec2f_exposer.def( bp::init< cv::Vec< float, 2 > const & >(( bp::arg("v") )) );
        { //::cv::Vec< float, 2 >::all
        
            typedef cv::Vec< float, 2 > exported_class_t;
            typedef ::cv::Vec< float, 2 > ( *all_function_type )( float );
            
            Vec2f_exposer.def( 
                "all"
                , all_function_type( &::cv::Vec< float, 2 >::all )
                , ( bp::arg("alpha") ) );
        
        }
        { //::cv::Vec< float, 2 >::cross
        
            typedef cv::Vec< float, 2 > exported_class_t;
            typedef ::cv::Vec< float, 2 > ( exported_class_t::*cross_function_type )( ::cv::Vec< float, 2 > const & ) const;
            
            Vec2f_exposer.def( 
                "cross"
                , cross_function_type( &::cv::Vec< float, 2 >::cross )
                , ( bp::arg("v") ) );
        
        }
        { //::cv::Vec< float, 2 >::ddot
        
            typedef cv::Vec< float, 2 > exported_class_t;
            typedef double ( exported_class_t::*ddot_function_type )( ::cv::Vec< float, 2 > const & ) const;
            
            Vec2f_exposer.def( 
                "ddot"
                , ddot_function_type( &::cv::Vec< float, 2 >::ddot )
                , ( bp::arg("v") ) );
        
        }
        { //::cv::Vec< float, 2 >::dot
        
            typedef cv::Vec< float, 2 > exported_class_t;
            typedef float ( exported_class_t::*dot_function_type )( ::cv::Vec< float, 2 > const & ) const;
            
            Vec2f_exposer.def( 
                "dot"
                , dot_function_type( &::cv::Vec< float, 2 >::dot )
                , ( bp::arg("v") ) );
        
        }
        { //::cv::Vec< float, 2 >::operator[]
        
            typedef cv::Vec< float, 2 > exported_class_t;
            typedef float ( exported_class_t::*__getitem___function_type )( int ) const;
            
            Vec2f_exposer.def( 
                "__getitem__"
                , __getitem___function_type( &::cv::Vec< float, 2 >::operator[] )
                , ( bp::arg("i") )
                , "\nWrapped function:"
    "\n    operator[]" );
        
        }
        { //::cv::Vec< float, 2 >::operator[]
        
            typedef cv::Vec< float, 2 > exported_class_t;
            typedef float & ( exported_class_t::*__getitem___function_type )( int ) ;
            
            Vec2f_exposer.def( 
                "__getitem__"
                , __getitem___function_type( &::cv::Vec< float, 2 >::operator[] )
                , ( bp::arg("i") )
                , bp::return_value_policy< bp::copy_non_const_reference >()
                , "\nWrapped function:"
    "\n    operator[]" );
        
        }
        Vec2f_exposer.staticmethod( "all" );
        Vec2f_exposer.add_property("ndarray", &sdcpp::as_ndarray< cv::Vec<float,2> >);
        Vec2f_exposer.def("__iadd__", &__iadd__<cv::Vec2f, cv::Vec2b>, bp::return_self<>() );
        Vec2f_exposer.def("__isub__", &__isub__<cv::Vec2f, cv::Vec2b>, bp::return_self<>() );
        Vec2f_exposer.def("__iadd__", &__iadd__<cv::Vec2f, cv::Vec2s>, bp::return_self<>() );
        Vec2f_exposer.def("__isub__", &__isub__<cv::Vec2f, cv::Vec2s>, bp::return_self<>() );
        Vec2f_exposer.def("__iadd__", &__iadd__<cv::Vec2f, cv::Vec2w>, bp::return_self<>() );
        Vec2f_exposer.def("__isub__", &__isub__<cv::Vec2f, cv::Vec2w>, bp::return_self<>() );
        Vec2f_exposer.def("__iadd__", &__iadd__<cv::Vec2f, cv::Vec2i>, bp::return_self<>() );
        Vec2f_exposer.def("__isub__", &__isub__<cv::Vec2f, cv::Vec2i>, bp::return_self<>() );
        Vec2f_exposer.def("__iadd__", &__iadd__<cv::Vec2f, cv::Vec2f>, bp::return_self<>() );
        Vec2f_exposer.def("__isub__", &__isub__<cv::Vec2f, cv::Vec2f>, bp::return_self<>() );
        Vec2f_exposer.def("__iadd__", &__iadd__<cv::Vec2f, cv::Vec2d>, bp::return_self<>() );
        Vec2f_exposer.def("__isub__", &__isub__<cv::Vec2f, cv::Vec2d>, bp::return_self<>() );
        Vec2f_exposer.def("__add__", &__add__<cv::Vec2f, cv::Vec2f> );
        Vec2f_exposer.def("__sub__", &__sub__<cv::Vec2f, cv::Vec2f> );
        Vec2f_exposer.def("__eq__", &__eq__<cv::Vec2f, cv::Vec2f> );
        Vec2f_exposer.def("__ne__", &__ne__<cv::Vec2f, cv::Vec2f> );
        Vec2f_exposer.def("__imul__", &__imul__<cv::Vec2f, float>, bp::return_self<>() );
        Vec2f_exposer.def("__mul__", &__mul__<cv::Vec2f, float> );
        Vec2f_exposer.def("__rmul__", &__rmul__<float, cv::Vec2f> );
        Vec2f_exposer.def("__neg__", &__neg__<cv::Vec2f> );
    }

    { //::cv::Vec< float, 3 >
        typedef bp::class_< cv::Vec< float, 3 > > Vec3f_exposer_t;
        Vec3f_exposer_t Vec3f_exposer = Vec3f_exposer_t( "Vec3f", bp::init< >() );
        bp::scope Vec3f_scope( Vec3f_exposer );
        Vec3f_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::Vec< float, 3 > >() );
        bp::scope().attr("depth") = (int)cv::Vec<float, 3>::depth;
        bp::scope().attr("channels") = (int)cv::Vec<float, 3>::channels;
        bp::scope().attr("type") = (int)cv::Vec<float, 3>::type;
        Vec3f_exposer.def( bp::init< float >(( bp::arg("v0") )) );
        bp::implicitly_convertible< float, cv::Vec< float, 3 > >();
        Vec3f_exposer.def( bp::init< float, float >(( bp::arg("v0"), bp::arg("v1") )) );
        Vec3f_exposer.def( bp::init< float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2") )) );
        Vec3f_exposer.def( bp::init< float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3") )) );
        Vec3f_exposer.def( bp::init< float, float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4") )) );
        Vec3f_exposer.def( bp::init< float, float, float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4"), bp::arg("v5") )) );
        Vec3f_exposer.def( bp::init< float, float, float, float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4"), bp::arg("v5"), bp::arg("v6") )) );
        Vec3f_exposer.def( bp::init< float, float, float, float, float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4"), bp::arg("v5"), bp::arg("v6"), bp::arg("v7") )) );
        Vec3f_exposer.def( bp::init< float, float, float, float, float, float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4"), bp::arg("v5"), bp::arg("v6"), bp::arg("v7"), bp::arg("v8") )) );
        Vec3f_exposer.def( bp::init< float, float, float, float, float, float, float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4"), bp::arg("v5"), bp::arg("v6"), bp::arg("v7"), bp::arg("v8"), bp::arg("v9") )) );
        Vec3f_exposer.def( bp::init< cv::Vec< float, 3 > const & >(( bp::arg("v") )) );
        { //::cv::Vec< float, 3 >::all
        
            typedef cv::Vec< float, 3 > exported_class_t;
            typedef ::cv::Vec< float, 3 > ( *all_function_type )( float );
            
            Vec3f_exposer.def( 
                "all"
                , all_function_type( &::cv::Vec< float, 3 >::all )
                , ( bp::arg("alpha") ) );
        
        }
        { //::cv::Vec< float, 3 >::cross
        
            typedef cv::Vec< float, 3 > exported_class_t;
            typedef ::cv::Vec< float, 3 > ( exported_class_t::*cross_function_type )( ::cv::Vec< float, 3 > const & ) const;
            
            Vec3f_exposer.def( 
                "cross"
                , cross_function_type( &::cv::Vec< float, 3 >::cross )
                , ( bp::arg("v") ) );
        
        }
        { //::cv::Vec< float, 3 >::ddot
        
            typedef cv::Vec< float, 3 > exported_class_t;
            typedef double ( exported_class_t::*ddot_function_type )( ::cv::Vec< float, 3 > const & ) const;
            
            Vec3f_exposer.def( 
                "ddot"
                , ddot_function_type( &::cv::Vec< float, 3 >::ddot )
                , ( bp::arg("v") ) );
        
        }
        { //::cv::Vec< float, 3 >::dot
        
            typedef cv::Vec< float, 3 > exported_class_t;
            typedef float ( exported_class_t::*dot_function_type )( ::cv::Vec< float, 3 > const & ) const;
            
            Vec3f_exposer.def( 
                "dot"
                , dot_function_type( &::cv::Vec< float, 3 >::dot )
                , ( bp::arg("v") ) );
        
        }
        { //::cv::Vec< float, 3 >::operator[]
        
            typedef cv::Vec< float, 3 > exported_class_t;
            typedef float ( exported_class_t::*__getitem___function_type )( int ) const;
            
            Vec3f_exposer.def( 
                "__getitem__"
                , __getitem___function_type( &::cv::Vec< float, 3 >::operator[] )
                , ( bp::arg("i") )
                , "\nWrapped function:"
    "\n    operator[]" );
        
        }
        { //::cv::Vec< float, 3 >::operator[]
        
            typedef cv::Vec< float, 3 > exported_class_t;
            typedef float & ( exported_class_t::*__getitem___function_type )( int ) ;
            
            Vec3f_exposer.def( 
                "__getitem__"
                , __getitem___function_type( &::cv::Vec< float, 3 >::operator[] )
                , ( bp::arg("i") )
                , bp::return_value_policy< bp::copy_non_const_reference >()
                , "\nWrapped function:"
    "\n    operator[]" );
        
        }
        Vec3f_exposer.staticmethod( "all" );
        Vec3f_exposer.add_property("ndarray", &sdcpp::as_ndarray< cv::Vec<float,3> >);
        Vec3f_exposer.def("__iadd__", &__iadd__<cv::Vec3f, cv::Vec3b>, bp::return_self<>() );
        Vec3f_exposer.def("__isub__", &__isub__<cv::Vec3f, cv::Vec3b>, bp::return_self<>() );
        Vec3f_exposer.def("__iadd__", &__iadd__<cv::Vec3f, cv::Vec3s>, bp::return_self<>() );
        Vec3f_exposer.def("__isub__", &__isub__<cv::Vec3f, cv::Vec3s>, bp::return_self<>() );
        Vec3f_exposer.def("__iadd__", &__iadd__<cv::Vec3f, cv::Vec3w>, bp::return_self<>() );
        Vec3f_exposer.def("__isub__", &__isub__<cv::Vec3f, cv::Vec3w>, bp::return_self<>() );
        Vec3f_exposer.def("__iadd__", &__iadd__<cv::Vec3f, cv::Vec3i>, bp::return_self<>() );
        Vec3f_exposer.def("__isub__", &__isub__<cv::Vec3f, cv::Vec3i>, bp::return_self<>() );
        Vec3f_exposer.def("__iadd__", &__iadd__<cv::Vec3f, cv::Vec3f>, bp::return_self<>() );
        Vec3f_exposer.def("__isub__", &__isub__<cv::Vec3f, cv::Vec3f>, bp::return_self<>() );
        Vec3f_exposer.def("__iadd__", &__iadd__<cv::Vec3f, cv::Vec3d>, bp::return_self<>() );
        Vec3f_exposer.def("__isub__", &__isub__<cv::Vec3f, cv::Vec3d>, bp::return_self<>() );
        Vec3f_exposer.def("__add__", &__add__<cv::Vec3f, cv::Vec3f> );
        Vec3f_exposer.def("__sub__", &__sub__<cv::Vec3f, cv::Vec3f> );
        Vec3f_exposer.def("__eq__", &__eq__<cv::Vec3f, cv::Vec3f> );
        Vec3f_exposer.def("__ne__", &__ne__<cv::Vec3f, cv::Vec3f> );
        Vec3f_exposer.def("__imul__", &__imul__<cv::Vec3f, float>, bp::return_self<>() );
        Vec3f_exposer.def("__mul__", &__mul__<cv::Vec3f, float> );
        Vec3f_exposer.def("__rmul__", &__rmul__<float, cv::Vec3f> );
        Vec3f_exposer.def("__neg__", &__neg__<cv::Vec3f> );
    }

    { //::cv::Vec< float, 4 >
        typedef bp::class_< cv::Vec< float, 4 > > Vec4f_exposer_t;
        Vec4f_exposer_t Vec4f_exposer = Vec4f_exposer_t( "Vec4f", bp::init< >() );
        bp::scope Vec4f_scope( Vec4f_exposer );
        Vec4f_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::Vec< float, 4 > >() );
        bp::scope().attr("depth") = (int)cv::Vec<float, 4>::depth;
        bp::scope().attr("channels") = (int)cv::Vec<float, 4>::channels;
        bp::scope().attr("type") = (int)cv::Vec<float, 4>::type;
        Vec4f_exposer.def( bp::init< float >(( bp::arg("v0") )) );
        bp::implicitly_convertible< float, cv::Vec< float, 4 > >();
        Vec4f_exposer.def( bp::init< float, float >(( bp::arg("v0"), bp::arg("v1") )) );
        Vec4f_exposer.def( bp::init< float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2") )) );
        Vec4f_exposer.def( bp::init< float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3") )) );
        Vec4f_exposer.def( bp::init< float, float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4") )) );
        Vec4f_exposer.def( bp::init< float, float, float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4"), bp::arg("v5") )) );
        Vec4f_exposer.def( bp::init< float, float, float, float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4"), bp::arg("v5"), bp::arg("v6") )) );
        Vec4f_exposer.def( bp::init< float, float, float, float, float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4"), bp::arg("v5"), bp::arg("v6"), bp::arg("v7") )) );
        Vec4f_exposer.def( bp::init< float, float, float, float, float, float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4"), bp::arg("v5"), bp::arg("v6"), bp::arg("v7"), bp::arg("v8") )) );
        Vec4f_exposer.def( bp::init< float, float, float, float, float, float, float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4"), bp::arg("v5"), bp::arg("v6"), bp::arg("v7"), bp::arg("v8"), bp::arg("v9") )) );
        Vec4f_exposer.def( bp::init< cv::Vec< float, 4 > const & >(( bp::arg("v") )) );
        { //::cv::Vec< float, 4 >::all
        
            typedef cv::Vec< float, 4 > exported_class_t;
            typedef ::cv::Vec< float, 4 > ( *all_function_type )( float );
            
            Vec4f_exposer.def( 
                "all"
                , all_function_type( &::cv::Vec< float, 4 >::all )
                , ( bp::arg("alpha") ) );
        
        }
        { //::cv::Vec< float, 4 >::cross
        
            typedef cv::Vec< float, 4 > exported_class_t;
            typedef ::cv::Vec< float, 4 > ( exported_class_t::*cross_function_type )( ::cv::Vec< float, 4 > const & ) const;
            
            Vec4f_exposer.def( 
                "cross"
                , cross_function_type( &::cv::Vec< float, 4 >::cross )
                , ( bp::arg("v") ) );
        
        }
        { //::cv::Vec< float, 4 >::ddot
        
            typedef cv::Vec< float, 4 > exported_class_t;
            typedef double ( exported_class_t::*ddot_function_type )( ::cv::Vec< float, 4 > const & ) const;
            
            Vec4f_exposer.def( 
                "ddot"
                , ddot_function_type( &::cv::Vec< float, 4 >::ddot )
                , ( bp::arg("v") ) );
        
        }
        { //::cv::Vec< float, 4 >::dot
        
            typedef cv::Vec< float, 4 > exported_class_t;
            typedef float ( exported_class_t::*dot_function_type )( ::cv::Vec< float, 4 > const & ) const;
            
            Vec4f_exposer.def( 
                "dot"
                , dot_function_type( &::cv::Vec< float, 4 >::dot )
                , ( bp::arg("v") ) );
        
        }
        { //::cv::Vec< float, 4 >::operator[]
        
            typedef cv::Vec< float, 4 > exported_class_t;
            typedef float ( exported_class_t::*__getitem___function_type )( int ) const;
            
            Vec4f_exposer.def( 
                "__getitem__"
                , __getitem___function_type( &::cv::Vec< float, 4 >::operator[] )
                , ( bp::arg("i") )
                , "\nWrapped function:"
    "\n    operator[]" );
        
        }
        { //::cv::Vec< float, 4 >::operator[]
        
            typedef cv::Vec< float, 4 > exported_class_t;
            typedef float & ( exported_class_t::*__getitem___function_type )( int ) ;
            
            Vec4f_exposer.def( 
                "__getitem__"
                , __getitem___function_type( &::cv::Vec< float, 4 >::operator[] )
                , ( bp::arg("i") )
                , bp::return_value_policy< bp::copy_non_const_reference >()
                , "\nWrapped function:"
    "\n    operator[]" );
        
        }
        Vec4f_exposer.staticmethod( "all" );
        Vec4f_exposer.add_property("ndarray", &sdcpp::as_ndarray< cv::Vec<float,4> >);
        Vec4f_exposer.def("__iadd__", &__iadd__<cv::Vec4f, cv::Vec4b>, bp::return_self<>() );
        Vec4f_exposer.def("__isub__", &__isub__<cv::Vec4f, cv::Vec4b>, bp::return_self<>() );
        Vec4f_exposer.def("__iadd__", &__iadd__<cv::Vec4f, cv::Vec4s>, bp::return_self<>() );
        Vec4f_exposer.def("__isub__", &__isub__<cv::Vec4f, cv::Vec4s>, bp::return_self<>() );
        Vec4f_exposer.def("__iadd__", &__iadd__<cv::Vec4f, cv::Vec4w>, bp::return_self<>() );
        Vec4f_exposer.def("__isub__", &__isub__<cv::Vec4f, cv::Vec4w>, bp::return_self<>() );
        Vec4f_exposer.def("__iadd__", &__iadd__<cv::Vec4f, cv::Vec4i>, bp::return_self<>() );
        Vec4f_exposer.def("__isub__", &__isub__<cv::Vec4f, cv::Vec4i>, bp::return_self<>() );
        Vec4f_exposer.def("__iadd__", &__iadd__<cv::Vec4f, cv::Vec4f>, bp::return_self<>() );
        Vec4f_exposer.def("__isub__", &__isub__<cv::Vec4f, cv::Vec4f>, bp::return_self<>() );
        Vec4f_exposer.def("__iadd__", &__iadd__<cv::Vec4f, cv::Vec4d>, bp::return_self<>() );
        Vec4f_exposer.def("__isub__", &__isub__<cv::Vec4f, cv::Vec4d>, bp::return_self<>() );
        Vec4f_exposer.def("__add__", &__add__<cv::Vec4f, cv::Vec4f> );
        Vec4f_exposer.def("__sub__", &__sub__<cv::Vec4f, cv::Vec4f> );
        Vec4f_exposer.def("__eq__", &__eq__<cv::Vec4f, cv::Vec4f> );
        Vec4f_exposer.def("__ne__", &__ne__<cv::Vec4f, cv::Vec4f> );
        Vec4f_exposer.def("__imul__", &__imul__<cv::Vec4f, float>, bp::return_self<>() );
        Vec4f_exposer.def("__mul__", &__mul__<cv::Vec4f, float> );
        Vec4f_exposer.def("__rmul__", &__rmul__<float, cv::Vec4f> );
        Vec4f_exposer.def("__neg__", &__neg__<cv::Vec4f> );
    }

    { //::cv::Vec< float, 6 >
        typedef bp::class_< cv::Vec< float, 6 > > Vec6f_exposer_t;
        Vec6f_exposer_t Vec6f_exposer = Vec6f_exposer_t( "Vec6f", bp::init< >() );
        bp::scope Vec6f_scope( Vec6f_exposer );
        Vec6f_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::Vec< float, 6 > >() );
        bp::scope().attr("depth") = (int)cv::Vec<float, 6>::depth;
        bp::scope().attr("channels") = (int)cv::Vec<float, 6>::channels;
        bp::scope().attr("type") = (int)cv::Vec<float, 6>::type;
        Vec6f_exposer.def( bp::init< float >(( bp::arg("v0") )) );
        bp::implicitly_convertible< float, cv::Vec< float, 6 > >();
        Vec6f_exposer.def( bp::init< float, float >(( bp::arg("v0"), bp::arg("v1") )) );
        Vec6f_exposer.def( bp::init< float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2") )) );
        Vec6f_exposer.def( bp::init< float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3") )) );
        Vec6f_exposer.def( bp::init< float, float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4") )) );
        Vec6f_exposer.def( bp::init< float, float, float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4"), bp::arg("v5") )) );
        Vec6f_exposer.def( bp::init< float, float, float, float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4"), bp::arg("v5"), bp::arg("v6") )) );
        Vec6f_exposer.def( bp::init< float, float, float, float, float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4"), bp::arg("v5"), bp::arg("v6"), bp::arg("v7") )) );
        Vec6f_exposer.def( bp::init< float, float, float, float, float, float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4"), bp::arg("v5"), bp::arg("v6"), bp::arg("v7"), bp::arg("v8") )) );
        Vec6f_exposer.def( bp::init< float, float, float, float, float, float, float, float, float, float >(( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3"), bp::arg("v4"), bp::arg("v5"), bp::arg("v6"), bp::arg("v7"), bp::arg("v8"), bp::arg("v9") )) );
        Vec6f_exposer.def( bp::init< cv::Vec< float, 6 > const & >(( bp::arg("v") )) );
        { //::cv::Vec< float, 6 >::all
        
            typedef cv::Vec< float, 6 > exported_class_t;
            typedef ::cv::Vec< float, 6 > ( *all_function_type )( float );
            
            Vec6f_exposer.def( 
                "all"
                , all_function_type( &::cv::Vec< float, 6 >::all )
                , ( bp::arg("alpha") ) );
        
        }
        { //::cv::Vec< float, 6 >::cross
        
            typedef cv::Vec< float, 6 > exported_class_t;
            typedef ::cv::Vec< float, 6 > ( exported_class_t::*cross_function_type )( ::cv::Vec< float, 6 > const & ) const;
            
            Vec6f_exposer.def( 
                "cross"
                , cross_function_type( &::cv::Vec< float, 6 >::cross )
                , ( bp::arg("v") ) );
        
        }
        { //::cv::Vec< float, 6 >::ddot
        
            typedef cv::Vec< float, 6 > exported_class_t;
            typedef double ( exported_class_t::*ddot_function_type )( ::cv::Vec< float, 6 > const & ) const;
            
            Vec6f_exposer.def( 
                "ddot"
                , ddot_function_type( &::cv::Vec< float, 6 >::ddot )
                , ( bp::arg("v") ) );
        
        }
        { //::cv::Vec< float, 6 >::dot
        
            typedef cv::Vec< float, 6 > exported_class_t;
            typedef float ( exported_class_t::*dot_function_type )( ::cv::Vec< float, 6 > const & ) const;
            
            Vec6f_exposer.def( 
                "dot"
                , dot_function_type( &::cv::Vec< float, 6 >::dot )
                , ( bp::arg("v") ) );
        
        }
        { //::cv::Vec< float, 6 >::operator[]
        
            typedef cv::Vec< float, 6 > exported_class_t;
            typedef float ( exported_class_t::*__getitem___function_type )( int ) const;
            
            Vec6f_exposer.def( 
                "__getitem__"
                , __getitem___function_type( &::cv::Vec< float, 6 >::operator[] )
                , ( bp::arg("i") )
                , "\nWrapped function:"
    "\n    operator[]" );
        
        }
        { //::cv::Vec< float, 6 >::operator[]
        
            typedef cv::Vec< float, 6 > exported_class_t;
            typedef float & ( exported_class_t::*__getitem___function_type )( int ) ;
            
            Vec6f_exposer.def( 
                "__getitem__"
                , __getitem___function_type( &::cv::Vec< float, 6 >::operator[] )
                , ( bp::arg("i") )
                , bp::return_value_policy< bp::copy_non_const_reference >()
                , "\nWrapped function:"
    "\n    operator[]" );
        
        }
        Vec6f_exposer.staticmethod( "all" );
        Vec6f_exposer.add_property("ndarray", &sdcpp::as_ndarray< cv::Vec<float,6> >);
        Vec6f_exposer.def("__iadd__", &__iadd__<cv::Vec6f, cv::Vec6f>, bp::return_self<>() );
        Vec6f_exposer.def("__isub__", &__isub__<cv::Vec6f, cv::Vec6f>, bp::return_self<>() );
        Vec6f_exposer.def("__iadd__", &__iadd__<cv::Vec6f, cv::Vec6d>, bp::return_self<>() );
        Vec6f_exposer.def("__isub__", &__isub__<cv::Vec6f, cv::Vec6d>, bp::return_self<>() );
        Vec6f_exposer.def("__add__", &__add__<cv::Vec6f, cv::Vec6f> );
        Vec6f_exposer.def("__sub__", &__sub__<cv::Vec6f, cv::Vec6f> );
        Vec6f_exposer.def("__eq__", &__eq__<cv::Vec6f, cv::Vec6f> );
        Vec6f_exposer.def("__ne__", &__ne__<cv::Vec6f, cv::Vec6f> );
        Vec6f_exposer.def("__neg__", &__neg__<cv::Vec6f> );
    }

}
