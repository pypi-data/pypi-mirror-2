// This file has been generated by Py++.

#include "boost/python.hpp"

#include "__array_1.pypp.hpp"

#include "opencv_converters.hpp"

#include "__call_policies.pypp.hpp"

#include "boost/python/object.hpp"

#include "boost/python/tuple.hpp"

#include "with_ownershiplevel_postcall.hpp"

#include "__convenience.pypp.hpp"

#include "ndarray.hpp"

#include "boost/python/suite/indexing/vector_indexing_suite.hpp"

#include "__ctypes_integration.pypp.hpp"

#include "cv_h_wrapper.hpp"

#include "cv_h_ext/cv_h_ext_classes_1.pypp.hpp"

#include "cv_h_ext/cv_h_ext_classes_2.pypp.hpp"

#include "cv_h_ext/cv_h_ext_classes_3.pypp.hpp"

#include "cv_h_ext/cv_h_ext_enumerations.pypp.hpp"

#include "cv_h_ext/cv_h_ext_free_functions.pypp.hpp"

namespace bp = boost::python;

static void cvAcc_ef7ed9735ac6fce4129e5e89f645482d( ::cv::Mat & image, ::cv::Mat & sum, ::cv::Mat mask=cv::Mat() ){
    ::cvAcc(get_CvMat_ptr(image), get_CvMat_ptr(sum), get_CvMat_ptr(mask));
}

static boost::python::object cvApproxChains_b8771ffee686c2a91ab4b9fdc5919291( ::CvSeq * src_seq, ::cv::MemStorage & storage, int method=2, double parameter=0, int minimal_perimeter=0, int recursive=0 ){
    ::CvSeq * result = ::cvApproxChains(src_seq, (CvMemStorage *)storage, method, parameter, minimal_perimeter, recursive);
    typedef bp::with_custodian_and_ward_postcall< 0, 2, bp::return_value_policy< bp::reference_existing_object > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvSeq * >( result ) );
}

static void cvBoxPoints_a61b9e0e802e9997b4fd4c2315f450ae( cv::RotatedRect const & box, ::CvPoint2D32f * pt ){
    ::cvBoxPoints((CvBox2D const &)box, pt);
}

static boost::python::tuple cvCalcAffineFlowPyrLK_3a4b3f5dff85e72a121da3f42cded4aa( ::cv::Mat & prev, ::cv::Mat & curr, ::cv::Mat & prev_pyr, ::cv::Mat & curr_pyr, std::vector<cv::Point_<float> > const & prev_features, cv::Size_<int> const & win_size, int level, cv::TermCriteria const & criteria, int flags ){
    int prev_features2=(int)(prev_features.size());
    std::vector<cv::Point_<float> > curr_features2(prev_features2);
    std::vector<float> matrices2(prev_features2);
    std::vector<char> status2(prev_features2);
    std::vector<float> track_error2(prev_features2);
    ::cvCalcAffineFlowPyrLK(get_CvMat_ptr(prev), get_CvMat_ptr(curr), get_CvMat_ptr(prev_pyr), get_CvMat_ptr(curr_pyr), (::CvPoint2D32f const *)(&prev_features[0]), (::CvPoint2D32f *)(&curr_features2[0]), (float *)(&matrices2[0]), prev_features2, (CvSize const &)win_size, level, (char *)(&status2[0]), (float *)(&track_error2[0]), (CvTermCriteria const &)criteria, flags);
    return bp::make_tuple( curr_features2, matrices2, status2, track_error2 );
}

static boost::python::object cvCalcEMD2_f4e5308a9258b3a75a06fb112d06a2e8( ::cv::Mat & signature1, ::cv::Mat & signature2, int distance_type, boost::python::object distance_func=bp::object(), ::cv::Mat cost_matrix=cv::Mat(), ::cv::Mat flow=cv::Mat(), float * lower_bound=0, boost::python::object userdata=bp::object() ){
    bool b_distance_func= distance_func.ptr() != Py_None;
    boost::python::tuple z_distance_func;
    if(b_distance_func) z_distance_func = bp::make_tuple(distance_func, userdata);
    float result = ::cvCalcEMD2(get_CvMat_ptr(signature1), get_CvMat_ptr(signature2), distance_type, b_distance_func? sdDistanceFunction: 0, get_CvMat_ptr(cost_matrix), get_CvMat_ptr(flow), lower_bound, b_distance_func? (void *)(z_distance_func.ptr()): 0);
    return bp::object( result );
}

static boost::python::object cvCalcGlobalOrientation_9d75a586d5a67c41e4450ccf9b8af7b3( ::cv::Mat & orientation, ::cv::Mat & mask, ::cv::Mat & mhi, double timestamp, double duration ){
    double result = ::cvCalcGlobalOrientation(get_CvMat_ptr(orientation), get_CvMat_ptr(mask), get_CvMat_ptr(mhi), timestamp, duration);
    return bp::object( result );
}

static void cvCalcMotionGradient_7506fb6ca34b4a6cb9165f5aff081454( ::cv::Mat & mhi, ::cv::Mat & mask, ::cv::Mat & orientation, double delta1, double delta2, int aperture_size=3 ){
    ::cvCalcMotionGradient(get_CvMat_ptr(mhi), get_CvMat_ptr(mask), get_CvMat_ptr(orientation), delta1, delta2, aperture_size);
}

static void cvCalcOpticalFlowBM_3537c5574d176e4f3dea85450be5ee9f( ::cv::Mat & prev, ::cv::Mat & curr, cv::Size_<int> const & block_size, cv::Size_<int> const & shift_size, cv::Size_<int> const & max_range, int use_previous, ::cv::Mat & velx, ::cv::Mat & vely ){
    ::cvCalcOpticalFlowBM(get_CvMat_ptr(prev), get_CvMat_ptr(curr), (CvSize const &)block_size, (CvSize const &)shift_size, (CvSize const &)max_range, use_previous, get_CvMat_ptr(velx), get_CvMat_ptr(vely));
}

static void cvCalcOpticalFlowFarneback_409b7a55ce4ab8f251cb192176e9376c( ::cv::Mat & prev, ::cv::Mat & next, ::cv::Mat & flow, double pyr_scale, int levels, int winsize, int iterations, int poly_n, double poly_sigma, int flags ){
    ::cvCalcOpticalFlowFarneback(get_CvMat_ptr(prev), get_CvMat_ptr(next), get_CvMat_ptr(flow), pyr_scale, levels, winsize, iterations, poly_n, poly_sigma, flags);
}

static void cvCalcOpticalFlowHS_0757feb4eeb7fd8c38b710aec2f5f8e9( ::cv::Mat & prev, ::cv::Mat & curr, int use_previous, ::cv::Mat & velx, ::cv::Mat & vely, double lambda, cv::TermCriteria const & criteria ){
    ::cvCalcOpticalFlowHS(get_CvMat_ptr(prev), get_CvMat_ptr(curr), use_previous, get_CvMat_ptr(velx), get_CvMat_ptr(vely), lambda, (CvTermCriteria const &)criteria);
}

static void cvCalcOpticalFlowLK_0539268816232dbc93df209c0dc87327( ::cv::Mat & prev, ::cv::Mat & curr, cv::Size_<int> const & win_size, ::cv::Mat & velx, ::cv::Mat & vely ){
    ::cvCalcOpticalFlowLK(get_CvMat_ptr(prev), get_CvMat_ptr(curr), (CvSize const &)win_size, get_CvMat_ptr(velx), get_CvMat_ptr(vely));
}

static boost::python::tuple cvCalcOpticalFlowPyrLK_925fd4448f97740474886f84b12836c2( ::cv::Mat & prev, ::cv::Mat & curr, ::cv::Mat & prev_pyr, ::cv::Mat & curr_pyr, std::vector<cv::Point_<float> > const & prev_features, cv::Size_<int> const & win_size, int level, cv::TermCriteria const & criteria, int flags ){
    int prev_features2=(int)(prev_features.size());
    std::vector<cv::Point_<float> > curr_features2(prev_features2);
    std::vector<char> status2(prev_features2);
    std::vector<float> track_error2(prev_features2);
    ::cvCalcOpticalFlowPyrLK(get_CvMat_ptr(prev), get_CvMat_ptr(curr), get_CvMat_ptr(prev_pyr), get_CvMat_ptr(curr_pyr), (::CvPoint2D32f const *)(&prev_features[0]), (::CvPoint2D32f *)(&curr_features2[0]), prev_features2, (CvSize const &)win_size, level, (char *)(&status2[0]), (float *)(&track_error2[0]), (CvTermCriteria const &)criteria, flags);
    return bp::make_tuple( curr_features2, status2, track_error2 );
}

static boost::python::object cvCheckChessboard_59f8753d978791ecd1fc97cea5e10f04( ::cv::Mat & src, cv::Size_<int> const & size ){
    int result = ::cvCheckChessboard(get_IplImage_ptr(src), (CvSize const &)size);
    return bp::object( result );
}

static boost::python::object cvContourFromContourTree_47f5c065694c470d5919cd861fe8d325( ::CvContourTree const * tree, ::cv::MemStorage & storage, cv::TermCriteria const & criteria ){
    ::CvSeq * result = ::cvContourFromContourTree(tree, (CvMemStorage *)storage, (CvTermCriteria const &)criteria);
    typedef bp::with_custodian_and_ward_postcall< 0, 2, bp::return_value_policy< bp::reference_existing_object > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvSeq * >( result ) );
}

static boost::python::object cvConvexityDefects_cc97bf52cc42e365950605a23b42e95a( ::cv::Mat & contour, ::cv::Mat & convexhull, ::cv::MemStorage storage=cv::MemStorage(0) ){
    ::CvSeq * result = ::cvConvexityDefects(get_CvMat_ptr(contour), get_CvMat_ptr(convexhull), (CvMemStorage *)storage);
    typedef bp::with_custodian_and_ward_postcall< 0, 2, bp::with_custodian_and_ward_postcall< 0, 1, bp::with_custodian_and_ward_postcall< 0, 3, bp::return_value_policy< bp::reference_existing_object > > > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvSeq * >( result ) );
}

static void cvCorrectMatches_055faac2f695cea7fa86e829ba6bdc99( ::cv::Mat & F, ::cv::Mat & points1, ::cv::Mat & points2, ::cv::Mat & new_points1, ::cv::Mat & new_points2 ){
    ::cvCorrectMatches(get_CvMat_ptr(F), get_CvMat_ptr(points1), get_CvMat_ptr(points2), get_CvMat_ptr(new_points1), get_CvMat_ptr(new_points2));
}

static boost::python::object cvCreateContourTree_d634bc0ea26451db7832bf763df380f3( ::CvSeq const * contour, ::cv::MemStorage & storage, double threshold ){
    ::CvContourTree * result = ::cvCreateContourTree(contour, (CvMemStorage *)storage, threshold);
    typedef bp::with_custodian_and_ward_postcall< 0, 2, bp::return_value_policy< bp::reference_existing_object > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvContourTree * >( result ) );
}

static boost::python::object cvCreateKDTree_bedd697814f42b0adb235e1d1bda9bdd( ::cv::Mat & desc ){
    CvFeatureTree * result = ::cvCreateKDTree(get_CvMat_ptr(desc));
    typedef bp::with_ownershiplevel_postcall< 1, bp::with_custodian_and_ward_postcall< 0, 1, bp::return_value_policy< bp::reference_existing_object > > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, CvFeatureTree * >( result ) );
}

static boost::python::object cvCreateSpillTree_22146c3478f3d8c8ff22213a86f1b244( ::cv::Mat & raw_data, int const naive=50, double const rho=6.99999999999999955591079014993738383054733276367e-1, double const tau=1.00000000000000005551115123125782702118158340454e-1 ){
    CvFeatureTree * result = ::cvCreateSpillTree(get_CvMat_ptr(raw_data), naive, rho, tau);
    typedef bp::with_ownershiplevel_postcall< 1, bp::with_custodian_and_ward_postcall< 0, 1, bp::return_value_policy< bp::reference_existing_object > > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, CvFeatureTree * >( result ) );
}

static boost::python::object cvCreateSubdiv2D_56b293d10aa190d3e2dee490cf17ff0c( int subdiv_type, int header_size, int vtx_size, int quadedge_size, ::cv::MemStorage & storage ){
    ::CvSubdiv2D * result = ::cvCreateSubdiv2D(subdiv_type, header_size, vtx_size, quadedge_size, (CvMemStorage *)storage);
    typedef bp::with_custodian_and_ward_postcall< 0, 5, bp::return_value_policy< bp::reference_existing_object > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvSubdiv2D * >( result ) );
}

static boost::python::object cvCreateSubdivDelaunay2D_8eda8e15f20a4d068defcf9afd8ee589( cv::Rect_<int> const & rect, ::cv::MemStorage & storage ){
    ::CvSubdiv2D * result = ::cvCreateSubdivDelaunay2D((CvRect const &)rect, (CvMemStorage *)storage);
    typedef bp::with_custodian_and_ward_postcall< 0, 2, bp::return_value_policy< bp::reference_existing_object > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvSubdiv2D * >( result ) );
}

static void cvDistTransform_68addecae85b6b48cd46044102a6c028( ::cv::Mat & src, ::cv::Mat & dst, int distance_type=2, std::vector<float> const & mask=std::vector<float>(), ::cv::Mat labels=cv::Mat() ){
    ::cvDistTransform(get_CvMat_ptr(src), get_CvMat_ptr(dst), distance_type, (int)(mask.size()), (float const *)(&mask[0]), get_CvMat_ptr(labels));
}

static boost::python::object cvEstimateRigidTransform_2f885814bd847b94c8621a570a36abad( ::cv::Mat & A, ::cv::Mat & B, ::cv::Mat & M, int full_affine ){
    int result = ::cvEstimateRigidTransform(get_CvMat_ptr(A), get_CvMat_ptr(B), get_CvMat_ptr(M), full_affine);
    return bp::object( result );
}

static boost::python::object cvExtractSURF_7b3c589cd61921d6c8f246dded72b86f( ::cv::Mat & img, ::cv::Mat & mask, cv::Seq<CvSURFPoint> & keypoints, ::CvSURFParams params, int useProvidedKeyPts=0 ){
    CvSeq * descriptors2=0;
    ::cvExtractSURF(get_CvMat_ptr(img), get_CvMat_ptr(mask), &keypoints.seq, &descriptors2, keypoints.seq->storage, params, useProvidedKeyPts);
    return bp::object( convert_CvSeq_ptr_to_vector<float>(descriptors2) );
}

static void cvFindFeatures_3cdcd7c246944a80a295b6f20e448cfc( ::CvFeatureTree * tr, ::cv::Mat & query_points, ::cv::Mat & indices, ::cv::Mat & dist, int k, int emax=20 ){
    ::cvFindFeatures(tr, get_CvMat_ptr(query_points), get_CvMat_ptr(indices), get_CvMat_ptr(dist), k, emax);
}

static boost::python::object cvFindFeaturesBoxed_6d675cd8257b64f665600bd276900d3e( ::CvFeatureTree * tr, ::cv::Mat & bounds_min, ::cv::Mat & bounds_max, ::cv::Mat & out_indices ){
    int result = ::cvFindFeaturesBoxed(tr, get_CvMat_ptr(bounds_min), get_CvMat_ptr(bounds_max), get_CvMat_ptr(out_indices));
    return bp::object( result );
}

static boost::python::object cvFindNearestPoint2D_4658231361f43a6fc66c2e150f75dca8( ::CvSubdiv2D * subdiv, cv::Point_<float> const & pt ){
    ::CvSubdiv2DPoint * result = ::cvFindNearestPoint2D(subdiv, (CvPoint2D32f const &)pt);
    typedef bp::with_custodian_and_ward_postcall< 0, 1, bp::return_value_policy< bp::reference_existing_object > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvSubdiv2DPoint * >( result ) );
}

static void cvFindStereoCorrespondenceGC_c3eefaed321a780e7059f7c3392c4672( ::cv::Mat & left, ::cv::Mat & right, ::cv::Mat & disparityLeft, ::cv::Mat & disparityRight, ::CvStereoGCState * state, int useDisparityGuess=0 ){
    ::cvFindStereoCorrespondenceGC(get_CvMat_ptr(left), get_CvMat_ptr(right), get_CvMat_ptr(disparityLeft), get_CvMat_ptr(disparityRight), state, useDisparityGuess);
}

static void cvGetQuadrangleSubPix_fe2b1a5028fa8b02301dc960cdfbc131( ::cv::Mat & src, ::cv::Mat & dst, ::cv::Mat & map_matrix ){
    ::cvGetQuadrangleSubPix(get_CvMat_ptr(src), get_CvMat_ptr(dst), get_CvMat_ptr(map_matrix));
}

static void cvInitSubdivDelaunay2D_9125b981b281211984978f2c9ce6eb8b( ::CvSubdiv2D * subdiv, cv::Rect_<int> const & rect ){
    ::cvInitSubdivDelaunay2D(subdiv, (CvRect const &)rect);
}

static void cvLSHAdd_fead3e6b36de0b14c88ef1b561c6e621( ::CvLSH * lsh, ::cv::Mat & data, ::cv::Mat indices=cv::Mat() ){
    ::cvLSHAdd(lsh, get_CvMat_ptr(data), get_CvMat_ptr(indices));
}

static void cvLSHQuery_a5f47e360cc9701a6672c12490153852( ::CvLSH * lsh, ::cv::Mat & query_points, ::cv::Mat & indices, ::cv::Mat & dist, int k, int emax ){
    ::cvLSHQuery(lsh, get_CvMat_ptr(query_points), get_CvMat_ptr(indices), get_CvMat_ptr(dist), k, emax);
}

static void cvLSHRemove_5f32fb503216c52038c4ae3bf17b62db( ::CvLSH * lsh, ::cv::Mat & indices ){
    ::cvLSHRemove(lsh, get_CvMat_ptr(indices));
}

static void cvLinearPolar_b75d44697de3c90f0462366e93d77425( ::cv::Mat & src, ::cv::Mat & dst, cv::Point_<float> const & center, double maxRadius, int flags=9 ){
    ::cvLinearPolar(get_CvMat_ptr(src), get_CvMat_ptr(dst), (CvPoint2D32f const &)center, maxRadius, flags);
}

static void cvLogPolar_27c4d18226a6e750886777db97773f4d( ::cv::Mat & src, ::cv::Mat & dst, cv::Point_<float> const & center, double M, int flags=9 ){
    ::cvLogPolar(get_CvMat_ptr(src), get_CvMat_ptr(dst), (CvPoint2D32f const &)center, M, flags);
}

static void cvMultiplyAcc_c64c83fc39cb1265f3d1a69d9e600a47( ::cv::Mat & image1, ::cv::Mat & image2, ::cv::Mat & acc, ::cv::Mat mask=cv::Mat() ){
    ::cvMultiplyAcc(get_CvMat_ptr(image1), get_CvMat_ptr(image2), get_CvMat_ptr(acc), get_CvMat_ptr(mask));
}

static void cvPOSIT_87713841f128738a6d8e29669752951a( ::CvPOSITObject * posit_object, ::CvPoint2D32f * image_points, double focal_length, cv::TermCriteria const & criteria, ::CvMatr32f rotation_matrix, ::CvVect32f translation_vector ){
    ::cvPOSIT(posit_object, image_points, focal_length, (CvTermCriteria const &)criteria, rotation_matrix, translation_vector);
}

static boost::python::object cvPointSeqFromMat_ef8459cfef37d715411cf088e0da5576( int seq_kind, ::cv::Mat & mat, ::CvContour * contour_header, ::CvSeqBlock * block ){
    ::CvSeq * result = ::cvPointSeqFromMat(seq_kind, get_CvMat_ptr(mat), contour_header, block);
    typedef bp::with_custodian_and_ward_postcall< 0, 2, bp::with_custodian_and_ward_postcall< 0, 3, bp::return_value_policy< bp::reference_existing_object > > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvSeq * >( result ) );
}

static void cvPyrMeanShiftFiltering_21ec6b7149a6e00a31f1d76aebb9a22b( ::cv::Mat & src, ::cv::Mat & dst, double sp, double sr, int max_level=1, cv::TermCriteria const & termcrit=cv::TermCriteria(3, 5, 1.0e+0) ){
    ::cvPyrMeanShiftFiltering(get_CvMat_ptr(src), get_CvMat_ptr(dst), sp, sr, max_level, (CvTermCriteria const &)termcrit);
}

static boost::python::object cvPyrSegmentation_0a5e58f4641f1c9757bb83d3f16f4191( ::cv::Mat & src, ::cv::Mat & dst, ::cv::MemStorage & storage, int level, double threshold1, double threshold2 ){
    CvSeq * comp2=(CvSeq *)0;
    ::cvPyrSegmentation(get_IplImage_ptr(src), get_IplImage_ptr(dst), (CvMemStorage *)storage, &comp2, level, threshold1, threshold2);
    typedef bp::with_custodian_and_ward_postcall< 0, 3, bp::return_value_policy< bp::reference_existing_object > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, CvSeq * >( comp2 ) );
}

static void cvReleasePOSITObject_679a5da1d4e28b86fdc9a28aa691c6ef( ::CvPOSITObject posit_object ){
    CvPOSITObject * tmp_posit_object = reinterpret_cast< CvPOSITObject * >(& posit_object);
    ::cvReleasePOSITObject(reinterpret_cast< CvPOSITObject * * >( & tmp_posit_object ));
}

static void cvReleaseStereoGCState_f9448f3f98670de75bac96972e1b9d45( ::CvStereoGCState state ){
    CvStereoGCState * tmp_state = reinterpret_cast< CvStereoGCState * >(& state);
    ::cvReleaseStereoGCState(reinterpret_cast< CvStereoGCState * * >( & tmp_state ));
}

static void cvReprojectImageTo3D_4ca87cd67ba33150d51d345f21a24447( ::cv::Mat & disparityImage, ::cv::Mat & _3dImage, ::cv::Mat & Q, int handleMissingValues=0 ){
    ::cvReprojectImageTo3D(get_CvMat_ptr(disparityImage), get_CvMat_ptr(_3dImage), get_CvMat_ptr(Q), handleMissingValues);
}

static void cvRunningAvg_16515bd00db4472140aa21554e25bbc7( ::cv::Mat & image, ::cv::Mat & acc, double alpha, ::cv::Mat mask=cv::Mat() ){
    ::cvRunningAvg(get_CvMat_ptr(image), get_CvMat_ptr(acc), alpha, get_CvMat_ptr(mask));
}

static boost::python::object cvSampleLine_9eb7a74db955c3538aef5be3e7392fc5( ::cv::Mat & image, cv::Point_<int> const & pt1, cv::Point_<int> const & pt2, void * buffer, int connectivity=8 ){
    int result = ::cvSampleLine(get_CvMat_ptr(image), (CvPoint const &)pt1, (CvPoint const &)pt2, buffer, connectivity);
    return bp::object( result );
}

static boost::python::object cvSegmentMotion_ed831c1d8f816ea759222aec4d41f1f0( ::cv::Mat & mhi, ::cv::Mat & seg_mask, ::cv::MemStorage & storage, double timestamp, double seg_thresh ){
    ::CvSeq * result = ::cvSegmentMotion(get_CvMat_ptr(mhi), get_CvMat_ptr(seg_mask), (CvMemStorage *)storage, timestamp, seg_thresh);
    typedef bp::with_custodian_and_ward_postcall< 0, 3, bp::return_value_policy< bp::reference_existing_object > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvSeq * >( result ) );
}

static void cvSmooth_77e0c983f4273497b4a61c0a6dcda04f( ::cv::Mat & src, ::cv::Mat & dst, int smoothtype=2, int size1=3, int size2=0, double sigma1=0, double sigma2=0 ){
    ::cvSmooth(get_CvMat_ptr(src), get_CvMat_ptr(dst), smoothtype, size1, size2, sigma1, sigma2);
}

static void cvSquareAcc_df8ad076f822a2856ccecbbdf6a2b2b0( ::cv::Mat & image, ::cv::Mat & sqsum, ::cv::Mat mask=cv::Mat() ){
    ::cvSquareAcc(get_CvMat_ptr(image), get_CvMat_ptr(sqsum), get_CvMat_ptr(mask));
}

static boost::python::object cvStarKeypoint_1c87e44a3d11d1203d898ffe498e82f7( cv::Point_<int> const & pt, int size, float response ){
    ::CvStarKeypoint result = ::cvStarKeypoint((CvPoint const &)pt, size, response);
    return bp::object( result );
}

static boost::python::object cvStartFindContours_1914ce1dccb0d5710ebdf49d4c3d96cc( ::cv::Mat & image, ::cv::MemStorage & storage, int header_size=88u, int mode=1, int method=2, cv::Point_<int> const & offset=cv::Point(0, 0) ){
    ::CvContourScanner result = ::cvStartFindContours(get_CvMat_ptr(image), (CvMemStorage *)storage, header_size, mode, method, (CvPoint const &)offset);
    typedef bp::with_ownershiplevel_postcall< 1, bp::with_custodian_and_ward_postcall< 0, 2, bp::return_value_policy< bp::reference_existing_object > > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvContourScanner >( result ) );
}

static boost::python::tuple cvSubdiv2DLocate_1df86dbc29fc9de6df2bbdb2196d6db3( ::CvSubdiv2D * subdiv, cv::Point_<float> const & pt, ::CvSubdiv2DEdge * edge ){
    CvSubdiv2DPoint * vertex2=(CvSubdiv2DPoint *)0;
    ::CvSubdiv2DPointLocation result = ::cvSubdiv2DLocate(subdiv, (CvPoint2D32f const &)pt, edge, &vertex2);
    return bp::make_tuple( result, vertex2 );
}

static boost::python::object cvSubdivDelaunay2DInsert_0d66ff0b2bc8918d0793f968404f1cb2( ::CvSubdiv2D * subdiv, cv::Point_<float> const & pt ){
    ::CvSubdiv2DPoint * result = ::cvSubdivDelaunay2DInsert(subdiv, (CvPoint2D32f const &)pt);
    typedef bp::with_custodian_and_ward_postcall< 0, 1, bp::return_value_policy< bp::reference_existing_object > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvSubdiv2DPoint * >( result ) );
}

static boost::python::object cvTriangleArea_727599fdabcae9fb78274a766e9dac94( cv::Point_<float> const & a, cv::Point_<float> const & b, cv::Point_<float> const & c ){
    double result = ::cvTriangleArea((CvPoint2D32f const &)a, (CvPoint2D32f const &)b, (CvPoint2D32f const &)c);
    return bp::object( result );
}

static void cvTriangulatePoints_eb948ff6300aa4ebf4fad0ec7d6d4e78( ::cv::Mat & projMatr1, ::cv::Mat & projMatr2, ::cv::Mat & projPoints1, ::cv::Mat & projPoints2, ::cv::Mat & points4D ){
    ::cvTriangulatePoints(get_CvMat_ptr(projMatr1), get_CvMat_ptr(projMatr2), get_CvMat_ptr(projPoints1), get_CvMat_ptr(projPoints2), get_CvMat_ptr(points4D));
}

static void cvUpdateMotionHistory_fb635b1eb55f77d94f46a70f41eac0b3( ::cv::Mat & silhouette, ::cv::Mat & mhi, double timestamp, double duration ){
    ::cvUpdateMotionHistory(get_CvMat_ptr(silhouette), get_CvMat_ptr(mhi), timestamp, duration);
}

static void sdSnakeImage( cv::Mat const & image, cv::Mat const & points, bp::object const & alpha, bp::object const & beta, bp::object const & gamma, int coeff_usage, cv::Size const & win, cv::TermCriteria const & criteria, int calc_gradient=1 ){
    char s[500];
    float alpha2, beta2, gamma2;
    std::vector<float> alpha3, beta3, gamma3;
    
    cv::Point *points2; int points2_len; convert_from_Mat_to_array_of_T(points, points2, points2_len);
    
    IplImage img = image;
    
    switch (coeff_usage)
    {
    case CV_VALUE:
        alpha2 = (float) bp::extract<float>(alpha);
        beta2 = (float) bp::extract<float>(beta);
        gamma2 = (float) bp::extract<float>(gamma);
        ::cvSnakeImage(&img, (CvPoint *)points2, points2_len, &alpha2, &beta2, &gamma2, coeff_usage, (CvSize)win, (CvTermCriteria)criteria, calc_gradient);
        break;
    case CV_ARRAY:
        convert_from_object_to_T(alpha, alpha3);
        convert_from_object_to_T(beta, beta3);
        convert_from_object_to_T(gamma, gamma3);
        ::cvSnakeImage(&img, (CvPoint *)points2, points2_len, &alpha3[0], &beta3[0], &gamma3[0], coeff_usage, (CvSize)win, (CvTermCriteria)criteria, calc_gradient);
        break;
    default:
        sprintf(s, "coeff_usage only takes either CV_VALUE or CV_ARRAY as value, %d was given.", coeff_usage);
        PyErr_SetString(PyExc_ValueError, s);
        throw bp::error_already_set(); 
    }
}

BOOST_PYTHON_MODULE(cv_h_ext){
    register_enumerations();

    bp::implicitly_convertible< cv::Seq< CvConnectedComp >, std::vector< CvConnectedComp > >();

    bp::implicitly_convertible< cv::Seq< CvSURFPoint >, std::vector< CvSURFPoint > >();

    { //::cvAcc
    
        typedef void ( *acc_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat );
        
        bp::def( 
            "acc"
            , acc_function_type( &cvAcc_ef7ed9735ac6fce4129e5e89f645482d )
            , ( bp::arg("image"), bp::arg("sum"), bp::arg("mask")=cv::Mat() )
            , "\nWrapped function:"
    "\n    cvAcc"
    "\nArgument 'image':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'sum':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'mask':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvApproxChains
    
        typedef boost::python::object ( *approxChains_function_type )( ::CvSeq *,::cv::MemStorage &,int,double,int,int );
        
        bp::def( 
            "approxChains"
            , approxChains_function_type( &cvApproxChains_b8771ffee686c2a91ab4b9fdc5919291 )
            , ( bp::arg("src_seq"), bp::arg("storage"), bp::arg("method")=(int)(2), bp::arg("parameter")=0, bp::arg("minimal_perimeter")=(int)(0), bp::arg("recursive")=(int)(0) )
            , "\nWrapped function:"
    "\n    cvApproxChains"
    "\nArgument 'storage':"\
    "\n    C++ type: ::CvMemStorage *."\
    "\n    Python type: MemStorage." );
    
    }

    { //::cvBoxPoints
    
        typedef void ( *boxPoints_function_type )( cv::RotatedRect const &,::CvPoint2D32f * );
        
        bp::def( 
            "boxPoints"
            , boxPoints_function_type( &cvBoxPoints_a61b9e0e802e9997b4fd4c2315f450ae )
            , ( bp::arg("box"), bp::arg("pt") )
            , "\nWrapped function:"
    "\n    cvBoxPoints"
    "\nArgument 'box':"\
    "\n    C++ type: ::CvBox2D."\
    "\n    Python type: RotatedRect." );
    
    }

    { //::cvCalcAffineFlowPyrLK
    
        typedef boost::python::tuple ( *calcAffineFlowPyrLK_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,std::vector<cv::Point_<float> > const &,cv::Size_<int> const &,int,cv::TermCriteria const &,int );
        
        bp::def( 
            "calcAffineFlowPyrLK"
            , calcAffineFlowPyrLK_function_type( &cvCalcAffineFlowPyrLK_3a4b3f5dff85e72a121da3f42cded4aa )
            , ( bp::arg("prev"), bp::arg("curr"), bp::arg("prev_pyr"), bp::arg("curr_pyr"), bp::arg("prev_features"), bp::arg("win_size"), bp::arg("level"), bp::arg("criteria"), bp::arg("flags") )
            , "\nWrapped function:"
    "\n    cvCalcAffineFlowPyrLK"
    "\nArgument 'prev':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'curr':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'prev_pyr':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'curr_pyr':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'prev_features':"\
    "\n    C++ type: ::CvPoint2D32f const *."\
    "\n    Python type: vector_Point2f."\
    "\nArgument 'curr_features':"\
    "\n    C++ type: ::CvPoint2D32f *."\
    "\n    Python type: vector_Point2f."\
    "\n    Output argument: omitted from input and returned as output."\
    "\nArgument 'matrices':"\
    "\n    C++ type: float *."\
    "\n    Python type: vector_float32."\
    "\n    Output argument: omitted from input and returned as output."\
    "\nArgument 'count':"\
    "\n    Dependent argument: omitted from input. Its value is derived from "\
    "\n    argument 'prev_features'."\
    "\nArgument 'win_size':"\
    "\n    C++ type: ::CvSize."\
    "\n    Python type: Size2i."\
    "\nArgument 'status':"\
    "\n    C++ type: char *."\
    "\n    Python type: vector_int8."\
    "\n    Output argument: omitted from input and returned as output."\
    "\nArgument 'track_error':"\
    "\n    C++ type: float *."\
    "\n    Python type: vector_float32."\
    "\n    Output argument: omitted from input and returned as output."\
    "\nArgument 'criteria':"\
    "\n    C++ type: ::CvTermCriteria."\
    "\n    Python type: TermCriteria."\
    "\nReturns:"\
    "\n    (curr_features, matrices, status, track_error)" );
    
    }

    { //::cvCalcEMD2
    
        typedef boost::python::object ( *calcEMD2_function_type )( ::cv::Mat &,::cv::Mat &,int,boost::python::object,::cv::Mat,::cv::Mat,float *,boost::python::object );
        
        bp::def( 
            "calcEMD2"
            , calcEMD2_function_type( &cvCalcEMD2_f4e5308a9258b3a75a06fb112d06a2e8 )
            , ( bp::arg("signature1"), bp::arg("signature2"), bp::arg("distance_type"), bp::arg("distance_func")=bp::object(), bp::arg("cost_matrix")=cv::Mat(), bp::arg("flow")=cv::Mat(), bp::arg("lower_bound")=bp::object(), bp::arg("userdata")=bp::object() )
            , "\nWrapped function:"
    "\n    cvCalcEMD2"
    "\nArgument 'signature1':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'signature2':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'cost_matrix':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'flow':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvCalcGlobalOrientation
    
        typedef boost::python::object ( *calcGlobalOrientation_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,double,double );
        
        bp::def( 
            "calcGlobalOrientation"
            , calcGlobalOrientation_function_type( &cvCalcGlobalOrientation_9d75a586d5a67c41e4450ccf9b8af7b3 )
            , ( bp::arg("orientation"), bp::arg("mask"), bp::arg("mhi"), bp::arg("timestamp"), bp::arg("duration") )
            , "\nWrapped function:"
    "\n    cvCalcGlobalOrientation"
    "\nArgument 'orientation':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'mask':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'mhi':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvCalcMotionGradient
    
        typedef void ( *calcMotionGradient_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,double,double,int );
        
        bp::def( 
            "calcMotionGradient"
            , calcMotionGradient_function_type( &cvCalcMotionGradient_7506fb6ca34b4a6cb9165f5aff081454 )
            , ( bp::arg("mhi"), bp::arg("mask"), bp::arg("orientation"), bp::arg("delta1"), bp::arg("delta2"), bp::arg("aperture_size")=(int)(3) )
            , "\nWrapped function:"
    "\n    cvCalcMotionGradient"
    "\nArgument 'mhi':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'mask':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'orientation':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvCalcOpticalFlowBM
    
        typedef void ( *calcOpticalFlowBM_function_type )( ::cv::Mat &,::cv::Mat &,cv::Size_<int> const &,cv::Size_<int> const &,cv::Size_<int> const &,int,::cv::Mat &,::cv::Mat & );
        
        bp::def( 
            "calcOpticalFlowBM"
            , calcOpticalFlowBM_function_type( &cvCalcOpticalFlowBM_3537c5574d176e4f3dea85450be5ee9f )
            , ( bp::arg("prev"), bp::arg("curr"), bp::arg("block_size"), bp::arg("shift_size"), bp::arg("max_range"), bp::arg("use_previous"), bp::arg("velx"), bp::arg("vely") )
            , "\nWrapped function:"
    "\n    cvCalcOpticalFlowBM"
    "\nArgument 'prev':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'curr':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'block_size':"\
    "\n    C++ type: ::CvSize."\
    "\n    Python type: Size2i."\
    "\nArgument 'shift_size':"\
    "\n    C++ type: ::CvSize."\
    "\n    Python type: Size2i."\
    "\nArgument 'max_range':"\
    "\n    C++ type: ::CvSize."\
    "\n    Python type: Size2i."\
    "\nArgument 'velx':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'vely':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvCalcOpticalFlowFarneback
    
        typedef void ( *calcOpticalFlowFarneback_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,double,int,int,int,int,double,int );
        
        bp::def( 
            "calcOpticalFlowFarneback"
            , calcOpticalFlowFarneback_function_type( &cvCalcOpticalFlowFarneback_409b7a55ce4ab8f251cb192176e9376c )
            , ( bp::arg("prev"), bp::arg("next"), bp::arg("flow"), bp::arg("pyr_scale"), bp::arg("levels"), bp::arg("winsize"), bp::arg("iterations"), bp::arg("poly_n"), bp::arg("poly_sigma"), bp::arg("flags") )
            , "\nWrapped function:"
    "\n    cvCalcOpticalFlowFarneback"
    "\nArgument 'prev':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'next':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'flow':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvCalcOpticalFlowHS
    
        typedef void ( *calcOpticalFlowHS_function_type )( ::cv::Mat &,::cv::Mat &,int,::cv::Mat &,::cv::Mat &,double,cv::TermCriteria const & );
        
        bp::def( 
            "calcOpticalFlowHS"
            , calcOpticalFlowHS_function_type( &cvCalcOpticalFlowHS_0757feb4eeb7fd8c38b710aec2f5f8e9 )
            , ( bp::arg("prev"), bp::arg("curr"), bp::arg("use_previous"), bp::arg("velx"), bp::arg("vely"), bp::arg("lambda"), bp::arg("criteria") )
            , "\nWrapped function:"
    "\n    cvCalcOpticalFlowHS"
    "\nArgument 'prev':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'curr':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'velx':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'vely':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'criteria':"\
    "\n    C++ type: ::CvTermCriteria."\
    "\n    Python type: TermCriteria." );
    
    }

    { //::cvCalcOpticalFlowLK
    
        typedef void ( *calcOpticalFlowLK_function_type )( ::cv::Mat &,::cv::Mat &,cv::Size_<int> const &,::cv::Mat &,::cv::Mat & );
        
        bp::def( 
            "calcOpticalFlowLK"
            , calcOpticalFlowLK_function_type( &cvCalcOpticalFlowLK_0539268816232dbc93df209c0dc87327 )
            , ( bp::arg("prev"), bp::arg("curr"), bp::arg("win_size"), bp::arg("velx"), bp::arg("vely") )
            , "\nWrapped function:"
    "\n    cvCalcOpticalFlowLK"
    "\nArgument 'prev':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'curr':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'win_size':"\
    "\n    C++ type: ::CvSize."\
    "\n    Python type: Size2i."\
    "\nArgument 'velx':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'vely':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvCalcOpticalFlowPyrLK
    
        typedef boost::python::tuple ( *calcOpticalFlowPyrLK_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,std::vector<cv::Point_<float> > const &,cv::Size_<int> const &,int,cv::TermCriteria const &,int );
        
        bp::def( 
            "calcOpticalFlowPyrLK"
            , calcOpticalFlowPyrLK_function_type( &cvCalcOpticalFlowPyrLK_925fd4448f97740474886f84b12836c2 )
            , ( bp::arg("prev"), bp::arg("curr"), bp::arg("prev_pyr"), bp::arg("curr_pyr"), bp::arg("prev_features"), bp::arg("win_size"), bp::arg("level"), bp::arg("criteria"), bp::arg("flags") )
            , "\nWrapped function:"
    "\n    cvCalcOpticalFlowPyrLK"
    "\nArgument 'prev':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'curr':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'prev_pyr':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'curr_pyr':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'prev_features':"\
    "\n    C++ type: ::CvPoint2D32f const *."\
    "\n    Python type: vector_Point2f."\
    "\nArgument 'curr_features':"\
    "\n    C++ type: ::CvPoint2D32f *."\
    "\n    Python type: vector_Point2f."\
    "\n    Output argument: omitted from input and returned as output."\
    "\nArgument 'count':"\
    "\n    Dependent argument: omitted from input. Its value is derived from "\
    "\n    argument 'prev_features'."\
    "\nArgument 'win_size':"\
    "\n    C++ type: ::CvSize."\
    "\n    Python type: Size2i."\
    "\nArgument 'status':"\
    "\n    C++ type: char *."\
    "\n    Python type: vector_int8."\
    "\n    Output argument: omitted from input and returned as output."\
    "\nArgument 'track_error':"\
    "\n    C++ type: float *."\
    "\n    Python type: vector_float32."\
    "\n    Output argument: omitted from input and returned as output."\
    "\nArgument 'criteria':"\
    "\n    C++ type: ::CvTermCriteria."\
    "\n    Python type: TermCriteria."\
    "\nReturns:"\
    "\n    (curr_features, status, track_error)" );
    
    }

    { //::cvCheckChessboard
    
        typedef boost::python::object ( *checkChessboard_function_type )( ::cv::Mat &,cv::Size_<int> const & );
        
        bp::def( 
            "checkChessboard"
            , checkChessboard_function_type( &cvCheckChessboard_59f8753d978791ecd1fc97cea5e10f04 )
            , ( bp::arg("src"), bp::arg("size") )
            , "\nWrapped function:"
    "\n    cvCheckChessboard"
    "\nArgument 'src':"\
    "\n    C++ type: ::IplImage *."\
    "\n    Python type: Mat."\
    "\nArgument 'size':"\
    "\n    C++ type: ::CvSize."\
    "\n    Python type: Size2i." );
    
    }

    { //::cvContourFromContourTree
    
        typedef boost::python::object ( *contourFromContourTree_function_type )( ::CvContourTree const *,::cv::MemStorage &,cv::TermCriteria const & );
        
        bp::def( 
            "contourFromContourTree"
            , contourFromContourTree_function_type( &cvContourFromContourTree_47f5c065694c470d5919cd861fe8d325 )
            , ( bp::arg("tree"), bp::arg("storage"), bp::arg("criteria") )
            , "\nWrapped function:"
    "\n    cvContourFromContourTree"
    "\nArgument 'storage':"\
    "\n    C++ type: ::CvMemStorage *."\
    "\n    Python type: MemStorage."\
    "\nArgument 'criteria':"\
    "\n    C++ type: ::CvTermCriteria."\
    "\n    Python type: TermCriteria." );
    
    }

    { //::cvConvexityDefects
    
        typedef boost::python::object ( *convexityDefects_function_type )( ::cv::Mat &,::cv::Mat &,::cv::MemStorage );
        
        bp::def( 
            "convexityDefects"
            , convexityDefects_function_type( &cvConvexityDefects_cc97bf52cc42e365950605a23b42e95a )
            , ( bp::arg("contour"), bp::arg("convexhull"), bp::arg("storage")=cv::MemStorage(0) )
            , "\nWrapped function:"
    "\n    cvConvexityDefects"
    "\nArgument 'contour':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'convexhull':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'storage':"\
    "\n    C++ type: ::CvMemStorage *."\
    "\n    Python type: MemStorage." );
    
    }

    { //::cvCorrectMatches
    
        typedef void ( *correctMatches_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat & );
        
        bp::def( 
            "correctMatches"
            , correctMatches_function_type( &cvCorrectMatches_055faac2f695cea7fa86e829ba6bdc99 )
            , ( bp::arg("F"), bp::arg("points1"), bp::arg("points2"), bp::arg("new_points1"), bp::arg("new_points2") )
            , "\nWrapped function:"
    "\n    cvCorrectMatches"
    "\nArgument 'F':"\
    "\n    C++ type: ::CvMat *."\
    "\n    Python type: Mat."\
    "\nArgument 'points1':"\
    "\n    C++ type: ::CvMat *."\
    "\n    Python type: Mat."\
    "\nArgument 'points2':"\
    "\n    C++ type: ::CvMat *."\
    "\n    Python type: Mat."\
    "\nArgument 'new_points1':"\
    "\n    C++ type: ::CvMat *."\
    "\n    Python type: Mat."\
    "\nArgument 'new_points2':"\
    "\n    C++ type: ::CvMat *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvCreateContourTree
    
        typedef boost::python::object ( *createContourTree_function_type )( ::CvSeq const *,::cv::MemStorage &,double );
        
        bp::def( 
            "createContourTree"
            , createContourTree_function_type( &cvCreateContourTree_d634bc0ea26451db7832bf763df380f3 )
            , ( bp::arg("contour"), bp::arg("storage"), bp::arg("threshold") )
            , "\nWrapped function:"
    "\n    cvCreateContourTree"
    "\nArgument 'storage':"\
    "\n    C++ type: ::CvMemStorage *."\
    "\n    Python type: MemStorage." );
    
    }

    { //::cvCreateKDTree
    
        typedef boost::python::object ( *createKDTree_function_type )( ::cv::Mat & );
        
        bp::def( 
            "createKDTree"
            , createKDTree_function_type( &cvCreateKDTree_bedd697814f42b0adb235e1d1bda9bdd )
            , ( bp::arg("desc") )
            , "\nWrapped function:"
    "\n    cvCreateKDTree"
    "\nArgument 'desc':"\
    "\n    C++ type: ::CvMat *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvCreateSpillTree
    
        typedef boost::python::object ( *createSpillTree_function_type )( ::cv::Mat &,int const,double const,double const );
        
        bp::def( 
            "createSpillTree"
            , createSpillTree_function_type( &cvCreateSpillTree_22146c3478f3d8c8ff22213a86f1b244 )
            , ( bp::arg("raw_data"), bp::arg("naive")=(int const)(50), bp::arg("rho")=6.99999999999999955591079014993738383054733276367e-1, bp::arg("tau")=1.00000000000000005551115123125782702118158340454e-1 )
            , "\nWrapped function:"
    "\n    cvCreateSpillTree"
    "\nArgument 'raw_data':"\
    "\n    C++ type: ::CvMat const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvCreateSubdiv2D
    
        typedef boost::python::object ( *createSubdiv2D_function_type )( int,int,int,int,::cv::MemStorage & );
        
        bp::def( 
            "createSubdiv2D"
            , createSubdiv2D_function_type( &cvCreateSubdiv2D_56b293d10aa190d3e2dee490cf17ff0c )
            , ( bp::arg("subdiv_type"), bp::arg("header_size"), bp::arg("vtx_size"), bp::arg("quadedge_size"), bp::arg("storage") )
            , "\nWrapped function:"
    "\n    cvCreateSubdiv2D"
    "\nArgument 'storage':"\
    "\n    C++ type: ::CvMemStorage *."\
    "\n    Python type: MemStorage." );
    
    }

    { //::cvCreateSubdivDelaunay2D
    
        typedef boost::python::object ( *createSubdivDelaunay2D_function_type )( cv::Rect_<int> const &,::cv::MemStorage & );
        
        bp::def( 
            "createSubdivDelaunay2D"
            , createSubdivDelaunay2D_function_type( &cvCreateSubdivDelaunay2D_8eda8e15f20a4d068defcf9afd8ee589 )
            , ( bp::arg("rect"), bp::arg("storage") )
            , "\nWrapped function:"
    "\n    cvCreateSubdivDelaunay2D"
    "\nArgument 'rect':"\
    "\n    C++ type: ::CvRect."\
    "\n    Python type: Rect."\
    "\nArgument 'storage':"\
    "\n    C++ type: ::CvMemStorage *."\
    "\n    Python type: MemStorage." );
    
    }

    { //::cvDistTransform
    
        typedef void ( *distTransform_function_type )( ::cv::Mat &,::cv::Mat &,int,std::vector<float> const &,::cv::Mat );
        
        bp::def( 
            "distTransform"
            , distTransform_function_type( &cvDistTransform_68addecae85b6b48cd46044102a6c028 )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("distance_type")=(int)(2), bp::arg("mask")=std::vector<float>(), bp::arg("labels")=cv::Mat() )
            , "\nWrapped function:"
    "\n    cvDistTransform"
    "\nArgument 'src':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'dst':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'mask_size':"\
    "\n    Dependent argument: omitted from input. Its value is derived from "\
    "\n    argument 'mask'."\
    "\nArgument 'mask':"\
    "\n    C++ type: float const *."\
    "\n    Python type: vector_float32."\
    "\nArgument 'labels':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvEstimateRigidTransform
    
        typedef boost::python::object ( *estimateRigidTransform_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,int );
        
        bp::def( 
            "estimateRigidTransform"
            , estimateRigidTransform_function_type( &cvEstimateRigidTransform_2f885814bd847b94c8621a570a36abad )
            , ( bp::arg("A"), bp::arg("B"), bp::arg("M"), bp::arg("full_affine") )
            , "\nWrapped function:"
    "\n    cvEstimateRigidTransform"
    "\nArgument 'A':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'B':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'M':"\
    "\n    C++ type: ::CvMat *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvExtractSURF
    
        typedef boost::python::object ( *extractSURF_function_type )( ::cv::Mat &,::cv::Mat &,cv::Seq<CvSURFPoint> &,::CvSURFParams,int );
        
        bp::def( 
            "extractSURF"
            , extractSURF_function_type( &cvExtractSURF_7b3c589cd61921d6c8f246dded72b86f )
            , ( bp::arg("img"), bp::arg("mask"), bp::arg("keypoints"), bp::arg("params"), bp::arg("useProvidedKeyPts")=(int)(0) )
            , "\nWrapped function:"
    "\n    cvExtractSURF"
    "\nArgument 'img':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'mask':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'keypoints':"\
    "\n    C++ type: ::CvSeq * *."\
    "\n    Python type: Seq_CvSURFPoint."\
    "\nArgument 'descriptors':"\
    "\n    C++ type: ::CvSeq * *."\
    "\n    Python type: vector_float32."\
    "\n    Output argument: omitted from input and returned as output."\
    "\nArgument 'storage':"\
    "\n    Dependent argument: omitted from input. Its value is derived from "\
    "\n    argument 'keypoints'."\
    "\nReturns:"\
    "\n    descriptors" );
    
    }

    { //::cvFindFeatures
    
        typedef void ( *findFeatures_function_type )( CvFeatureTree *,::cv::Mat &,::cv::Mat &,::cv::Mat &,int,int );
        
        bp::def( 
            "findFeatures"
            , findFeatures_function_type( &cvFindFeatures_3cdcd7c246944a80a295b6f20e448cfc )
            , ( bp::arg("tr"), bp::arg("query_points"), bp::arg("indices"), bp::arg("dist"), bp::arg("k"), bp::arg("emax")=(int)(20) )
            , "\nWrapped function:"
    "\n    cvFindFeatures"
    "\nArgument 'query_points':"\
    "\n    C++ type: ::CvMat const *."\
    "\n    Python type: Mat."\
    "\nArgument 'indices':"\
    "\n    C++ type: ::CvMat *."\
    "\n    Python type: Mat."\
    "\nArgument 'dist':"\
    "\n    C++ type: ::CvMat *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvFindFeaturesBoxed
    
        typedef boost::python::object ( *findFeaturesBoxed_function_type )( CvFeatureTree *,::cv::Mat &,::cv::Mat &,::cv::Mat & );
        
        bp::def( 
            "findFeaturesBoxed"
            , findFeaturesBoxed_function_type( &cvFindFeaturesBoxed_6d675cd8257b64f665600bd276900d3e )
            , ( bp::arg("tr"), bp::arg("bounds_min"), bp::arg("bounds_max"), bp::arg("out_indices") )
            , "\nWrapped function:"
    "\n    cvFindFeaturesBoxed"
    "\nArgument 'bounds_min':"\
    "\n    C++ type: ::CvMat *."\
    "\n    Python type: Mat."\
    "\nArgument 'bounds_max':"\
    "\n    C++ type: ::CvMat *."\
    "\n    Python type: Mat."\
    "\nArgument 'out_indices':"\
    "\n    C++ type: ::CvMat *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvFindNearestPoint2D
    
        typedef boost::python::object ( *findNearestPoint2D_function_type )( ::CvSubdiv2D *,cv::Point_<float> const & );
        
        bp::def( 
            "findNearestPoint2D"
            , findNearestPoint2D_function_type( &cvFindNearestPoint2D_4658231361f43a6fc66c2e150f75dca8 )
            , ( bp::arg("subdiv"), bp::arg("pt") )
            , "\nWrapped function:"
    "\n    cvFindNearestPoint2D"
    "\nArgument 'pt':"\
    "\n    C++ type: ::CvPoint2D32f."\
    "\n    Python type: Point2f." );
    
    }

    { //::cvFindStereoCorrespondenceGC
    
        typedef void ( *findStereoCorrespondenceGC_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::CvStereoGCState *,int );
        
        bp::def( 
            "findStereoCorrespondenceGC"
            , findStereoCorrespondenceGC_function_type( &cvFindStereoCorrespondenceGC_c3eefaed321a780e7059f7c3392c4672 )
            , ( bp::arg("left"), bp::arg("right"), bp::arg("disparityLeft"), bp::arg("disparityRight"), bp::arg("state"), bp::arg("useDisparityGuess")=(int)(0) )
            , "\nWrapped function:"
    "\n    cvFindStereoCorrespondenceGC"
    "\nArgument 'left':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'right':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'disparityLeft':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'disparityRight':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvGetQuadrangleSubPix
    
        typedef void ( *getQuadrangleSubPix_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat & );
        
        bp::def( 
            "getQuadrangleSubPix"
            , getQuadrangleSubPix_function_type( &cvGetQuadrangleSubPix_fe2b1a5028fa8b02301dc960cdfbc131 )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("map_matrix") )
            , "\nWrapped function:"
    "\n    cvGetQuadrangleSubPix"
    "\nArgument 'src':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'dst':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'map_matrix':"\
    "\n    C++ type: ::CvMat const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvInitSubdivDelaunay2D
    
        typedef void ( *initSubdivDelaunay2D_function_type )( ::CvSubdiv2D *,cv::Rect_<int> const & );
        
        bp::def( 
            "initSubdivDelaunay2D"
            , initSubdivDelaunay2D_function_type( &cvInitSubdivDelaunay2D_9125b981b281211984978f2c9ce6eb8b )
            , ( bp::arg("subdiv"), bp::arg("rect") )
            , "\nWrapped function:"
    "\n    cvInitSubdivDelaunay2D"
    "\nArgument 'rect':"\
    "\n    C++ type: ::CvRect."\
    "\n    Python type: Rect." );
    
    }

    { //::cvLSHAdd
    
        typedef void ( *LSHAdd_function_type )( CvLSH *,::cv::Mat &,::cv::Mat );
        
        bp::def( 
            "LSHAdd"
            , LSHAdd_function_type( &cvLSHAdd_fead3e6b36de0b14c88ef1b561c6e621 )
            , ( bp::arg("lsh"), bp::arg("data"), bp::arg("indices")=cv::Mat() )
            , "\nWrapped function:"
    "\n    cvLSHAdd"
    "\nArgument 'data':"\
    "\n    C++ type: ::CvMat const *."\
    "\n    Python type: Mat."\
    "\nArgument 'indices':"\
    "\n    C++ type: ::CvMat *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvLSHQuery
    
        typedef void ( *LSHQuery_function_type )( CvLSH *,::cv::Mat &,::cv::Mat &,::cv::Mat &,int,int );
        
        bp::def( 
            "LSHQuery"
            , LSHQuery_function_type( &cvLSHQuery_a5f47e360cc9701a6672c12490153852 )
            , ( bp::arg("lsh"), bp::arg("query_points"), bp::arg("indices"), bp::arg("dist"), bp::arg("k"), bp::arg("emax") )
            , "\nWrapped function:"
    "\n    cvLSHQuery"
    "\nArgument 'query_points':"\
    "\n    C++ type: ::CvMat const *."\
    "\n    Python type: Mat."\
    "\nArgument 'indices':"\
    "\n    C++ type: ::CvMat *."\
    "\n    Python type: Mat."\
    "\nArgument 'dist':"\
    "\n    C++ type: ::CvMat *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvLSHRemove
    
        typedef void ( *LSHRemove_function_type )( CvLSH *,::cv::Mat & );
        
        bp::def( 
            "LSHRemove"
            , LSHRemove_function_type( &cvLSHRemove_5f32fb503216c52038c4ae3bf17b62db )
            , ( bp::arg("lsh"), bp::arg("indices") )
            , "\nWrapped function:"
    "\n    cvLSHRemove"
    "\nArgument 'indices':"\
    "\n    C++ type: ::CvMat const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvLinearPolar
    
        typedef void ( *linearPolar_function_type )( ::cv::Mat &,::cv::Mat &,cv::Point_<float> const &,double,int );
        
        bp::def( 
            "linearPolar"
            , linearPolar_function_type( &cvLinearPolar_b75d44697de3c90f0462366e93d77425 )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("center"), bp::arg("maxRadius"), bp::arg("flags")=(int)(9) )
            , "\nWrapped function:"
    "\n    cvLinearPolar"
    "\nArgument 'src':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'dst':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'center':"\
    "\n    C++ type: ::CvPoint2D32f."\
    "\n    Python type: Point2f." );
    
    }

    { //::cvLogPolar
    
        typedef void ( *logPolar_function_type )( ::cv::Mat &,::cv::Mat &,cv::Point_<float> const &,double,int );
        
        bp::def( 
            "logPolar"
            , logPolar_function_type( &cvLogPolar_27c4d18226a6e750886777db97773f4d )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("center"), bp::arg("M"), bp::arg("flags")=(int)(9) )
            , "\nWrapped function:"
    "\n    cvLogPolar"
    "\nArgument 'src':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'dst':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'center':"\
    "\n    C++ type: ::CvPoint2D32f."\
    "\n    Python type: Point2f." );
    
    }

    { //::cvMultiplyAcc
    
        typedef void ( *multiplyAcc_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat );
        
        bp::def( 
            "multiplyAcc"
            , multiplyAcc_function_type( &cvMultiplyAcc_c64c83fc39cb1265f3d1a69d9e600a47 )
            , ( bp::arg("image1"), bp::arg("image2"), bp::arg("acc"), bp::arg("mask")=cv::Mat() )
            , "\nWrapped function:"
    "\n    cvMultiplyAcc"
    "\nArgument 'image1':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'image2':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'acc':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'mask':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvPOSIT
    
        typedef void ( *POSIT_function_type )( ::CvPOSITObject *,::CvPoint2D32f *,double,cv::TermCriteria const &,::CvMatr32f,::CvVect32f );
        
        bp::def( 
            "POSIT"
            , POSIT_function_type( &cvPOSIT_87713841f128738a6d8e29669752951a )
            , ( bp::arg("posit_object"), bp::arg("image_points"), bp::arg("focal_length"), bp::arg("criteria"), bp::arg("rotation_matrix"), bp::arg("translation_vector") )
            , "\nWrapped function:"
    "\n    cvPOSIT"
    "\nArgument 'criteria':"\
    "\n    C++ type: ::CvTermCriteria."\
    "\n    Python type: TermCriteria." );
    
    }

    { //::cvPointSeqFromMat
    
        typedef boost::python::object ( *pointSeqFromMat_function_type )( int,::cv::Mat &,::CvContour *,::CvSeqBlock * );
        
        bp::def( 
            "pointSeqFromMat"
            , pointSeqFromMat_function_type( &cvPointSeqFromMat_ef8459cfef37d715411cf088e0da5576 )
            , ( bp::arg("seq_kind"), bp::arg("mat"), bp::arg("contour_header"), bp::arg("block") )
            , "\nWrapped function:"
    "\n    cvPointSeqFromMat"
    "\nArgument 'mat':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvPyrMeanShiftFiltering
    
        typedef void ( *pyrMeanShiftFiltering_function_type )( ::cv::Mat &,::cv::Mat &,double,double,int,cv::TermCriteria const & );
        
        bp::def( 
            "pyrMeanShiftFiltering"
            , pyrMeanShiftFiltering_function_type( &cvPyrMeanShiftFiltering_21ec6b7149a6e00a31f1d76aebb9a22b )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("sp"), bp::arg("sr"), bp::arg("max_level")=(int)(1), bp::arg("termcrit")=cv::TermCriteria(3, 5, 1.0e+0) )
            , "\nWrapped function:"
    "\n    cvPyrMeanShiftFiltering"
    "\nArgument 'src':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'dst':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'termcrit':"\
    "\n    C++ type: ::CvTermCriteria."\
    "\n    Python type: TermCriteria." );
    
    }

    { //::cvPyrSegmentation
    
        typedef boost::python::object ( *pyrSegmentation_function_type )( ::cv::Mat &,::cv::Mat &,::cv::MemStorage &,int,double,double );
        
        bp::def( 
            "pyrSegmentation"
            , pyrSegmentation_function_type( &cvPyrSegmentation_0a5e58f4641f1c9757bb83d3f16f4191 )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("storage"), bp::arg("level"), bp::arg("threshold1"), bp::arg("threshold2") )
            , "\nWrapped function:"
    "\n    cvPyrSegmentation"
    "\nArgument 'src':"\
    "\n    C++ type: ::IplImage *."\
    "\n    Python type: Mat."\
    "\nArgument 'dst':"\
    "\n    C++ type: ::IplImage *."\
    "\n    Python type: Mat."\
    "\nArgument 'storage':"\
    "\n    C++ type: ::CvMemStorage *."\
    "\n    Python type: MemStorage."\
    "\nArgument 'comp':"\
    "\n    C++ type: ::CvSeq * *."\
    "\n    Python type: (C++)CvSeq *."\
    "\n    Output argument: omitted from input and returned as output."\
    "\nReturns:"\
    "\n    comp" );
    
    }

    { //::cvReleasePOSITObject
    
        typedef void ( *_cvReleasePOSITObject_function_type )( CvPOSITObject );
        
        bp::def( 
            "_cvReleasePOSITObject"
            , _cvReleasePOSITObject_function_type( &cvReleasePOSITObject_679a5da1d4e28b86fdc9a28aa691c6ef )
            , ( bp::arg("posit_object") )
            , "\nWrapped function:"
    "\n    cvReleasePOSITObject"
    "\nArgument 'posit_object':"\
    "\n    C++ type: ::CvPOSITObject * *."\
    "\n    Python type: CvPOSITObject." );
    
    }

    { //::cvReleaseStereoGCState
    
        typedef void ( *_cvReleaseStereoGCState_function_type )( CvStereoGCState );
        
        bp::def( 
            "_cvReleaseStereoGCState"
            , _cvReleaseStereoGCState_function_type( &cvReleaseStereoGCState_f9448f3f98670de75bac96972e1b9d45 )
            , ( bp::arg("state") )
            , "\nWrapped function:"
    "\n    cvReleaseStereoGCState"
    "\nArgument 'state':"\
    "\n    C++ type: ::CvStereoGCState * *."\
    "\n    Python type: CvStereoGCState." );
    
    }

    { //::cvReprojectImageTo3D
    
        typedef void ( *reprojectImageTo3D_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,int );
        
        bp::def( 
            "reprojectImageTo3D"
            , reprojectImageTo3D_function_type( &cvReprojectImageTo3D_4ca87cd67ba33150d51d345f21a24447 )
            , ( bp::arg("disparityImage"), bp::arg("_3dImage"), bp::arg("Q"), bp::arg("handleMissingValues")=(int)(0) )
            , "\nWrapped function:"
    "\n    cvReprojectImageTo3D"
    "\nArgument 'disparityImage':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument '_3dImage':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'Q':"\
    "\n    C++ type: ::CvMat const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvRunningAvg
    
        typedef void ( *runningAvg_function_type )( ::cv::Mat &,::cv::Mat &,double,::cv::Mat );
        
        bp::def( 
            "runningAvg"
            , runningAvg_function_type( &cvRunningAvg_16515bd00db4472140aa21554e25bbc7 )
            , ( bp::arg("image"), bp::arg("acc"), bp::arg("alpha"), bp::arg("mask")=cv::Mat() )
            , "\nWrapped function:"
    "\n    cvRunningAvg"
    "\nArgument 'image':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'acc':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'mask':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvSampleLine
    
        typedef boost::python::object ( *sampleLine_function_type )( ::cv::Mat &,cv::Point_<int> const &,cv::Point_<int> const &,void *,int );
        
        bp::def( 
            "sampleLine"
            , sampleLine_function_type( &cvSampleLine_9eb7a74db955c3538aef5be3e7392fc5 )
            , ( bp::arg("image"), bp::arg("pt1"), bp::arg("pt2"), bp::arg("buffer"), bp::arg("connectivity")=(int)(8) )
            , "\nWrapped function:"
    "\n    cvSampleLine"
    "\nArgument 'image':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'pt1':"\
    "\n    C++ type: ::CvPoint."\
    "\n    Python type: Point2i."\
    "\nArgument 'pt2':"\
    "\n    C++ type: ::CvPoint."\
    "\n    Python type: Point2i." );
    
    }

    { //::cvSegmentMotion
    
        typedef boost::python::object ( *segmentMotion_function_type )( ::cv::Mat &,::cv::Mat &,::cv::MemStorage &,double,double );
        
        bp::def( 
            "segmentMotion"
            , segmentMotion_function_type( &cvSegmentMotion_ed831c1d8f816ea759222aec4d41f1f0 )
            , ( bp::arg("mhi"), bp::arg("seg_mask"), bp::arg("storage"), bp::arg("timestamp"), bp::arg("seg_thresh") )
            , "\nWrapped function:"
    "\n    cvSegmentMotion"
    "\nArgument 'mhi':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'seg_mask':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'storage':"\
    "\n    C++ type: ::CvMemStorage *."\
    "\n    Python type: MemStorage." );
    
    }

    { //::cvSmooth
    
        typedef void ( *smooth_function_type )( ::cv::Mat &,::cv::Mat &,int,int,int,double,double );
        
        bp::def( 
            "smooth"
            , smooth_function_type( &cvSmooth_77e0c983f4273497b4a61c0a6dcda04f )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("smoothtype")=(int)(2), bp::arg("size1")=(int)(3), bp::arg("size2")=(int)(0), bp::arg("sigma1")=0, bp::arg("sigma2")=0 )
            , "\nWrapped function:"
    "\n    cvSmooth"
    "\nArgument 'src':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'dst':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvSquareAcc
    
        typedef void ( *squareAcc_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat );
        
        bp::def( 
            "squareAcc"
            , squareAcc_function_type( &cvSquareAcc_df8ad076f822a2856ccecbbdf6a2b2b0 )
            , ( bp::arg("image"), bp::arg("sqsum"), bp::arg("mask")=cv::Mat() )
            , "\nWrapped function:"
    "\n    cvSquareAcc"
    "\nArgument 'image':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'sqsum':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'mask':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat." );
    
    }

    { //::cvStarKeypoint
    
        typedef boost::python::object ( *starKeypoint_function_type )( cv::Point_<int> const &,int,float );
        
        bp::def( 
            "starKeypoint"
            , starKeypoint_function_type( &cvStarKeypoint_1c87e44a3d11d1203d898ffe498e82f7 )
            , ( bp::arg("pt"), bp::arg("size"), bp::arg("response") )
            , "\nWrapped function:"
    "\n    cvStarKeypoint"
    "\nArgument 'pt':"\
    "\n    C++ type: ::CvPoint."\
    "\n    Python type: Point2i." );
    
    }

    { //::cvStartFindContours
    
        typedef boost::python::object ( *startFindContours_function_type )( ::cv::Mat &,::cv::MemStorage &,int,int,int,cv::Point_<int> const & );
        
        bp::def( 
            "startFindContours"
            , startFindContours_function_type( &cvStartFindContours_1914ce1dccb0d5710ebdf49d4c3d96cc )
            , ( bp::arg("image"), bp::arg("storage"), bp::arg("header_size")=(int)(88u), bp::arg("mode")=(int)(1), bp::arg("method")=(int)(2), bp::arg("offset")=cv::Point(0, 0) )
            , "\nWrapped function:"
    "\n    cvStartFindContours"
    "\nArgument 'image':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat."\
    "\nArgument 'storage':"\
    "\n    C++ type: ::CvMemStorage *."\
    "\n    Python type: MemStorage."\
    "\nArgument 'offset':"\
    "\n    C++ type: ::CvPoint."\
    "\n    Python type: Point2i." );
    
    }

    { //::cvSubdiv2DLocate
    
        typedef boost::python::tuple ( *subdiv2DLocate_function_type )( ::CvSubdiv2D *,cv::Point_<float> const &,::CvSubdiv2DEdge * );
        
        bp::def( 
            "subdiv2DLocate"
            , subdiv2DLocate_function_type( &cvSubdiv2DLocate_1df86dbc29fc9de6df2bbdb2196d6db3 )
            , ( bp::arg("subdiv"), bp::arg("pt"), bp::arg("edge") )
            , "\nWrapped function:"
    "\n    cvSubdiv2DLocate"
    "\nArgument 'pt':"\
    "\n    C++ type: ::CvPoint2D32f."\
    "\n    Python type: Point2f."\
    "\nArgument 'vertex':"\
    "\n    C++ type: ::CvSubdiv2DPoint * *."\
    "\n    Python type: (C++)CvSubdiv2DPoint *."\
    "\n    Output argument: omitted from input and returned as output."\
    "\nReturns:"\
    "\n    (((C++)CvSubdiv2DPointLocation), vertex)" );
    
    }

    { //::cvSubdivDelaunay2DInsert
    
        typedef boost::python::object ( *subdivDelaunay2DInsert_function_type )( ::CvSubdiv2D *,cv::Point_<float> const & );
        
        bp::def( 
            "subdivDelaunay2DInsert"
            , subdivDelaunay2DInsert_function_type( &cvSubdivDelaunay2DInsert_0d66ff0b2bc8918d0793f968404f1cb2 )
            , ( bp::arg("subdiv"), bp::arg("pt") )
            , "\nWrapped function:"
    "\n    cvSubdivDelaunay2DInsert"
    "\nArgument 'pt':"\
    "\n    C++ type: ::CvPoint2D32f."\
    "\n    Python type: Point2f." );
    
    }

    { //::cvTriangleArea
    
        typedef boost::python::object ( *triangleArea_function_type )( cv::Point_<float> const &,cv::Point_<float> const &,cv::Point_<float> const & );
        
        bp::def( 
            "triangleArea"
            , triangleArea_function_type( &cvTriangleArea_727599fdabcae9fb78274a766e9dac94 )
            , ( bp::arg("a"), bp::arg("b"), bp::arg("c") )
            , "\nWrapped function:"
    "\n    cvTriangleArea"
    "\nArgument 'a':"\
    "\n    C++ type: ::CvPoint2D32f."\
    "\n    Python type: Point2f."\
    "\nArgument 'b':"\
    "\n    C++ type: ::CvPoint2D32f."\
    "\n    Python type: Point2f."\
    "\nArgument 'c':"\
    "\n    C++ type: ::CvPoint2D32f."\
    "\n    Python type: Point2f." );
    
    }

    { //::cvTriangulatePoints
    
        typedef void ( *triangulatePoints_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat & );
        
        bp::def( 
            "triangulatePoints"
            , triangulatePoints_function_type( &cvTriangulatePoints_eb948ff6300aa4ebf4fad0ec7d6d4e78 )
            , ( bp::arg("projMatr1"), bp::arg("projMatr2"), bp::arg("projPoints1"), bp::arg("projPoints2"), bp::arg("points4D") )
            , "\nWrapped function:"
    "\n    cvTriangulatePoints"
    "\nArgument 'projMatr1':"\
    "\n    C++ type: ::CvMat *."\
    "\n    Python type: Mat."\
    "\nArgument 'projMatr2':"\
    "\n    C++ type: ::CvMat *."\
    "\n    Python type: Mat."\
    "\nArgument 'projPoints1':"\
    "\n    C++ type: ::CvMat *."\
    "\n    Python type: Mat."\
    "\nArgument 'projPoints2':"\
    "\n    C++ type: ::CvMat *."\
    "\n    Python type: Mat."\
    "\nArgument 'points4D':"\
    "\n    C++ type: ::CvMat *."\
    "\n    Python type: Mat." );
    
    }

    bp::def( 
        "snakeImage"
        , &sdSnakeImage
        , ( bp::arg("image"), bp::arg("points"), bp::arg("alpha"), bp::arg("beta"), bp::arg("gamma"), bp::arg("coeff_usage"), bp::arg("win"), bp::arg("criteria"), bp::arg("calc_gradient")=(int)(1) ) );

    register_classes_1();

    register_classes_2();

    register_classes_3();

    register_free_functions();

    { //::cvUpdateMotionHistory
    
        typedef void ( *updateMotionHistory_function_type )( ::cv::Mat &,::cv::Mat &,double,double );
        
        bp::def( 
            "updateMotionHistory"
            , updateMotionHistory_function_type( &cvUpdateMotionHistory_fb635b1eb55f77d94f46a70f41eac0b3 )
            , ( bp::arg("silhouette"), bp::arg("mhi"), bp::arg("timestamp"), bp::arg("duration") )
            , "\nWrapped function:"
    "\n    cvUpdateMotionHistory"
    "\nArgument 'silhouette':"\
    "\n    C++ type: ::CvArr const *."\
    "\n    Python type: Mat."\
    "\nArgument 'mhi':"\
    "\n    C++ type: ::CvArr *."\
    "\n    Python type: Mat." );
    
    }
}

