// This file has been generated by Py++.

#include "boost/python.hpp"
#include "with_ownershiplevel_postcall.hpp"
#include "cv_h_wrapper.hpp"
#include "cv_h_ext_free_functions.pypp.hpp"

namespace bp = boost::python;

void register_free_functions(){

    { //::LSHSize
    
        typedef unsigned int ( *LSHSize_function_type )( ::CvLSH * );
        
        bp::def( 
            "LSHSize"
            , LSHSize_function_type( &::LSHSize )
            , ( bp::arg("lsh") ) );
    
    }

    { //::cvCalcSubdivVoronoi2D
    
        typedef void ( *calcSubdivVoronoi2D_function_type )( ::CvSubdiv2D * );
        
        bp::def( 
            "calcSubdivVoronoi2D"
            , calcSubdivVoronoi2D_function_type( &::cvCalcSubdivVoronoi2D )
            , ( bp::arg("subdiv") )
            , "\nWrapped function:"
    "\n    cvCalcSubdivVoronoi2D" );
    
    }

    { //::cvClearSubdivVoronoi2D
    
        typedef void ( *clearSubdivVoronoi2D_function_type )( ::CvSubdiv2D * );
        
        bp::def( 
            "clearSubdivVoronoi2D"
            , clearSubdivVoronoi2D_function_type( &::cvClearSubdivVoronoi2D )
            , ( bp::arg("subdiv") )
            , "\nWrapped function:"
    "\n    cvClearSubdivVoronoi2D" );
    
    }

    { //::cvCreateLSH
    
        typedef ::CvLSH * ( *createLSH_function_type )( ::CvLSHOperations *,int,int,int,int,double,::int64 );
        
        bp::def( 
            "createLSH"
            , createLSH_function_type( &::cvCreateLSH )
            , ( bp::arg("ops"), bp::arg("d"), bp::arg("L")=(int)(10), bp::arg("k")=(int)(10), bp::arg("type")=(int)(6), bp::arg("r")=4, bp::arg("seed")=(::int64)(-0x000000001) )
            , bp::with_ownershiplevel_postcall< 1, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvCreateLSH" );
    
    }

    { //::cvCreateMemoryLSH
    
        typedef ::CvLSH * ( *createMemoryLSH_function_type )( int,int,int,int,int,double,::int64 );
        
        bp::def( 
            "createMemoryLSH"
            , createMemoryLSH_function_type( &::cvCreateMemoryLSH )
            , ( bp::arg("d"), bp::arg("n"), bp::arg("L")=(int)(10), bp::arg("k")=(int)(10), bp::arg("type")=(int)(6), bp::arg("r")=4, bp::arg("seed")=(::int64)(-0x000000001) )
            , bp::with_ownershiplevel_postcall< 1, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvCreateMemoryLSH" );
    
    }

    { //::cvCreatePOSITObject
    
        typedef ::CvPOSITObject * ( *createPOSITObject_function_type )( ::CvPoint3D32f *,int );
        
        bp::def( 
            "createPOSITObject"
            , createPOSITObject_function_type( &::cvCreatePOSITObject )
            , ( bp::arg("points"), bp::arg("point_count") )
            , bp::with_ownershiplevel_postcall< 1, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvCreatePOSITObject" );
    
    }

    { //::cvCreateStereoGCState
    
        typedef ::CvStereoGCState * ( *createStereoGCState_function_type )( int,int );
        
        bp::def( 
            "createStereoGCState"
            , createStereoGCState_function_type( &::cvCreateStereoGCState )
            , ( bp::arg("numberOfDisparities"), bp::arg("maxIters") )
            , bp::with_ownershiplevel_postcall< 1, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvCreateStereoGCState" );
    
    }

    { //::cvEndFindContours
    
        typedef ::CvSeq * ( *_cvEndFindContours_function_type )( ::CvContourScanner * );
        
        bp::def( 
            "_cvEndFindContours"
            , _cvEndFindContours_function_type( &::cvEndFindContours )
            , ( bp::arg("scanner") )
            , bp::with_custodian_and_ward_postcall< 0, 1, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvEndFindContours" );
    
    }

    { //::cvFindNextContour
    
        typedef ::CvSeq * ( *findNextContour_function_type )( ::CvContourScanner );
        
        bp::def( 
            "findNextContour"
            , findNextContour_function_type( &::cvFindNextContour )
            , ( bp::arg("scanner") )
            , bp::with_custodian_and_ward_postcall< 0, 1, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvFindNextContour" );
    
    }

    { //::cvMatchContourTrees
    
        typedef double ( *matchContourTrees_function_type )( ::CvContourTree const *,::CvContourTree const *,int,double );
        
        bp::def( 
            "matchContourTrees"
            , matchContourTrees_function_type( &::cvMatchContourTrees )
            , ( bp::arg("tree1"), bp::arg("tree2"), bp::arg("method"), bp::arg("threshold") )
            , "\nWrapped function:"
    "\n    cvMatchContourTrees" );
    
    }

    { //::cvMaxRect
    
        typedef ::CvRect ( *maxRect_function_type )( ::CvRect const *,::CvRect const * );
        
        bp::def( 
            "maxRect"
            , maxRect_function_type( &::cvMaxRect )
            , ( bp::arg("rect1"), bp::arg("rect2") )
            , "\nWrapped function:"
    "\n    cvMaxRect" );
    
    }

    { //::cvRANSACUpdateNumIters
    
        typedef int ( *RANSACUpdateNumIters_function_type )( double,double,int,int );
        
        bp::def( 
            "RANSACUpdateNumIters"
            , RANSACUpdateNumIters_function_type( &::cvRANSACUpdateNumIters )
            , ( bp::arg("p"), bp::arg("err_prob"), bp::arg("model_points"), bp::arg("max_iters") )
            , "\nWrapped function:"
    "\n    cvRANSACUpdateNumIters" );
    
    }

    { //::cvReadChainPoint
    
        typedef ::CvPoint ( *readChainPoint_function_type )( ::CvChainPtReader * );
        
        bp::def( 
            "readChainPoint"
            , readChainPoint_function_type( &::cvReadChainPoint )
            , ( bp::arg("reader") )
            , "\nWrapped function:"
    "\n    cvReadChainPoint" );
    
    }

    { //::cvReleaseFeatureTree
    
        typedef void ( *_cvReleaseFeatureTree_function_type )( ::CvFeatureTree * );
        
        bp::def( 
            "_cvReleaseFeatureTree"
            , _cvReleaseFeatureTree_function_type( &::cvReleaseFeatureTree )
            , ( bp::arg("tr") )
            , "\nWrapped function:"
    "\n    cvReleaseFeatureTree" );
    
    }

    { //::cvReleaseLSH
    
        typedef void ( *_cvReleaseLSH_function_type )( ::CvLSH * * );
        
        bp::def( 
            "_cvReleaseLSH"
            , _cvReleaseLSH_function_type( &::cvReleaseLSH )
            , ( bp::arg("lsh") )
            , "\nWrapped function:"
    "\n    cvReleaseLSH" );
    
    }

    { //::cvSURFParams
    
        typedef ::CvSURFParams ( *SURFParams_function_type )( double,int );
        
        bp::def( 
            "SURFParams"
            , SURFParams_function_type( &::cvSURFParams )
            , ( bp::arg("hessianThreshold"), bp::arg("extended")=(int)(0) )
            , "\nWrapped function:"
    "\n    cvSURFParams" );
    
    }

    { //::cvStartReadChainPoints
    
        typedef void ( *startReadChainPoints_function_type )( ::CvChain *,::CvChainPtReader * );
        
        bp::def( 
            "startReadChainPoints"
            , startReadChainPoints_function_type( &::cvStartReadChainPoints )
            , ( bp::arg("chain"), bp::arg("reader") )
            , "\nWrapped function:"
    "\n    cvStartReadChainPoints" );
    
    }

    { //::cvSubdiv2DEdgeDst
    
        typedef ::CvSubdiv2DPoint * ( *subdiv2DEdgeDst_function_type )( ::CvSubdiv2DEdge );
        
        bp::def( 
            "subdiv2DEdgeDst"
            , subdiv2DEdgeDst_function_type( &::cvSubdiv2DEdgeDst )
            , ( bp::arg("edge") )
            , bp::return_value_policy< bp::reference_existing_object >()
            , "\nWrapped function:"
    "\n    cvSubdiv2DEdgeDst" );
    
    }

    { //::cvSubdiv2DEdgeOrg
    
        typedef ::CvSubdiv2DPoint * ( *subdiv2DEdgeOrg_function_type )( ::CvSubdiv2DEdge );
        
        bp::def( 
            "subdiv2DEdgeOrg"
            , subdiv2DEdgeOrg_function_type( &::cvSubdiv2DEdgeOrg )
            , ( bp::arg("edge") )
            , bp::return_value_policy< bp::reference_existing_object >()
            , "\nWrapped function:"
    "\n    cvSubdiv2DEdgeOrg" );
    
    }

    { //::cvSubdiv2DGetEdge
    
        typedef ::CvSubdiv2DEdge ( *subdiv2DGetEdge_function_type )( ::CvSubdiv2DEdge,::CvNextEdgeType );
        
        bp::def( 
            "subdiv2DGetEdge"
            , subdiv2DGetEdge_function_type( &::cvSubdiv2DGetEdge )
            , ( bp::arg("edge"), bp::arg("type") )
            , "\nWrapped function:"
    "\n    cvSubdiv2DGetEdge" );
    
    }

    { //::cvSubdiv2DNextEdge
    
        typedef ::CvSubdiv2DEdge ( *subdiv2DNextEdge_function_type )( ::CvSubdiv2DEdge );
        
        bp::def( 
            "subdiv2DNextEdge"
            , subdiv2DNextEdge_function_type( &::cvSubdiv2DNextEdge )
            , ( bp::arg("edge") )
            , "\nWrapped function:"
    "\n    cvSubdiv2DNextEdge" );
    
    }

    { //::cvSubdiv2DRotateEdge
    
        typedef ::CvSubdiv2DEdge ( *subdiv2DRotateEdge_function_type )( ::CvSubdiv2DEdge,int );
        
        bp::def( 
            "subdiv2DRotateEdge"
            , subdiv2DRotateEdge_function_type( &::cvSubdiv2DRotateEdge )
            , ( bp::arg("edge"), bp::arg("rotate") )
            , "\nWrapped function:"
    "\n    cvSubdiv2DRotateEdge" );
    
    }

    { //::cvSubdiv2DSymEdge
    
        typedef ::CvSubdiv2DEdge ( *subdiv2DSymEdge_function_type )( ::CvSubdiv2DEdge );
        
        bp::def( 
            "subdiv2DSymEdge"
            , subdiv2DSymEdge_function_type( &::cvSubdiv2DSymEdge )
            , ( bp::arg("edge") )
            , "\nWrapped function:"
    "\n    cvSubdiv2DSymEdge" );
    
    }

    { //::cvSubstituteContour
    
        typedef void ( *substituteContour_function_type )( ::CvContourScanner,::CvSeq * );
        
        bp::def( 
            "substituteContour"
            , substituteContour_function_type( &::cvSubstituteContour )
            , ( bp::arg("scanner"), bp::arg("new_contour") )
            , "\nWrapped function:"
    "\n    cvSubstituteContour" );
    
    }

}
