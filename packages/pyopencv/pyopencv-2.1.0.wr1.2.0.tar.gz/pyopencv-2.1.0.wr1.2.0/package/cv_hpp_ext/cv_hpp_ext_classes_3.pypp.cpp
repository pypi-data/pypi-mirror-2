// This file has been generated by Py++.

#include "boost/python.hpp"
#include "__call_policies.pypp.hpp"
#include "__ctypes_integration.pypp.hpp"
#include "cv_hpp_wrapper.hpp"
#include "boost/python/object/life_support.hpp"
#include "cv_hpp_ext_classes_3.pypp.hpp"

namespace bp = boost::python;

static bp::object Ptr_BaseFilter_from_BaseFilter(bp::object const &inst_BaseFilter)
{
    bp::extract<cv::BaseFilter *> elem(inst_BaseFilter);
    if(!elem.check())
    {
        char s[300];
        sprintf( s, "Argument 'inst_BaseFilter' must contain an object of type BaseFilter." );
        PyErr_SetString(PyExc_TypeError, s);
        throw bp::error_already_set();
    }

    bp::object result = bp::object(::cv::Ptr< cv::BaseFilter >(elem()));
    result.attr("_depends") = inst_BaseFilter;
    return result;
}

static cv::BaseFilter const &Ptr_BaseFilter_pointee(::cv::Ptr< cv::BaseFilter > const &inst) { return *((cv::BaseFilter const *)inst); }

static bp::object Ptr_BaseRowFilter_from_BaseRowFilter(bp::object const &inst_BaseRowFilter)
{
    bp::extract<cv::BaseRowFilter *> elem(inst_BaseRowFilter);
    if(!elem.check())
    {
        char s[300];
        sprintf( s, "Argument 'inst_BaseRowFilter' must contain an object of type BaseRowFilter." );
        PyErr_SetString(PyExc_TypeError, s);
        throw bp::error_already_set();
    }

    bp::object result = bp::object(::cv::Ptr< cv::BaseRowFilter >(elem()));
    result.attr("_depends") = inst_BaseRowFilter;
    return result;
}

static cv::BaseRowFilter const &Ptr_BaseRowFilter_pointee(::cv::Ptr< cv::BaseRowFilter > const &inst) { return *((cv::BaseRowFilter const *)inst); }

static bp::object Ptr_FeatureEvaluator_from_FeatureEvaluator(bp::object const &inst_FeatureEvaluator)
{
    bp::extract<cv::FeatureEvaluator *> elem(inst_FeatureEvaluator);
    if(!elem.check())
    {
        char s[300];
        sprintf( s, "Argument 'inst_FeatureEvaluator' must contain an object of type FeatureEvaluator." );
        PyErr_SetString(PyExc_TypeError, s);
        throw bp::error_already_set();
    }

    bp::object result = bp::object(::cv::Ptr< cv::FeatureEvaluator >(elem()));
    result.attr("_depends") = inst_FeatureEvaluator;
    return result;
}

static cv::FeatureEvaluator const &Ptr_FeatureEvaluator_pointee(::cv::Ptr< cv::FeatureEvaluator > const &inst) { return *((cv::FeatureEvaluator const *)inst); }

static bp::object Ptr_FilterEngine_from_FilterEngine(bp::object const &inst_FilterEngine)
{
    bp::extract<cv::FilterEngine *> elem(inst_FilterEngine);
    if(!elem.check())
    {
        char s[300];
        sprintf( s, "Argument 'inst_FilterEngine' must contain an object of type FilterEngine." );
        PyErr_SetString(PyExc_TypeError, s);
        throw bp::error_already_set();
    }

    bp::object result = bp::object(::cv::Ptr< cv::FilterEngine >(elem()));
    result.attr("_depends") = inst_FilterEngine;
    return result;
}

static cv::FilterEngine const &Ptr_FilterEngine_pointee(::cv::Ptr< cv::FilterEngine > const &inst) { return *((cv::FilterEngine const *)inst); }

static boost::python::object __call___8fbaf2f3b7cf23fdd67db0f4874c6b20( ::cv::SURF const & inst, ::cv::Mat const & img, ::cv::Mat const & mask ){
    std::vector<cv::KeyPoint> keypoints2;
    inst.operator()(img, mask, keypoints2);
    return bp::object( keypoints2 );
}

static boost::python::object __call___8904ace00c2f24b8eb00d3aa8ac85014( ::cv::SURF const & inst, ::cv::Mat const & img, ::cv::Mat const & mask, ::std::vector< cv::KeyPoint > & keypoints, bool useProvidedKeypoints=false ){
    std::vector<float> descriptors2;
    inst.operator()(img, mask, keypoints, descriptors2, useProvidedKeypoints);
    return bp::object( descriptors2 );
}

static boost::python::object __call___c2d97c9701a9c79dcec3239fd753dffc( ::cv::StarDetector const & inst, ::cv::Mat const & image ){
    std::vector<cv::KeyPoint> keypoints2;
    inst.operator()(image, keypoints2);
    return bp::object( keypoints2 );
}

struct StereoSGBM_wrapper : cv::StereoSGBM, bp::wrapper< cv::StereoSGBM > {

    StereoSGBM_wrapper(cv::StereoSGBM const & arg )
    : cv::StereoSGBM( arg )
      , bp::wrapper< cv::StereoSGBM >(){
        // copy constructor
        
    }

    StereoSGBM_wrapper( )
    : cv::StereoSGBM( )
      , bp::wrapper< cv::StereoSGBM >(){
        // null constructor
    
    }

    StereoSGBM_wrapper(int minDisparity, int numDisparities, int SADWindowSize, int P1=0, int P2=0, int disp12MaxDiff=0, int preFilterCap=0, int uniquenessRatio=0, int speckleWindowSize=0, int speckleRange=0, bool fullDP=false )
    : cv::StereoSGBM( minDisparity, numDisparities, SADWindowSize, P1, P2, disp12MaxDiff, preFilterCap, uniquenessRatio, speckleWindowSize, speckleRange, fullDP )
      , bp::wrapper< cv::StereoSGBM >(){
        // constructor
    
    }

    virtual void operator()( ::cv::Mat const & left, ::cv::Mat const & right, ::cv::Mat & disp ) {
        if( bp::override func___call__ = this->get_override( "__call__" ) )
            func___call__( boost::ref(left), boost::ref(right), boost::ref(disp) );
        else{
            this->cv::StereoSGBM::operator()( boost::ref(left), boost::ref(right), boost::ref(disp) );
        }
    }
    
    void default___call__( ::cv::Mat const & left, ::cv::Mat const & right, ::cv::Mat & disp ) {
        cv::StereoSGBM::operator()( boost::ref(left), boost::ref(right), boost::ref(disp) );
    }

};

void register_classes_3(){

    { //::cv::Ptr< cv::BaseFilter >
        typedef bp::class_< cv::Ptr< cv::BaseFilter > > Ptr_BaseFilter_exposer_t;
        Ptr_BaseFilter_exposer_t Ptr_BaseFilter_exposer = Ptr_BaseFilter_exposer_t( "Ptr_BaseFilter", bp::init< >() );
        bp::scope Ptr_BaseFilter_scope( Ptr_BaseFilter_exposer );
        Ptr_BaseFilter_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::Ptr< cv::BaseFilter > >() );
        { //::cv::Ptr< cv::BaseFilter >::addref
        
            typedef cv::Ptr< cv::BaseFilter > exported_class_t;
            typedef void ( exported_class_t::*addref_function_type )(  ) ;
            
            Ptr_BaseFilter_exposer.def( 
                "addref"
                , addref_function_type( &::cv::Ptr< cv::BaseFilter >::addref ) );
        
        }
        { //::cv::Ptr< cv::BaseFilter >::delete_obj
        
            typedef cv::Ptr< cv::BaseFilter > exported_class_t;
            typedef void ( exported_class_t::*delete_obj_function_type )(  ) ;
            
            Ptr_BaseFilter_exposer.def( 
                "delete_obj"
                , delete_obj_function_type( &::cv::Ptr< cv::BaseFilter >::delete_obj ) );
        
        }
        { //::cv::Ptr< cv::BaseFilter >::empty
        
            typedef cv::Ptr< cv::BaseFilter > exported_class_t;
            typedef bool ( exported_class_t::*empty_function_type )(  ) const;
            
            Ptr_BaseFilter_exposer.def( 
                "empty"
                , empty_function_type( &::cv::Ptr< cv::BaseFilter >::empty ) );
        
        }
        { //::cv::Ptr< cv::BaseFilter >::release
        
            typedef cv::Ptr< cv::BaseFilter > exported_class_t;
            typedef void ( exported_class_t::*release_function_type )(  ) ;
            
            Ptr_BaseFilter_exposer.def( 
                "release"
                , release_function_type( &::cv::Ptr< cv::BaseFilter >::release ) );
        
        }
        Ptr_BaseFilter_exposer.def("fromBaseFilter", &::Ptr_BaseFilter_from_BaseFilter, (bp::arg("inst_BaseFilter")));
        Ptr_BaseFilter_exposer.staticmethod("fromBaseFilter");
        Ptr_BaseFilter_exposer.add_property("pointee", bp::make_function(&::Ptr_BaseFilter_pointee, bp::return_internal_reference<>()));
    }

    { //::cv::Ptr< cv::BaseRowFilter >
        typedef bp::class_< cv::Ptr< cv::BaseRowFilter > > Ptr_BaseRowFilter_exposer_t;
        Ptr_BaseRowFilter_exposer_t Ptr_BaseRowFilter_exposer = Ptr_BaseRowFilter_exposer_t( "Ptr_BaseRowFilter", bp::init< >() );
        bp::scope Ptr_BaseRowFilter_scope( Ptr_BaseRowFilter_exposer );
        Ptr_BaseRowFilter_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::Ptr< cv::BaseRowFilter > >() );
        { //::cv::Ptr< cv::BaseRowFilter >::addref
        
            typedef cv::Ptr< cv::BaseRowFilter > exported_class_t;
            typedef void ( exported_class_t::*addref_function_type )(  ) ;
            
            Ptr_BaseRowFilter_exposer.def( 
                "addref"
                , addref_function_type( &::cv::Ptr< cv::BaseRowFilter >::addref ) );
        
        }
        { //::cv::Ptr< cv::BaseRowFilter >::delete_obj
        
            typedef cv::Ptr< cv::BaseRowFilter > exported_class_t;
            typedef void ( exported_class_t::*delete_obj_function_type )(  ) ;
            
            Ptr_BaseRowFilter_exposer.def( 
                "delete_obj"
                , delete_obj_function_type( &::cv::Ptr< cv::BaseRowFilter >::delete_obj ) );
        
        }
        { //::cv::Ptr< cv::BaseRowFilter >::empty
        
            typedef cv::Ptr< cv::BaseRowFilter > exported_class_t;
            typedef bool ( exported_class_t::*empty_function_type )(  ) const;
            
            Ptr_BaseRowFilter_exposer.def( 
                "empty"
                , empty_function_type( &::cv::Ptr< cv::BaseRowFilter >::empty ) );
        
        }
        { //::cv::Ptr< cv::BaseRowFilter >::release
        
            typedef cv::Ptr< cv::BaseRowFilter > exported_class_t;
            typedef void ( exported_class_t::*release_function_type )(  ) ;
            
            Ptr_BaseRowFilter_exposer.def( 
                "release"
                , release_function_type( &::cv::Ptr< cv::BaseRowFilter >::release ) );
        
        }
        Ptr_BaseRowFilter_exposer.def("fromBaseRowFilter", &::Ptr_BaseRowFilter_from_BaseRowFilter, (bp::arg("inst_BaseRowFilter")));
        Ptr_BaseRowFilter_exposer.staticmethod("fromBaseRowFilter");
        Ptr_BaseRowFilter_exposer.add_property("pointee", bp::make_function(&::Ptr_BaseRowFilter_pointee, bp::return_internal_reference<>()));
    }

    { //::cv::Ptr< cv::FeatureEvaluator >
        typedef bp::class_< cv::Ptr< cv::FeatureEvaluator > > Ptr_FeatureEvaluator_exposer_t;
        Ptr_FeatureEvaluator_exposer_t Ptr_FeatureEvaluator_exposer = Ptr_FeatureEvaluator_exposer_t( "Ptr_FeatureEvaluator", bp::init< >() );
        bp::scope Ptr_FeatureEvaluator_scope( Ptr_FeatureEvaluator_exposer );
        Ptr_FeatureEvaluator_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::Ptr< cv::FeatureEvaluator > >() );
        { //::cv::Ptr< cv::FeatureEvaluator >::addref
        
            typedef cv::Ptr< cv::FeatureEvaluator > exported_class_t;
            typedef void ( exported_class_t::*addref_function_type )(  ) ;
            
            Ptr_FeatureEvaluator_exposer.def( 
                "addref"
                , addref_function_type( &::cv::Ptr< cv::FeatureEvaluator >::addref ) );
        
        }
        { //::cv::Ptr< cv::FeatureEvaluator >::delete_obj
        
            typedef cv::Ptr< cv::FeatureEvaluator > exported_class_t;
            typedef void ( exported_class_t::*delete_obj_function_type )(  ) ;
            
            Ptr_FeatureEvaluator_exposer.def( 
                "delete_obj"
                , delete_obj_function_type( &::cv::Ptr< cv::FeatureEvaluator >::delete_obj ) );
        
        }
        { //::cv::Ptr< cv::FeatureEvaluator >::empty
        
            typedef cv::Ptr< cv::FeatureEvaluator > exported_class_t;
            typedef bool ( exported_class_t::*empty_function_type )(  ) const;
            
            Ptr_FeatureEvaluator_exposer.def( 
                "empty"
                , empty_function_type( &::cv::Ptr< cv::FeatureEvaluator >::empty ) );
        
        }
        { //::cv::Ptr< cv::FeatureEvaluator >::release
        
            typedef cv::Ptr< cv::FeatureEvaluator > exported_class_t;
            typedef void ( exported_class_t::*release_function_type )(  ) ;
            
            Ptr_FeatureEvaluator_exposer.def( 
                "release"
                , release_function_type( &::cv::Ptr< cv::FeatureEvaluator >::release ) );
        
        }
        Ptr_FeatureEvaluator_exposer.def("fromFeatureEvaluator", &::Ptr_FeatureEvaluator_from_FeatureEvaluator, (bp::arg("inst_FeatureEvaluator")));
        Ptr_FeatureEvaluator_exposer.staticmethod("fromFeatureEvaluator");
        Ptr_FeatureEvaluator_exposer.add_property("pointee", bp::make_function(&::Ptr_FeatureEvaluator_pointee, bp::return_internal_reference<>()));
    }

    { //::cv::Ptr< cv::FilterEngine >
        typedef bp::class_< cv::Ptr< cv::FilterEngine > > Ptr_FilterEngine_exposer_t;
        Ptr_FilterEngine_exposer_t Ptr_FilterEngine_exposer = Ptr_FilterEngine_exposer_t( "Ptr_FilterEngine", bp::init< >() );
        bp::scope Ptr_FilterEngine_scope( Ptr_FilterEngine_exposer );
        Ptr_FilterEngine_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::Ptr< cv::FilterEngine > >() );
        { //::cv::Ptr< cv::FilterEngine >::addref
        
            typedef cv::Ptr< cv::FilterEngine > exported_class_t;
            typedef void ( exported_class_t::*addref_function_type )(  ) ;
            
            Ptr_FilterEngine_exposer.def( 
                "addref"
                , addref_function_type( &::cv::Ptr< cv::FilterEngine >::addref ) );
        
        }
        { //::cv::Ptr< cv::FilterEngine >::delete_obj
        
            typedef cv::Ptr< cv::FilterEngine > exported_class_t;
            typedef void ( exported_class_t::*delete_obj_function_type )(  ) ;
            
            Ptr_FilterEngine_exposer.def( 
                "delete_obj"
                , delete_obj_function_type( &::cv::Ptr< cv::FilterEngine >::delete_obj ) );
        
        }
        { //::cv::Ptr< cv::FilterEngine >::empty
        
            typedef cv::Ptr< cv::FilterEngine > exported_class_t;
            typedef bool ( exported_class_t::*empty_function_type )(  ) const;
            
            Ptr_FilterEngine_exposer.def( 
                "empty"
                , empty_function_type( &::cv::Ptr< cv::FilterEngine >::empty ) );
        
        }
        { //::cv::Ptr< cv::FilterEngine >::release
        
            typedef cv::Ptr< cv::FilterEngine > exported_class_t;
            typedef void ( exported_class_t::*release_function_type )(  ) ;
            
            Ptr_FilterEngine_exposer.def( 
                "release"
                , release_function_type( &::cv::Ptr< cv::FilterEngine >::release ) );
        
        }
        Ptr_FilterEngine_exposer.def("fromFilterEngine", &::Ptr_FilterEngine_from_FilterEngine, (bp::arg("inst_FilterEngine")));
        Ptr_FilterEngine_exposer.staticmethod("fromFilterEngine");
        Ptr_FilterEngine_exposer.add_property("pointee", bp::make_function(&::Ptr_FilterEngine_pointee, bp::return_internal_reference<>()));
    }

    { //::cv::SURF
        typedef bp::class_< cv::SURF > SURF_exposer_t;
        SURF_exposer_t SURF_exposer = SURF_exposer_t( "SURF", bp::init< >() );
        bp::scope SURF_scope( SURF_exposer );
        SURF_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::SURF >() );
        SURF_exposer.def( bp::init< double, bp::optional< int, int, bool > >(( bp::arg("_hessianThreshold"), bp::arg("_nOctaves")=(int)(4), bp::arg("_nOctaveLayers")=(int)(2), bp::arg("_extended")=(bool)(false) )) );
        bp::implicitly_convertible< double, cv::SURF >();
        { //::cv::SURF::descriptorSize
        
            typedef int ( ::cv::SURF::*descriptorSize_function_type )(  ) const;
            
            SURF_exposer.def( 
                "descriptorSize"
                , descriptorSize_function_type( &::cv::SURF::descriptorSize ) );
        
        }
        { //::cv::SURF::operator()
        
            typedef boost::python::object ( *__call___function_type )( cv::SURF const &,cv::Mat const &,cv::Mat const & );
            
            SURF_exposer.def( 
                "__call__"
                , __call___function_type( &__call___8fbaf2f3b7cf23fdd67db0f4874c6b20 )
                , ( bp::arg("inst"), bp::arg("img"), bp::arg("mask") )
                , "\nWrapped function:"
    "\n    operator()"
    "\nArgument 'keypoints':"\
    "\n    C++ type: ::std::vector< cv::KeyPoint > &"\
    "\n    Python type: vector_KeyPoint"\
    "\n    Output argument: omitted from input and returned as output."\
    "\nReturns:"\
    "\n    keypoints" );
        
        }
        { //::cv::SURF::operator()
        
            typedef boost::python::object ( *__call___function_type )( cv::SURF const &,cv::Mat const &,cv::Mat const &,std::vector<cv::KeyPoint> &,bool );
            
            SURF_exposer.def( 
                "__call__"
                , __call___function_type( &__call___8904ace00c2f24b8eb00d3aa8ac85014 )
                , ( bp::arg("inst"), bp::arg("img"), bp::arg("mask"), bp::arg("keypoints"), bp::arg("useProvidedKeypoints")=(bool)(false) )
                , "\nWrapped function:"
    "\n    operator()"
    "\nArgument 'descriptors':"\
    "\n    C++ type: ::std::vector< float > &"\
    "\n    Python type: vector_float32"\
    "\n    Output argument: omitted from input and returned as output."\
    "\nReturns:"\
    "\n    descriptors" );
        
        }
    }

    bp::class_< cv::StarDetector, bp::bases< CvStarDetectorParams > >( "StarDetector", bp::init< >() )    
        .add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::StarDetector >() )    
        .def( bp::init< int, int, int, int, int >(( bp::arg("_maxSize"), bp::arg("_responseThreshold"), bp::arg("_lineThresholdProjected"), bp::arg("_lineThresholdBinarized"), bp::arg("_suppressNonmaxSize") )) )    
        .def( 
            "__call__"
            , (boost::python::object (*)( cv::StarDetector const &,cv::Mat const & ))( &__call___c2d97c9701a9c79dcec3239fd753dffc )
            , ( bp::arg("inst"), bp::arg("image") )
            , "\nWrapped function:"
    "\n    operator()"
    "\nArgument 'keypoints':"\
    "\n    C++ type: ::std::vector< cv::KeyPoint > &"\
    "\n    Python type: vector_KeyPoint"\
    "\n    Output argument: omitted from input and returned as output."\
    "\nReturns:"\
    "\n    keypoints" );

    { //::cv::StereoBM
        typedef bp::class_< cv::StereoBM > StereoBM_exposer_t;
        StereoBM_exposer_t StereoBM_exposer = StereoBM_exposer_t( "StereoBM", bp::init< >() );
        bp::scope StereoBM_scope( StereoBM_exposer );
        StereoBM_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::StereoBM >() );
        bp::scope().attr("PREFILTER_NORMALIZED_RESPONSE") = (int)cv::StereoBM::PREFILTER_NORMALIZED_RESPONSE;
        bp::scope().attr("PREFILTER_XSOBEL") = (int)cv::StereoBM::PREFILTER_XSOBEL;
        bp::scope().attr("BASIC_PRESET") = (int)cv::StereoBM::BASIC_PRESET;
        bp::scope().attr("FISH_EYE_PRESET") = (int)cv::StereoBM::FISH_EYE_PRESET;
        bp::scope().attr("NARROW_PRESET") = (int)cv::StereoBM::NARROW_PRESET;
        StereoBM_exposer.def( bp::init< int, bp::optional< int, int > >(( bp::arg("preset"), bp::arg("ndisparities")=(int)(0), bp::arg("SADWindowSize")=(int)(21) )) );
        bp::implicitly_convertible< int, cv::StereoBM >();
        { //::cv::StereoBM::init
        
            typedef void ( ::cv::StereoBM::*init_function_type )( int,int,int ) ;
            
            StereoBM_exposer.def( 
                "init"
                , init_function_type( &::cv::StereoBM::init )
                , ( bp::arg("preset"), bp::arg("ndisparities")=(int)(0), bp::arg("SADWindowSize")=(int)(21) ) );
        
        }
        { //::cv::StereoBM::operator()
        
            typedef void ( ::cv::StereoBM::*__call___function_type )( ::cv::Mat const &,::cv::Mat const &,::cv::Mat &,int ) ;
            
            StereoBM_exposer.def( 
                "__call__"
                , __call___function_type( &::cv::StereoBM::operator() )
                , ( bp::arg("left"), bp::arg("right"), bp::arg("disparity"), bp::arg("disptype")=(int)(3) )
                , "\nWrapped function:"
    "\n    operator()" );
        
        }
        StereoBM_exposer.def_readwrite( "state", &cv::StereoBM::state );
    }

    { //::cv::StereoSGBM
        typedef bp::class_< StereoSGBM_wrapper > StereoSGBM_exposer_t;
        StereoSGBM_exposer_t StereoSGBM_exposer = StereoSGBM_exposer_t( "StereoSGBM", bp::init< >() );
        bp::scope StereoSGBM_scope( StereoSGBM_exposer );
        StereoSGBM_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::StereoSGBM >() );
        bp::scope().attr("DISP_SHIFT") = (int)cv::StereoSGBM::DISP_SHIFT;
        bp::scope().attr("DISP_SCALE") = (int)cv::StereoSGBM::DISP_SCALE;
        StereoSGBM_exposer.def( bp::init< int, int, int, bp::optional< int, int, int, int, int, int, int, bool > >(( bp::arg("minDisparity"), bp::arg("numDisparities"), bp::arg("SADWindowSize"), bp::arg("P1")=(int)(0), bp::arg("P2")=(int)(0), bp::arg("disp12MaxDiff")=(int)(0), bp::arg("preFilterCap")=(int)(0), bp::arg("uniquenessRatio")=(int)(0), bp::arg("speckleWindowSize")=(int)(0), bp::arg("speckleRange")=(int)(0), bp::arg("fullDP")=(bool)(false) )) );
        { //::cv::StereoSGBM::operator()
        
            typedef void ( ::cv::StereoSGBM::*__call___function_type )( ::cv::Mat const &,::cv::Mat const &,::cv::Mat & ) ;
            typedef void ( StereoSGBM_wrapper::*default___call___function_type )( ::cv::Mat const &,::cv::Mat const &,::cv::Mat & ) ;
            
            StereoSGBM_exposer.def( 
                "__call__"
                , __call___function_type(&::cv::StereoSGBM::operator())
                , default___call___function_type(&StereoSGBM_wrapper::default___call__)
                , ( bp::arg("left"), bp::arg("right"), bp::arg("disp") ) );
        
        }
        StereoSGBM_exposer.def_readwrite( "P1", &cv::StereoSGBM::P1 );
        StereoSGBM_exposer.def_readwrite( "P2", &cv::StereoSGBM::P2 );
        StereoSGBM_exposer.def_readwrite( "SADWindowSize", &cv::StereoSGBM::SADWindowSize );
        StereoSGBM_exposer.def_readwrite( "disp12MaxDiff", &cv::StereoSGBM::disp12MaxDiff );
        StereoSGBM_exposer.def_readwrite( "fullDP", &cv::StereoSGBM::fullDP );
        StereoSGBM_exposer.def_readwrite( "minDisparity", &cv::StereoSGBM::minDisparity );
        StereoSGBM_exposer.def_readwrite( "numberOfDisparities", &cv::StereoSGBM::numberOfDisparities );
        StereoSGBM_exposer.def_readwrite( "preFilterCap", &cv::StereoSGBM::preFilterCap );
        StereoSGBM_exposer.def_readwrite( "speckleRange", &cv::StereoSGBM::speckleRange );
        StereoSGBM_exposer.def_readwrite( "speckleWindowSize", &cv::StereoSGBM::speckleWindowSize );
        StereoSGBM_exposer.def_readwrite( "uniquenessRatio", &cv::StereoSGBM::uniquenessRatio );
    }

    { //::cv_hpp_dummy_struct
        typedef bp::class_< cv_hpp_dummy_struct > __cv_hpp_dummy_struct_exposer_t;
        __cv_hpp_dummy_struct_exposer_t __cv_hpp_dummy_struct_exposer = __cv_hpp_dummy_struct_exposer_t( "__cv_hpp_dummy_struct" );
        bp::scope __cv_hpp_dummy_struct_scope( __cv_hpp_dummy_struct_exposer );
        __cv_hpp_dummy_struct_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< cv_hpp_dummy_struct >() );
        bp::class_< cv_hpp_dummy_struct::dummy_struct2 >( "dummy_struct2" )    
            .add_property( "this", pyplus_conv::make_addressof_inst_getter< cv_hpp_dummy_struct::dummy_struct2 >() );
        __cv_hpp_dummy_struct_exposer.setattr("v0", 0);
    }
    {;
    }

    bp::class_< lsh_hash >( "lsh_hash" )    
        .add_property( "this", pyplus_conv::make_addressof_inst_getter< lsh_hash >() )    
        .def_readwrite( "h1", &lsh_hash::h1 )    
        .def_readwrite( "h2", &lsh_hash::h2 );

}
