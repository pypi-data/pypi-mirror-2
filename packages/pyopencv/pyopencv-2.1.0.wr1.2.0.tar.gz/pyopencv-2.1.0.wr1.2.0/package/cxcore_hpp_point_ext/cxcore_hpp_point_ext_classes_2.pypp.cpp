// This file has been generated by Py++.

#include "boost/python.hpp"
#include "boost/python/suite/indexing/vector_indexing_suite.hpp"
#include "__ctypes_integration.pypp.hpp"
#include "cxcore_hpp_point_wrapper.hpp"
#include "opencv_headers.hpp"
#include "opencv_converters.hpp"
#include "ndarray.hpp"
#include "cxcore_hpp_point_ext_classes_2.pypp.hpp"

namespace bp = boost::python;

static inline void vector_Point2f_resize(::std::vector< cv::Point_<float> > &inst, size_t num) { inst.resize(num); }

static inline void vector_Point2d_resize(::std::vector< cv::Point_<double> > &inst, size_t num) { inst.resize(num); }

static inline void vector_Point3i_resize(::std::vector< cv::Point3_<int> > &inst, size_t num) { inst.resize(num); }

static inline void vector_Point3f_resize(::std::vector< cv::Point3_<float> > &inst, size_t num) { inst.resize(num); }

static inline void vector_Point3d_resize(::std::vector< cv::Point3_<double> > &inst, size_t num) { inst.resize(num); }

static inline void vector_MatND_resize(::std::vector< cv::MatND > &inst, size_t num) { inst.resize(num); }

static inline void vector_Mat_resize(::std::vector< cv::Mat > &inst, size_t num) { inst.resize(num); }

static bp::object Mat_get_data(cv::Mat const &inst)
{
    return sdcpp::get_new_object(
        PyBuffer_FromReadWriteMemory(
            (void*)(inst.data), 
            (size_t)(inst.rows*inst.step)));
}

static boost::shared_ptr<cv::Mat> Mat__init1__(bp::object const &arg1)
{
    // None
    if(arg1.ptr() == Py_None) return boost::shared_ptr<cv::Mat>(new cv::Mat());
    
    // cv::Mat const &
    bp::extract<cv::Mat const &> arg1a(arg1);
    if(arg1a.check()) return boost::shared_ptr<cv::Mat>(new cv::Mat(arg1a()));
    
    // TODO: here
    PyErr_SetString(PyExc_NotImplementedError, "Unable to construct cv::Mat using the given argument.");
    throw bp::error_already_set(); 
    return boost::shared_ptr<cv::Mat>(new cv::Mat());
}

static boost::shared_ptr<cv::Mat> Mat__init2__(bp::object const &arg1, bp::object const &arg2)
{
    // cv::Size, int
    bp::extract<cv::Size const &> arg1a(arg1);
    bp::extract<int> arg2a(arg2);
    if(arg1a.check() && arg2a.check()) return boost::shared_ptr<cv::Mat>(new cv::Mat(arg1a(), arg2a()));
    
    // cv::Mat, cv::Rect
    bp::extract<cv::Mat const &> arg1b(arg1);
    bp::extract<cv::Rect> arg2b(arg2);
    if(arg1b.check() && arg2b.check()) return boost::shared_ptr<cv::Mat>(new cv::Mat(arg1b(), arg2b()));
    
    // TODO: here
    PyErr_SetString(PyExc_NotImplementedError, "Unable to construct cv::Mat using the given 2 arguments.");
    throw bp::error_already_set(); 
    return boost::shared_ptr<cv::Mat>(new cv::Mat());
}

static boost::shared_ptr<cv::Mat> Mat__init3__(bp::object const &arg1, bp::object const &arg2, bp::object const &arg3)
{
    // int, int, int
    bp::extract<int> arg1a(arg1);
    bp::extract<int> arg2a(arg2);
    bp::extract<int> arg3a(arg3);
    if(arg1a.check() && arg2a.check() && arg3a.check()) return boost::shared_ptr<cv::Mat>(new cv::Mat(arg1a(), arg2a(), arg3a()));
    
    // cv::Size, int, cv::Scalar
    bp::extract<cv::Size const &> arg1b(arg1);
    bp::extract<int> arg2b(arg2);
    bp::extract<cv::Scalar const &> arg3b(arg3);
    if(arg1b.check() && arg2b.check() && arg3b.check()) return boost::shared_ptr<cv::Mat>(new cv::Mat(arg1b(), arg2b(), arg3b()));
    
    // cv::Mat, cv::Range, cv::Range
    bp::extract<cv::Mat const &> arg1c(arg1);
    bp::extract<cv::Range const &> arg2c(arg2);
    bp::extract<cv::Range const &> arg3c(arg3);
    if(arg1c.check() && arg2c.check() && arg3c.check()) return boost::shared_ptr<cv::Mat>(new cv::Mat(arg1c(), arg2c(), arg3c()));
    
    // TODO: here
    PyErr_SetString(PyExc_NotImplementedError, "Unable to construct cv::Mat using the given 3 arguments.");
    throw bp::error_already_set(); 
    return boost::shared_ptr<cv::Mat>(new cv::Mat());
}

void register_classes_2(){

    { //::std::vector< cv::Point_<float> >
        typedef bp::class_< std::vector< cv::Point_<float> > > vector_Point2f_exposer_t;
        vector_Point2f_exposer_t vector_Point2f_exposer = vector_Point2f_exposer_t( "vector_Point2f" );
        bp::scope vector_Point2f_scope( vector_Point2f_exposer );
        //WARNING: the next line of code will not compile, because "cv::Point_<float>" does not have operator== !
        vector_Point2f_exposer.def( bp::vector_indexing_suite< ::std::vector< cv::Point_<float> > >() );
        vector_Point2f_exposer.def("resize", &::vector_Point2f_resize, ( bp::arg("num") ));
    }

    { //::std::vector< cv::Point_<double> >
        typedef bp::class_< std::vector< cv::Point_<double> > > vector_Point2d_exposer_t;
        vector_Point2d_exposer_t vector_Point2d_exposer = vector_Point2d_exposer_t( "vector_Point2d" );
        bp::scope vector_Point2d_scope( vector_Point2d_exposer );
        //WARNING: the next line of code will not compile, because "cv::Point_<double>" does not have operator== !
        vector_Point2d_exposer.def( bp::vector_indexing_suite< ::std::vector< cv::Point_<double> > >() );
        vector_Point2d_exposer.def("resize", &::vector_Point2d_resize, ( bp::arg("num") ));
    }

    { //::std::vector< cv::Point3_<int> >
        typedef bp::class_< std::vector< cv::Point3_<int> > > vector_Point3i_exposer_t;
        vector_Point3i_exposer_t vector_Point3i_exposer = vector_Point3i_exposer_t( "vector_Point3i" );
        bp::scope vector_Point3i_scope( vector_Point3i_exposer );
        //WARNING: the next line of code will not compile, because "cv::Point3_<int>" does not have operator== !
        vector_Point3i_exposer.def( bp::vector_indexing_suite< ::std::vector< cv::Point3_<int> > >() );
        vector_Point3i_exposer.def("resize", &::vector_Point3i_resize, ( bp::arg("num") ));
    }

    { //::std::vector< cv::Point3_<float> >
        typedef bp::class_< std::vector< cv::Point3_<float> > > vector_Point3f_exposer_t;
        vector_Point3f_exposer_t vector_Point3f_exposer = vector_Point3f_exposer_t( "vector_Point3f" );
        bp::scope vector_Point3f_scope( vector_Point3f_exposer );
        //WARNING: the next line of code will not compile, because "cv::Point3_<float>" does not have operator== !
        vector_Point3f_exposer.def( bp::vector_indexing_suite< ::std::vector< cv::Point3_<float> > >() );
        vector_Point3f_exposer.def("resize", &::vector_Point3f_resize, ( bp::arg("num") ));
    }

    { //::std::vector< cv::Point3_<double> >
        typedef bp::class_< std::vector< cv::Point3_<double> > > vector_Point3d_exposer_t;
        vector_Point3d_exposer_t vector_Point3d_exposer = vector_Point3d_exposer_t( "vector_Point3d" );
        bp::scope vector_Point3d_scope( vector_Point3d_exposer );
        //WARNING: the next line of code will not compile, because "cv::Point3_<double>" does not have operator== !
        vector_Point3d_exposer.def( bp::vector_indexing_suite< ::std::vector< cv::Point3_<double> > >() );
        vector_Point3d_exposer.def("resize", &::vector_Point3d_resize, ( bp::arg("num") ));
    }

    { //::std::vector< cv::MatND >
        typedef bp::class_< std::vector< cv::MatND > > vector_MatND_exposer_t;
        vector_MatND_exposer_t vector_MatND_exposer = vector_MatND_exposer_t( "vector_MatND" );
        bp::scope vector_MatND_scope( vector_MatND_exposer );
        //WARNING: the next line of code will not compile, because "cv::MatND" does not have operator== !
        vector_MatND_exposer.def( bp::vector_indexing_suite< ::std::vector< cv::MatND > >() );
        vector_MatND_exposer.def("resize", &::vector_MatND_resize, ( bp::arg("num") ));
    }

    { //::std::vector< cv::Mat >
        typedef bp::class_< std::vector< cv::Mat > > vector_Mat_exposer_t;
        vector_Mat_exposer_t vector_Mat_exposer = vector_Mat_exposer_t( "vector_Mat" );
        bp::scope vector_Mat_scope( vector_Mat_exposer );
        vector_Mat_exposer.def( bp::vector_indexing_suite< ::std::vector< cv::Mat > >() );
        vector_Mat_exposer.def("resize", &::vector_Mat_resize, ( bp::arg("num") ));
    }

    { //::cv::Mat
        typedef bp::class_< cv::Mat > Mat_exposer_t;
        Mat_exposer_t Mat_exposer = Mat_exposer_t( "Mat", bp::init< >() );
        bp::scope Mat_scope( Mat_exposer );
        Mat_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::Mat >() );
        bp::scope().attr("MAGIC_VAL") = (int)cv::Mat::MAGIC_VAL;
        bp::scope().attr("AUTO_STEP") = (int)cv::Mat::AUTO_STEP;
        bp::scope().attr("CONTINUOUS_FLAG") = (int)cv::Mat::CONTINUOUS_FLAG;
        Mat_exposer.def( bp::init< int, int, int >(( bp::arg("_rows"), bp::arg("_cols"), bp::arg("_type") )) );
        Mat_exposer.def( bp::init< int, int, int, cv::Scalar const & >(( bp::arg("_rows"), bp::arg("_cols"), bp::arg("_type"), bp::arg("_s") )) );
        Mat_exposer.def( bp::init< cv::Size, int >(( bp::arg("_size"), bp::arg("_type") )) );
        Mat_exposer.def( bp::init< cv::Size, int, cv::Scalar const & >(( bp::arg("_size"), bp::arg("_type"), bp::arg("_s") )) );
        Mat_exposer.def( bp::init< cv::Mat const & >(( bp::arg("m") )) );
        Mat_exposer.def( bp::init< cv::Mat const &, cv::Range const &, cv::Range const & >(( bp::arg("m"), bp::arg("rowRange"), bp::arg("colRange") )) );
        Mat_exposer.def( bp::init< cv::Mat const &, cv::Rect const & >(( bp::arg("m"), bp::arg("roi") )) );
        { //::cv::Mat::adjustROI
        
            typedef ::cv::Mat & ( ::cv::Mat::*adjustROI_function_type )( int,int,int,int ) ;
            
            Mat_exposer.def( 
                "adjustROI"
                , adjustROI_function_type( &::cv::Mat::adjustROI )
                , ( bp::arg("dtop"), bp::arg("dbottom"), bp::arg("dleft"), bp::arg("dright") )
                , bp::return_self< >() );
        
        }
        { //::cv::Mat::assignTo
        
            typedef void ( ::cv::Mat::*assignTo_function_type )( ::cv::Mat &,int ) const;
            
            Mat_exposer.def( 
                "assignTo"
                , assignTo_function_type( &::cv::Mat::assignTo )
                , ( bp::arg("m"), bp::arg("type")=(int)(-0x000000001) ) );
        
        }
        { //::cv::Mat::channels
        
            typedef int ( ::cv::Mat::*channels_function_type )(  ) const;
            
            Mat_exposer.def( 
                "channels"
                , channels_function_type( &::cv::Mat::channels ) );
        
        }
        { //::cv::Mat::clone
        
            typedef ::cv::Mat ( ::cv::Mat::*clone_function_type )(  ) const;
            
            Mat_exposer.def( 
                "clone"
                , clone_function_type( &::cv::Mat::clone ) );
        
        }
        { //::cv::Mat::col
        
            typedef ::cv::Mat ( ::cv::Mat::*col_function_type )( int ) const;
            
            Mat_exposer.def( 
                "col"
                , col_function_type( &::cv::Mat::col )
                , ( bp::arg("x") ) );
        
        }
        { //::cv::Mat::colRange
        
            typedef ::cv::Mat ( ::cv::Mat::*colRange_function_type )( int,int ) const;
            
            Mat_exposer.def( 
                "colRange"
                , colRange_function_type( &::cv::Mat::colRange )
                , ( bp::arg("startcol"), bp::arg("endcol") ) );
        
        }
        { //::cv::Mat::colRange
        
            typedef ::cv::Mat ( ::cv::Mat::*colRange_function_type )( ::cv::Range const & ) const;
            
            Mat_exposer.def( 
                "colRange"
                , colRange_function_type( &::cv::Mat::colRange )
                , ( bp::arg("r") ) );
        
        }
        { //::cv::Mat::convertTo
        
            typedef void ( ::cv::Mat::*convertTo_function_type )( ::cv::Mat &,int,double,double ) const;
            
            Mat_exposer.def( 
                "convertTo"
                , convertTo_function_type( &::cv::Mat::convertTo )
                , ( bp::arg("m"), bp::arg("rtype"), bp::arg("alpha")=1, bp::arg("beta")=0 ) );
        
        }
        { //::cv::Mat::copyTo
        
            typedef void ( ::cv::Mat::*copyTo_function_type )( ::cv::Mat & ) const;
            
            Mat_exposer.def( 
                "copyTo"
                , copyTo_function_type( &::cv::Mat::copyTo )
                , ( bp::arg("m") ) );
        
        }
        { //::cv::Mat::copyTo
        
            typedef void ( ::cv::Mat::*copyTo_function_type )( ::cv::Mat &,::cv::Mat const & ) const;
            
            Mat_exposer.def( 
                "copyTo"
                , copyTo_function_type( &::cv::Mat::copyTo )
                , ( bp::arg("m"), bp::arg("mask") ) );
        
        }
        { //::cv::Mat::create
        
            typedef void ( ::cv::Mat::*create_function_type )( int,int,int ) ;
            
            Mat_exposer.def( 
                "create"
                , create_function_type( &::cv::Mat::create )
                , ( bp::arg("_rows"), bp::arg("_cols"), bp::arg("_type") ) );
        
        }
        { //::cv::Mat::create
        
            typedef void ( ::cv::Mat::*create_function_type )( ::cv::Size,int ) ;
            
            Mat_exposer.def( 
                "create"
                , create_function_type( &::cv::Mat::create )
                , ( bp::arg("_size"), bp::arg("_type") ) );
        
        }
        { //::cv::Mat::cross
        
            typedef ::cv::Mat ( ::cv::Mat::*cross_function_type )( ::cv::Mat const & ) const;
            
            Mat_exposer.def( 
                "cross"
                , cross_function_type( &::cv::Mat::cross )
                , ( bp::arg("m") ) );
        
        }
        { //::cv::Mat::depth
        
            typedef int ( ::cv::Mat::*depth_function_type )(  ) const;
            
            Mat_exposer.def( 
                "depth"
                , depth_function_type( &::cv::Mat::depth ) );
        
        }
        { //::cv::Mat::diag
        
            typedef ::cv::Mat ( ::cv::Mat::*diag_function_type )( int ) const;
            
            Mat_exposer.def( 
                "diag"
                , diag_function_type( &::cv::Mat::diag )
                , ( bp::arg("d")=(int)(0) ) );
        
        }
        { //::cv::Mat::diag
        
            typedef ::cv::Mat ( *diag_function_type )( ::cv::Mat const & );
            
            Mat_exposer.def( 
                "diag"
                , diag_function_type( &::cv::Mat::diag )
                , ( bp::arg("d") ) );
        
        }
        { //::cv::Mat::dot
        
            typedef double ( ::cv::Mat::*dot_function_type )( ::cv::Mat const & ) const;
            
            Mat_exposer.def( 
                "dot"
                , dot_function_type( &::cv::Mat::dot )
                , ( bp::arg("m") ) );
        
        }
        { //::cv::Mat::elemSize
        
            typedef ::size_t ( ::cv::Mat::*elemSize_function_type )(  ) const;
            
            Mat_exposer.def( 
                "elemSize"
                , elemSize_function_type( &::cv::Mat::elemSize ) );
        
        }
        { //::cv::Mat::elemSize1
        
            typedef ::size_t ( ::cv::Mat::*elemSize1_function_type )(  ) const;
            
            Mat_exposer.def( 
                "elemSize1"
                , elemSize1_function_type( &::cv::Mat::elemSize1 ) );
        
        }
        { //::cv::Mat::empty
        
            typedef bool ( ::cv::Mat::*empty_function_type )(  ) const;
            
            Mat_exposer.def( 
                "empty"
                , empty_function_type( &::cv::Mat::empty ) );
        
        }
        { //::cv::Mat::isContinuous
        
            typedef bool ( ::cv::Mat::*isContinuous_function_type )(  ) const;
            
            Mat_exposer.def( 
                "isContinuous"
                , isContinuous_function_type( &::cv::Mat::isContinuous ) );
        
        }
        { //::cv::Mat::locateROI
        
            typedef void ( ::cv::Mat::*locateROI_function_type )( ::cv::Size &,::cv::Point & ) const;
            
            Mat_exposer.def( 
                "locateROI"
                , locateROI_function_type( &::cv::Mat::locateROI )
                , ( bp::arg("wholeSize"), bp::arg("ofs") ) );
        
        }
        { //::cv::Mat::operator()
        
            typedef ::cv::Mat ( ::cv::Mat::*__call___function_type )( ::cv::Range,::cv::Range ) const;
            
            Mat_exposer.def( 
                "__call__"
                , __call___function_type( &::cv::Mat::operator() )
                , ( bp::arg("rowRange"), bp::arg("colRange") )
                , "\nWrapped function:"
    "\n    operator()" );
        
        }
        { //::cv::Mat::operator()
        
            typedef ::cv::Mat ( ::cv::Mat::*__call___function_type )( ::cv::Rect const & ) const;
            
            Mat_exposer.def( 
                "__call__"
                , __call___function_type( &::cv::Mat::operator() )
                , ( bp::arg("roi") )
                , "\nWrapped function:"
    "\n    operator()" );
        
        }
        { //::cv::Mat::operator=
        
            typedef ::cv::Mat & ( ::cv::Mat::*assign_function_type )( ::cv::Mat const & ) ;
            
            Mat_exposer.def( 
                "assign"
                , assign_function_type( &::cv::Mat::operator= )
                , ( bp::arg("m") )
                , bp::return_self< >()
                , "\nWrapped function:"
    "\n    operator=" );
        
        }
        { //::cv::Mat::operator=
        
            typedef ::cv::Mat & ( ::cv::Mat::*assign_function_type )( ::cv::Scalar const & ) ;
            
            Mat_exposer.def( 
                "assign"
                , assign_function_type( &::cv::Mat::operator= )
                , ( bp::arg("s") )
                , bp::return_self< >()
                , "\nWrapped function:"
    "\n    operator=" );
        
        }
        { //::cv::Mat::reshape
        
            typedef ::cv::Mat ( ::cv::Mat::*reshape_function_type )( int,int ) const;
            
            Mat_exposer.def( 
                "reshape"
                , reshape_function_type( &::cv::Mat::reshape )
                , ( bp::arg("_cn"), bp::arg("_rows")=(int)(0) ) );
        
        }
        { //::cv::Mat::row
        
            typedef ::cv::Mat ( ::cv::Mat::*row_function_type )( int ) const;
            
            Mat_exposer.def( 
                "row"
                , row_function_type( &::cv::Mat::row )
                , ( bp::arg("y") ) );
        
        }
        { //::cv::Mat::rowRange
        
            typedef ::cv::Mat ( ::cv::Mat::*rowRange_function_type )( int,int ) const;
            
            Mat_exposer.def( 
                "rowRange"
                , rowRange_function_type( &::cv::Mat::rowRange )
                , ( bp::arg("startrow"), bp::arg("endrow") ) );
        
        }
        { //::cv::Mat::rowRange
        
            typedef ::cv::Mat ( ::cv::Mat::*rowRange_function_type )( ::cv::Range const & ) const;
            
            Mat_exposer.def( 
                "rowRange"
                , rowRange_function_type( &::cv::Mat::rowRange )
                , ( bp::arg("r") ) );
        
        }
        { //::cv::Mat::setTo
        
            typedef ::cv::Mat & ( ::cv::Mat::*setTo_function_type )( ::cv::Scalar const &,::cv::Mat const & ) ;
            
            Mat_exposer.def( 
                "setTo"
                , setTo_function_type( &::cv::Mat::setTo )
                , ( bp::arg("s"), bp::arg("mask")=cv::Mat() )
                , bp::return_self< >() );
        
        }
        { //::cv::Mat::size
        
            typedef ::cv::Size ( ::cv::Mat::*size_function_type )(  ) const;
            
            Mat_exposer.def( 
                "size"
                , size_function_type( &::cv::Mat::size ) );
        
        }
        { //::cv::Mat::step1
        
            typedef ::size_t ( ::cv::Mat::*step1_function_type )(  ) const;
            
            Mat_exposer.def( 
                "step1"
                , step1_function_type( &::cv::Mat::step1 ) );
        
        }
        { //::cv::Mat::type
        
            typedef int ( ::cv::Mat::*type_function_type )(  ) const;
            
            Mat_exposer.def( 
                "type"
                , type_function_type( &::cv::Mat::type ) );
        
        }
        Mat_exposer.def_readwrite( "cols", &cv::Mat::cols );
        Mat_exposer.def_readwrite( "flags", &cv::Mat::flags );
        Mat_exposer.def_readwrite( "rows", &cv::Mat::rows );
        Mat_exposer.def_readwrite( "step", &cv::Mat::step );
        Mat_exposer.staticmethod( "diag" );
        Mat_exposer.add_property("data", &::Mat_get_data);
        Mat_exposer.add_property("ndarray", &sdcpp::as_ndarray< cv::Mat >);
        Mat_exposer.def("__init__", bp::make_constructor(&Mat__init1__, bp::default_call_policies(), ( bp::arg("arg1") )));
        Mat_exposer.def("__init__", bp::make_constructor(&Mat__init2__, bp::default_call_policies(), ( bp::arg("arg1"), bp::arg("arg2") )));
        Mat_exposer.def("__init__", bp::make_constructor(&Mat__init3__, bp::default_call_policies(), ( bp::arg("arg1"), bp::arg("arg2"), bp::arg("arg3") )));
    }

}
