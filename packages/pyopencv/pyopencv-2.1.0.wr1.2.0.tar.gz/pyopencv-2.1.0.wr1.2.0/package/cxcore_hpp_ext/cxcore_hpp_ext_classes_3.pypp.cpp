// This file has been generated by Py++.

#include "boost/python.hpp"
#include "__ctypes_integration.pypp.hpp"
#include "cxcore_hpp_wrapper.hpp"
#include "ndarray.hpp"
#include "opencv_converters.hpp"
#include "cxcore_hpp_ext_classes_3.pypp.hpp"

namespace bp = boost::python;

void register_classes_3(){

    bp::class_< cv::PCA >( "PCA", "\nClass for Principal Component Analysis."
    "\n"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#pca", bp::init< >("\nPCA constructors."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-pca-pca") )    
        .add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::PCA >(), "\nClass for Principal Component Analysis."
    "\n"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#pca" )    
        .def( bp::init< cv::Mat const &, cv::Mat const &, int, bp::optional< int > >(( bp::arg("data"), bp::arg("mean"), bp::arg("flags"), bp::arg("maxComponents")=(int)(0) ), "\nPCA constructors."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-pca-pca") )    
        .def( 
            "backProject"
            , (::cv::Mat ( cv::PCA::* )( ::cv::Mat const & ) const)( &::cv::PCA::backProject )
            , ( bp::arg("vec") )
            , "\nReconstruct vectors from their PC projections."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-pca-backproject" )    
        .def( 
            "backProject"
            , (void ( cv::PCA::* )( ::cv::Mat const &,::cv::Mat & ) const)( &::cv::PCA::backProject )
            , ( bp::arg("vec"), bp::arg("result") )
            , "\nReconstruct vectors from their PC projections."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-pca-backproject" )    
        .def( 
            "__call__"
            , (::cv::PCA & ( cv::PCA::* )( ::cv::Mat const &,::cv::Mat const &,int,int ) )( &::cv::PCA::operator() )
            , ( bp::arg("data"), bp::arg("mean"), bp::arg("flags"), bp::arg("maxComponents")=(int)(0) )
            , bp::return_self< >()
            , "\nPerforms Principal Component Analysis of the supplied dataset."
    "\nWrapped function:"
    "\n    operator()"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-pca-operator" )    
        .def( 
            "project"
            , (::cv::Mat ( cv::PCA::* )( ::cv::Mat const & ) const)( &::cv::PCA::project )
            , ( bp::arg("vec") )
            , "\nProject vector(s) to the principal component subspace."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-pca-project" )    
        .def( 
            "project"
            , (void ( cv::PCA::* )( ::cv::Mat const &,::cv::Mat & ) const)( &::cv::PCA::project )
            , ( bp::arg("vec"), bp::arg("result") )
            , "\nProject vector(s) to the principal component subspace."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-pca-project" )    
        .def_readwrite( "eigenvalues", &cv::PCA::eigenvalues )    
        .def_readwrite( "eigenvectors", &cv::PCA::eigenvectors )    
        .def_readwrite( "mean", &cv::PCA::mean );

    { //::cv::RNG
        typedef bp::class_< cv::RNG > RNG_exposer_t;
        RNG_exposer_t RNG_exposer = RNG_exposer_t( "RNG", "\nRandom number generator class."
    "\n"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#rng", bp::init< >("\nRNG constructors."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-rng-rng") );
        bp::scope RNG_scope( RNG_exposer );
        RNG_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::RNG >(), "\nRandom number generator class."
    "\n"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#rng" );
        bp::scope().attr("A") = (int)cv::RNG::A;
        bp::scope().attr("UNIFORM") = (int)cv::RNG::UNIFORM;
        bp::scope().attr("NORMAL") = (int)cv::RNG::NORMAL;
        RNG_exposer.def( bp::init< uint64 >(( bp::arg("_state") ), "\nRNG constructors."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-rng-rng") );
        bp::implicitly_convertible< uint64, cv::RNG >();
        { //::cv::RNG::fill
        
            typedef void ( ::cv::RNG::*fill_function_type )( ::cv::Mat &,int,::cv::Scalar const &,::cv::Scalar const & ) ;
            
            RNG_exposer.def( 
                "fill"
                , fill_function_type( &::cv::RNG::fill )
                , ( bp::arg("mat"), bp::arg("distType"), bp::arg("a"), bp::arg("b") )
                , "\nFill arrays with random numbers."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-rng-fill" );
        
        }
        { //::cv::RNG::fill
        
            typedef void ( ::cv::RNG::*fill_function_type )( ::cv::MatND &,int,::cv::Scalar const &,::cv::Scalar const & ) ;
            
            RNG_exposer.def( 
                "fill"
                , fill_function_type( &::cv::RNG::fill )
                , ( bp::arg("mat"), bp::arg("distType"), bp::arg("a"), bp::arg("b") )
                , "\nFill arrays with random numbers."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-rng-fill" );
        
        }
        { //::cv::RNG::gaussian
        
            typedef double ( ::cv::RNG::*gaussian_function_type )( double ) ;
            
            RNG_exposer.def( 
                "gaussian"
                , gaussian_function_type( &::cv::RNG::gaussian )
                , ( bp::arg("sigma") )
                , "\nReturns the next random number sampled from the Gaussian distribution."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-rng-gaussian" );
        
        }
        { //::cv::RNG::next
        
            typedef unsigned int ( ::cv::RNG::*next_function_type )(  ) ;
            
            RNG_exposer.def( 
                "next"
                , next_function_type( &::cv::RNG::next )
                , "\nReturns the next random number."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-rng-next" );
        
        }
        RNG_exposer.def( "as_int8", &cv::RNG::operator ::schar , "\nWrapped function:"
    "\n    operator ::schar" );
        RNG_exposer.def( "as_uint8", &cv::RNG::operator ::uchar , "\nWrapped function:"
    "\n    operator ::uchar" );
        RNG_exposer.def( "as_uint16", &cv::RNG::operator ::ushort , "\nWrapped function:"
    "\n    operator ::ushort" );
        RNG_exposer.def( "as_float64", &cv::RNG::operator double , "\nWrapped function:"
    "\n    operator double" );
        RNG_exposer.def( "as_float32", &cv::RNG::operator float , "\nWrapped function:"
    "\n    operator float" );
        RNG_exposer.def( "as_int", &cv::RNG::operator int , "\nWrapped function:"
    "\n    operator int" );
        RNG_exposer.def( "as_int16", &cv::RNG::operator short int , "\nWrapped function:"
    "\n    operator short int" );
        RNG_exposer.def( "as_uint", &cv::RNG::operator unsigned int , "\nWrapped function:"
    "\n    operator unsigned int" );
        { //::cv::RNG::operator()
        
            typedef unsigned int ( ::cv::RNG::*__call___function_type )( unsigned int ) ;
            
            RNG_exposer.def( 
                "__call__"
                , __call___function_type( &::cv::RNG::operator() )
                , ( bp::arg("N") )
                , "\nReturns the next random number."
    "\nWrapped function:"
    "\n    operator()"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-rng-operator" );
        
        }
        { //::cv::RNG::operator()
        
            typedef unsigned int ( ::cv::RNG::*__call___function_type )(  ) ;
            
            RNG_exposer.def( 
                "__call__"
                , __call___function_type( &::cv::RNG::operator() )
                , "\nReturns the next random number."
    "\nWrapped function:"
    "\n    operator()"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-rng-operator" );
        
        }
        { //::cv::RNG::uniform
        
            typedef int ( ::cv::RNG::*uniform_int_function_type )( int,int ) ;
            
            RNG_exposer.def( 
                "uniform_int"
                , uniform_int_function_type( &::cv::RNG::uniform )
                , ( bp::arg("a"), bp::arg("b") )
                , "\nReturns the next random number sampled from the uniform distribution."
    "\nWrapped function:"
    "\n    uniform"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-rng-uniform" );
        
        }
        { //::cv::RNG::uniform
        
            typedef float ( ::cv::RNG::*uniform_float32_function_type )( float,float ) ;
            
            RNG_exposer.def( 
                "uniform_float32"
                , uniform_float32_function_type( &::cv::RNG::uniform )
                , ( bp::arg("a"), bp::arg("b") )
                , "\nReturns the next random number sampled from the uniform distribution."
    "\nWrapped function:"
    "\n    uniform"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-rng-uniform" );
        
        }
        { //::cv::RNG::uniform
        
            typedef double ( ::cv::RNG::*uniform_float64_function_type )( double,double ) ;
            
            RNG_exposer.def( 
                "uniform_float64"
                , uniform_float64_function_type( &::cv::RNG::uniform )
                , ( bp::arg("a"), bp::arg("b") )
                , "\nReturns the next random number sampled from the uniform distribution."
    "\nWrapped function:"
    "\n    uniform"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-rng-uniform" );
        
        }
        RNG_exposer.def_readwrite( "state", &cv::RNG::state );
    }

    { //::cv::Rect_< int >
        typedef bp::class_< cv::Rect_< int > > Rect_exposer_t;
        Rect_exposer_t Rect_exposer = Rect_exposer_t( "Rect", bp::init< >() );
        bp::scope Rect_scope( Rect_exposer );
        Rect_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::Rect_< int > >() );
        Rect_exposer.def( bp::init< int, int, int, int >(( bp::arg("_x"), bp::arg("_y"), bp::arg("_width"), bp::arg("_height") )) );
        Rect_exposer.def( bp::init< cv::Rect_< int > const & >(( bp::arg("r") )) );
        Rect_exposer.def( bp::init< cv::Point_< int > const &, cv::Size_< int > const & >(( bp::arg("org"), bp::arg("sz") )) );
        Rect_exposer.def( bp::init< cv::Point_< int > const &, cv::Point_< int > const & >(( bp::arg("pt1"), bp::arg("pt2") )) );
        { //::cv::Rect_< int >::area
        
            typedef cv::Rect_< int > exported_class_t;
            typedef int ( exported_class_t::*area_function_type )(  ) const;
            
            Rect_exposer.def( 
                "area"
                , area_function_type( &::cv::Rect_< int >::area ) );
        
        }
        { //::cv::Rect_< int >::br
        
            typedef cv::Rect_< int > exported_class_t;
            typedef ::cv::Point_< int > ( exported_class_t::*br_function_type )(  ) const;
            
            Rect_exposer.def( 
                "br"
                , br_function_type( &::cv::Rect_< int >::br ) );
        
        }
        { //::cv::Rect_< int >::contains
        
            typedef cv::Rect_< int > exported_class_t;
            typedef bool ( exported_class_t::*contains_function_type )( ::cv::Point_< int > const & ) const;
            
            Rect_exposer.def( 
                "contains"
                , contains_function_type( &::cv::Rect_< int >::contains )
                , ( bp::arg("pt") ) );
        
        }
        { //::cv::Rect_< int >::operator=
        
            typedef cv::Rect_< int > exported_class_t;
            typedef ::cv::Rect_< int > & ( exported_class_t::*assign_function_type )( ::cv::Rect_< int > const & ) ;
            
            Rect_exposer.def( 
                "assign"
                , assign_function_type( &::cv::Rect_< int >::operator= )
                , ( bp::arg("r") )
                , bp::return_self< >()
                , "\nWrapped function:"
    "\n    operator=" );
        
        }
        { //::cv::Rect_< int >::size
        
            typedef cv::Rect_< int > exported_class_t;
            typedef ::cv::Size_< int > ( exported_class_t::*size_function_type )(  ) const;
            
            Rect_exposer.def( 
                "size"
                , size_function_type( &::cv::Rect_< int >::size ) );
        
        }
        { //::cv::Rect_< int >::tl
        
            typedef cv::Rect_< int > exported_class_t;
            typedef ::cv::Point_< int > ( exported_class_t::*tl_function_type )(  ) const;
            
            Rect_exposer.def( 
                "tl"
                , tl_function_type( &::cv::Rect_< int >::tl ) );
        
        }
        Rect_exposer.def_readwrite( "height", &cv::Rect_< int >::height );
        Rect_exposer.def_readwrite( "width", &cv::Rect_< int >::width );
        Rect_exposer.def_readwrite( "x", &cv::Rect_< int >::x );
        Rect_exposer.def_readwrite( "y", &cv::Rect_< int >::y );
        Rect_exposer.add_property("ndarray", &sdcpp::as_ndarray< cv::Rect_<int> >);
        Rect_exposer.def("__iadd__", &__iadd__<cv::Rect, cv::Point_<int> >, bp::return_self<>() );
        Rect_exposer.def("__iadd__", &__iadd__<cv::Rect, cv::Size_<int> >, bp::return_self<>() );
        Rect_exposer.def("__isub__", &__isub__<cv::Rect, cv::Point_<int> >, bp::return_self<>() );
        Rect_exposer.def("__isub__", &__isub__<cv::Rect, cv::Size_<int> >, bp::return_self<>() );
        Rect_exposer.def("__iand__", &__iand__<cv::Rect, cv::Rect>, bp::return_self<>() );
        Rect_exposer.def("__ior__", &__ior__<cv::Rect, cv::Rect>, bp::return_self<>() );
        Rect_exposer.def("__and__", &__and__<cv::Rect, cv::Rect> );
        Rect_exposer.def("__or__", &__or__<cv::Rect, cv::Rect> );
        Rect_exposer.def("__eq__", &__eq__<cv::Rect, cv::Rect> );
        Rect_exposer.def("__add__", &__add__<cv::Rect, cv::Point_<int> > );
        Rect_exposer.def("__sub__", &__sub__<cv::Rect, cv::Point_<int> > );
        Rect_exposer.def("__add__", &__add__<cv::Rect, cv::Size_<int> > );
    }

    bp::class_< cv::RotatedRect >( "RotatedRect", "\nPossibly rotated rectangle."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/basic_structures.html#rotatedrect", bp::init< >("\nConstructor."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/basic_structures.html#rotatedrect") )    
        .add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::RotatedRect >(), "\nPossibly rotated rectangle."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/basic_structures.html#rotatedrect" )    
        .def( bp::init< cv::Point2f const &, cv::Size2f const &, float >(( bp::arg("_center"), bp::arg("_size"), bp::arg("_angle") ), "\nConstructor."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/basic_structures.html#rotatedrect") )    
        .def( 
            "boundingRect"
            , (::cv::Rect ( cv::RotatedRect::* )(  ) const)( &::cv::RotatedRect::boundingRect )
            , "\nReturns minimal up-right rectangle that contains the rotated "
    "\nrectangle."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/basic_structures.html#rotatedrect" )    
        .def( 
            "points"
            , (void ( cv::RotatedRect::* )( ::cv::Point2f * ) const)( &::cv::RotatedRect::points )
            , ( bp::arg("pt") ) )    
        .def_readwrite( "angle", &cv::RotatedRect::angle )    
        .def_readwrite( "center", &cv::RotatedRect::center )    
        .def_readwrite( "size", &cv::RotatedRect::size )    
        .add_property("ndarray", &sdcpp::as_ndarray< cv::RotatedRect >);

    { //::cv::SVD
        typedef bp::class_< cv::SVD > SVD_exposer_t;
        SVD_exposer_t SVD_exposer = SVD_exposer_t( "SVD", "\nClass for computing Singular Value Decomposition."
    "\n"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#svd", bp::init< >("\nSVD constructors."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-svd-svd") );
        bp::scope SVD_scope( SVD_exposer );
        SVD_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::SVD >(), "\nClass for computing Singular Value Decomposition."
    "\n"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#svd" );
        bp::scope().attr("MODIFY_A") = (int)cv::SVD::MODIFY_A;
        bp::scope().attr("NO_UV") = (int)cv::SVD::NO_UV;
        bp::scope().attr("FULL_UV") = (int)cv::SVD::FULL_UV;
        SVD_exposer.def( bp::init< cv::Mat const &, bp::optional< int > >(( bp::arg("m"), bp::arg("flags")=(int)(0) ), "\nSVD constructors."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-svd-svd") );
        bp::implicitly_convertible< cv::Mat const &, cv::SVD >();
        { //::cv::SVD::backSubst
        
            typedef void ( ::cv::SVD::*backSubst_function_type )( ::cv::Mat const &,::cv::Mat & ) const;
            
            SVD_exposer.def( 
                "backSubst"
                , backSubst_function_type( &::cv::SVD::backSubst )
                , ( bp::arg("rhs"), bp::arg("dst") )
                , "\nPerforms singular value back substitution."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-svd-backsubst" );
        
        }
        { //::cv::SVD::operator()
        
            typedef ::cv::SVD & ( ::cv::SVD::*__call___function_type )( ::cv::Mat const &,int ) ;
            
            SVD_exposer.def( 
                "__call__"
                , __call___function_type( &::cv::SVD::operator() )
                , ( bp::arg("m"), bp::arg("flags")=(int)(0) )
                , bp::return_self< >()
                , "\nPerforms SVD of a matrix."
    "\nWrapped function:"
    "\n    operator()"
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-svd-operator" );
        
        }
        { //::cv::SVD::solveZ
        
            typedef void ( *solveZ_function_type )( ::cv::Mat const &,::cv::Mat & );
            
            SVD_exposer.def( 
                "solveZ"
                , solveZ_function_type( &::cv::SVD::solveZ )
                , ( bp::arg("m"), bp::arg("dst") )
                , "\nSolves under-determined singular linear system."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-svd-solvez" );
        
        }
        SVD_exposer.def_readwrite( "u", &cv::SVD::u );
        SVD_exposer.def_readwrite( "vt", &cv::SVD::vt );
        SVD_exposer.def_readwrite( "w", &cv::SVD::w );
        SVD_exposer.staticmethod( "solveZ" );
    }

}
