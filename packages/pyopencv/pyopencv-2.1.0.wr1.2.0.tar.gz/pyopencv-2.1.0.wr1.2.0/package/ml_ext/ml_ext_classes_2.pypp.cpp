// This file has been generated by Py++.

#include "boost/python.hpp"
#include "__call_policies.pypp.hpp"
#include "__convenience.pypp.hpp"
#include "opencv_converters.hpp"
#include "ndarray.hpp"
#include "__ctypes_integration.pypp.hpp"
#include "ml_wrapper.hpp"
#include "ndarray.hpp"
#include "ml_ext_classes_2.pypp.hpp"

namespace bp = boost::python;

static sdcpp::ndarray CvDTreeParams_get_CvDTreeParams_priors( CvDTreeParams const & inst ){
    return sdcpp::new_ndarray1d(inst.max_categories, sdcpp::dtypeof< float const >(), (void *)(inst.priors));
}

struct CvBoost_wrapper : CvBoost, bp::wrapper< CvBoost > {

    CvBoost_wrapper(CvBoost const & arg )
    : CvBoost( arg )
      , bp::wrapper< CvBoost >(){
        // copy constructor
        
    }

    CvBoost_wrapper( )
    : CvBoost( )
      , bp::wrapper< CvBoost >(){
        // null constructor
    
    }

    CvBoost_wrapper(::CvMat const * _train_data, int _tflag, ::CvMat const * _responses, ::CvMat const * _var_idx=0, ::CvMat const * _sample_idx=0, ::CvMat const * _var_type=0, ::CvMat const * _missing_mask=0, ::CvBoostParams params=::CvBoostParams( ) )
    : CvBoost( boost::python::ptr(_train_data), _tflag, boost::python::ptr(_responses), boost::python::ptr(_var_idx), boost::python::ptr(_sample_idx), boost::python::ptr(_var_type), boost::python::ptr(_missing_mask), params )
      , bp::wrapper< CvBoost >(){
        // constructor
    
    }

    CvBoost_wrapper(::cv::Mat const & _train_data, int _tflag, ::cv::Mat const & _responses, ::cv::Mat const & _var_idx=cv::Mat(), ::cv::Mat const & _sample_idx=cv::Mat(), ::cv::Mat const & _var_type=cv::Mat(), ::cv::Mat const & _missing_mask=cv::Mat(), ::CvBoostParams params=::CvBoostParams( ) )
    : CvBoost( boost::ref(_train_data), _tflag, boost::ref(_responses), boost::ref(_var_idx), boost::ref(_sample_idx), boost::ref(_var_type), boost::ref(_missing_mask), params )
      , bp::wrapper< CvBoost >(){
        // constructor
    
    }

    virtual float calc_error( ::CvMLData * _data, int type, ::std::vector< float > * resp=0 ) {
        if( bp::override func_calc_error = this->get_override( "calc_error" ) )
            return func_calc_error( boost::python::ptr(_data), type, boost::python::ptr(resp) );
        else{
            return this->CvBoost::calc_error( boost::python::ptr(_data), type, boost::python::ptr(resp) );
        }
    }
    
    float default_calc_error( ::CvMLData * _data, int type, ::std::vector< float > * resp=0 ) {
        return CvBoost::calc_error( boost::python::ptr(_data), type, boost::python::ptr(resp) );
    }

    virtual void clear(  ) {
        if( bp::override func_clear = this->get_override( "clear" ) )
            func_clear(  );
        else{
            this->CvBoost::clear(  );
        }
    }
    
    void default_clear(  ) {
        CvBoost::clear( );
    }

    virtual ::CvMat const * get_active_vars( bool absolute_idx=true ) {
        if( bp::override func_get_active_vars = this->get_override( "get_active_vars" ) )
            return func_get_active_vars( absolute_idx );
        else{
            return this->CvBoost::get_active_vars( absolute_idx );
        }
    }
    
    ::CvMat const * default_get_active_vars( bool absolute_idx=true ) {
        return CvBoost::get_active_vars( absolute_idx );
    }

    virtual float predict( ::CvMat const * _sample, ::CvMat const * _missing=0, ::CvMat * weak_responses=0, ::CvSlice slice=cv::Range( 0, 0x3fffffff ), bool raw_mode=false, bool return_sum=false ) const  {
        namespace bpl = boost::python;
        if( bpl::override func_predict = this->get_override( "predict" ) ){
            bpl::object py_result = bpl::call<bpl::object>( func_predict.ptr(), _sample, _missing, weak_responses, slice, raw_mode, return_sum );
            return bpl::extract< float >( pyplus_conv::get_out_argument( py_result, 0 ) );
        }
        else{
            return CvBoost::predict( boost::python::ptr(_sample), boost::python::ptr(_missing), boost::python::ptr(weak_responses), slice, raw_mode, return_sum );
        }
    }
    
    static boost::python::tuple default_predict_886066153d61aabdd5ea5947ce710be6( ::CvBoost const & inst, ::cv::Mat & _sample, ::cv::Mat _missing=cv::Mat(), cv::Range const & slice=cv::Range( 0, 0x3fffffff ), bool raw_mode=false, bool return_sum=false ){
        CvMat weak_responses2;
        float result;
        if( dynamic_cast< CvBoost_wrapper const* >( boost::addressof( inst ) ) ){
            result = inst.::CvBoost::predict(get_CvMat_ptr(_sample), get_CvMat_ptr(_missing), &weak_responses2, (CvSlice const &)slice, raw_mode, return_sum);
        }
        else{
            result = inst.predict(get_CvMat_ptr(_sample), get_CvMat_ptr(_missing), &weak_responses2, (CvSlice const &)slice, raw_mode, return_sum);
        }
        return bp::make_tuple( result, weak_responses2 );
    }

    virtual float predict( ::cv::Mat const & _sample, ::cv::Mat const & _missing=cv::Mat(), ::cv::Mat * weak_responses=0, ::CvSlice slice=cv::Range( 0, 0x3fffffff ), bool raw_mode=false, bool return_sum=false ) const  {
        namespace bpl = boost::python;
        if( bpl::override func_predict = this->get_override( "predict" ) ){
            bpl::object py_result = bpl::call<bpl::object>( func_predict.ptr(), _sample, _missing, weak_responses, slice, raw_mode, return_sum );
            return bpl::extract< float >( pyplus_conv::get_out_argument( py_result, 0 ) );
        }
        else{
            return CvBoost::predict( boost::ref(_sample), boost::ref(_missing), boost::python::ptr(weak_responses), slice, raw_mode, return_sum );
        }
    }
    
    static boost::python::tuple default_predict_457b8998388d215e0ce5b2a4e8c7c55f( ::CvBoost const & inst, ::cv::Mat const & _sample, ::cv::Mat const & _missing=cv::Mat(), cv::Range const & slice=cv::Range( 0, 0x3fffffff ), bool raw_mode=false, bool return_sum=false ){
        cv::Mat weak_responses2;
        float result;
        if( dynamic_cast< CvBoost_wrapper const* >( boost::addressof( inst ) ) ){
            result = inst.::CvBoost::predict(_sample, _missing, &weak_responses2, (CvSlice const &)slice, raw_mode, return_sum);
        }
        else{
            result = inst.predict(_sample, _missing, &weak_responses2, (CvSlice const &)slice, raw_mode, return_sum);
        }
        return bp::make_tuple( result, weak_responses2 );
    }

    virtual void prune( ::CvSlice slice ) {
        namespace bpl = boost::python;
        if( bpl::override func_prune = this->get_override( "prune" ) ){
            bpl::object py_result = bpl::call<bpl::object>( func_prune.ptr(), slice );
        }
        else{
            CvBoost::prune( slice );
        }
    }
    
    static void default_prune( ::CvBoost & inst, cv::Range const & slice ){
        if( dynamic_cast< CvBoost_wrapper * >( boost::addressof( inst ) ) ){
            inst.::CvBoost::prune((CvSlice const &)slice);
        }
        else{
            inst.prune((CvSlice const &)slice);
        }
    }

    virtual void read( ::CvFileStorage * storage, ::CvFileNode * node ) {
        namespace bpl = boost::python;
        if( bpl::override func_read = this->get_override( "read" ) ){
            bpl::object py_result = bpl::call<bpl::object>( func_read.ptr(), storage, node );
        }
        else{
            CvBoost::read( boost::python::ptr(storage), boost::python::ptr(node) );
        }
    }
    
    static void default_read( ::CvBoost & inst, ::cv::FileStorage & storage, ::cv::FileNode & node ){
        if( dynamic_cast< CvBoost_wrapper * >( boost::addressof( inst ) ) ){
            inst.::CvBoost::read(storage.fs, *(node));
        }
        else{
            inst.read(storage.fs, *(node));
        }
    }

    virtual bool train( ::CvMat const * _train_data, int _tflag, ::CvMat const * _responses, ::CvMat const * _var_idx=0, ::CvMat const * _sample_idx=0, ::CvMat const * _var_type=0, ::CvMat const * _missing_mask=0, ::CvBoostParams params=::CvBoostParams( ), bool update=false ) {
        namespace bpl = boost::python;
        if( bpl::override func_train = this->get_override( "train" ) ){
            bpl::object py_result = bpl::call<bpl::object>( func_train.ptr(), _train_data, _tflag, _responses, _var_idx, _sample_idx, _var_type, _missing_mask, params, update );
            return bpl::extract< bool >( pyplus_conv::get_out_argument( py_result, 0 ) );
        }
        else{
            return CvBoost::train( boost::python::ptr(_train_data), _tflag, boost::python::ptr(_responses), boost::python::ptr(_var_idx), boost::python::ptr(_sample_idx), boost::python::ptr(_var_type), boost::python::ptr(_missing_mask), params, update );
        }
    }
    
    static boost::python::object default_train_3f66572c988fe182c19720cf6ee35a3e( ::CvBoost & inst, ::cv::Mat & _train_data, int _tflag, ::cv::Mat & _responses, ::cv::Mat _var_idx=cv::Mat(), ::cv::Mat _sample_idx=cv::Mat(), ::cv::Mat _var_type=cv::Mat(), ::cv::Mat _missing_mask=cv::Mat(), ::CvBoostParams params=::CvBoostParams( ), bool update=false ){
        bool result;
        if( dynamic_cast< CvBoost_wrapper * >( boost::addressof( inst ) ) ){
            result = inst.::CvBoost::train(get_CvMat_ptr(_train_data), _tflag, get_CvMat_ptr(_responses), get_CvMat_ptr(_var_idx), get_CvMat_ptr(_sample_idx), get_CvMat_ptr(_var_type), get_CvMat_ptr(_missing_mask), params, update);
        }
        else{
            result = inst.train(get_CvMat_ptr(_train_data), _tflag, get_CvMat_ptr(_responses), get_CvMat_ptr(_var_idx), get_CvMat_ptr(_sample_idx), get_CvMat_ptr(_var_type), get_CvMat_ptr(_missing_mask), params, update);
        }
        return bp::object( result );
    }

    virtual bool train( ::CvMLData * data, ::CvBoostParams params=::CvBoostParams( ), bool update=false ) {
        if( bp::override func_train = this->get_override( "train" ) )
            return func_train( boost::python::ptr(data), params, update );
        else{
            return this->CvBoost::train( boost::python::ptr(data), params, update );
        }
    }
    
    bool default_train( ::CvMLData * data, ::CvBoostParams params=::CvBoostParams( ), bool update=false ) {
        return CvBoost::train( boost::python::ptr(data), params, update );
    }

    virtual bool train( ::cv::Mat const & _train_data, int _tflag, ::cv::Mat const & _responses, ::cv::Mat const & _var_idx=cv::Mat(), ::cv::Mat const & _sample_idx=cv::Mat(), ::cv::Mat const & _var_type=cv::Mat(), ::cv::Mat const & _missing_mask=cv::Mat(), ::CvBoostParams params=::CvBoostParams( ), bool update=false ) {
        if( bp::override func_train = this->get_override( "train" ) )
            return func_train( boost::ref(_train_data), _tflag, boost::ref(_responses), boost::ref(_var_idx), boost::ref(_sample_idx), boost::ref(_var_type), boost::ref(_missing_mask), params, update );
        else{
            return this->CvBoost::train( boost::ref(_train_data), _tflag, boost::ref(_responses), boost::ref(_var_idx), boost::ref(_sample_idx), boost::ref(_var_type), boost::ref(_missing_mask), params, update );
        }
    }
    
    bool default_train( ::cv::Mat const & _train_data, int _tflag, ::cv::Mat const & _responses, ::cv::Mat const & _var_idx=cv::Mat(), ::cv::Mat const & _sample_idx=cv::Mat(), ::cv::Mat const & _var_type=cv::Mat(), ::cv::Mat const & _missing_mask=cv::Mat(), ::CvBoostParams params=::CvBoostParams( ), bool update=false ) {
        return CvBoost::train( boost::ref(_train_data), _tflag, boost::ref(_responses), boost::ref(_var_idx), boost::ref(_sample_idx), boost::ref(_var_type), boost::ref(_missing_mask), params, update );
    }

    virtual void write( ::CvFileStorage * storage, char const * name ) const  {
        namespace bpl = boost::python;
        if( bpl::override func_write = this->get_override( "write" ) ){
            bpl::object py_result = bpl::call<bpl::object>( func_write.ptr(), storage, name );
        }
        else{
            CvBoost::write( boost::python::ptr(storage), name );
        }
    }
    
    static void default_write( ::CvBoost const & inst, ::cv::FileStorage & storage, char const * name ){
        if( dynamic_cast< CvBoost_wrapper const* >( boost::addressof( inst ) ) ){
            inst.::CvBoost::write(storage.fs, name);
        }
        else{
            inst.write(storage.fs, name);
        }
    }

    virtual void load( char const * filename, char const * name=0 ) {
        if( bp::override func_load = this->get_override( "load" ) )
            func_load( filename, name );
        else{
            this->CvStatModel::load( filename, name );
        }
    }
    
    void default_load( char const * filename, char const * name=0 ) {
        CvStatModel::load( filename, name );
    }

    virtual void save( char const * filename, char const * name=0 ) const  {
        if( bp::override func_save = this->get_override( "save" ) )
            func_save( filename, name );
        else{
            this->CvStatModel::save( filename, name );
        }
    }
    
    void default_save( char const * filename, char const * name=0 ) const  {
        CvStatModel::save( filename, name );
    }

};

void register_classes_2(){

    bp::class_< CvDTreeParams >( "CvDTreeParams", bp::init< >() )    
        .add_property( "this", pyplus_conv::make_addressof_inst_getter< CvDTreeParams >() )    
        .def( bp::init< int, int, float, bool, int, int, bool, bool, float const * >(( bp::arg("_max_depth"), bp::arg("_min_sample_count"), bp::arg("_regression_accuracy"), bp::arg("_use_surrogates"), bp::arg("_max_categories"), bp::arg("_cv_folds"), bp::arg("_use_1se_rule"), bp::arg("_truncate_pruned_tree"), bp::arg("_priors") ), "\nWrapped function:"
    "\n    CvDTreeParams"
    "\nArgument '_priors':"\
    "\n    C++ type: float const *"\
    "\n    Python type: vector_float32") )    
        .def_readwrite( "cv_folds", &CvDTreeParams::cv_folds )    
        .def_readwrite( "max_categories", &CvDTreeParams::max_categories )    
        .def_readwrite( "max_depth", &CvDTreeParams::max_depth )    
        .def_readwrite( "min_sample_count", &CvDTreeParams::min_sample_count )    
        .def_readwrite( "regression_accuracy", &CvDTreeParams::regression_accuracy )    
        .def_readwrite( "truncate_pruned_tree", &CvDTreeParams::truncate_pruned_tree )    
        .def_readwrite( "use_1se_rule", &CvDTreeParams::use_1se_rule )    
        .def_readwrite( "use_surrogates", &CvDTreeParams::use_surrogates )    
        .add_property( "priors", &::CvDTreeParams_get_CvDTreeParams_priors );

    bp::class_< CvBoostParams, bp::bases< CvDTreeParams > >( "CvBoostParams", bp::init< >() )    
        .add_property( "this", pyplus_conv::make_addressof_inst_getter< CvBoostParams >() )    
        .def( bp::init< int, int, double, int, bool, float const * >(( bp::arg("boost_type"), bp::arg("weak_count"), bp::arg("weight_trim_rate"), bp::arg("max_depth"), bp::arg("use_surrogates"), bp::arg("priors") ), "\nWrapped function:"
    "\n    CvBoostParams"
    "\nArgument 'priors':"\
    "\n    C++ type: float const *"\
    "\n    Python type: vector_float32") )    
        .def_readwrite( "boost_type", &CvBoostParams::boost_type )    
        .def_readwrite( "split_criteria", &CvBoostParams::split_criteria )    
        .def_readwrite( "weak_count", &CvBoostParams::weak_count )    
        .def_readwrite( "weight_trim_rate", &CvBoostParams::weight_trim_rate );

    { //::CvBoost
        typedef bp::class_< CvBoost_wrapper, bp::bases< CvStatModel > > CvBoost_exposer_t;
        CvBoost_exposer_t CvBoost_exposer = CvBoost_exposer_t( "CvBoost", bp::init< >() );
        bp::scope CvBoost_scope( CvBoost_exposer );
        CvBoost_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< CvBoost >() );
        bp::scope().attr("DISCRETE") = (int)CvBoost::DISCRETE;
        bp::scope().attr("REAL") = (int)CvBoost::REAL;
        bp::scope().attr("LOGIT") = (int)CvBoost::LOGIT;
        bp::scope().attr("GENTLE") = (int)CvBoost::GENTLE;
        bp::scope().attr("DEFAULT") = (int)CvBoost::DEFAULT;
        bp::scope().attr("GINI") = (int)CvBoost::GINI;
        bp::scope().attr("MISCLASS") = (int)CvBoost::MISCLASS;
        bp::scope().attr("SQERR") = (int)CvBoost::SQERR;
        CvBoost_exposer.def( bp::init< CvMat const *, int, CvMat const *, bp::optional< CvMat const *, CvMat const *, CvMat const *, CvMat const *, CvBoostParams > >(( bp::arg("_train_data"), bp::arg("_tflag"), bp::arg("_responses"), bp::arg("_var_idx")=bp::object(), bp::arg("_sample_idx")=bp::object(), bp::arg("_var_type")=bp::object(), bp::arg("_missing_mask")=bp::object(), bp::arg("params")=::CvBoostParams( ) ), "\nWrapped function:"
    "\n    CvBoost"
    "\nArgument '_train_data':"\
    "\n    C++ type: ::CvMat const *"\
    "\n    Python type: Mat"\
    "\nArgument '_responses':"\
    "\n    C++ type: ::CvMat const *"\
    "\n    Python type: Mat"\
    "\nArgument '_var_idx':"\
    "\n    C++ type: ::CvMat const *"\
    "\n    Python type: Mat"\
    "\nArgument '_sample_idx':"\
    "\n    C++ type: ::CvMat const *"\
    "\n    Python type: Mat"\
    "\nArgument '_var_type':"\
    "\n    C++ type: ::CvMat const *"\
    "\n    Python type: Mat"\
    "\nArgument '_missing_mask':"\
    "\n    C++ type: ::CvMat const *"\
    "\n    Python type: Mat") );
        CvBoost_exposer.def( bp::init< cv::Mat const &, int, cv::Mat const &, bp::optional< cv::Mat const &, cv::Mat const &, cv::Mat const &, cv::Mat const &, CvBoostParams > >(( bp::arg("_train_data"), bp::arg("_tflag"), bp::arg("_responses"), bp::arg("_var_idx")=cv::Mat(), bp::arg("_sample_idx")=cv::Mat(), bp::arg("_var_type")=cv::Mat(), bp::arg("_missing_mask")=cv::Mat(), bp::arg("params")=::CvBoostParams( ) )) );
        { //::CvBoost::calc_error
        
            typedef float ( ::CvBoost::*calc_error_function_type )( ::CvMLData *,int,::std::vector< float > * ) ;
            typedef float ( CvBoost_wrapper::*default_calc_error_function_type )( ::CvMLData *,int,::std::vector< float > * ) ;
            
            CvBoost_exposer.def( 
                "calc_error"
                , calc_error_function_type(&::CvBoost::calc_error)
                , default_calc_error_function_type(&CvBoost_wrapper::default_calc_error)
                , ( bp::arg("_data"), bp::arg("type"), bp::arg("resp")=bp::object() ) );
        
        }
        { //::CvBoost::clear
        
            typedef void ( ::CvBoost::*clear_function_type )(  ) ;
            typedef void ( CvBoost_wrapper::*default_clear_function_type )(  ) ;
            
            CvBoost_exposer.def( 
                "clear"
                , clear_function_type(&::CvBoost::clear)
                , default_clear_function_type(&CvBoost_wrapper::default_clear) );
        
        }
        { //::CvBoost::get_active_vars
        
            typedef ::CvMat const * ( ::CvBoost::*get_active_vars_function_type )( bool ) ;
            typedef ::CvMat const * ( CvBoost_wrapper::*default_get_active_vars_function_type )( bool ) ;
            
            CvBoost_exposer.def( 
                "get_active_vars"
                , get_active_vars_function_type(&::CvBoost::get_active_vars)
                , default_get_active_vars_function_type(&CvBoost_wrapper::default_get_active_vars)
                , ( bp::arg("absolute_idx")=(bool)(true) )
                , bp::return_internal_reference< >() );
        
        }
        { //::CvBoost::get_data
        
            typedef ::CvDTreeTrainData const * ( ::CvBoost::*get_data_function_type )(  ) const;
            
            CvBoost_exposer.def( 
                "get_data"
                , get_data_function_type( &::CvBoost::get_data )
                , bp::return_internal_reference< >() );
        
        }
        { //::CvBoost::get_params
        
            typedef ::CvBoostParams const & ( ::CvBoost::*get_params_function_type )(  ) const;
            
            CvBoost_exposer.def( 
                "get_params"
                , get_params_function_type( &::CvBoost::get_params )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::CvBoost::get_subtree_weights
        
            typedef ::CvMat * ( ::CvBoost::*get_subtree_weights_function_type )(  ) ;
            
            CvBoost_exposer.def( 
                "get_subtree_weights"
                , get_subtree_weights_function_type( &::CvBoost::get_subtree_weights )
                , bp::return_internal_reference< >() );
        
        }
        { //::CvBoost::get_weak_predictors
        
            typedef ::CvSeq * ( ::CvBoost::*get_weak_predictors_function_type )(  ) ;
            
            CvBoost_exposer.def( 
                "get_weak_predictors"
                , get_weak_predictors_function_type( &::CvBoost::get_weak_predictors )
                , bp::return_internal_reference< >() );
        
        }
        { //::CvBoost::get_weak_response
        
            typedef ::CvMat * ( ::CvBoost::*get_weak_response_function_type )(  ) ;
            
            CvBoost_exposer.def( 
                "get_weak_response"
                , get_weak_response_function_type( &::CvBoost::get_weak_response )
                , bp::return_internal_reference< >() );
        
        }
        { //::CvBoost::get_weights
        
            typedef ::CvMat * ( ::CvBoost::*get_weights_function_type )(  ) ;
            
            CvBoost_exposer.def( 
                "get_weights"
                , get_weights_function_type( &::CvBoost::get_weights )
                , bp::return_internal_reference< >() );
        
        }
        { //::CvBoost::predict
        
            typedef boost::python::tuple ( *default_predict_function_type )( CvBoost const &,::cv::Mat &,::cv::Mat,cv::Range const &,bool,bool );
            
            CvBoost_exposer.def( 
                "predict"
                , default_predict_function_type( &CvBoost_wrapper::default_predict_886066153d61aabdd5ea5947ce710be6 )
                , ( bp::arg("inst"), bp::arg("_sample"), bp::arg("_missing")=cv::Mat(), bp::arg("slice")=cv::Range( 0, 0x3fffffff ), bp::arg("raw_mode")=(bool)(false), bp::arg("return_sum")=(bool)(false) )
                , "\nArgument '_sample':"\
    "\n    C++ type: ::CvMat const *"\
    "\n    Python type: Mat"\
    "\nArgument '_missing':"\
    "\n    C++ type: ::CvMat const *"\
    "\n    Python type: Mat"\
    "\nArgument 'weak_responses':"\
    "\n    C++ type: ::CvMat *"\
    "\n    Python type: CvMat"\
    "\n    Output argument: omitted from input and returned as output."\
    "\nArgument 'slice':"\
    "\n    C++ type: ::CvSlice"\
    "\n    Python type: Range"\
    "\nReturns:"\
    "\n    ((float32), weak_responses)" );
        
        }
        { //::CvBoost::predict
        
            typedef boost::python::tuple ( *default_predict_function_type )( CvBoost const &,cv::Mat const &,cv::Mat const &,cv::Range const &,bool,bool );
            
            CvBoost_exposer.def( 
                "predict"
                , default_predict_function_type( &CvBoost_wrapper::default_predict_457b8998388d215e0ce5b2a4e8c7c55f )
                , ( bp::arg("inst"), bp::arg("_sample"), bp::arg("_missing")=cv::Mat(), bp::arg("slice")=cv::Range( 0, 0x3fffffff ), bp::arg("raw_mode")=(bool)(false), bp::arg("return_sum")=(bool)(false) )
                , "\nArgument 'weak_responses':"\
    "\n    C++ type: ::cv::Mat *"\
    "\n    Python type: Mat"\
    "\n    Output argument: omitted from input and returned as output."\
    "\nArgument 'slice':"\
    "\n    C++ type: ::CvSlice"\
    "\n    Python type: Range"\
    "\nReturns:"\
    "\n    ((float32), weak_responses)" );
        
        }
        { //::CvBoost::prune
        
            typedef void ( *default_prune_function_type )( CvBoost &,cv::Range const & );
            
            CvBoost_exposer.def( 
                "prune"
                , default_prune_function_type( &CvBoost_wrapper::default_prune )
                , ( bp::arg("inst"), bp::arg("slice") )
                , "\nArgument 'slice':"\
    "\n    C++ type: ::CvSlice"\
    "\n    Python type: Range" );
        
        }
        { //::CvBoost::read
        
            typedef void ( *default_read_function_type )( CvBoost &,::cv::FileStorage &,::cv::FileNode & );
            
            CvBoost_exposer.def( 
                "read"
                , default_read_function_type( &CvBoost_wrapper::default_read )
                , ( bp::arg("inst"), bp::arg("storage"), bp::arg("node") )
                , "\nArgument 'storage':"\
    "\n    C++ type: ::CvFileStorage *"\
    "\n    Python type: FileStorage"\
    "\nArgument 'node':"\
    "\n    C++ type: ::CvFileNode *"\
    "\n    Python type: FileNode" );
        
        }
        { //::CvBoost::train
        
            typedef boost::python::object ( *default_train_function_type )( CvBoost &,::cv::Mat &,int,::cv::Mat &,::cv::Mat,::cv::Mat,::cv::Mat,::cv::Mat,CvBoostParams,bool );
            
            CvBoost_exposer.def( 
                "train"
                , default_train_function_type( &CvBoost_wrapper::default_train_3f66572c988fe182c19720cf6ee35a3e )
                , ( bp::arg("inst"), bp::arg("_train_data"), bp::arg("_tflag"), bp::arg("_responses"), bp::arg("_var_idx")=cv::Mat(), bp::arg("_sample_idx")=cv::Mat(), bp::arg("_var_type")=cv::Mat(), bp::arg("_missing_mask")=cv::Mat(), bp::arg("params")=::CvBoostParams( ), bp::arg("update")=(bool)(false) )
                , "\nArgument '_train_data':"\
    "\n    C++ type: ::CvMat const *"\
    "\n    Python type: Mat"\
    "\nArgument '_responses':"\
    "\n    C++ type: ::CvMat const *"\
    "\n    Python type: Mat"\
    "\nArgument '_var_idx':"\
    "\n    C++ type: ::CvMat const *"\
    "\n    Python type: Mat"\
    "\nArgument '_sample_idx':"\
    "\n    C++ type: ::CvMat const *"\
    "\n    Python type: Mat"\
    "\nArgument '_var_type':"\
    "\n    C++ type: ::CvMat const *"\
    "\n    Python type: Mat"\
    "\nArgument '_missing_mask':"\
    "\n    C++ type: ::CvMat const *"\
    "\n    Python type: Mat" );
        
        }
        { //::CvBoost::train
        
            typedef bool ( ::CvBoost::*train_function_type )( ::CvMLData *,::CvBoostParams,bool ) ;
            typedef bool ( CvBoost_wrapper::*default_train_function_type )( ::CvMLData *,::CvBoostParams,bool ) ;
            
            CvBoost_exposer.def( 
                "train"
                , train_function_type(&::CvBoost::train)
                , default_train_function_type(&CvBoost_wrapper::default_train)
                , ( bp::arg("data"), bp::arg("params")=::CvBoostParams( ), bp::arg("update")=(bool)(false) ) );
        
        }
        { //::CvBoost::train
        
            typedef bool ( ::CvBoost::*train_function_type )( ::cv::Mat const &,int,::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::CvBoostParams,bool ) ;
            typedef bool ( CvBoost_wrapper::*default_train_function_type )( ::cv::Mat const &,int,::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::CvBoostParams,bool ) ;
            
            CvBoost_exposer.def( 
                "train"
                , train_function_type(&::CvBoost::train)
                , default_train_function_type(&CvBoost_wrapper::default_train)
                , ( bp::arg("_train_data"), bp::arg("_tflag"), bp::arg("_responses"), bp::arg("_var_idx")=cv::Mat(), bp::arg("_sample_idx")=cv::Mat(), bp::arg("_var_type")=cv::Mat(), bp::arg("_missing_mask")=cv::Mat(), bp::arg("params")=::CvBoostParams( ), bp::arg("update")=(bool)(false) ) );
        
        }
        { //::CvBoost::write
        
            typedef void ( *default_write_function_type )( CvBoost const &,::cv::FileStorage &,char const * );
            
            CvBoost_exposer.def( 
                "write"
                , default_write_function_type( &CvBoost_wrapper::default_write )
                , ( bp::arg("inst"), bp::arg("storage"), bp::arg("name") )
                , "\nArgument 'storage':"\
    "\n    C++ type: ::CvFileStorage *"\
    "\n    Python type: FileStorage" );
        
        }
        { //::CvStatModel::load
        
            typedef void ( ::CvStatModel::*load_function_type )( char const *,char const * ) ;
            typedef void ( CvBoost_wrapper::*default_load_function_type )( char const *,char const * ) ;
            
            CvBoost_exposer.def( 
                "load"
                , load_function_type(&::CvStatModel::load)
                , default_load_function_type(&CvBoost_wrapper::default_load)
                , ( bp::arg("filename"), bp::arg("name")=bp::object() ) );
        
        }
        { //::CvStatModel::save
        
            typedef void ( ::CvStatModel::*save_function_type )( char const *,char const * ) const;
            typedef void ( CvBoost_wrapper::*default_save_function_type )( char const *,char const * ) const;
            
            CvBoost_exposer.def( 
                "save"
                , save_function_type(&::CvStatModel::save)
                , default_save_function_type(&CvBoost_wrapper::default_save)
                , ( bp::arg("filename"), bp::arg("name")=bp::object() ) );
        
        }
    }

}
