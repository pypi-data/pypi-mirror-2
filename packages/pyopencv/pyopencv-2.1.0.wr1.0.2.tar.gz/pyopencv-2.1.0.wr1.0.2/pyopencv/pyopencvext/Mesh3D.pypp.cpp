// This file has been generated by Py++.

#include "boost/python.hpp"
#include "__call_policies.pypp.hpp"
#include "opencv_converters.hpp"
#include "__ctypes_integration.pypp.hpp"
#include "opencv_headers.hpp"
#include "Mesh3D.pypp.hpp"

namespace bp = boost::python;

static void computeNormals_0372659dbb67ca1f98a084bb3e33c861( ::cv::Mesh3D & inst, cv::Mat const & subset, float normalRadius, int minNeighbors=20 ){
    ::std::vector< int > subset2;
    convert_from_Mat_to_vector_of_T(subset, subset2);
    inst.computeNormals(subset2, normalRadius, minNeighbors);
}

static void writeAsVrml_8e53a52859ed45ddf6fdddd9bce7a16a( ::cv::Mesh3D const & inst, ::cv::String const & file, cv::Mat const & colors=convert_from_vector_of_T_to_Mat(std::vector<cv::Scalar>()) ){
    ::std::vector< cv::Scalar_<double> > colors2;
    convert_from_Mat_to_vector_of_T(colors, colors2);
    inst.writeAsVrml(file, colors2);
}

void register_Mesh3D_class(){

    { //::cv::Mesh3D
        typedef bp::class_< cv::Mesh3D > Mesh3D_exposer_t;
        Mesh3D_exposer_t Mesh3D_exposer = Mesh3D_exposer_t( "Mesh3D", bp::init< >() );
        bp::scope Mesh3D_scope( Mesh3D_exposer );
        Mesh3D_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::Mesh3D >() );
        bp::class_< cv::Mesh3D::EmptyMeshException >( "EmptyMeshException" )    
            .add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::Mesh3D::EmptyMeshException >() );
        Mesh3D_exposer.def( bp::init< std::vector< cv::Point3_<float> > const & >(( bp::arg("vtx") ), "\nWrapped function:"
    "\n    Mesh3D"
    "\nArgument 'vtx':"\
    "\n    C/C++ type: ::std::vector< cv::Point3_<float> > const &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2)).") );
        bp::implicitly_convertible< std::vector< cv::Point3_<float> > const &, cv::Mesh3D >();
        { //::cv::Mesh3D::buildOctree
        
            typedef void ( ::cv::Mesh3D::*buildOctree_function_type )(  ) ;
            
            Mesh3D_exposer.def( 
                "buildOctree"
                , buildOctree_function_type( &::cv::Mesh3D::buildOctree ) );
        
        }
        { //::cv::Mesh3D::clearOctree
        
            typedef void ( ::cv::Mesh3D::*clearOctree_function_type )(  ) ;
            
            Mesh3D_exposer.def( 
                "clearOctree"
                , clearOctree_function_type( &::cv::Mesh3D::clearOctree ) );
        
        }
        { //::cv::Mesh3D::computeNormals
        
            typedef void ( ::cv::Mesh3D::*computeNormals_function_type )( float,int ) ;
            
            Mesh3D_exposer.def( 
                "computeNormals"
                , computeNormals_function_type( &::cv::Mesh3D::computeNormals )
                , ( bp::arg("normalRadius"), bp::arg("minNeighbors")=(int)(20) ) );
        
        }
        { //::cv::Mesh3D::computeNormals
        
            typedef void ( *computeNormals_0372659dbb67ca1f98a084bb3e33c861_function_type )( ::cv::Mesh3D &,cv::Mat const &,float,int );
            
            Mesh3D_exposer.def( 
                "computeNormals_0372659dbb67ca1f98a084bb3e33c861"
                , computeNormals_0372659dbb67ca1f98a084bb3e33c861_function_type( &computeNormals_0372659dbb67ca1f98a084bb3e33c861 )
                , ( bp::arg("inst"), bp::arg("subset"), bp::arg("normalRadius"), bp::arg("minNeighbors")=(int)(20) )
                , "\nWrapped function:"
    "\n    computeNormals"
    "\nArgument 'subset':"\
    "\n    C/C++ type: ::std::vector< int > const &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))." );
        
        }
        { //::cv::Mesh3D::estimateResolution
        
            typedef float ( ::cv::Mesh3D::*estimateResolution_function_type )( float ) ;
            
            Mesh3D_exposer.def( 
                "estimateResolution"
                , estimateResolution_function_type( &::cv::Mesh3D::estimateResolution )
                , ( bp::arg("tryRatio")=1.00000001490116119384765625e-1f ) );
        
        }
        { //::cv::Mesh3D::writeAsVrml
        
            typedef void ( *writeAsVrml_function_type )( ::cv::Mesh3D const &,::cv::String const &,cv::Mat const & );
            
            Mesh3D_exposer.def( 
                "writeAsVrml"
                , writeAsVrml_function_type( &writeAsVrml_8e53a52859ed45ddf6fdddd9bce7a16a )
                , ( bp::arg("inst"), bp::arg("file"), bp::arg("colors")=convert_from_vector_of_T_to_Mat(std::vector<cv::Scalar>()) )
                , "\nArgument 'colors':"\
    "\n    C/C++ type: ::std::vector< cv::Scalar_<double> > const &."\
    "\n    Python type: Mat."\
    "\n    Invoke asMat() to convert a 1D Python sequence into a Mat, e.g. "\
    "\n    asMat([0,1,2]) or asMat((0,1,2))." );
        
        }
        Mesh3D_exposer.def_readonly( "allzero", cv::Mesh3D::allzero );
        Mesh3D_exposer.def_readwrite( "normals", &cv::Mesh3D::normals );
        Mesh3D_exposer.def_readwrite( "octree", &cv::Mesh3D::octree );
        Mesh3D_exposer.def_readwrite( "resolution", &cv::Mesh3D::resolution );
        Mesh3D_exposer.def_readwrite( "vtx", &cv::Mesh3D::vtx );
    }

}
