// This file has been generated by Py++.

#include "boost/python.hpp"
#include "__call_policies.pypp.hpp"
#include "__convenience.pypp.hpp"
#include "__ctypes_integration.pypp.hpp"
#include "opencv_headers.hpp"
#include "CvRTrees.pypp.hpp"

namespace bp = boost::python;

struct CvRTrees_wrapper : CvRTrees, bp::wrapper< CvRTrees > {

    CvRTrees_wrapper(CvRTrees const & arg )
    : CvRTrees( arg )
      , bp::wrapper< CvRTrees >(){
        // copy constructor
        
    }

    CvRTrees_wrapper( )
    : CvRTrees( )
      , bp::wrapper< CvRTrees >(){
        // null constructor
    
    }

    virtual void clear(  ) {
        if( bp::override func_clear = this->get_override( "clear" ) )
            func_clear(  );
        else{
            this->CvRTrees::clear(  );
        }
    }
    
    void default_clear(  ) {
        CvRTrees::clear( );
    }

    virtual float get_train_error(  ) {
        if( bp::override func_get_train_error = this->get_override( "get_train_error" ) )
            return func_get_train_error(  );
        else{
            return this->CvRTrees::get_train_error(  );
        }
    }
    
    float default_get_train_error(  ) {
        return CvRTrees::get_train_error( );
    }

    virtual float predict( ::cv::Mat const & sample, ::cv::Mat const & missing=cv::Mat() ) const  {
        if( bp::override func_predict = this->get_override( "predict" ) )
            return func_predict( boost::ref(sample), boost::ref(missing) );
        else{
            return this->CvRTrees::predict( boost::ref(sample), boost::ref(missing) );
        }
    }
    
    float default_predict( ::cv::Mat const & sample, ::cv::Mat const & missing=cv::Mat() ) const  {
        return CvRTrees::predict( boost::ref(sample), boost::ref(missing) );
    }

    virtual float predict_prob( ::cv::Mat const & sample, ::cv::Mat const & missing=cv::Mat() ) const  {
        if( bp::override func_predict_prob = this->get_override( "predict_prob" ) )
            return func_predict_prob( boost::ref(sample), boost::ref(missing) );
        else{
            return this->CvRTrees::predict_prob( boost::ref(sample), boost::ref(missing) );
        }
    }
    
    float default_predict_prob( ::cv::Mat const & sample, ::cv::Mat const & missing=cv::Mat() ) const  {
        return CvRTrees::predict_prob( boost::ref(sample), boost::ref(missing) );
    }

    virtual void read( ::CvFileStorage * fs, ::CvFileNode * node ) {
        namespace bpl = boost::python;
        if( bpl::override func_read = this->get_override( "read" ) ){
            bpl::object py_result = bpl::call<bpl::object>( func_read.ptr(), fs, node );
        }
        else{
            CvRTrees::read( boost::python::ptr(fs), boost::python::ptr(node) );
        }
    }
    
    static void default_read( ::CvRTrees & inst, ::cv::FileStorage & fs, ::cv::FileNode & node ){
        if( dynamic_cast< CvRTrees_wrapper * >( boost::addressof( inst ) ) ){
            inst.::CvRTrees::read(fs.fs, *(node));
        }
        else{
            inst.read(fs.fs, *(node));
        }
    }

    virtual bool train( ::CvMLData * data, ::CvRTParams params=::CvRTParams( ) ) {
        if( bp::override func_train = this->get_override( "train" ) )
            return func_train( boost::python::ptr(data), params );
        else{
            return this->CvRTrees::train( boost::python::ptr(data), params );
        }
    }
    
    bool default_train( ::CvMLData * data, ::CvRTParams params=::CvRTParams( ) ) {
        return CvRTrees::train( boost::python::ptr(data), params );
    }

    virtual bool train( ::cv::Mat const & _train_data, int _tflag, ::cv::Mat const & _responses, ::cv::Mat const & _var_idx=cv::Mat(), ::cv::Mat const & _sample_idx=cv::Mat(), ::cv::Mat const & _var_type=cv::Mat(), ::cv::Mat const & _missing_mask=cv::Mat(), ::CvRTParams params=::CvRTParams( ) ) {
        if( bp::override func_train = this->get_override( "train" ) )
            return func_train( boost::ref(_train_data), _tflag, boost::ref(_responses), boost::ref(_var_idx), boost::ref(_sample_idx), boost::ref(_var_type), boost::ref(_missing_mask), params );
        else{
            return this->CvRTrees::train( boost::ref(_train_data), _tflag, boost::ref(_responses), boost::ref(_var_idx), boost::ref(_sample_idx), boost::ref(_var_type), boost::ref(_missing_mask), params );
        }
    }
    
    bool default_train( ::cv::Mat const & _train_data, int _tflag, ::cv::Mat const & _responses, ::cv::Mat const & _var_idx=cv::Mat(), ::cv::Mat const & _sample_idx=cv::Mat(), ::cv::Mat const & _var_type=cv::Mat(), ::cv::Mat const & _missing_mask=cv::Mat(), ::CvRTParams params=::CvRTParams( ) ) {
        return CvRTrees::train( boost::ref(_train_data), _tflag, boost::ref(_responses), boost::ref(_var_idx), boost::ref(_sample_idx), boost::ref(_var_type), boost::ref(_missing_mask), params );
    }

    virtual void write( ::CvFileStorage * fs, char const * name ) const  {
        namespace bpl = boost::python;
        if( bpl::override func_write = this->get_override( "write" ) ){
            bpl::object py_result = bpl::call<bpl::object>( func_write.ptr(), fs, name );
        }
        else{
            CvRTrees::write( boost::python::ptr(fs), name );
        }
    }
    
    static void default_write( ::CvRTrees const & inst, ::cv::FileStorage & fs, char const * name ){
        if( dynamic_cast< CvRTrees_wrapper const* >( boost::addressof( inst ) ) ){
            inst.::CvRTrees::write(fs.fs, name);
        }
        else{
            inst.write(fs.fs, name);
        }
    }

    virtual void load( char const * filename, char const * name=0 ) {
        if( bp::override func_load = this->get_override( "load" ) )
            func_load( filename, name );
        else{
            this->CvStatModel::load( filename, name );
        }
    }
    
    void default_load( char const * filename, char const * name=0 ) {
        CvStatModel::load( filename, name );
    }

    virtual void save( char const * filename, char const * name=0 ) const  {
        if( bp::override func_save = this->get_override( "save" ) )
            func_save( filename, name );
        else{
            this->CvStatModel::save( filename, name );
        }
    }
    
    void default_save( char const * filename, char const * name=0 ) const  {
        CvStatModel::save( filename, name );
    }

};

void register_CvRTrees_class(){

    bp::class_< CvRTrees_wrapper, bp::bases< CvStatModel > >( "CvRTrees", bp::init< >() )    
        .add_property( "this", pyplus_conv::make_addressof_inst_getter< CvRTrees >() )    
        .def( 
            "clear"
            , (void ( ::CvRTrees::* )(  ) )(&::CvRTrees::clear)
            , (void ( CvRTrees_wrapper::* )(  ) )(&CvRTrees_wrapper::default_clear) )    
        .def( 
            "get_train_error"
            , (float ( ::CvRTrees::* )(  ) )(&::CvRTrees::get_train_error)
            , (float ( CvRTrees_wrapper::* )(  ) )(&CvRTrees_wrapper::default_get_train_error) )    
        .def( 
            "get_tree"
            , (::CvForestTree * ( ::CvRTrees::* )( int ) const)( &::CvRTrees::get_tree )
            , ( bp::arg("i") )
            , bp::return_internal_reference< >() )    
        .def( 
            "get_tree_count"
            , (int ( ::CvRTrees::* )(  ) const)( &::CvRTrees::get_tree_count ) )    
        .def( 
            "predict"
            , (float ( ::CvRTrees::* )( ::cv::Mat const &,::cv::Mat const & ) const)(&::CvRTrees::predict)
            , (float ( CvRTrees_wrapper::* )( ::cv::Mat const &,::cv::Mat const & ) const)(&CvRTrees_wrapper::default_predict)
            , ( bp::arg("sample"), bp::arg("missing")=cv::Mat() ) )    
        .def( 
            "predict_prob"
            , (float ( ::CvRTrees::* )( ::cv::Mat const &,::cv::Mat const & ) const)(&::CvRTrees::predict_prob)
            , (float ( CvRTrees_wrapper::* )( ::cv::Mat const &,::cv::Mat const & ) const)(&CvRTrees_wrapper::default_predict_prob)
            , ( bp::arg("sample"), bp::arg("missing")=cv::Mat() ) )    
        .def( 
            "read"
            , (void (*)( ::CvRTrees &,::cv::FileStorage &,::cv::FileNode & ))( &CvRTrees_wrapper::default_read )
            , ( bp::arg("inst"), bp::arg("fs"), bp::arg("node") )
            , "\nArgument 'node':"\
    "\n    C/C++ type: ::CvFileNode *."\
    "\n    Python type: FileNode."\
    "\nArgument 'fs':"\
    "\n    C/C++ type: ::CvFileStorage *."\
    "\n    Python type: FileStorage." )    
        .def( 
            "train"
            , (bool ( ::CvRTrees::* )( ::CvMLData *,::CvRTParams ) )(&::CvRTrees::train)
            , (bool ( CvRTrees_wrapper::* )( ::CvMLData *,::CvRTParams ) )(&CvRTrees_wrapper::default_train)
            , ( bp::arg("data"), bp::arg("params")=::CvRTParams( ) ) )    
        .def( 
            "train"
            , (bool ( ::CvRTrees::* )( ::cv::Mat const &,int,::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::CvRTParams ) )(&::CvRTrees::train)
            , (bool ( CvRTrees_wrapper::* )( ::cv::Mat const &,int,::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::CvRTParams ) )(&CvRTrees_wrapper::default_train)
            , ( bp::arg("_train_data"), bp::arg("_tflag"), bp::arg("_responses"), bp::arg("_var_idx")=cv::Mat(), bp::arg("_sample_idx")=cv::Mat(), bp::arg("_var_type")=cv::Mat(), bp::arg("_missing_mask")=cv::Mat(), bp::arg("params")=::CvRTParams( ) ) )    
        .def( 
            "write"
            , (void (*)( ::CvRTrees const &,::cv::FileStorage &,char const * ))( &CvRTrees_wrapper::default_write )
            , ( bp::arg("inst"), bp::arg("fs"), bp::arg("name") )
            , "\nArgument 'fs':"\
    "\n    C/C++ type: ::CvFileStorage *."\
    "\n    Python type: FileStorage." )    
        .def( 
            "load"
            , (void ( ::CvStatModel::* )( char const *,char const * ) )(&::CvStatModel::load)
            , (void ( CvRTrees_wrapper::* )( char const *,char const * ) )(&CvRTrees_wrapper::default_load)
            , ( bp::arg("filename"), bp::arg("name")=bp::object() ) )    
        .def( 
            "save"
            , (void ( ::CvStatModel::* )( char const *,char const * ) const)(&::CvStatModel::save)
            , (void ( CvRTrees_wrapper::* )( char const *,char const * ) const)(&CvRTrees_wrapper::default_save)
            , ( bp::arg("filename"), bp::arg("name")=bp::object() ) );

}
