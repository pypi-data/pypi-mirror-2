// This file has been generated by Py++.

#include "boost/python.hpp"
#include "__call_policies.pypp.hpp"
#include "__convenience.pypp.hpp"
#include "opencv_converters.hpp"
#include "ndarray.hpp"
#include "__ctypes_integration.pypp.hpp"
#include "opencv_headers.hpp"
#include "boost/python/object/life_support.hpp"
#include "arrayobject.h"
#include "ndarray.hpp"
#include "KDTree.pypp.hpp"

namespace bp = boost::python;

static boost::python::tuple findNearest_ea97c6aa84c5363d34b3e91951773ead( ::cv::KDTree const & inst, std::vector<float> const & vec, int K, int Emax ){
    std::vector<int> neighborsIdx2;
    cv::Mat neighbors2;
    std::vector<float> dist2;
    int result = inst.findNearest((float const *)(&vec[0]), K, Emax, &neighborsIdx2, &neighbors2, &dist2);
    return bp::make_tuple( result, neighborsIdx2, neighbors2, dist2 );
}

static boost::python::tuple findOrthoRange_8f5141c7ea87ab587a033ff4e81c09d9( ::cv::KDTree const & inst, std::vector<float> const & minBounds, std::vector<float> const & maxBounds ){
    std::vector<int> neighborsIdx2;
    cv::Mat neighbors2;
    inst.findOrthoRange((float const *)(&minBounds[0]), (float const *)(&maxBounds[0]), &neighborsIdx2, &neighbors2);
    return bp::make_tuple( neighborsIdx2, neighbors2 );
}

static boost::python::object getPoints_cb19ade779f56a2e3d487759ce0fd7ea( ::cv::KDTree const & inst, std::vector<int> const & idx ){
    cv::Mat pts2;
    inst.getPoints((int const *)(&idx[0]), (int)(idx.size()), pts2);
    return bp::object( pts2 );
}

static boost::python::object getPoints_dfa4c20a74f0aaa501985d64a11da238( ::cv::KDTree const & inst, ::cv::Mat const & idxs ){
    cv::Mat pts2;
    inst.getPoints(idxs, pts2);
    return bp::object( pts2 );
}

inline int cv::KDTree::dims() const { return points.cols; }

bp::object KDTree_getPoint(PyObject *pyinst, int i) {
    cv::KDTree const &inst = bp::extract<cv::KDTree const &>(pyinst);
    int len = inst.points.cols; // number of dimensions
    bp::object result = sdcpp::new_ndarray(1, &len, NPY_FLOAT,
        (void *)inst.getPoint(i), NPY_C_CONTIGUOUS).get_obj();
    bp::objects::make_nurse_and_patient(result.ptr(), pyinst);
    return result;
}

void register_KDTree_class(){

    { //::cv::KDTree
        typedef bp::class_< cv::KDTree > KDTree_exposer_t;
        KDTree_exposer_t KDTree_exposer = KDTree_exposer_t( "KDTree", bp::init< >() );
        bp::scope KDTree_scope( KDTree_exposer );
        KDTree_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::KDTree >() );
        bp::class_< cv::KDTree::Node >( "Node", bp::init< >() )    
            .add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::KDTree::Node >() )    
            .def( bp::init< int, int, int, float >(( bp::arg("_idx"), bp::arg("_left"), bp::arg("_right"), bp::arg("_boundary") )) )    
            .def_readwrite( "boundary", &cv::KDTree::Node::boundary )    
            .def_readwrite( "idx", &cv::KDTree::Node::idx )    
            .def_readwrite( "left", &cv::KDTree::Node::left )    
            .def_readwrite( "right", &cv::KDTree::Node::right );
        KDTree_exposer.def( bp::init< cv::Mat const &, bp::optional< bool > >(( bp::arg("_points"), bp::arg("copyAndReorderPoints")=(bool)(false) )) );
        bp::implicitly_convertible< cv::Mat const &, cv::KDTree >();
        { //::cv::KDTree::build
        
            typedef void ( ::cv::KDTree::*build_function_type )( ::cv::Mat const &,bool ) ;
            
            KDTree_exposer.def( 
                "build"
                , build_function_type( &::cv::KDTree::build )
                , ( bp::arg("_points"), bp::arg("copyAndReorderPoints")=(bool)(false) ) );
        
        }
        { //::cv::KDTree::dims
        
            typedef int ( ::cv::KDTree::*dims_function_type )(  ) const;
            
            KDTree_exposer.def( 
                "dims"
                , dims_function_type( &::cv::KDTree::dims ) );
        
        }
        { //::cv::KDTree::findNearest
        
            typedef boost::python::tuple ( *findNearest_function_type )( cv::KDTree const &,std::vector<float> const &,int,int );
            
            KDTree_exposer.def( 
                "findNearest"
                , findNearest_function_type( &findNearest_ea97c6aa84c5363d34b3e91951773ead )
                , ( bp::arg("inst"), bp::arg("vec"), bp::arg("K"), bp::arg("Emax") )
                , "\nArgument 'vec':"\
    "\n    C++ type: float const *."\
    "\n    Python type: vector_float32."\
    "\nArgument 'neighborsIdx':"\
    "\n    C++ type: ::std::vector< int > *."\
    "\n    Python type: vector_int."\
    "\n    Output argument: omitted from input and returned as output."\
    "\nArgument 'neighbors':"\
    "\n    C++ type: ::cv::Mat *."\
    "\n    Python type: Mat."\
    "\n    Output argument: omitted from input and returned as output."\
    "\nArgument 'dist':"\
    "\n    C++ type: ::std::vector< float > *."\
    "\n    Python type: vector_float32."\
    "\n    Output argument: omitted from input and returned as output."\
    "\nReturns:"\
    "\n    ((int), neighborsIdx, neighbors, dist)" );
        
        }
        { //::cv::KDTree::findOrthoRange
        
            typedef boost::python::tuple ( *findOrthoRange_function_type )( cv::KDTree const &,std::vector<float> const &,std::vector<float> const & );
            
            KDTree_exposer.def( 
                "findOrthoRange"
                , findOrthoRange_function_type( &findOrthoRange_8f5141c7ea87ab587a033ff4e81c09d9 )
                , ( bp::arg("inst"), bp::arg("minBounds"), bp::arg("maxBounds") )
                , "\nArgument 'minBounds':"\
    "\n    C++ type: float const *."\
    "\n    Python type: vector_float32."\
    "\nArgument 'maxBounds':"\
    "\n    C++ type: float const *."\
    "\n    Python type: vector_float32."\
    "\nArgument 'neighborsIdx':"\
    "\n    C++ type: ::std::vector< int > *."\
    "\n    Python type: vector_int."\
    "\n    Output argument: omitted from input and returned as output."\
    "\nArgument 'neighbors':"\
    "\n    C++ type: ::cv::Mat *."\
    "\n    Python type: Mat."\
    "\n    Output argument: omitted from input and returned as output."\
    "\nReturns:"\
    "\n    (neighborsIdx, neighbors)" );
        
        }
        { //::cv::KDTree::getPoints
        
            typedef boost::python::object ( *getPoints_function_type )( cv::KDTree const &,std::vector<int> const & );
            
            KDTree_exposer.def( 
                "getPoints"
                , getPoints_function_type( &getPoints_cb19ade779f56a2e3d487759ce0fd7ea )
                , ( bp::arg("inst"), bp::arg("idx") )
                , "\nArgument 'idx':"\
    "\n    C++ type: int const *."\
    "\n    Python type: vector_int."\
    "\nArgument 'nidx':"\
    "\n    Dependent argument: omitted from input. Its value is derived from "\
    "\n    argument 'idx'."\
    "\nArgument 'pts':"\
    "\n    C++ type: ::cv::Mat &."\
    "\n    Python type: Mat."\
    "\n    Output argument: omitted from input and returned as output."\
    "\nReturns:"\
    "\n    pts" );
        
        }
        { //::cv::KDTree::getPoints
        
            typedef boost::python::object ( *getPoints_function_type )( cv::KDTree const &,cv::Mat const & );
            
            KDTree_exposer.def( 
                "getPoints"
                , getPoints_function_type( &getPoints_dfa4c20a74f0aaa501985d64a11da238 )
                , ( bp::arg("inst"), bp::arg("idxs") )
                , "\nArgument 'pts':"\
    "\n    C++ type: ::cv::Mat &."\
    "\n    Python type: Mat."\
    "\n    Output argument: omitted from input and returned as output."\
    "\nReturns:"\
    "\n    pts" );
        
        }
        KDTree_exposer.def_readwrite( "maxDepth", &cv::KDTree::maxDepth );
        KDTree_exposer.def_readwrite( "nodes", &cv::KDTree::nodes );
        KDTree_exposer.def_readwrite( "normType", &cv::KDTree::normType );
        KDTree_exposer.def_readwrite( "points", &cv::KDTree::points );
        KDTree_exposer.def( "getPoint", &KDTree_getPoint, (bp::arg("ptidx")) );
    }

}
