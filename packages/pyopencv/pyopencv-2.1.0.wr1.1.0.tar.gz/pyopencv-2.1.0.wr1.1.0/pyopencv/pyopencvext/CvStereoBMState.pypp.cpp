// This file has been generated by Py++.

#include "boost/python.hpp"
#include "__ctypes_integration.pypp.hpp"
#include "opencv_headers.hpp"
#include "CvStereoBMState.pypp.hpp"

namespace bp = boost::python;

struct CvStereoBMState_wrapper : CvStereoBMState, bp::wrapper< CvStereoBMState > {

    CvStereoBMState_wrapper(CvStereoBMState const & arg )
    : CvStereoBMState( arg )
      , bp::wrapper< CvStereoBMState >(){
        // copy constructor
        
    }

    CvStereoBMState_wrapper()
    : CvStereoBMState()
      , bp::wrapper< CvStereoBMState >(){
        // null constructor
        
    }

    cv::Mat preFilteredImg0_as_Mat;
    CvMat preFilteredImg0_as_CvMat;
    void update_preFilteredImg0()
    {
        if(preFilteredImg0_as_Mat.empty()) preFilteredImg0 = 0; // NULL pointer
        else
        {
            preFilteredImg0_as_CvMat = preFilteredImg0_as_Mat; // to ensure preFilteredImg0 points to a valid CvMat
            preFilteredImg0 = &preFilteredImg0_as_CvMat;
        }
    }
    void set_preFilteredImg0(cv::Mat const &new_preFilteredImg0)
    {
        preFilteredImg0_as_Mat = new_preFilteredImg0; // to keep a reference to preFilteredImg0
        update_preFilteredImg0();
    }
    cv::Mat & get_preFilteredImg0()
    {
        update_preFilteredImg0();
        return preFilteredImg0_as_Mat;
    }

    cv::Mat preFilteredImg1_as_Mat;
    CvMat preFilteredImg1_as_CvMat;
    void update_preFilteredImg1()
    {
        if(preFilteredImg1_as_Mat.empty()) preFilteredImg1 = 0; // NULL pointer
        else
        {
            preFilteredImg1_as_CvMat = preFilteredImg1_as_Mat; // to ensure preFilteredImg1 points to a valid CvMat
            preFilteredImg1 = &preFilteredImg1_as_CvMat;
        }
    }
    void set_preFilteredImg1(cv::Mat const &new_preFilteredImg1)
    {
        preFilteredImg1_as_Mat = new_preFilteredImg1; // to keep a reference to preFilteredImg1
        update_preFilteredImg1();
    }
    cv::Mat & get_preFilteredImg1()
    {
        update_preFilteredImg1();
        return preFilteredImg1_as_Mat;
    }

    cv::Mat slidingSumBuf_as_Mat;
    CvMat slidingSumBuf_as_CvMat;
    void update_slidingSumBuf()
    {
        if(slidingSumBuf_as_Mat.empty()) slidingSumBuf = 0; // NULL pointer
        else
        {
            slidingSumBuf_as_CvMat = slidingSumBuf_as_Mat; // to ensure slidingSumBuf points to a valid CvMat
            slidingSumBuf = &slidingSumBuf_as_CvMat;
        }
    }
    void set_slidingSumBuf(cv::Mat const &new_slidingSumBuf)
    {
        slidingSumBuf_as_Mat = new_slidingSumBuf; // to keep a reference to slidingSumBuf
        update_slidingSumBuf();
    }
    cv::Mat & get_slidingSumBuf()
    {
        update_slidingSumBuf();
        return slidingSumBuf_as_Mat;
    }

    cv::Mat cost_as_Mat;
    CvMat cost_as_CvMat;
    void update_cost()
    {
        if(cost_as_Mat.empty()) cost = 0; // NULL pointer
        else
        {
            cost_as_CvMat = cost_as_Mat; // to ensure cost points to a valid CvMat
            cost = &cost_as_CvMat;
        }
    }
    void set_cost(cv::Mat const &new_cost)
    {
        cost_as_Mat = new_cost; // to keep a reference to cost
        update_cost();
    }
    cv::Mat & get_cost()
    {
        update_cost();
        return cost_as_Mat;
    }

    cv::Mat disp_as_Mat;
    CvMat disp_as_CvMat;
    void update_disp()
    {
        if(disp_as_Mat.empty()) disp = 0; // NULL pointer
        else
        {
            disp_as_CvMat = disp_as_Mat; // to ensure disp points to a valid CvMat
            disp = &disp_as_CvMat;
        }
    }
    void set_disp(cv::Mat const &new_disp)
    {
        disp_as_Mat = new_disp; // to keep a reference to disp
        update_disp();
    }
    cv::Mat & get_disp()
    {
        update_disp();
        return disp_as_Mat;
    }

};

static cv::Rect_<int> *get_roi1(CvStereoBMState const &inst) { return (cv::Rect_<int> *)(&inst.roi1); }

static cv::Rect_<int> *get_roi2(CvStereoBMState const &inst) { return (cv::Rect_<int> *)(&inst.roi2); }

void register_CvStereoBMState_class(){

    bp::class_< CvStereoBMState_wrapper >( "CvStereoBMState" )    
        .add_property( "this", pyplus_conv::make_addressof_inst_getter< CvStereoBMState >() )    
        .def_readwrite( "SADWindowSize", &CvStereoBMState::SADWindowSize )    
        .def_readwrite( "disp12MaxDiff", &CvStereoBMState::disp12MaxDiff )    
        .def_readwrite( "minDisparity", &CvStereoBMState::minDisparity )    
        .def_readwrite( "numberOfDisparities", &CvStereoBMState::numberOfDisparities )    
        .def_readwrite( "preFilterCap", &CvStereoBMState::preFilterCap )    
        .def_readwrite( "preFilterSize", &CvStereoBMState::preFilterSize )    
        .def_readwrite( "preFilterType", &CvStereoBMState::preFilterType )    
        .def_readwrite( "speckleRange", &CvStereoBMState::speckleRange )    
        .def_readwrite( "speckleWindowSize", &CvStereoBMState::speckleWindowSize )    
        .def_readwrite( "textureThreshold", &CvStereoBMState::textureThreshold )    
        .def_readwrite( "trySmallerWindows", &CvStereoBMState::trySmallerWindows )    
        .def_readwrite( "uniquenessRatio", &CvStereoBMState::uniquenessRatio )    
        .add_property( "roi1", bp::make_function(&::get_roi1, bp::return_internal_reference<>()) )    
        .add_property( "roi2", bp::make_function(&::get_roi2, bp::return_internal_reference<>()) )    
        .add_property( "preFilteredImg0", bp::make_function(&::CvStereoBMState_wrapper::get_preFilteredImg0, bp::return_internal_reference<>()),
            &::CvStereoBMState_wrapper::set_preFilteredImg0)    
        .def( "validate_preFilteredImg0", &::CvStereoBMState_wrapper::update_preFilteredImg0, "Updates the internal C pointer that represents 'preFilteredImg0'. The function should be called every time the header of 'preFilteredImg0' is modified by the user." )    
        .add_property( "preFilteredImg1", bp::make_function(&::CvStereoBMState_wrapper::get_preFilteredImg1, bp::return_internal_reference<>()),
            &::CvStereoBMState_wrapper::set_preFilteredImg1)    
        .def( "validate_preFilteredImg1", &::CvStereoBMState_wrapper::update_preFilteredImg1, "Updates the internal C pointer that represents 'preFilteredImg1'. The function should be called every time the header of 'preFilteredImg1' is modified by the user." )    
        .add_property( "slidingSumBuf", bp::make_function(&::CvStereoBMState_wrapper::get_slidingSumBuf, bp::return_internal_reference<>()),
            &::CvStereoBMState_wrapper::set_slidingSumBuf)    
        .def( "validate_slidingSumBuf", &::CvStereoBMState_wrapper::update_slidingSumBuf, "Updates the internal C pointer that represents 'slidingSumBuf'. The function should be called every time the header of 'slidingSumBuf' is modified by the user." )    
        .add_property( "cost", bp::make_function(&::CvStereoBMState_wrapper::get_cost, bp::return_internal_reference<>()),
            &::CvStereoBMState_wrapper::set_cost)    
        .def( "validate_cost", &::CvStereoBMState_wrapper::update_cost, "Updates the internal C pointer that represents 'cost'. The function should be called every time the header of 'cost' is modified by the user." )    
        .add_property( "disp", bp::make_function(&::CvStereoBMState_wrapper::get_disp, bp::return_internal_reference<>()),
            &::CvStereoBMState_wrapper::set_disp)    
        .def( "validate_disp", &::CvStereoBMState_wrapper::update_disp, "Updates the internal C pointer that represents 'disp'. The function should be called every time the header of 'disp' is modified by the user." );

}
