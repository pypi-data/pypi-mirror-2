// This file has been generated by Py++.

#include "boost/python.hpp"
#include "opencv_headers.hpp"
#include "pyopencvext_free_functions_ca.pypp.hpp"

namespace bp = boost::python;

void register_free_functions_ca(){

    { //::cv::CamShift
    
        typedef ::cv::RotatedRect ( *CamShift_function_type )( ::cv::Mat const &,::cv::Rect &,::cv::TermCriteria );
        
        bp::def( 
            "CamShift"
            , CamShift_function_type( &::cv::CamShift )
            , ( bp::arg("probImage"), bp::arg("window"), bp::arg("criteria") ) );
    
    }

    { //::cv::Canny
    
        typedef void ( *Canny_function_type )( ::cv::Mat const &,::cv::Mat &,double,double,int,bool );
        
        bp::def( 
            "Canny"
            , Canny_function_type( &::cv::Canny )
            , ( bp::arg("image"), bp::arg("edges"), bp::arg("threshold1"), bp::arg("threshold2"), bp::arg("apertureSize")=(int)(3), bp::arg("L2gradient")=(bool)(false) ) );
    
    }

    { //::cv::calcCovarMatrix
    
        typedef void ( *calcCovarMatrix_function_type )( ::cv::Mat const &,::cv::Mat &,::cv::Mat &,int,int );
        
        bp::def( 
            "calcCovarMatrix"
            , calcCovarMatrix_function_type( &::cv::calcCovarMatrix )
            , ( bp::arg("samples"), bp::arg("covar"), bp::arg("mean"), bp::arg("flags"), bp::arg("ctype")=(int)(6) )
            , "\nCalculates covariation matrix of a set of vectors."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#calccovarmatrix" );
    
    }

    { //::cv::calcGlobalOrientation
    
        typedef double ( *calcGlobalOrientation_function_type )( ::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,double,double );
        
        bp::def( 
            "calcGlobalOrientation"
            , calcGlobalOrientation_function_type( &::cv::calcGlobalOrientation )
            , ( bp::arg("orientation"), bp::arg("mask"), bp::arg("mhi"), bp::arg("timestamp"), bp::arg("duration") ) );
    
    }

    { //::cv::calcMotionGradient
    
        typedef void ( *calcMotionGradient_function_type )( ::cv::Mat const &,::cv::Mat &,::cv::Mat &,double,double,int );
        
        bp::def( 
            "calcMotionGradient"
            , calcMotionGradient_function_type( &::cv::calcMotionGradient )
            , ( bp::arg("mhi"), bp::arg("mask"), bp::arg("orientation"), bp::arg("delta1"), bp::arg("delta2"), bp::arg("apertureSize")=(int)(3) ) );
    
    }

    { //::cv::calcOpticalFlowFarneback
    
        typedef void ( *calcOpticalFlowFarneback_function_type )( ::cv::Mat const &,::cv::Mat const &,::cv::Mat &,double,int,int,int,int,double,int );
        
        bp::def( 
            "calcOpticalFlowFarneback"
            , calcOpticalFlowFarneback_function_type( &::cv::calcOpticalFlowFarneback )
            , ( bp::arg("prev0"), bp::arg("next0"), bp::arg("flow0"), bp::arg("pyr_scale"), bp::arg("levels"), bp::arg("winsize"), bp::arg("iterations"), bp::arg("poly_n"), bp::arg("poly_sigma"), bp::arg("flags") ) );
    
    }

    { //::cv::calcOpticalFlowPyrLK
    
        typedef void ( *calcOpticalFlowPyrLK_function_type )( ::cv::Mat const &,::cv::Mat const &,::std::vector< cv::Point_<float> > const &,::std::vector< cv::Point_<float> > &,::std::vector< unsigned char > &,::std::vector< float > &,::cv::Size,int,::cv::TermCriteria,double,int );
        
        bp::def( 
            "calcOpticalFlowPyrLK"
            , calcOpticalFlowPyrLK_function_type( &::cv::calcOpticalFlowPyrLK )
            , ( bp::arg("prevImg"), bp::arg("nextImg"), bp::arg("prevPts"), bp::arg("nextPts"), bp::arg("status"), bp::arg("err"), bp::arg("winSize")=cv::Size_<int>(15, 15), bp::arg("maxLevel")=(int)(3), bp::arg("criteria")=cv::TermCriteria(3, 30, 1.0000000000000000208166817117216851329430937767e-2), bp::arg("derivLambda")=5.0e-1, bp::arg("flags")=(int)(0) ) );
    
    }

    { //::cv::calibrationMatrixValues
    
        typedef void ( *calibrationMatrixValues_function_type )( ::cv::Mat const &,::cv::Size,double,double,double &,double &,double &,::cv::Point2d &,double & );
        
        bp::def( 
            "calibrationMatrixValues"
            , calibrationMatrixValues_function_type( &::cv::calibrationMatrixValues )
            , ( bp::arg("cameraMatrix"), bp::arg("imageSize"), bp::arg("apertureWidth"), bp::arg("apertureHeight"), bp::arg("fovx"), bp::arg("fovy"), bp::arg("focalLength"), bp::arg("principalPoint"), bp::arg("aspectRatio") ) );
    
    }

    { //::cv::cartToPolar
    
        typedef void ( *cartToPolar_function_type )( ::cv::Mat const &,::cv::Mat const &,::cv::Mat &,::cv::Mat &,bool );
        
        bp::def( 
            "cartToPolar"
            , cartToPolar_function_type( &::cv::cartToPolar )
            , ( bp::arg("x"), bp::arg("y"), bp::arg("magnitude"), bp::arg("angle"), bp::arg("angleInDegrees")=(bool)(false) )
            , "\nCalculates the magnitude and angle of 2d vectors."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#carttopolar" );
    
    }

    { //::cvCalcSubdivVoronoi2D
    
        typedef void ( *calcSubdivVoronoi2D_function_type )( ::CvSubdiv2D * );
        
        bp::def( 
            "calcSubdivVoronoi2D"
            , calcSubdivVoronoi2D_function_type( &::cvCalcSubdivVoronoi2D )
            , ( bp::arg("subdiv") )
            , "\nWrapped function:"
    "\n    cvCalcSubdivVoronoi2D" );
    
    }

}
