// This file has been generated by Py++.

#include "boost/python.hpp"
#include "__ctypes_integration.pypp.hpp"
#include "opencv_headers.hpp"
#include "Mesh3D.pypp.hpp"

namespace bp = boost::python;

void register_Mesh3D_class(){

    { //::cv::Mesh3D
        typedef bp::class_< cv::Mesh3D > Mesh3D_exposer_t;
        Mesh3D_exposer_t Mesh3D_exposer = Mesh3D_exposer_t( "Mesh3D", bp::init< >() );
        bp::scope Mesh3D_scope( Mesh3D_exposer );
        Mesh3D_exposer.add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::Mesh3D >() );
        bp::class_< cv::Mesh3D::EmptyMeshException >( "EmptyMeshException" )    
            .add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::Mesh3D::EmptyMeshException >() );
        Mesh3D_exposer.def( bp::init< std::vector< cv::Point3_<float> > const & >(( bp::arg("vtx") )) );
        bp::implicitly_convertible< std::vector< cv::Point3_<float> > const &, cv::Mesh3D >();
        { //::cv::Mesh3D::buildOctree
        
            typedef void ( ::cv::Mesh3D::*buildOctree_function_type )(  ) ;
            
            Mesh3D_exposer.def( 
                "buildOctree"
                , buildOctree_function_type( &::cv::Mesh3D::buildOctree ) );
        
        }
        { //::cv::Mesh3D::clearOctree
        
            typedef void ( ::cv::Mesh3D::*clearOctree_function_type )(  ) ;
            
            Mesh3D_exposer.def( 
                "clearOctree"
                , clearOctree_function_type( &::cv::Mesh3D::clearOctree ) );
        
        }
        { //::cv::Mesh3D::computeNormals
        
            typedef void ( ::cv::Mesh3D::*computeNormals_function_type )( float,int ) ;
            
            Mesh3D_exposer.def( 
                "computeNormals"
                , computeNormals_function_type( &::cv::Mesh3D::computeNormals )
                , ( bp::arg("normalRadius"), bp::arg("minNeighbors")=(int)(20) ) );
        
        }
        { //::cv::Mesh3D::computeNormals
        
            typedef void ( ::cv::Mesh3D::*computeNormals_function_type )( ::std::vector< int > const &,float,int ) ;
            
            Mesh3D_exposer.def( 
                "computeNormals"
                , computeNormals_function_type( &::cv::Mesh3D::computeNormals )
                , ( bp::arg("subset"), bp::arg("normalRadius"), bp::arg("minNeighbors")=(int)(20) ) );
        
        }
        { //::cv::Mesh3D::estimateResolution
        
            typedef float ( ::cv::Mesh3D::*estimateResolution_function_type )( float ) ;
            
            Mesh3D_exposer.def( 
                "estimateResolution"
                , estimateResolution_function_type( &::cv::Mesh3D::estimateResolution )
                , ( bp::arg("tryRatio")=1.00000001490116119384765625e-1f ) );
        
        }
        { //::cv::Mesh3D::writeAsVrml
        
            typedef void ( ::cv::Mesh3D::*writeAsVrml_function_type )( ::cv::String const &,::std::vector< cv::Scalar_<double> > const & ) const;
            
            Mesh3D_exposer.def( 
                "writeAsVrml"
                , writeAsVrml_function_type( &::cv::Mesh3D::writeAsVrml )
                , ( bp::arg("file"), bp::arg("colors")=std::vector<cv::Scalar>() ) );
        
        }
        Mesh3D_exposer.def_readonly( "allzero", cv::Mesh3D::allzero );
        Mesh3D_exposer.def_readwrite( "normals", &cv::Mesh3D::normals );
        Mesh3D_exposer.def_readwrite( "octree", &cv::Mesh3D::octree );
        Mesh3D_exposer.def_readwrite( "resolution", &cv::Mesh3D::resolution );
        Mesh3D_exposer.def_readwrite( "vtx", &cv::Mesh3D::vtx );
    }

}
