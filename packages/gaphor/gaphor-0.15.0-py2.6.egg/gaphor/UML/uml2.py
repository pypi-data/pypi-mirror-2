# This file is generated by build_uml.py. DO NOT EDIT!

from properties import association, attribute, enumeration, derived, derivedunion, redefine
# 16: override Element
from element import Element
class Relationship(Element): pass
class DirectedRelationship(Relationship): pass
class Include(DirectedRelationship): pass
class NamedElement(Element): pass
class PackageableElement(NamedElement): pass
class Type(PackageableElement): pass
class RedefinableElement(NamedElement): pass
class ActivityNode(RedefinableElement): pass
class TypedElement(NamedElement): pass
class ObjectNode(ActivityNode, TypedElement): pass
class Pin(ObjectNode): pass
class InputPin(Pin): pass
class ValuePin(InputPin): pass
class ValueSpecification(TypedElement): pass
class LiteralSpecification(ValueSpecification): pass
class LiteralInteger(LiteralSpecification): pass
class ExecutableNode(ActivityNode): pass
class MultiplicityElement(Element): pass
class Feature(RedefinableElement): pass
class StructuralFeature(TypedElement, MultiplicityElement, Feature): pass
class DeploymentTarget(NamedElement): pass
class DeployedArtifact(NamedElement): pass
class Namespace(NamedElement): pass
class Classifier(Namespace, RedefinableElement, Type): pass
class Artifact(DeployedArtifact, Classifier): pass
class ConnectableElement(TypedElement): pass
class BehavioralFeature(Namespace, Feature): pass
class StructuredClassifier(Classifier): pass
class EncapsulatedClassifer(StructuredClassifier): pass
class BehavioredClassifier(Classifier): pass
class Class(EncapsulatedClassifer, BehavioredClassifier): pass
class Node(Class, DeploymentTarget): pass
class Device(Node): pass
class InstanceSpecification(PackageableElement): pass
class EnumerationLiteral(InstanceSpecification): pass
class InteractionFragment(NamedElement): pass
class Behavior(Class): pass
class Interaction(InteractionFragment, Behavior): pass
class Expression(ValueSpecification): pass
class ConnectorEnd(MultiplicityElement): pass
class Package(PackageableElement, Namespace): pass
class ExtensionPoint(RedefinableElement): pass
class PackageMerge(DirectedRelationship): pass
class Vertex(NamedElement): pass
class State(Vertex, RedefinableElement, Namespace): pass
class FinalState(State): pass
class PackageImport(DirectedRelationship): pass
class ProfileApplication(PackageImport): pass
class Action(ExecutableNode): pass
class GeneralOrdering(NamedElement): pass
class Association(Classifier, Relationship): pass
class CommunicationPath(Association): pass
class Extension(Association): pass
class Dependency(DirectedRelationship, PackageableElement): pass
class Deployment(Dependency): pass
class ControlNode(ActivityNode): pass
class JoinNode(ControlNode): pass
class Pseudostate(Vertex): pass
class Comment(Element): pass
class Slot(Element): pass
class ActivityGroup(Element): pass
class ActivityPartition(ActivityGroup, NamedElement): pass
class Actor(Classifier): pass
class Property(StructuralFeature, ConnectableElement): pass
class Port(Property): pass
class Region(Namespace, RedefinableElement): pass
class Generalization(DirectedRelationship): pass
class Extend(DirectedRelationship): pass
class LiteralBoolean(LiteralSpecification): pass
class Abstraction(Dependency): pass
class Manifestation(Abstraction): pass
class Realization(Abstraction): pass
class Implementation(Realization): pass
class MergeNode(ControlNode): pass
class Transition(RedefinableElement, NamedElement): pass
class Permission(Dependency): pass
class ActivityEdge(RedefinableElement): pass
class ElementImport(DirectedRelationship): pass
class InitialNode(ControlNode): pass
class Parameter(TypedElement, MultiplicityElement): pass
class Presentation(Element): pass
class Component(Class): pass
class Constraint(PackageableElement): pass
class FinalNode(ControlNode): pass
class LiteralUnlimitedNatural(LiteralSpecification): pass
class UseCase(BehavioredClassifier): pass
class Interface(Classifier, ConnectableElement): pass
class Operation(BehavioralFeature): pass
class ControlFlow(ActivityEdge): pass
class Message(NamedElement): pass
class FlowFinalNode(FinalNode): pass
class Activity(Behavior): pass
class Substitution(Realization): pass
class Stereotype(Class): pass
# 19: override Diagram
from diagram import Diagram
class StateMachine(Behavior): pass
class Connector(Feature): pass
class ConnectionPointReference(Vertex): pass
class OccurrenceSpecification(InteractionFragment): pass
class ExecutionOccurence(InteractionFragment): pass
class DataType(Classifier): pass
class ObjectFlow(ActivityEdge): pass
class ActivityParameterNode(ObjectNode): pass
class OpaqueExpression(ValueSpecification): pass
class PrimitiveType(DataType): pass
class InstanceValue(ValueSpecification): pass
class ActivityFinalNode(FinalNode): pass
class Lifeline(NamedElement): pass
class ExecutionEnvironment(Node): pass
class DecisionNode(ControlNode): pass
class Usage(Dependency): pass
class OutputPin(Pin): pass
class ForkNode(ControlNode): pass
class MessageEnd(NamedElement): pass
class ExtensionEnd(Property): pass
class LiteralString(LiteralSpecification): pass
class StateInvariant(InteractionFragment): pass
class Enumeration(DataType): pass
class MessageOccurrenceSpecification(OccurrenceSpecification, MessageEnd): pass
class Profile(Package): pass
class LiteralNull(LiteralSpecification): pass
LiteralInteger.value = attribute('value', int)
LiteralSpecification.value = attribute('value', object)
StructuralFeature.isReadOnly = attribute('isReadOnly', int, default=False)
BehavioralFeature.isAbstract = attribute('isAbstract', int)
RedefinableElement.isLeaf = attribute('isLeaf', int, default=True)
Expression.symbol = attribute('symbol', str)
Classifier.isAbstract = attribute('isAbstract', int, default=False)
Action.effect = attribute('effect', str)
Extension.isRequired = attribute('isRequired', int)
JoinNode.isCombineDuplicate = attribute('isCombineDuplicate', int, default=True)
NamedElement.visibility = enumeration('visibility', ('public', 'private', 'package', 'protected'), 'public')
NamedElement.name = attribute('name', str)
# 30: override NamedElement.qualifiedName

def namedelement_qualifiedname(self):
    """
    Returns the qualified name of the element as a tuple
    """
    if self.namespace:
        return self.namespace.qualifiedName + (self.name,)
    else:
        return (self.name,)

NamedElement.qualifiedName = property(namedelement_qualifiedname, doc=namedelement_qualifiedname.__doc__)

del namedelement_qualifiedname
Pseudostate.kind = enumeration('kind', ('initial', 'deepHistory', 'shallowHistory', 'join', 'fork', 'junction', 'choice', 'entryPoint', 'exitPoint', 'terminate'), 'initial')
Comment.body = attribute('body', str)
ActivityPartition.isDimension = attribute('isDimension', int, default=False)
ActivityPartition.isExternal = attribute('isExternal', int, default=False)
Port.isBehavior = attribute('isBehavior', int)
Port.isService = attribute('isService', int)
Generalization.isSubstitutable = attribute('isSubstitutable', int)
ObjectNode.ordering = enumeration('ordering', ('unordered', 'ordered', 'LIFO', 'FIFO'), 'FIFO')
ObjectNode.isControlType = attribute('isControlType', int, default=False)
LiteralBoolean.value = attribute('value', int)
Transition.kind = enumeration('kind', ('internal', 'local', 'external'), 'internal')
PackageableElement.visibility = enumeration('visibility', ('public', 'private', 'package', 'protected'), 'public')
ElementImport.visibility = enumeration('visibility', ('public', 'private', 'package', 'protected'), 'public')
ElementImport.alias = attribute('alias', str)
Parameter.direction = enumeration('direction', ('inout', 'in', 'out', 'return'), 'in')
Component.isIndirectlyInstantiated = attribute('isIndirectlyInstantiated', int, default=True)
LiteralUnlimitedNatural.value = attribute('value', int)
Operation.isQuery = attribute('isQuery', int, default=False)
# 237: override Message.messageKind

def message_messageKind(self):
    kind = 'unknown'
    if self.sendEvent:
        kind = 'lost'
        if self.receiveEvent:
            kind = 'complete'
    elif self.receiveEvent:
        kind = 'found'
    return kind

Message.messageKind = property(message_messageKind, doc="""
    MessageKind
    """)
del message_messageKind


Message.messageSort = enumeration('messageSort', ('synchCall', 'asynchCall', 'asynchSignal', 'createMessage', 'deleteMessage', 'reply'), 'synchCall')
Property.aggregation = enumeration('aggregation', ('none', 'shared', 'composite'), 'none')
Property.isDerivedUnion = attribute('isDerivedUnion', int, default=False)
Property.isDerived = attribute('isDerived', int, default=False)
Property.isReadOnly = attribute('isReadOnly', int, default=False)
# 132: override Property.navigability

def property_navigability(self):
    """
    Get navigability of an association end.
    If no association is related to the property, then unknown navigability
    is assumed.
    """
    assoc = self.association
    if not assoc or not self.opposite:
        return None # assume unknown
    owner = self.opposite.type
    if owner and ((type(self.type) in (Class, Interface) \
                and self in owner.ownedAttribute) \
            or self in assoc.navigableOwnedEnd):
        return True
    elif self in assoc.ownedEnd:
        return None
    else:
        return False

Property.navigability = property(property_navigability, doc=property_navigability.__doc__)

del property_navigability
Activity.body = attribute('body', str)
Activity.language = attribute('language', str)
Connector.kind = enumeration('kind', ('assembly', 'delegation'), 'assembly')
PackageImport.visibility = enumeration('visibility', ('public', 'private', 'package', 'protected'), 'public')
OpaqueExpression.language = attribute('language', str)
OpaqueExpression.body = attribute('body', str)
Feature.isStatic = attribute('isStatic', int, default=False)
Association.isDerived = attribute('isDerived', int, default=False)
Behavior.isReentrant = attribute('isReentrant', int)
LiteralString.value = attribute('value', str)
MultiplicityElement.isUnique = attribute('isUnique', int, default=True)
MultiplicityElement.isOrdered = attribute('isOrdered', int, default=True)
Connector.redefinedConnector = association('redefinedConnector', Connector)
BehavioralFeature.method = association('method', Behavior)
Operation.precondition = association('precondition', Constraint, composite=True)
Realization.abstraction = association('abstraction', Component, upper=1, opposite='realization')
Component.realization = association('realization', Realization, composite=True, opposite='abstraction')
Artifact.manifestation = association('manifestation', Manifestation, composite=True)
ConnectorEnd.role = association('role', ConnectableElement, upper=1, opposite='end')
ConnectableElement.end = association('end', ConnectorEnd, opposite='role')
Parameter.defaultValue = association('defaultValue', ValueSpecification, upper=1, composite=True)
Transition.target = association('target', Vertex, lower=1, upper=1, opposite='incoming')
Vertex.incoming = association('incoming', Transition, opposite='target')
ValuePin.value_ = association('value_', ValueSpecification, lower=1, upper=1, composite=True)
ExtensionPoint.useCase = association('useCase', UseCase, lower=1, upper=1, opposite='extensionPoint')
UseCase.extensionPoint = association('extensionPoint', ExtensionPoint, opposite='useCase')
Region.subvertex = association('subvertex', Vertex, composite=True, opposite='container')
Vertex.container = association('container', Region, upper=1, opposite='subvertex')
State.exit = association('exit', Behavior, upper=1, composite=True)
Class.nestedClassifier = association('nestedClassifier', Classifier, composite=True)
Slot.value = association('value', ValueSpecification, upper=1, composite=True)
Message.interaction = association('interaction', Interaction, lower=1, upper=1, opposite='message')
Interaction.message = association('message', Message, composite=True, opposite='interaction')
Package.ownedDiagram = association('ownedDiagram', Diagram, composite=True, opposite='package')
Diagram.package = association('package', Package, upper=1, opposite='ownedDiagram')
Include.includingCase = association('includingCase', UseCase, lower=1, upper=1, opposite='include')
UseCase.include = association('include', Include, composite=True, opposite='includingCase')
Element.appliedStereotype = association('appliedStereotype', InstanceSpecification, opposite='extended')
InstanceSpecification.extended = association('extended', Element, opposite='appliedStereotype')
ConnectionPointReference.entry = association('entry', Pseudostate)
Extension.ownedEnd = association('ownedEnd', ExtensionEnd, lower=1, upper=1, composite=True)
Include.addition = association('addition', UseCase, lower=1, upper=1)
Transition.guard = association('guard', Constraint, upper=1, composite=True)
BehavioralFeature.raisedException = association('raisedException', Type)
Lifeline.coveredBy = association('coveredBy', InteractionFragment, opposite='covered')
InteractionFragment.covered = association('covered', Lifeline, lower=1, upper=1, opposite='coveredBy')
ActivityPartition.represents = association('represents', Element, upper=1)
InstanceValue.instance = association('instance', InstanceSpecification, lower=1, upper=1)
Lifeline.interaction = association('interaction', Interaction, lower=1, upper=1, opposite='lifeline')
Interaction.lifeline = association('lifeline', Lifeline, composite=True, opposite='interaction')
Pseudostate.state = association('state', State, upper=1)
Property.datatype = association('datatype', DataType, upper=1, opposite='ownedAttribute')
DataType.ownedAttribute = association('ownedAttribute', Property, composite=True, opposite='datatype')
Message.argument = association('argument', ValueSpecification, composite=True)
Realization.realizingClassifier = association('realizingClassifier', Classifier, lower=1, upper=1)
Property.defaultValue = association('defaultValue', ValueSpecification, upper=1, composite=True)
TypedElement.type = association('type', Type, upper=1)
Constraint.specification = association('specification', ValueSpecification, lower=1, upper=1, composite=True)
Extend.extension = association('extension', UseCase, lower=1, upper=1, opposite='extend')
UseCase.extend = association('extend', Extend, composite=True, opposite='extension')
Constraint.constrainedElement = association('constrainedElement', Element)
StructuredClassifier.ownedAttribute = association('ownedAttribute', Property, composite=True)
MessageEnd.sendMessage = association('sendMessage', Message, upper=1, opposite='sendEvent')
Message.sendEvent = association('sendEvent', MessageEnd, upper=1, composite=True, opposite='sendMessage')
Region.state = association('state', State, upper=1)
DeploymentTarget.deployment = association('deployment', Deployment, composite=True)
Profile.metamodelReference = association('metamodelReference', PackageImport, composite=True)
PackageMerge.mergedPackage = association('mergedPackage', Package, lower=1, upper=1)
Message.signature = association('signature', NamedElement, upper=1)
Namespace.ownedRule = association('ownedRule', Constraint, composite=True)
Class.ownedOperation = association('ownedOperation', Operation, composite=True, opposite='class_')
Operation.class_ = association('class_', Class, upper=1, opposite='ownedOperation')
ExecutionOccurence.start = association('start', OccurrenceSpecification, lower=1, upper=1, opposite='startExec')
OccurrenceSpecification.startExec = association('startExec', ExecutionOccurence, opposite='start')
StructuredClassifier.ownedConnector = association('ownedConnector', Connector, composite=True)
Package.nestedPackage = association('nestedPackage', Package, composite=True, opposite='package')
Package.package = association('package', Package, upper=1, opposite='nestedPackage')
Operation.redefinedOperation = association('redefinedOperation', Operation)
InteractionFragment.generalOrdering = association('generalOrdering', GeneralOrdering, composite=True)
Activity.action = association('action', Action, composite=True)
Namespace.elementImport = association('elementImport', ElementImport, composite=True, opposite='importingNamespace')
ElementImport.importingNamespace = association('importingNamespace', Namespace, upper=1, opposite='elementImport')
NamedElement.clientDependency = association('clientDependency', Dependency, opposite='client')
Dependency.client = association('client', NamedElement, lower=1, opposite='clientDependency')
StateMachine.region = association('region', Region, lower=1, composite=True, opposite='stateMachine')
Region.stateMachine = association('stateMachine', StateMachine, upper=1, opposite='region')
Transition.effect = association('effect', Behavior, upper=1, composite=True)
Element.presentation = association('presentation', Presentation, composite=True, opposite='subject')
Presentation.subject = association('subject', Element, upper=1, opposite='presentation')
MessageEnd.receiveMessage = association('receiveMessage', Message, upper=1, opposite='receiveEvent')
Message.receiveEvent = association('receiveEvent', MessageEnd, upper=1, composite=True, opposite='receiveMessage')
TypedElement.typeValue = association('typeValue', ValueSpecification, upper=1, composite=True)
StateMachine.extendedStateMachine = association('extendedStateMachine', StateMachine, upper=1)
Dependency.supplier = association('supplier', NamedElement, lower=1, opposite='supplierDependency')
NamedElement.supplierDependency = association('supplierDependency', Dependency, opposite='supplier')
Enumeration.literal = association('literal', EnumerationLiteral, composite=True, opposite='enumeration')
EnumerationLiteral.enumeration = association('enumeration', Enumeration, upper=1, opposite='literal')
Profile.metaclassReference = association('metaclassReference', ElementImport, composite=True)
Class.ownedAttribute = association('ownedAttribute', Property, composite=True, opposite='class_')
Property.class_ = association('class_', Class, upper=1, opposite='ownedAttribute')
Substitution.contract = association('contract', Classifier, lower=1, upper=1)
Property.association = association('association', Association, upper=1, opposite='memberEnd')
Association.memberEnd = association('memberEnd', Property, lower=2, composite=True, opposite='association')
DataType.ownedOperation = association('ownedOperation', Operation, composite=True, opposite='datatype')
Operation.datatype = association('datatype', DataType, upper=1, opposite='ownedOperation')
MultiplicityElement.lowerValue = association('lowerValue', ValueSpecification, upper=1, composite=True)
InstanceSpecification.classifier = association('classifier', Classifier)
Interface.nestedInterface = association('nestedInterface', Interface, composite=True)
EncapsulatedClassifer.ownedPort = association('ownedPort', Port, composite=True)
Abstraction.mapping = association('mapping', Expression, lower=1, upper=1, composite=True)
ActivityEdge.source = association('source', ActivityNode, lower=1, upper=1, opposite='outgoing')
ActivityNode.outgoing = association('outgoing', ActivityEdge, opposite='source')
DecisionNode.decisionInput = association('decisionInput', Behavior, upper=1)
Activity.edge = association('edge', ActivityEdge, composite=True, opposite='activity')
ActivityEdge.activity = association('activity', Activity, upper=1, opposite='edge')
InteractionFragment.enclosingInteraction = association('enclosingInteraction', Interaction, upper=1, opposite='fragment')
Interaction.fragment = association('fragment', InteractionFragment, opposite='enclosingInteraction')
Extend.extendedCase = association('extendedCase', UseCase, lower=1, upper=1)
Property.redefinedProperty = association('redefinedProperty', Property)
State.statevariant = association('statevariant', Constraint, upper=1, composite=True, opposite='owningState')
Constraint.owningState = association('owningState', State, upper=1, opposite='statevariant')
StateInvariant.invariant = association('invariant', Constraint, lower=1, upper=1, composite=True)
JoinNode.joinSpec = association('joinSpec', ValueSpecification, lower=1, upper=1, composite=True)
Classifier.generalization = association('generalization', Generalization, composite=True, opposite='specific')
Generalization.specific = association('specific', Classifier, lower=1, upper=1, opposite='generalization')
Extend.extensionLocation = association('extensionLocation', ExtensionPoint, lower=1)
Deployment.deployedArtifact = association('deployedArtifact', DeployedArtifact)
Property.interface_ = association('interface_', Interface, upper=1, opposite='ownedAttribute')
Interface.ownedAttribute = association('ownedAttribute', Property, composite=True, opposite='interface_')
ConnectionPointReference.state = association('state', State, upper=1)
Behavior.context = association('context', BehavioredClassifier, upper=1, opposite='ownedBehavior')
BehavioredClassifier.ownedBehavior = association('ownedBehavior', Behavior, composite=True, opposite='context')
ConnectorEnd.partWithPort = association('partWithPort', Property, upper=1)
Generalization.general = association('general', Classifier, lower=1, upper=1)
Extend.constraint = association('constraint', Constraint, upper=1, composite=True)
ActivityParameterNode.parameter = association('parameter', Parameter, lower=1, upper=1)
Transition.container = association('container', Region, lower=1, upper=1)
ActivityNode.incoming = association('incoming', ActivityEdge, opposite='target')
ActivityEdge.target = association('target', ActivityNode, lower=1, upper=1, opposite='incoming')
Connector.contract = association('contract', Behavior)
ExecutionOccurence.behavior = association('behavior', Behavior)
GeneralOrdering.before = association('before', OccurrenceSpecification, lower=1, upper=1, opposite='toAfter')
OccurrenceSpecification.toAfter = association('toAfter', GeneralOrdering, opposite='before')
Connector.end = association('end', ConnectorEnd, lower=2, composite=True)
Connector.type = association('type', Association, upper=1)
Operation.postcondition = association('postcondition', Constraint, composite=True)
State.submachine = association('submachine', StateMachine, upper=1)
StructuralFeature.slot = association('slot', Slot, composite=True, opposite='definingFeature')
Slot.definingFeature = association('definingFeature', StructuralFeature, lower=1, upper=1, opposite='slot')
Property.actor = association('actor', Actor, upper=1, opposite='ownedAttribute')
Actor.ownedAttribute = association('ownedAttribute', Property, composite=True, opposite='actor')
Classifier.ownedUseCase = association('ownedUseCase', UseCase, composite=True)
ProfileApplication.importedProfile = association('importedProfile', Profile, lower=1, upper=1)
Node.nestedNode = association('nestedNode', Node, composite=True)
Property.classifier = association('classifier', Classifier, upper=1, opposite='attribute')
Profile.ownedStereotype = association('ownedStereotype', Stereotype, composite=True)
Namespace.packageImport = association('packageImport', PackageImport, composite=True, opposite='importingNamespace')
PackageImport.importingNamespace = association('importingNamespace', Namespace, upper=1, opposite='packageImport')
ActivityPartition.subpartition = association('subpartition', ActivityPartition)
ElementImport.importedElement = association('importedElement', PackageableElement, lower=1, upper=1)
Behavior.redefinedBehavior = association('redefinedBehavior', Behavior)
State.doActivity = association('doActivity', Behavior, upper=1, composite=True)
MultiplicityElement.upperValue = association('upperValue', ValueSpecification, upper=1, composite=True)
Parameter.ownerReturnParam = association('ownerReturnParam', BehavioralFeature, upper=1, opposite='returnResult')
BehavioralFeature.returnResult = association('returnResult', Parameter, composite=True, opposite='ownerReturnParam')
Pseudostate.stateMachine = association('stateMachine', StateMachine, upper=1)
PackageMerge.mergingPackage = association('mergingPackage', Package, lower=1, upper=1, opposite='packageExtension')
Package.packageExtension = association('packageExtension', PackageMerge, composite=True, opposite='mergingPackage')
Lifeline.discriminator = association('discriminator', Expression, upper=1, composite=True)
Expression.operand = association('operand', ValueSpecification, composite=True)
ActivityNode.inPartition = association('inPartition', ActivityPartition, opposite='node')
ActivityPartition.node = association('node', ActivityNode, opposite='inPartition')
Activity.group = association('group', ActivityGroup, composite=True, opposite='activity')
ActivityGroup.activity = association('activity', Activity, upper=1, opposite='group')
Association.navigableOwnedEnd = association('navigableOwnedEnd', Property)
ConnectionPointReference.exit = association('exit', Pseudostate)
ActivityGroup.edgeContents = association('edgeContents', ActivityEdge, opposite='inGroup')
ActivityEdge.inGroup = association('inGroup', ActivityGroup, opposite='edgeContents')
Interface.ownedOperation = association('ownedOperation', Operation, composite=True, opposite='interface_')
Operation.interface_ = association('interface_', Interface, upper=1, opposite='ownedOperation')
State.entry = association('entry', Behavior, upper=1, composite=True)
ActivityEdge.guard = association('guard', ValueSpecification, lower=1, upper=1, composite=True)
Package.ownedClassifier = association('ownedClassifier', Type, composite=True, opposite='package')
Type.package = association('package', Package, upper=1, opposite='ownedClassifier')
Classifier.redefinedClassifier = association('redefinedClassifier', Classifier)
Element.ownedComment = association('ownedComment', Comment, opposite='annotatedElement')
Comment.annotatedElement = association('annotatedElement', Element, opposite='ownedComment')
Transition.source = association('source', Vertex, lower=1, upper=1, opposite='outgoing')
Vertex.outgoing = association('outgoing', Transition, opposite='source')
Slot.owningInstance = association('owningInstance', InstanceSpecification, lower=1, upper=1, opposite='slot')
InstanceSpecification.slot = association('slot', Slot, composite=True, opposite='owningInstance')
Package.appliedProfile = association('appliedProfile', ProfileApplication, composite=True)
ObjectNode.upperBound = association('upperBound', ValueSpecification, lower=1, upper=1, composite=True)
BehavioralFeature.formalParameter = association('formalParameter', Parameter, composite=True, opposite='ownerFormalParam')
Parameter.ownerFormalParam = association('ownerFormalParam', BehavioralFeature, upper=1, opposite='formalParameter')
Property.subsettedProperty = association('subsettedProperty', Property)
InstanceSpecification.specification = association('specification', ValueSpecification, upper=1, composite=True)
Activity.node = association('node', ActivityNode, composite=True)
Operation.bodyCondition = association('bodyCondition', Constraint, upper=1, composite=True)
Property.owningAssociation = association('owningAssociation', Association, upper=1, opposite='ownedEnd')
Association.ownedEnd = association('ownedEnd', Property, composite=True, opposite='owningAssociation')
Substitution.substitutingClassifier = association('substitutingClassifier', Classifier, lower=1, upper=1, opposite='substitution')
Classifier.substitution = association('substitution', Substitution, composite=True, opposite='substitutingClassifier')
ExecutionOccurence.finish = association('finish', OccurrenceSpecification, lower=1, upper=1, opposite='finishExec')
OccurrenceSpecification.finishExec = association('finishExec', ExecutionOccurence, opposite='finish')
ObjectNode.selection = association('selection', Behavior, upper=1)
Operation.raisedException = association('raisedException', Type)
PackageImport.importedPackage = association('importedPackage', Package, lower=1, upper=1)
ActivityGroup.nodeContents = association('nodeContents', ActivityNode, opposite='inGroup')
ActivityNode.inGroup = association('inGroup', ActivityGroup, opposite='nodeContents')
GeneralOrdering.after = association('after', OccurrenceSpecification, lower=1, upper=1, opposite='toBefore')
OccurrenceSpecification.toBefore = association('toBefore', GeneralOrdering, opposite='after')
UseCase.subject = association('subject', Classifier)
Interface.redefinedInterface = association('redefinedInterface', Interface)
UseCase.ownedAttribute = association('ownedAttribute', Property, composite=True, opposite='useCase')
Property.useCase = association('useCase', UseCase, upper=1, opposite='ownedAttribute')
ExtensionEnd.type = association('type', Stereotype, lower=1, upper=1)
# 26: override MultiplicityElement.upper derives MultiplicityElement.upperValue
MultiplicityElement.upper = derived('upper', object, 0, 1, MultiplicityElement.upperValue, LiteralSpecification.value, LiteralString.value)
MultiplicityElement.upper.filter = lambda obj: [ obj.upperValue and obj.upperValue.value ]
# 124: override Property.isComposite derives Property.aggregation
#Property.isComposite = property(lambda self: self.aggregation == intern('composite'))
Property.isComposite = derivedunion('isComposite', bool, 0, 1, Property.aggregation)
Property.isComposite.filter = lambda obj: [obj.aggregation == intern('composite')]
# 22: override MultiplicityElement.lower derives MultiplicityElement.lowerValue
MultiplicityElement.lower = derived('lower', object, 0, 1, MultiplicityElement.lowerValue, LiteralSpecification.value, LiteralString.value)
MultiplicityElement.lower.filter = lambda obj: [ obj.lowerValue and obj.lowerValue.value ]
Transition.redefintionContext = derivedunion('redefintionContext', Classifier, 1, 1)
RedefinableElement.redefinitionContext = derivedunion('redefinitionContext', Classifier, 0, '*', Property.classifier, Operation.datatype, Transition.redefintionContext, Operation.class_)
Classifier.attribute = derivedunion('attribute', Property, 0, '*', Interface.ownedAttribute, UseCase.ownedAttribute, Actor.ownedAttribute, Class.ownedAttribute, DataType.ownedAttribute)
Namespace.ownedMember = derivedunion('ownedMember', NamedElement, 0, '*', Node.nestedNode, Interface.ownedOperation, UseCase.extensionPoint, Package.ownedClassifier, Enumeration.literal, Package.ownedDiagram, Region.subvertex, Interface.ownedAttribute, Namespace.ownedRule, Package.nestedPackage, Operation.bodyCondition, BehavioredClassifier.ownedBehavior, UseCase.ownedAttribute, StateInvariant.invariant, Operation.postcondition, Extend.constraint, DataType.ownedOperation, Operation.precondition, Actor.ownedAttribute, BehavioralFeature.returnResult, Interaction.lifeline, Profile.ownedStereotype, Class.nestedClassifier, Class.ownedAttribute, Classifier.ownedUseCase, BehavioralFeature.formalParameter, Interaction.message, StateMachine.region, DataType.ownedAttribute, Class.ownedOperation, Association.ownedEnd)
# 88: override Classifier.general
def classifier_general(self):
    return [g.general for g in self.generalization]

Classifier.general = property(classifier_general, doc="""
    Return a list of all superclasses for class (iterating the Generalizations.
    """)
del classifier_general
ActivityGroup.superGroup = derivedunion('superGroup', ActivityGroup, 0, 1)
NamedElement.namespace = derivedunion('namespace', Namespace, 0, 1, Diagram.package, Property.owningAssociation, Property.useCase, Lifeline.interaction, Parameter.ownerReturnParam, Region.state, Property.actor, Operation.datatype, Type.package, Property.interface_, Property.datatype, Pseudostate.stateMachine, Vertex.container, ConnectionPointReference.state, Region.stateMachine, Property.class_, Message.interaction, Operation.interface_, EnumerationLiteral.enumeration, Package.package, Transition.container, Parameter.ownerFormalParam, Operation.class_)
Element.owner = derivedunion('owner', Element, 0, 1, Generalization.specific, Realization.abstraction, ActivityEdge.activity, ActivityGroup.superGroup, Slot.owningInstance, NamedElement.namespace, PackageImport.importingNamespace, PackageMerge.mergingPackage, ElementImport.importingNamespace, ActivityGroup.activity, Pseudostate.state)
DirectedRelationship.target = derivedunion('target', Element, 1, '*', Extend.extendedCase, Realization.realizingClassifier, PackageImport.importedPackage, Substitution.contract, PackageMerge.mergedPackage, Generalization.general, Include.addition, ElementImport.importedElement)
DirectedRelationship.source = derivedunion('source', Element, 1, '*', Extend.extension, Generalization.specific, Realization.abstraction, Substitution.substitutingClassifier, PackageImport.importingNamespace, PackageMerge.mergingPackage, Include.includingCase, ElementImport.importingNamespace)
Relationship.relatedElement = derivedunion('relatedElement', Element, 1, '*', DirectedRelationship.target, DirectedRelationship.source)
# 85: override Classifier.inheritedMember
Classifier.inheritedMember = derivedunion('inheritedMember', NamedElement, 0, '*')
# 103: override Property.opposite

def property_opposite(self):
    """
    In the case where the property is one navigable end of a binary
    association with both ends navigable, this gives the other end.

    For Gaphor the property on the other end is returned regardless the
    navigability.
    """
    if self.association is not None and len(self.association.memberEnd) == 2:
        return self.association.memberEnd[0] is self \
               and self.association.memberEnd[1] \
               or self.association.memberEnd[0]
    return None

Property.opposite = property(property_opposite, doc=property_opposite.__doc__)

del property_opposite

ActivityGroup.superGroup = derivedunion('superGroup', ActivityGroup, 0, 1)
Classifier.feature = derivedunion('feature', Feature, 0, '*', StructuredClassifier.ownedConnector, Interface.ownedOperation, UseCase.extensionPoint, DataType.ownedOperation, Classifier.attribute, Class.ownedOperation, Association.ownedEnd)
StructuredClassifier.role = derivedunion('role', ConnectableElement, 0, '*', StructuredClassifier.ownedAttribute)
BehavioralFeature.parameter = derivedunion('parameter', Parameter, 0, '*', BehavioralFeature.returnResult, BehavioralFeature.formalParameter)
Namespace.member = derivedunion('member', NamedElement, 0, '*', StructuredClassifier.role, Association.memberEnd, BehavioralFeature.parameter, Classifier.inheritedMember, Namespace.ownedMember)
DirectedRelationship.source = derivedunion('source', Element, 1, '*', Extend.extension, Generalization.specific, Realization.abstraction, Substitution.substitutingClassifier, PackageImport.importingNamespace, PackageMerge.mergingPackage, Include.includingCase, ElementImport.importingNamespace)
Feature.featuringClassifier = derivedunion('featuringClassifier', Classifier, 1, '*', Property.owningAssociation, Operation.datatype, Property.datatype, Property.class_, Operation.interface_, Operation.class_)
StructuredClassifier.role = derivedunion('role', ConnectableElement, 0, '*', StructuredClassifier.ownedAttribute)
Action.input = derivedunion('input', InputPin, 0, '*')
# 157: override Operation.type
Operation.type = derivedunion('type', DataType, 0, 1)
Action.output = derivedunion('output', OutputPin, 0, '*')
ActivityGroup.subgroup = derivedunion('subgroup', ActivityGroup, 0, '*', ActivityPartition.subpartition)
Element.ownedElement = derivedunion('ownedElement', Element, 0, '*', Expression.operand, DeploymentTarget.deployment, Constraint.specification, Namespace.packageImport, Element.ownedComment, Activity.group, Lifeline.discriminator, ObjectNode.upperBound, MultiplicityElement.upperValue, Transition.guard, Package.packageExtension, State.entry, Substitution.contract, Action.input, InteractionFragment.generalOrdering, MultiplicityElement.lowerValue, Message.argument, InstanceSpecification.specification, Classifier.generalization, State.exit, ActivityEdge.guard, Slot.value, Namespace.ownedMember, Parameter.defaultValue, Interaction.fragment, State.statevariant, Namespace.elementImport, Action.output, Activity.edge, Property.defaultValue, ActivityGroup.subgroup, TypedElement.typeValue, State.doActivity, Connector.end, Transition.effect, Abstraction.mapping, Component.realization, JoinNode.joinSpec, Artifact.manifestation, Activity.node)
ConnectorEnd.definingEnd = derivedunion('definingEnd', Property, 0, 1)
RedefinableElement.redefinedElement = derivedunion('redefinedElement', RedefinableElement, 0, '*', Property.redefinedProperty, Connector.redefinedConnector, Operation.redefinedOperation, Interface.redefinedInterface, Behavior.redefinedBehavior, Classifier.redefinedClassifier)
Action.context_ = derivedunion('context_', Classifier, 0, 1)
# 186: override Component.provided
import itertools

def _pr_interface_deps(classifier, dep_type):
    """
    Return all interfaces, which are connected to a classifier with given
    dependency type.
    """
    return (dep.supplier[0] for dep in classifier.clientDependency \
        if dep.isKindOf(dep_type) and dep.supplier[0].isKindOf(Interface))

def _pr_rc_interface_deps(component, dep_type):
    """
    Return all interfaces, which are connected to realizing classifiers of
    specified component. Returned interfaces are connected to realizing
    classifiers with given dependency type.

    Generator of generators is returned. Do not forget to flat it later.
    """
    return (_pr_interface_deps(r.realizingClassifier, dep_type) for r in component.realization)

def component_provided(self):
    implementations = (impl.contract[0] for impl in self.implementation if impl.isKindOf(Implementation))
    realizations = _pr_interface_deps(self, Realization)

    # realizing classifiers realizations
    # this generator of generators, so flatten it later
    rc_realizations = _pr_rc_interface_deps(self, Realization)

    return tuple(set(itertools.chain(implementations, realizations, *rc_realizations)))

Component.provided = property(component_provided, doc="""
    Interfaces provided to component environment. 
    """)
del component_provided
# 100: override Namespace.importedMember
Namespace.importedMember = derivedunion('importedMember', PackageableElement, 0, '*')
# 256: override StructuredClassifier.part
def structuredclassifier_part(self):
    return tuple(a for a in self.ownedAttribute if a.isComposite)

StructuredClassifier.part = property(structuredclassifier_part, doc="""
    Properties owned by a classifier by composition.
""")
del structuredclassifier_part
# 45: override Association.endType derives Association.memberEnd Property.type

# References the classifiers that are used as types of the ends of the
# association.

Association.endType = derived('endType', Type, 0, '*', Association.memberEnd, Property.type)
Association.endType.filter = lambda self: [end.type for end in self.memberEnd if end]

# 68: override Extension.metaclass derives Extension.ownedEnd Association.memberEnd
def extension_metaclass(self):
    ownedEnd = self.ownedEnd
    metaend = [e for e in self.memberEnd if e is not ownedEnd]
    if metaend:
        return metaend[0].type

# Don't use derived now, as derived() does not properly propagate the events
# NOTE: let function return a list once this can be turned on
#Extension.metaclass = derived('metaclass', Class, 0, 1, Extension.ownedEnd, Association.memberEnd)
#Extension.metaclass.filter = extension_metaclass
Extension.metaclass = property(extension_metaclass, doc=\
"""References the Class that is extended through an Extension. The
property is derived from the type of the memberEnd that is not the
ownedEnd.""")
del extension_metaclass
DirectedRelationship.target = derivedunion('target', Element, 1, '*', Extend.extendedCase, Realization.realizingClassifier, PackageImport.importedPackage, Substitution.contract, PackageMerge.mergedPackage, Generalization.general, Include.addition, ElementImport.importedElement)
# 54: override Class.extension derives Extension.metaclass
def class_extension(self):
    return list(self._factory.select(lambda e: e.isKindOf(Extension) and self is e.metaclass))

# TODO: use those as soon as Extension.metaclass can be used.
#Class.extension = derived('extension', Extension, 0, '*', Extension.metaclass)
#Class.extension.filter = class_extension

Class.extension = property(class_extension, doc=\
"""References the Extensions that specify additional properties of the
metaclass. The property is derived from the extensions whose memberEnds
are typed by the Class.""")
del class_extension
BehavioralFeature.parameter = derivedunion('parameter', Parameter, 0, '*', BehavioralFeature.returnResult, BehavioralFeature.formalParameter)
Transition.redefintionContext = derivedunion('redefintionContext', Classifier, 1, 1)
# 222: override Component.required
def component_required(self):
    usages = _pr_interface_deps(self, Usage)

    # realizing classifiers usages
    # this generator of generators, so flatten it later
    rc_usages = _pr_rc_interface_deps(self, Usage)

    return tuple(set(itertools.chain(usages, *rc_usages)))

Component.required = property(component_required, doc="""
    Interfaces required by component. 
    """)
del component_required
# 129: override Constraint.context
Constraint.context = derivedunion('context', Namespace, 0, 1)
Action.output = derivedunion('output', OutputPin, 0, '*')
NamedElement.namespace = derivedunion('namespace', Namespace, 0, 1, Diagram.package, Property.owningAssociation, Property.useCase, Lifeline.interaction, Parameter.ownerReturnParam, Region.state, Property.actor, Operation.datatype, Type.package, Property.interface_, Property.datatype, Pseudostate.stateMachine, Vertex.container, ConnectionPointReference.state, Region.stateMachine, Property.class_, Message.interaction, Operation.interface_, EnumerationLiteral.enumeration, Package.package, Transition.container, Parameter.ownerFormalParam, Operation.class_)
ActivityGroup.subgroup = derivedunion('subgroup', ActivityGroup, 0, '*', ActivityPartition.subpartition)
ActivityEdge.redefinedElement = redefine(ActivityEdge, 'redefinedElement', ActivityEdge, RedefinableElement.redefinedElement)
BehavioredClassifier.implementation = redefine(BehavioredClassifier, 'implementation', Implementation, NamedElement.clientDependency)
Implementation.implementatingClassifier = redefine(Implementation, 'implementatingClassifier', BehavioredClassifier, Dependency.client)
Package.ownedMember = redefine(Package, 'ownedMember', PackageableElement, Namespace.ownedMember)
Transition.redefinedTransition = redefine(Transition, 'redefinedTransition', Transition, RedefinableElement.redefinedElement)
Implementation.contract = redefine(Implementation, 'contract', Interface, Dependency.supplier)
Parameter.operation = redefine(Parameter, 'operation', Operation, Parameter.ownerFormalParam)
Operation.formalParameter = redefine(Operation, 'formalParameter', Parameter, BehavioralFeature.formalParameter)
ActivityNode.redefinedElement = redefine(ActivityNode, 'redefinedElement', ActivityNode, RedefinableElement.redefinedElement)
Region.extendedRegion = redefine(Region, 'extendedRegion', Region, RedefinableElement.redefinedElement)
Component.ownedMember = redefine(Component, 'ownedMember', PackageableElement, Namespace.ownedMember)
# 97: override Class.superClass
Class.superClass = Classifier.general
State.redefinedState = redefine(State, 'redefinedState', State, RedefinableElement.redefinedElement)
# 160: override Lifeline.parse
from umllex import parse_lifeline
Lifeline.parse = parse_lifeline
del parse_lifeline
# 165: override Lifeline.render
from umllex import render_lifeline
Lifeline.render = render_lifeline
del render_lifeline
