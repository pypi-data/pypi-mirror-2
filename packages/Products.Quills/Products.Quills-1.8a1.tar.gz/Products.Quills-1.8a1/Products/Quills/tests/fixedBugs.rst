Quills browser tests
====================

Here we check for fixed bugs using tests, that don't fit into the 'narrative' in the main browser test. First some boilerplate to get our browser up and running:

    >>> self.setRoles(("Contributor",))
    >>> browser = self.getBrowser(logged_in=True)
    >>> browser.handleErrors = False
    >>> self.weblog.addEntry("Blog entry", "Just for testing", "Nothing to see.", \
    ... ['fishslapping'], id="entry")
    <WeblogEntry at /plone/weblog/entry>

Make it discussable and publish it

    >>> self.portal.weblog.entry.allowDiscussion(allowDiscussion=True)
    >>> self.portal.weblog.entry.publish()

    >>> date = self.portal.weblog.entry.getPublicationDate()
    >>> year = str(date.year())
    >>> month = str(date.month()).zfill(2)
    >>> day = str(date.day()).zfill(2)

    >>> self.setRoles(("Contributor", "Reviewer", "Manager"))
    >>> browser.open('http://nohost/plone/weblog/%s/%s/%s/entry' % (year, month, day))
    >>> browser.getControl('Add Comment').click()
    >>> browser.getControl('Subject').value = "Parrot"
    >>> browser.getControl('Comment').value = "Is dead. Is deceased."

Issue #111 shows that the URLs generated by the archive portlet are not correct.
Even when the weblog is not supposed to be using an extra 'archive' URL segment,
the URLs always have that segment in them.

To test this, we'll first make sure that the weblog config is setup to use the
'archive' segment for URLs.

    >>> from quills.core.interfaces import IWeblogConfiguration
    >>> config = IWeblogConfiguration(self.portal.weblog)
    >>> config.archive_format = 'archive'

Now we'll get a page and check its body for the appropriate link.

    >>> browser.open('http://nohost/plone/weblog/')
    >>> url = '<a href="http://nohost/plone/weblog/archive/%s/%s">'
    >>> url = url % (year, month)
    >>> url in browser.contents
    True

Now, if we change the archive_format, we should get different URLs.

    >>> config.archive_format = ''
    >>> browser.open('http://nohost/plone/weblog/')
    >>> url = '<a href="http://nohost/plone/weblog/%s/%s">'
    >>> url = url % (year, month)
    >>> url in browser.contents
    True


There was an issue whereby the correct comment count didn't get shown for each
weblog entry displayed in the weblog_view.  We verify that this is no longer
the case here.

First, let's add a comment so that we know one is there.

    >>> from Products.CMFCore.utils import getToolByName
    >>> dtool = getToolByName(self.portal, 'portal_discussion')
    >>> entry_discussion = dtool.getDiscussionFor(self.portal.weblog.entry)
    >>> comment_id = entry_discussion.createReply(title='Comment Title',
    ...                                           text='a little test body')

Now, when we look at the weblog view, we should find that there is a link to the
comments for `entry', together with a count of how many comments there are on
it.

    >>> browser.open('http://nohost/plone/weblog/')
    >>> url = '<a href="http://nohost/plone/weblog/%s/%s/%s/entry#comments"'
    >>> url = url % (year, month, day)
    >>> url in browser.contents
    True
    >>> '<span>1</span>' in browser.contents
    True

>> repr(browser.contents)

This last line of test is fairly lame as it could potentially match anywhere in
the source.  An example of what we are really trying to match is the following:

"""
          <a href="http://nohost/plone/weblog/2007/09/24/entry#comments"
           style="text-decoration: none;">
          Comments:
          </a>

          <span>3</span>
"""


Issue #112 found that the recent comments portlet was generating incorrect links
to comments as it wasn't utilising the archive URL of the weblog entry objects.

    >>> txt = '<a href="http://nohost/plone/weblog/%s/%s/%s/entry#%s"'
    >>> txt = txt % (year, month, day, comment_id)
    >>> txt in browser.contents
    True


Issue #117 found that the weblog admin portlet got displayed to anonymous users,
rather than being restricted to admin-ish users.  Let's verify that this is no
longer the case.

    >>> self.setRoles([])
    >>> browser = self.getBrowser(logged_in=False)
    >>> browser.handleErrors = False
    >>> browser.open('http://nohost/plone/weblog/')
    >>> 'portletWeblogAdmin' in browser.contents
    False

Issue #141 Getting a feed on discussion items causes an exception 
'DiscussionNotAllowed'to be thrown, when disscussion is not allowed for that entry.

Create an entry and disable discussion.

    >>> nodiscussionentry = self.weblog.addEntry("No discussion here",\
    ... "Just for testing", "Nothing to see.", ['fishslapping'], id="nodiscussionentry")
    >>> nodiscussionentry.allowDiscussion(allowDiscussion=False)
    >>> nodiscussionentry.publish()

Now get a feed to it, in this case a Atom feed and query all entries.
There should be only one: the entry itself.

    >>> from Products.basesyndication.interfaces import IFeedSource
    >>> feed = IFeedSource(nodiscussionentry)
    >>> entries = feed.getFeedEntries()
    >>> len(entries)
    1

Issue #147 in which an error is caused in weblog view when using
keywords with non-ascii characters.

    >>> from Products.CMFPlone.utils import _createObjectByType
    >>> entry = self.weblog.addEntry('New entry',
    ...                              'This is for testing non-ascii keywords',
    ...                              'Nothing to see here...',
    ...                              ['nón-ascïi-ñ'],
    ...                              id='new-entry')
    >>> entry
    <WeblogEntry at /plone/weblog/new-entry>
    >>> entry.publish()
    >>> browser.open('http://nohost/plone/weblog')
    >>> 'nón-ascïi-ñ' in browser.contents
    True


Issue #191: Topic listing contains broken links to indvidual topics
-------------------------------------------------------------------

The links generated lack the 'topics' infix. This happens only when trying to
render the topics via the 'topic_listing' view. This fix removes this
view registration.

We start as usual: create a post, this time with a topic assigned.

    >>> self.login()
    >>> self.setRoles(('Manager',))

    >>> entry = self.weblog.addEntry(title="Issue #191", id="issue191",
    ...                      topics=['brokenTopic'],
    ...                      excerpt="None", text="None")
    >>> entry.publish()

Hide the tag clouds portlet. This will otherwise give us two links with the
same name.

    >>> from zope.component import getMultiAdapter, getUtility
    >>> from plone.portlets.interfaces import IPortletManager
    >>> left = getUtility(IPortletManager, name='plone.leftcolumn')
    >>> from plone.portlets.interfaces import IPortletAssignmentMapping
    >>> portlets = getMultiAdapter((self.portal.weblog, left),
    ...                            IPortletAssignmentMapping)
    >>> topicPortlet =  portlets['tagcloud']
    >>> del portlets['tagcloud']

Have a look at the topics.

    >>> browser = self.getBrowser(logged_in=True)
    >>> browser.handleErrors = True
    >>> browser.open("http://nohost/plone/weblog/@@topic_listing")


Get the link to our topic.

    >>> link = browser.getLink("brokenTopic")
    >>> link.click()
    
    >>> browser.title
    '...brokenTopic...'

Show the portlet again.

    >>> portlets['tagcloud'] = topicPortlet
