#! /usr/bin/env python
#
# A script that runs reads in a PySP stochastic programming instance and writes the extensive form.
# Currently takes no arguments, and assumes the instance definition files are in the current directory.
#  _________________________________________________________________________
#
#  Coopr: A COmmon Optimization Python Repository
#  Copyright (c) 2009 Sandia Corporation.
#  This software is distributed under the BSD License.
#  Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
#  the U.S. Government retains certain rights in this software.
#  For more information, see the FAST README.txt file.
#  _________________________________________________________________________

import traceback
import sys
if sys.version_info[0:2] < (2,4):
   print ""
   print "ERROR: Pyomo requires Python 2.4 or newer"
   sys.exit(1)
from os.path import abspath, dirname
import os
import pyutilib.common
sys.path.insert(0, dirname(dirname(abspath(__file__))))
sys.path.append(".")
currdir = dirname(abspath(__file__))
coopr_path = dirname(currdir)
pyutilib_path = dirname(coopr_path)+os.sep+"pyutilib"
sys.path.append(coopr_path)
sys.path.append(pyutilib_path)
sys.path.append(abspath(os.getcwd()))
#
# Adjust the user path if it looks like this script is being used
# from an Acro build (adds the Acro bin directory, if it exists).
#
# Recurse up the current path, looking for a subdirectory that
# contains 'python' and 'bin'
#
curr = os.path.abspath(os.getcwd())
while os.sep in curr:
    if os.path.exists(curr+os.sep+"python") and os.path.exists(curr+os.sep+"bin"):
        os.environ["PATH"] = curr+os.sep+"bin:"+os.environ["PATH"]
        break
    if os.path.basename(curr) == "":
        break
    curr = os.path.dirname(curr)

import coopr.pysp.ef_writer_script

try:
    coopr.pysp.ef_writer_script.run()
except ValueError, str:
    print "VALUE ERROR:"   
    print str
except IOError, str:
    print "IO ERROR:"   
    print str
except RuntimeError, str:
    print "RUN-TIME ERROR:"   
    print str    
except pyutilib.common.ApplicationError, str:
    print "APPLICATION ERROR:"   
    print str
except:
   print "Encountered unhandled exception"
   traceback.print_exc()
