#!/usr/bin/env python

"""
usage: rosinstall [OPTIONS] INSTALL_PATH [URI]

Options:
-s SETUP_FILE or --setup=SETUP_FILE (use another setup.sh file to create env)
-n or --nobuild (don't perform a 'make core_cools' on the ros stack)

Common invocations:

initial checkout:   rosinstall ~/ros http://ros.org/rosconfigs/all.rosconfig
subsequent update:  rosinstall ~/ros

"""

from __future__ import with_statement

import os
import subprocess
import sys
import xml.dom.minidom #import parse
from optparse import OptionParser
import yaml

import rosinstall.helpers
from rosinstall.vcs import svn, bzr, git

def usage():
  print __doc__ % vars()
  exit(1)

class ROSInstallException(Exception): pass

class ConfigElement:
  def __init__(self, name, path):
    self.name = name
    self.path = path
  def get_path(self):
    return self.path
  def get_name(self):
    return self.name
  def install(self):
    raise NotImplementedError, "ConfigElement install unimplemented"

class OverlayConfigElement(ConfigElement):
  def install(self):
    return True

class VCSConfigElement(ConfigElement):
  def __init__(self, name, path, uri, version):
    self.name = name
    self.path = path
    self.uri = uri
    self.version = version
    
  def install(self):
    if not self.vcsc.path_exists():
      self.vcsc.checkout(self.uri, self.version)
    else:
      if not self.vcsc.detect_presence():
        raise ROSInstallException("Directory '%s' already exists but is not of type %s"%(self.vcsc.get_path(), self.vcsc.get_vcs_type_name()))
      self.vcsc.update(self.version)
    return True
  

class SVNConfigElement(VCSConfigElement):
  def __init__(self, name, path, uri, version = None):
    self.name = name
    self.path = path
    self.uri = uri
    self.version = version
    self.vcsc = svn.SVNClient(self.path)

class BZRConfigElement(VCSConfigElement):
  def __init__(self, name, path, uri, version = None):
    self.name = name
    self.path = path
    self.uri = uri
    self.version = version
    self.vcsc = bzr.BZRClient(self.path)

class GITConfigElement(VCSConfigElement):
  def __init__(self, name, path, uri, version = None):
    self.name = name
    self.path = path
    self.uri = uri
    self.version = version
    self.vcsc = git.GITClient(self.path)




class Config:
  def __init__(self, yaml_source, install_path):
    self.source_uri = "hack" #TODO Hack so I don't have to fix theusages of this remove!!!
    self.source = yaml_source
    self.trees = [ ]
    self.base_path = install_path

    if self.source:
      self.load_yaml(self.source)
      self.valid = True
    else:
      self.valid = False
    
  def is_valid(self):
    return self.valid

  def load_yaml(self, y):
    for t in y:
      for k, v in t.iteritems():


        if not 'local-name' in v:
          raise ROSInstallException("local-name is required on all code trees")
        else:
          local_name = v['local-name']

        source_uri = v.get('uri', None)
        version = v.get('version', '')
        local_path = os.path.join(self.base_path, local_name)

        #if local_path in self.vcs:
        #  raise Exception("cannot install two things into the same directory!! %s"%local_path)
        
        if k == 'svn':
          if not source_uri:
            raise ROSInstallException("woah! no uri for svn tree %s" % local_name)
          elem = SVNConfigElement(local_name, local_path, source_uri, version)
        elif k == 'git':
          if not source_uri:
            raise ROSInstallException("woah! no uri for git tree %s" % local_name)
          elem = GITConfigElement(local_name, local_path, source_uri, version)
        elif k == 'bzr':
          if not source_uri:
            raise ROSInstallException("woah! no uri for bzr tree %s" % local_name)
          elem = BZRConfigElement(local_name, local_path, source_uri, version)
        elif k == 'overlay':
          if not source_uri:
            print v
            raise ROSInstallException("woah! no uri for overlay %s" % local_name)
          rosinstall_uri = os.path.join(source_uri, "this.rosinstall")
          if os.path.exists(rosinstall_uri):
            child_config = Config(rosinstall.helpers.get_yaml_from_uri(rosinstall_uri), local_path)
            for child_t in child_config.trees:
              elem = OverlayConfigElement(child_t.get_name(), child_t.get_path())
              self.trees.append(elem)
            continue # so we don't append some individual one at the end
          else:
            raise ROSInstallException("woah! invalid uri for overlay tree %s: %s"% (local_name, rosinstall_uri))
          pass
        else:
          raise ROSInstallException("woah, unknown installation method %s" % k)


        self.trees.append(elem)

  def ros_path(self):
    for t in self.trees:
      if rosinstall.helpers.is_path_ros(t.get_path()):
        return t.get_path()
    return None
  
  def write_source(self):
    """
    Write this.rosinstall into the root of the checkout
    """
    if not os.path.exists(self.base_path):
      os.makedirs(self.base_path)
    f = open(os.path.join(self.base_path, "this.rosinstall"), "w+b")
    f.write(yaml.safe_dump(self.source))
    f.close()
    
  def execute_install(self):
    if not os.path.exists(self.base_path):
      os.mkdir(self.base_path)
    for t in self.trees:
      if not t.install():
        raise ROSInstallException("Failed to install tree '%s'\n vcs not setup correctly"%t.get_name())
        
  # TODO go back and make sure that everything in options.path is described
  # in the yaml, and offer to delete otherwise? not sure, but it could go here



  def get_ros_package_path(self):
    """ Return the simplifed ROS_PACKAGE_PATH """
    code_trees = []
    for t in self.trees:
      if t.get_name() != 'ros':
        code_trees.append(t.get_path())
    code_trees.reverse()
    rpp = ':'.join(set(code_trees))
    return rpp
    
  
  def generate_include_setup_text(self, filename):
    rpp = self.get_ros_package_path()
    text = ""
    text += "source %s\n" % filename
    text += "export ROS_PACKAGE_PATH=%s:$ROS_PACKAGE_PATH\n" % rpp
    return text

  def generate_full_setup_text(self, ros_root, ros_package_path):
    # overlay or standard
    text = ""
    text += "export ROS_ROOT=%s\n" % ros_root
    text += "export PATH=$ROS_ROOT/bin:$PATH\n" # might include it twice
    text += "export PYTHONPATH=$ROS_ROOT/core/roslib/src:$PYTHONPATH\n"
    text += "if [ ! \"$ROS_MASTER_URI\" ] ; then export ROS_MASTER_URI=http://localhost:11311 ; fi\n"
    text += "export ROS_PACKAGE_PATH=%s\n" % ros_package_path
    text += "source $ROS_ROOT/tools/rosbash/rosbash\n"
    return text
    

  def get_ros_package_path_from_env(self):
    return subprocess.Popen("env | grep ROS_PACKAGE_PATH", stdout=subprocess.PIPE, shell=True, executable="/bin/bash").communicate()[0].split('=')[-1]

  def generate_setup(self, options):
    # simplest case first
    ros_root = self.ros_path()
    rpp = self.get_ros_package_path()

    text = ""
    if options.setup_file:
      if ros_root:
        print >> sys.stderr, "woah. you gave a setup file %s, but your config %s also includes a ROS stack (%s)" % (options.setup_file, self.source_uri, ros_root)
        exit(1)
      # source the file and see if we can grep it, to handle chaining / whatever
      ros_root = rosinstall.helpers.get_ros_root_from_file(options.setup_file)
      if len(ros_root) == 0:
        print >> sys.stderr, "woah. you gave a setup file %s, but that file did not set ROS_ROOT" % options.setup_file
        exit(1)
      text = self.generate_include_setup_text(options.setup_file)
    else:
      if not ros_root: # Must be an overlay if no ros_root options.overlay:
        if not 'ROS_ROOT' in os.environ:
          print >> sys.stderr, "woah. There needs to be a version of ros either in your rosinstall file(%s) or your environment (ROS_ROOT)." % (self.source_uri)
          exit(1)
        ros_root = os.environ['ROS_ROOT']
        existing_rpp = self.get_ros_package_path_from_env()
        if len(existing_rpp) > 0:
          rpp = rpp + ':' + existing_rpp
      text = self.generate_full_setup_text(ros_root, rpp)


    setup_path = os.path.join(options.path, 'setup.sh')
    with open(setup_path, 'w') as f:
      f.write(text)


## legacy for breadcrumb which will be removed shortly.
def installed_uri(path):
  try:
    f = open(os.path.join(path, '.rosinstall_source_uri'),'r')
    print "Falling back onto deprecated .rosinstall_source_uri"
  except IOError, e:
    pass
    return None
  return rosinstall.helpers.conditional_abspath(f.readline())  # abspath here for backwards compatability with change to abspath in breadcrumb

def rosinstall_main(argv):
  if len(argv) < 2:
    usage()
  args = argv[1:]
  parser = OptionParser(usage="usage: %prog PATH [URI] [options]")
  parser.add_option("-u", "--update", dest="update", default=False,
                    help="(deprecated unused)",
                    action="store_true")
  parser.add_option("-s", "--setup_file", dest="setup_file",
                    metavar="SETUP_FILE",
                    help="create environment using an existing setup file")
  parser.add_option("-o", "--overlay", dest="overlay", default=False,
                    help="(deprecated unused)",
                    action="store_true")
  parser.add_option("-n", "--nobuild", dest="nobuild", default=False,
                    help="skip the build step for the ROS stack",
                    action="store_true")
  parser.add_option("--rosdep-yes", dest="rosdep_yes", default=False,
                    help="Pass through --rosdep-yes to rosmake", 
                    action="store_true")
  (options, args) = parser.parse_args(args)
    

  # Get the path to the rosinstall 
  options.path = os.path.abspath(args[0])

  # Find out what the URI is (args, this.rosinstall, or breadcrumb(for backwards compatability)


  config_uris = []

  if os.path.exists(os.path.join(options.path, "this.rosinstall")):
    config_uris.append(os.path.join(options.path, "this.rosinstall"))
  else: ## backwards compatability to be removed in the future
    # try to read the source uri from the breadcrumb mmmm delicious
    config_uri = installed_uri(options.path)
    if config_uri:
      config_uris.append(config_uri)

  config_uris.extend(args[1:])
    
  observed_paths = {}
  aggregate_source_yaml = []
  print "rosinstall operating on", options.path, "from specifications in rosinstall files ", ", ".join(config_uris)
  for a in config_uris:
    #print "argument", a
    config_uri = rosinstall.helpers.conditional_abspath(a)
    source_yaml = rosinstall.helpers.get_yaml_from_uri(config_uri)
    #print "source yaml", source_yaml
    if source_yaml:
      for element in source_yaml:
        #print "element", element
        for k in element:
          #print "k", k
          #print "element[k]", element[k]
          if 'local-name' in element[k]:
            path = element[k]['local-name']
            if path in observed_paths:
              parser.error("local-name '%s' multiply defined, first definition in %s, second definition in %s"%(path, observed_paths[path], a))
            else:
              observed_paths[path] = a
          else:  
            parser.error("local-name must be defined for all targets, failed in %s"%a)
      aggregate_source_yaml.extend(source_yaml)
      #print "aggregated to", aggregate_source_yaml

  ## Could not get uri therefore error out
  if len(config_uris) == 0:
    parser.error( "no source rosinstall file found! looked at arguments, %s , and %s(deprecated)"%(
        os.path.join(options.path, "this.rosinstall"), os.path.join(options.path, ".rosinstall_source_uri")))

  #print "source...........................", aggregate_source_yaml

  ## Generate the config class with the uri and path
  config = Config(aggregate_source_yaml, options.path)
  if not config.is_valid():
    return -1

  ## Save this.rosinstall 
  config.write_source()
  ## Generate setup.sh and save
  config.generate_setup(options)
  ## install or update each element
  config.execute_install()
  ## bootstrap the build if installing ros
  if config.ros_path() and not (options.setup_file or options.nobuild):
    print "Bootstraping ROS build"
    if options.rosdep_yes:
      subprocess.check_call("source %s && rosmake rostest --rosdep-install --rosdep-yes" % (os.path.join(options.path, 'setup.sh')), shell=True, executable='/bin/bash')
    else:
      subprocess.check_call("source %s && rosmake rostest --rosdep-install" % (os.path.join(options.path, 'setup.sh')), shell=True, executable='/bin/bash')
  print "\ndone. Now, type 'source %s/setup.sh' to set up your environment.\nAdd that to the bottom of your ~/.bashrc to set it up every time.\n\n" % options.path
  
if __name__ == "__main__":
  try:
    sys.exit(rosinstall_main(sys.argv) or 0)
  except ROSInstallException, e:
    print >> sys.stderr, "ERROR: %s"%str(e)
    sys.exit(1)

