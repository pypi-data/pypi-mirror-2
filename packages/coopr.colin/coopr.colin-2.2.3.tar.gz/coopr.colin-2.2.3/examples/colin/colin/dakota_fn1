#! /usr/bin/env python
#
# A python script that reads an XML input file, computes a simple function,
# and writes out an XML file.
#
# function_value: a quadratic function of real, integer and binary vars
#
# gradient: compute the derivative w.r.t. real vars
#
# nonlinear_constraint_values: two constraints, which are respectively
#       quadratic functions of the real and integer vars
#

import sys
from coopr.colin import *

class Problem(OptProblem):

    def __init__(self):
        self.response_types = [response_enum.FunctionValue, \
                                response_enum.FunctionValues,\
                                response_enum.Gradient, \
                                response_enum.NonlinearConstraintValues]
        self.nreal=3
        self.nint=2
        self.nbin=4

    def function_value(self, point):
        val=0.0
        for i in range(0,self.nreal):
            val = val + (point[i] - 3.0)*(point[i] - 3.0)
        for i in range(3,self.nreal+self.nint):
            val = val + (point[i] - 2)*(point[i] - 2)
        for i in range(5,self.nreal+self.nint+self.nbin):
            val = val + (point[i] - 1)*(point[i] - 1)
        return val

    def gradient(self, point):
        val=[]
        for i in range(0,self.nreal):
            val.append( 2.0*(point[i] - 3.0) )
        return val

    def nonlinear_constraint_values(self, point):
        val=[]
        tmp=0
        for i in range(0,self.nreal):
            tmp = tmp + (point[i] - 10.0)*(point[i] - 10.0)
        val.append(tmp)
        tmp=0
        for i in range(3,self.nreal+self.nint):
            tmp = tmp + (point[i] - 10)*(point[i] - 10)
        val.append(tmp)
        return val


instance = Problem()
instance.main(sys.argv, format='dakota')
