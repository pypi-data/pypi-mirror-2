*** 42,59 ****
      def __exit__(self, _exc_type, _exc_value, _traceback):
          self.unlock()
      
-     def lock(self):
-         current_time = time.time()
-         stop_time = current_time + self.timeout
          if not os.path.exists(os.path.dirname(self.lock_file)):
              try:
                  os.makedirs(os.path.dirname(self.lock_file))
              except OSError, e:
                  if e.errno is not errno.EEXIST:
                      raise e
          while not self._locked:
              try:
-                 self._lock = lockfile.LockFile(self.lock_file)
              except lockfile.LockError, e:
                  current_time = time.time()
                  if current_time < stop_time:
--- 43,67 ----
      def __exit__(self, _exc_type, _exc_value, _traceback):
          self.unlock()
      
+     def _make_lockdir(self):
          if not os.path.exists(os.path.dirname(self.lock_file)):
              try:
                  os.makedirs(os.path.dirname(self.lock_file))
              except OSError, e:
                  if e.errno is not errno.EEXIST:
                      raise e
+     
+     def _try_lock(self):
+         return lockfile.LockFile(self.lock_file)
+     
+     def lock(self):
+         self._make_lockdir()
+         current_time = time.time()
+         stop_time = current_time + self.timeout
+ 
          while not self._locked:
              try:
+                 self._lock = self._try_lock()
              except lockfile.LockError, e:
                  current_time = time.time()
                  if current_time < stop_time:
***************
*** 90,93 ****
          except OSError, e:
              # some one might remove the file, ignore this
              if e.errno != errno.ENOENT:
-                 raise e
--- 98,122 ----
          except OSError, e:
              # some one might remove the file, ignore this
              if e.errno != errno.ENOENT:
+                 raise e
+ 
+ 
+ class SemLock(FileLock):
+     """
+     File-lock-based counting semaphore (i.e. this lock can be locked n-times).
+     """
+     def __init__(self, lock_file, n, timeout=60.0, step=0.01):
+         FileLock.__init__(self, lock_file, timeout=timeout, step=step)
+         self.n = n
+     
+     def _try_lock(self):
+         tries = 0
+         i = random.randint(0, self.n-1)
+         while True:
+             tries += 1
+             try:
+                 return lockfile.LockFile(self.lock_file + str(i))
+             except lockfile.LockError, e:
+                 if tries >= self.n:
+                     raise
+             i = (i+1) % self.n
