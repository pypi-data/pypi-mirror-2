# ./pyxb/bundles/opengis/raw/gml.py
# PyXB bindings for NM:9f63f88e34ede5a0937e0529450bd64d24b14551
# Generated 2011-09-09 14:18:49.476929 by PyXB version 1.1.3
# Namespace http://www.opengis.net/gml

import pyxb
import pyxb.binding
import pyxb.binding.saxer
import StringIO
import pyxb.utils.utility
import pyxb.utils.domutils
import sys

# Unique identifier for bindings created at the same time
_GenerationUID = pyxb.utils.utility.UniqueIdentifier('urn:uuid:8ad340a4-db18-11e0-8861-001fbc013adc')

# Import bindings for namespaces imported into schema
import pyxb.binding.datatypes
import pyxb.bundles.opengis.misc.xlinks
import pyxb.bundles.opengis.raw._nsgroup_

Namespace = pyxb.namespace.NamespaceForURI(u'http://www.opengis.net/gml', create_if_missing=True)
Namespace.configureCategories(['typeBinding', 'elementBinding'])
ModuleRecord = Namespace.lookupModuleRecordByUID(_GenerationUID, create_if_missing=True)
ModuleRecord._setModule(sys.modules[__name__])

def CreateFromDocument (xml_text, default_namespace=None, location_base=None):
    """Parse the given XML and use the document element to create a Python instance."""
    if pyxb.XMLStyle_saxer != pyxb._XMLStyle:
        dom = pyxb.utils.domutils.StringToDOM(xml_text)
        return CreateFromDOM(dom.documentElement)
    saxer = pyxb.binding.saxer.make_parser(fallback_namespace=Namespace.fallbackNamespace(), location_base=location_base)
    handler = saxer.getContentHandler()
    saxer.parse(StringIO.StringIO(xml_text))
    instance = handler.rootObject()
    return instance

def CreateFromDOM (node, default_namespace=None):
    """Create a Python instance from the given DOM node.
    The node tag must correspond to an element declaration in this module.

    @deprecated: Forcing use of DOM interface is unnecessary; use L{CreateFromDocument}."""
    if default_namespace is None:
        default_namespace = Namespace.fallbackNamespace()
    return pyxb.binding.basis.element.AnyCreateFromDOM(node, _fallback_namespace=default_namespace)


# List SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class NCNameList (pyxb.binding.basis.STD_list):

    """A set of values, representing a list of token with the lexical value space of NCName. The tokens are seperated by whitespace."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'NCNameList')
    _Documentation = u'A set of values, representing a list of token with the lexical value space of NCName. The tokens are seperated by whitespace.'

    _ItemType = pyxb.binding.datatypes.NCName
NCNameList._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', u'NCNameList', NCNameList)

# List SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class doubleList (pyxb.binding.basis.STD_list):

    """XML List based on XML Schema double type.  An element of this type contains a space-separated list of double values"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'doubleList')
    _Documentation = u'XML List based on XML Schema double type.  An element of this type contains a space-separated list of double values'

    _ItemType = pyxb.binding.datatypes.double
doubleList._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', u'doubleList', doubleList)

# List SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class integerList (pyxb.binding.basis.STD_list):

    """XML List based on XML Schema integer type.  An element of this type contains a space-separated list of integer values"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'integerList')
    _Documentation = u'XML List based on XML Schema integer type.  An element of this type contains a space-separated list of integer values'

    _ItemType = pyxb.binding.datatypes.integer
integerList._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', u'integerList', integerList)

# Union SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class CalDate (pyxb.binding.basis.STD_union):

    """Calendar dates may be indicated with varying degrees of precision, 
      using year, year-month, date. 
      When used with non-Gregorian calendars based on years, months, days, 
      the same lexical representation should still be used, with leading zeros added if the 
      year value would otherwise have fewer than four digits.  
      time is used for a position that recurs daily (see clause 5.4.4.2 of ISO 19108:2002)."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CalDate')
    _Documentation = u'Calendar dates may be indicated with varying degrees of precision, \n      using year, year-month, date. \n      When used with non-Gregorian calendars based on years, months, days, \n      the same lexical representation should still be used, with leading zeros added if the \n      year value would otherwise have fewer than four digits.  \n      time is used for a position that recurs daily (see clause 5.4.4.2 of ISO 19108:2002).'

    _MemberTypes = ( pyxb.binding.datatypes.date, pyxb.binding.datatypes.gYearMonth, pyxb.binding.datatypes.gYear, )
CalDate._CF_pattern = pyxb.binding.facets.CF_pattern()
CalDate._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=CalDate)
CalDate._InitializeFacetMap(CalDate._CF_pattern,
   CalDate._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'CalDate', CalDate)

# Atomic SimpleTypeDefinition
class CurveInterpolationType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """CurveInterpolationType is a list of codes that may be used to identify the interpolation mechanisms specified by an
application schema."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CurveInterpolationType')
    _Documentation = u'CurveInterpolationType is a list of codes that may be used to identify the interpolation mechanisms specified by an\napplication schema.'
CurveInterpolationType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=CurveInterpolationType, enum_prefix=None)
CurveInterpolationType.linear = CurveInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'linear', tag=u'linear')
CurveInterpolationType.geodesic = CurveInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'geodesic', tag=u'geodesic')
CurveInterpolationType.circularArc3Points = CurveInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'circularArc3Points', tag=u'circularArc3Points')
CurveInterpolationType.circularArc2PointWithBulge = CurveInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'circularArc2PointWithBulge', tag=u'circularArc2PointWithBulge')
CurveInterpolationType.circularArcCenterPointWithRadius = CurveInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'circularArcCenterPointWithRadius', tag=u'circularArcCenterPointWithRadius')
CurveInterpolationType.elliptical = CurveInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'elliptical', tag=u'elliptical')
CurveInterpolationType.clothoid = CurveInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'clothoid', tag=u'clothoid')
CurveInterpolationType.conic = CurveInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'conic', tag=u'conic')
CurveInterpolationType.polynomialSpline = CurveInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'polynomialSpline', tag=u'polynomialSpline')
CurveInterpolationType.cubicSpline = CurveInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'cubicSpline', tag=u'cubicSpline')
CurveInterpolationType.rationalSpline = CurveInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'rationalSpline', tag=u'rationalSpline')
CurveInterpolationType._InitializeFacetMap(CurveInterpolationType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'CurveInterpolationType', CurveInterpolationType)

# Atomic SimpleTypeDefinition
class STD_ANON (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = None
    _Documentation = None
STD_ANON._CF_pattern = pyxb.binding.facets.CF_pattern()
STD_ANON._CF_pattern.addPattern(pattern=u'other:\\w{2,}')
STD_ANON._InitializeFacetMap(STD_ANON._CF_pattern)

# Atomic SimpleTypeDefinition
class STD_ANON_ (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = None
    _Documentation = None
STD_ANON_._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_, enum_prefix=None)
STD_ANON_.inapplicable = STD_ANON_._CF_enumeration.addEnumeration(unicode_value=u'inapplicable', tag=u'inapplicable')
STD_ANON_.missing = STD_ANON_._CF_enumeration.addEnumeration(unicode_value=u'missing', tag=u'missing')
STD_ANON_.template = STD_ANON_._CF_enumeration.addEnumeration(unicode_value=u'template', tag=u'template')
STD_ANON_.unknown = STD_ANON_._CF_enumeration.addEnumeration(unicode_value=u'unknown', tag=u'unknown')
STD_ANON_.withheld = STD_ANON_._CF_enumeration.addEnumeration(unicode_value=u'withheld', tag=u'withheld')
STD_ANON_._InitializeFacetMap(STD_ANON_._CF_enumeration)

# Union SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class integerOrNull (pyxb.binding.basis.STD_union):

    """Union of the XML Schema integer type and the GML Nulltype.  An element which uses this type may have content which is either an integer or a value from Nulltype"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'integerOrNull')
    _Documentation = u'Union of the XML Schema integer type and the GML Nulltype.  An element which uses this type may have content which is either an integer or a value from Nulltype'

    _MemberTypes = ( STD_ANON_, STD_ANON, pyxb.binding.datatypes.integer, pyxb.binding.datatypes.anyURI, )
integerOrNull._CF_pattern = pyxb.binding.facets.CF_pattern()
integerOrNull._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=integerOrNull)
integerOrNull.inapplicable = u'inapplicable'      # originally STD_ANON_.inapplicable
integerOrNull.missing = u'missing'                # originally STD_ANON_.missing
integerOrNull.template = u'template'              # originally STD_ANON_.template
integerOrNull.unknown = u'unknown'                # originally STD_ANON_.unknown
integerOrNull.withheld = u'withheld'              # originally STD_ANON_.withheld
integerOrNull._InitializeFacetMap(integerOrNull._CF_pattern,
   integerOrNull._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'integerOrNull', integerOrNull)

# List SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class integerOrNullList (pyxb.binding.basis.STD_list):

    """XML List based on the union type defined above.  An element declared with this type contains a space-separated list of integer values with null values interspersed as needed"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'integerOrNullList')
    _Documentation = u'XML List based on the union type defined above.  An element declared with this type contains a space-separated list of integer values with null values interspersed as needed'

    _ItemType = integerOrNull
integerOrNullList._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', u'integerOrNullList', integerOrNullList)

# Union SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class NameOrNull (pyxb.binding.basis.STD_union):

    """Union of the XML Schema Name type and the GML Nulltype.  An element which uses this type may have content which is either a Name or a value from Nulltype.  Note that a "Name" may not contain whitespace.  """

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'NameOrNull')
    _Documentation = u'Union of the XML Schema Name type and the GML Nulltype.  An element which uses this type may have content which is either a Name or a value from Nulltype.  Note that a "Name" may not contain whitespace.  '

    _MemberTypes = ( STD_ANON_, STD_ANON, pyxb.binding.datatypes.Name, pyxb.binding.datatypes.anyURI, )
NameOrNull._CF_pattern = pyxb.binding.facets.CF_pattern()
NameOrNull._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=NameOrNull)
NameOrNull.inapplicable = u'inapplicable'         # originally STD_ANON_.inapplicable
NameOrNull.missing = u'missing'                   # originally STD_ANON_.missing
NameOrNull.template = u'template'                 # originally STD_ANON_.template
NameOrNull.unknown = u'unknown'                   # originally STD_ANON_.unknown
NameOrNull.withheld = u'withheld'                 # originally STD_ANON_.withheld
NameOrNull._InitializeFacetMap(NameOrNull._CF_pattern,
   NameOrNull._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'NameOrNull', NameOrNull)

# List SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class NameOrNullList (pyxb.binding.basis.STD_list):

    """XML List based on the union type defined above.  An element declared with this type contains a space-separated list of Name values with null values interspersed as needed"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'NameOrNullList')
    _Documentation = u'XML List based on the union type defined above.  An element declared with this type contains a space-separated list of Name values with null values interspersed as needed'

    _ItemType = NameOrNull
NameOrNullList._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', u'NameOrNullList', NameOrNullList)

# List SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class QNameList (pyxb.binding.basis.STD_list):

    """A set of values, representing a list of token with the lexical value space of QName. The tokens are seperated by whitespace."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'QNameList')
    _Documentation = u'A set of values, representing a list of token with the lexical value space of QName. The tokens are seperated by whitespace.'

    _ItemType = pyxb.binding.datatypes.QName
QNameList._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', u'QNameList', QNameList)

# Atomic SimpleTypeDefinition
class SignType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """Utility type used in various places 
      - e.g. to indicate the direction of topological objects;
      "+" for forwards, or "-" for backwards."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignType')
    _Documentation = u'Utility type used in various places \n      - e.g. to indicate the direction of topological objects;\n      "+" for forwards, or "-" for backwards.'
SignType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=SignType, enum_prefix=None)
SignType.emptyString = SignType._CF_enumeration.addEnumeration(unicode_value=u'-', tag='emptyString')
SignType.emptyString_ = SignType._CF_enumeration.addEnumeration(unicode_value=u'+', tag='emptyString_')
SignType._InitializeFacetMap(SignType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'SignType', SignType)

# Union SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class NullType (pyxb.binding.basis.STD_union):

    """Utility type for null elements.  The value may be selected from one of the enumerated tokens, or may be a URI in which case this should identify a resource which describes the reason for the null. """

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'NullType')
    _Documentation = u'Utility type for null elements.  The value may be selected from one of the enumerated tokens, or may be a URI in which case this should identify a resource which describes the reason for the null. '

    _MemberTypes = ( STD_ANON_, STD_ANON, pyxb.binding.datatypes.anyURI, )
NullType._CF_pattern = pyxb.binding.facets.CF_pattern()
NullType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=NullType)
NullType.inapplicable = u'inapplicable'           # originally STD_ANON_.inapplicable
NullType.missing = u'missing'                     # originally STD_ANON_.missing
NullType.template = u'template'                   # originally STD_ANON_.template
NullType.unknown = u'unknown'                     # originally STD_ANON_.unknown
NullType.withheld = u'withheld'                   # originally STD_ANON_.withheld
NullType._InitializeFacetMap(NullType._CF_pattern,
   NullType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'NullType', NullType)

# Atomic SimpleTypeDefinition
class DecimalMinutesType (pyxb.binding.datatypes.decimal):

    """Decimal number of arc-minutes in a degree-minute angular value."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DecimalMinutesType')
    _Documentation = u'Decimal number of arc-minutes in a degree-minute angular value.'
DecimalMinutesType._CF_maxExclusive = pyxb.binding.facets.CF_maxExclusive(value_datatype=pyxb.binding.datatypes.decimal, value=pyxb.binding.datatypes.anySimpleType(u'60.00'))
DecimalMinutesType._CF_minInclusive = pyxb.binding.facets.CF_minInclusive(value_datatype=DecimalMinutesType, value=pyxb.binding.datatypes.decimal(0.0))
DecimalMinutesType._InitializeFacetMap(DecimalMinutesType._CF_maxExclusive,
   DecimalMinutesType._CF_minInclusive)
Namespace.addCategoryObject('typeBinding', u'DecimalMinutesType', DecimalMinutesType)

# Union SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class stringOrNull (pyxb.binding.basis.STD_union):

    """Union of the XML Schema string type and the GML Nulltype.  An element which uses this type may have content which is either a string or a value from Nulltype.  Note that a "string" may contain whitespace.  """

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'stringOrNull')
    _Documentation = u'Union of the XML Schema string type and the GML Nulltype.  An element which uses this type may have content which is either a string or a value from Nulltype.  Note that a "string" may contain whitespace.  '

    _MemberTypes = ( STD_ANON_, STD_ANON, pyxb.binding.datatypes.string, pyxb.binding.datatypes.anyURI, )
stringOrNull._CF_pattern = pyxb.binding.facets.CF_pattern()
stringOrNull._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=stringOrNull)
stringOrNull.inapplicable = u'inapplicable'       # originally STD_ANON_.inapplicable
stringOrNull.missing = u'missing'                 # originally STD_ANON_.missing
stringOrNull.template = u'template'               # originally STD_ANON_.template
stringOrNull.unknown = u'unknown'                 # originally STD_ANON_.unknown
stringOrNull.withheld = u'withheld'               # originally STD_ANON_.withheld
stringOrNull._InitializeFacetMap(stringOrNull._CF_pattern,
   stringOrNull._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'stringOrNull', stringOrNull)

# Union SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class NullEnumeration (pyxb.binding.basis.STD_union):

    """ Some common reasons for a null value:   
			
        innapplicable - the object does not have a value
        missing - The correct value is not readily available to the sender of this data.  
                           Furthermore, a correct value may not exist.
        template - the value will be available later
        unknown - The correct value is not known to, and not computable by, the sender of this data. 
                           However, a correct value probably exists.
        withheld - the value is not divulged 
        
        other:reason - as indicated by "reason" string
        
        Specific communities may agree to assign more strict semantics when these terms are used in a particular context.  
      """

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'NullEnumeration')
    _Documentation = u' Some common reasons for a null value:   \n\t\t\t\n        innapplicable - the object does not have a value\n        missing - The correct value is not readily available to the sender of this data.  \n                           Furthermore, a correct value may not exist.\n        template - the value will be available later\n        unknown - The correct value is not known to, and not computable by, the sender of this data. \n                           However, a correct value probably exists.\n        withheld - the value is not divulged \n        \n        other:reason - as indicated by "reason" string\n        \n        Specific communities may agree to assign more strict semantics when these terms are used in a particular context.  \n      '

    _MemberTypes = ( STD_ANON_, STD_ANON, )
NullEnumeration._CF_pattern = pyxb.binding.facets.CF_pattern()
NullEnumeration._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=NullEnumeration)
NullEnumeration.inapplicable = u'inapplicable'    # originally STD_ANON_.inapplicable
NullEnumeration.missing = u'missing'              # originally STD_ANON_.missing
NullEnumeration.template = u'template'            # originally STD_ANON_.template
NullEnumeration.unknown = u'unknown'              # originally STD_ANON_.unknown
NullEnumeration.withheld = u'withheld'            # originally STD_ANON_.withheld
NullEnumeration._InitializeFacetMap(NullEnumeration._CF_pattern,
   NullEnumeration._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'NullEnumeration', NullEnumeration)

# Atomic SimpleTypeDefinition
class FileValueModelType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """List of codes that identifies the file structure model for records stored in files."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'FileValueModelType')
    _Documentation = u'List of codes that identifies the file structure model for records stored in files.'
FileValueModelType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=FileValueModelType, enum_prefix=None)
FileValueModelType.Record_Interleaved = FileValueModelType._CF_enumeration.addEnumeration(unicode_value=u'Record Interleaved', tag=u'Record_Interleaved')
FileValueModelType._InitializeFacetMap(FileValueModelType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'FileValueModelType', FileValueModelType)

# Atomic SimpleTypeDefinition
class ArcSecondsType (pyxb.binding.datatypes.decimal):

    """Number of arc-seconds in a degree-minute-second angular value."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ArcSecondsType')
    _Documentation = u'Number of arc-seconds in a degree-minute-second angular value.'
ArcSecondsType._CF_maxExclusive = pyxb.binding.facets.CF_maxExclusive(value_datatype=pyxb.binding.datatypes.decimal, value=pyxb.binding.datatypes.anySimpleType(u'60.00'))
ArcSecondsType._CF_minInclusive = pyxb.binding.facets.CF_minInclusive(value_datatype=ArcSecondsType, value=pyxb.binding.datatypes.decimal(0.0))
ArcSecondsType._InitializeFacetMap(ArcSecondsType._CF_maxExclusive,
   ArcSecondsType._CF_minInclusive)
Namespace.addCategoryObject('typeBinding', u'ArcSecondsType', ArcSecondsType)

# Atomic SimpleTypeDefinition
class STD_ANON_2 (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = None
    _Documentation = None
STD_ANON_2._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_2, enum_prefix=None)
STD_ANON_2.N = STD_ANON_2._CF_enumeration.addEnumeration(unicode_value=u'N', tag=u'N')
STD_ANON_2.E = STD_ANON_2._CF_enumeration.addEnumeration(unicode_value=u'E', tag=u'E')
STD_ANON_2.S = STD_ANON_2._CF_enumeration.addEnumeration(unicode_value=u'S', tag=u'S')
STD_ANON_2.W = STD_ANON_2._CF_enumeration.addEnumeration(unicode_value=u'W', tag=u'W')
STD_ANON_2._InitializeFacetMap(STD_ANON_2._CF_enumeration)

# Atomic SimpleTypeDefinition
class STD_ANON_3 (SignType):

    """An atomic simple type."""

    _ExpandedName = None
    _Documentation = None
STD_ANON_3._InitializeFacetMap()

# Union SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class STD_ANON_4 (pyxb.binding.basis.STD_union):

    """Simple type that is a union of STD_ANON_2, STD_ANON_3."""

    _ExpandedName = None
    _Documentation = None

    _MemberTypes = ( STD_ANON_2, STD_ANON_3, )
STD_ANON_4._CF_pattern = pyxb.binding.facets.CF_pattern()
STD_ANON_4._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_4)
STD_ANON_4.N = u'N'                               # originally STD_ANON_2.N
STD_ANON_4.E = u'E'                               # originally STD_ANON_2.E
STD_ANON_4.S = u'S'                               # originally STD_ANON_2.S
STD_ANON_4.W = u'W'                               # originally STD_ANON_2.W
STD_ANON_4.emptyString = u'-'                     # originally SignType.emptyString
STD_ANON_4.emptyString_ = u'+'                    # originally SignType.emptyString_
STD_ANON_4._InitializeFacetMap(STD_ANON_4._CF_pattern,
   STD_ANON_4._CF_enumeration)

# Atomic SimpleTypeDefinition
class DegreeValueType (pyxb.binding.datatypes.nonNegativeInteger):

    """Integer number of degrees in a degree-minute-second or degree-minute angular value, without indication of direction."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DegreeValueType')
    _Documentation = u'Integer number of degrees in a degree-minute-second or degree-minute angular value, without indication of direction.'
DegreeValueType._CF_maxInclusive = pyxb.binding.facets.CF_maxInclusive(value_datatype=DegreeValueType, value=pyxb.binding.datatypes.nonNegativeInteger(359L))
DegreeValueType._InitializeFacetMap(DegreeValueType._CF_maxInclusive)
Namespace.addCategoryObject('typeBinding', u'DegreeValueType', DegreeValueType)

# Atomic SimpleTypeDefinition
class STD_ANON_5 (pyxb.binding.datatypes.double):

    """An atomic simple type."""

    _ExpandedName = None
    _Documentation = None
STD_ANON_5._InitializeFacetMap()

# Atomic SimpleTypeDefinition
class STD_ANON_6 (pyxb.binding.datatypes.double):

    """An atomic simple type."""

    _ExpandedName = None
    _Documentation = None
STD_ANON_6._InitializeFacetMap()

# Union SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class doubleOrNull (pyxb.binding.basis.STD_union):

    """Union of the XML Schema double type and the GML Nulltype.  An element which uses this type may have content which is either a double or a value from Nulltype"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'doubleOrNull')
    _Documentation = u'Union of the XML Schema double type and the GML Nulltype.  An element which uses this type may have content which is either a double or a value from Nulltype'

    _MemberTypes = ( STD_ANON_, STD_ANON, pyxb.binding.datatypes.double, pyxb.binding.datatypes.anyURI, )
doubleOrNull._CF_pattern = pyxb.binding.facets.CF_pattern()
doubleOrNull._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=doubleOrNull)
doubleOrNull.inapplicable = u'inapplicable'       # originally STD_ANON_.inapplicable
doubleOrNull.missing = u'missing'                 # originally STD_ANON_.missing
doubleOrNull.template = u'template'               # originally STD_ANON_.template
doubleOrNull.unknown = u'unknown'                 # originally STD_ANON_.unknown
doubleOrNull.withheld = u'withheld'               # originally STD_ANON_.withheld
doubleOrNull._InitializeFacetMap(doubleOrNull._CF_pattern,
   doubleOrNull._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'doubleOrNull', doubleOrNull)

# List SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class doubleOrNullList (pyxb.binding.basis.STD_list):

    """XML List based on the union type defined above.  An element declared with this type contains a space-separated list of double values with null values interspersed as needed"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'doubleOrNullList')
    _Documentation = u'XML List based on the union type defined above.  An element declared with this type contains a space-separated list of double values with null values interspersed as needed'

    _ItemType = doubleOrNull
doubleOrNullList._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', u'doubleOrNullList', doubleOrNullList)

# Atomic SimpleTypeDefinition
class STD_ANON_7 (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = None
    _Documentation = None
STD_ANON_7._CF_pattern = pyxb.binding.facets.CF_pattern()
STD_ANON_7._CF_pattern.addPattern(pattern=u'other:\\w{2,}')
STD_ANON_7._InitializeFacetMap(STD_ANON_7._CF_pattern)

# Atomic SimpleTypeDefinition
class STD_ANON_8 (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = None
    _Documentation = None
STD_ANON_8._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_8, enum_prefix=None)
STD_ANON_8.year = STD_ANON_8._CF_enumeration.addEnumeration(unicode_value=u'year', tag=u'year')
STD_ANON_8.day = STD_ANON_8._CF_enumeration.addEnumeration(unicode_value=u'day', tag=u'day')
STD_ANON_8.hour = STD_ANON_8._CF_enumeration.addEnumeration(unicode_value=u'hour', tag=u'hour')
STD_ANON_8.minute = STD_ANON_8._CF_enumeration.addEnumeration(unicode_value=u'minute', tag=u'minute')
STD_ANON_8.second = STD_ANON_8._CF_enumeration.addEnumeration(unicode_value=u'second', tag=u'second')
STD_ANON_8._InitializeFacetMap(STD_ANON_8._CF_enumeration)

# Union SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class TimeUnitType (pyxb.binding.basis.STD_union):

    """Standard units for measuring time intervals (see ISO 31-1)."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeUnitType')
    _Documentation = u'Standard units for measuring time intervals (see ISO 31-1).'

    _MemberTypes = ( STD_ANON_8, STD_ANON_7, )
TimeUnitType._CF_pattern = pyxb.binding.facets.CF_pattern()
TimeUnitType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=TimeUnitType)
TimeUnitType.year = u'year'                       # originally STD_ANON_8.year
TimeUnitType.day = u'day'                         # originally STD_ANON_8.day
TimeUnitType.hour = u'hour'                       # originally STD_ANON_8.hour
TimeUnitType.minute = u'minute'                   # originally STD_ANON_8.minute
TimeUnitType.second = u'second'                   # originally STD_ANON_8.second
TimeUnitType._InitializeFacetMap(TimeUnitType._CF_pattern,
   TimeUnitType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'TimeUnitType', TimeUnitType)

# Atomic SimpleTypeDefinition
class KnotTypesType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """Defines allowed values for the knots` type. Uniform knots implies that all knots are of multiplicity 1 and they differ by a positive constant from the preceding knot. Knots are quasi-uniform iff they are of multiplicity (degree + 1) at the ends, of multiplicity 1 elsewhere, and they differ by a positive constant from the preceding knot."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'KnotTypesType')
    _Documentation = u'Defines allowed values for the knots` type. Uniform knots implies that all knots are of multiplicity 1 and they differ by a positive constant from the preceding knot. Knots are quasi-uniform iff they are of multiplicity (degree + 1) at the ends, of multiplicity 1 elsewhere, and they differ by a positive constant from the preceding knot.'
KnotTypesType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=KnotTypesType, enum_prefix=None)
KnotTypesType.uniform = KnotTypesType._CF_enumeration.addEnumeration(unicode_value=u'uniform', tag=u'uniform')
KnotTypesType.quasiUniform = KnotTypesType._CF_enumeration.addEnumeration(unicode_value=u'quasiUniform', tag=u'quasiUniform')
KnotTypesType.piecewiseBezier = KnotTypesType._CF_enumeration.addEnumeration(unicode_value=u'piecewiseBezier', tag=u'piecewiseBezier')
KnotTypesType._InitializeFacetMap(KnotTypesType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'KnotTypesType', KnotTypesType)

# Atomic SimpleTypeDefinition
class TimeIndeterminateValueType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """This enumerated data type specifies values for indeterminate positions."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeIndeterminateValueType')
    _Documentation = u'This enumerated data type specifies values for indeterminate positions.'
TimeIndeterminateValueType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=TimeIndeterminateValueType, enum_prefix=None)
TimeIndeterminateValueType.after = TimeIndeterminateValueType._CF_enumeration.addEnumeration(unicode_value=u'after', tag=u'after')
TimeIndeterminateValueType.before = TimeIndeterminateValueType._CF_enumeration.addEnumeration(unicode_value=u'before', tag=u'before')
TimeIndeterminateValueType.now = TimeIndeterminateValueType._CF_enumeration.addEnumeration(unicode_value=u'now', tag=u'now')
TimeIndeterminateValueType.unknown = TimeIndeterminateValueType._CF_enumeration.addEnumeration(unicode_value=u'unknown', tag=u'unknown')
TimeIndeterminateValueType._InitializeFacetMap(TimeIndeterminateValueType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'TimeIndeterminateValueType', TimeIndeterminateValueType)

# Union SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class TimePositionUnion (pyxb.binding.basis.STD_union):

    """The ISO 19108:2002 hierarchy of subtypes for temporal position are collapsed 
      by defining a union of XML Schema simple types for indicating temporal position relative 
      to a specific reference system. 
      
      Dates and dateTime may be indicated with varying degrees of precision.  
      dateTime by itself does not allow right-truncation, except for fractions of seconds. 
      When used with non-Gregorian calendars based on years, months, days, 
      the same lexical representation should still be used, with leading zeros added if the 
      year value would otherwise have fewer than four digits.  
      
      An ordinal position may be referenced via URI identifying the definition of an ordinal era.  
      
      A time coordinate value is indicated as a decimal (e.g. UNIX time, GPS calendar)."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimePositionUnion')
    _Documentation = u'The ISO 19108:2002 hierarchy of subtypes for temporal position are collapsed \n      by defining a union of XML Schema simple types for indicating temporal position relative \n      to a specific reference system. \n      \n      Dates and dateTime may be indicated with varying degrees of precision.  \n      dateTime by itself does not allow right-truncation, except for fractions of seconds. \n      When used with non-Gregorian calendars based on years, months, days, \n      the same lexical representation should still be used, with leading zeros added if the \n      year value would otherwise have fewer than four digits.  \n      \n      An ordinal position may be referenced via URI identifying the definition of an ordinal era.  \n      \n      A time coordinate value is indicated as a decimal (e.g. UNIX time, GPS calendar).'

    _MemberTypes = ( pyxb.binding.datatypes.date, pyxb.binding.datatypes.gYearMonth, pyxb.binding.datatypes.gYear, pyxb.binding.datatypes.time, pyxb.binding.datatypes.dateTime, pyxb.binding.datatypes.anyURI, pyxb.binding.datatypes.decimal, )
TimePositionUnion._CF_pattern = pyxb.binding.facets.CF_pattern()
TimePositionUnion._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=TimePositionUnion)
TimePositionUnion._InitializeFacetMap(TimePositionUnion._CF_pattern,
   TimePositionUnion._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'TimePositionUnion', TimePositionUnion)

# List SimpleTypeDefinition
# superclasses integerOrNullList
class CountExtentType (pyxb.binding.basis.STD_list):

    """Restriction of list type to store a 2-point range of frequency values. If one member is a null, then this is a single ended interval."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CountExtentType')
    _Documentation = u'Restriction of list type to store a 2-point range of frequency values. If one member is a null, then this is a single ended interval.'

    _ItemType = integerOrNull
CountExtentType._CF_length = pyxb.binding.facets.CF_length(value=pyxb.binding.datatypes.nonNegativeInteger(2L))
CountExtentType._InitializeFacetMap(CountExtentType._CF_length)
Namespace.addCategoryObject('typeBinding', u'CountExtentType', CountExtentType)

# Union SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class booleanOrNull (pyxb.binding.basis.STD_union):

    """Union of the XML Schema boolean type and the GML Nulltype.  An element which uses this type may have content which is either a boolean {0,1,true,false} or a value from Nulltype"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'booleanOrNull')
    _Documentation = u'Union of the XML Schema boolean type and the GML Nulltype.  An element which uses this type may have content which is either a boolean {0,1,true,false} or a value from Nulltype'

    _MemberTypes = ( STD_ANON_, STD_ANON, pyxb.binding.datatypes.boolean, pyxb.binding.datatypes.anyURI, )
booleanOrNull._CF_pattern = pyxb.binding.facets.CF_pattern()
booleanOrNull._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=booleanOrNull)
booleanOrNull.inapplicable = u'inapplicable'      # originally STD_ANON_.inapplicable
booleanOrNull.missing = u'missing'                # originally STD_ANON_.missing
booleanOrNull.template = u'template'              # originally STD_ANON_.template
booleanOrNull.unknown = u'unknown'                # originally STD_ANON_.unknown
booleanOrNull.withheld = u'withheld'              # originally STD_ANON_.withheld
booleanOrNull._InitializeFacetMap(booleanOrNull._CF_pattern,
   booleanOrNull._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'booleanOrNull', booleanOrNull)

# List SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class booleanOrNullList (pyxb.binding.basis.STD_list):

    """XML List based on the union type defined above.  An element declared with this type contains a space-separated list of boolean values {0,1,true,false} with null values interspersed as needed"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'booleanOrNullList')
    _Documentation = u'XML List based on the union type defined above.  An element declared with this type contains a space-separated list of boolean values {0,1,true,false} with null values interspersed as needed'

    _ItemType = booleanOrNull
booleanOrNullList._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', u'booleanOrNullList', booleanOrNullList)

# Atomic SimpleTypeDefinition
class STD_ANON_9 (pyxb.binding.datatypes.double):

    """An atomic simple type."""

    _ExpandedName = None
    _Documentation = None
STD_ANON_9._InitializeFacetMap()

# Atomic SimpleTypeDefinition
class LineTypeType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """Graph-specific styling property."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LineTypeType')
    _Documentation = u'Graph-specific styling property.'
LineTypeType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=LineTypeType, enum_prefix=None)
LineTypeType.STRAIGHT = LineTypeType._CF_enumeration.addEnumeration(unicode_value=u'STRAIGHT', tag=u'STRAIGHT')
LineTypeType.BENT = LineTypeType._CF_enumeration.addEnumeration(unicode_value=u'BENT', tag=u'BENT')
LineTypeType._InitializeFacetMap(LineTypeType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'LineTypeType', LineTypeType)

# Atomic SimpleTypeDefinition
class SymbolTypeEnumeration (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """Used to specify the type of the symbol used."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SymbolTypeEnumeration')
    _Documentation = u'Used to specify the type of the symbol used.'
SymbolTypeEnumeration._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=SymbolTypeEnumeration, enum_prefix=None)
SymbolTypeEnumeration.svg = SymbolTypeEnumeration._CF_enumeration.addEnumeration(unicode_value=u'svg', tag=u'svg')
SymbolTypeEnumeration.xpath = SymbolTypeEnumeration._CF_enumeration.addEnumeration(unicode_value=u'xpath', tag=u'xpath')
SymbolTypeEnumeration.other = SymbolTypeEnumeration._CF_enumeration.addEnumeration(unicode_value=u'other', tag=u'other')
SymbolTypeEnumeration._InitializeFacetMap(SymbolTypeEnumeration._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'SymbolTypeEnumeration', SymbolTypeEnumeration)

# Atomic SimpleTypeDefinition
class AesheticCriteriaType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """Graph-specific styling property."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AesheticCriteriaType')
    _Documentation = u'Graph-specific styling property.'
AesheticCriteriaType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=AesheticCriteriaType, enum_prefix=None)
AesheticCriteriaType.MIN_CROSSINGS = AesheticCriteriaType._CF_enumeration.addEnumeration(unicode_value=u'MIN_CROSSINGS', tag=u'MIN_CROSSINGS')
AesheticCriteriaType.MIN_AREA = AesheticCriteriaType._CF_enumeration.addEnumeration(unicode_value=u'MIN_AREA', tag=u'MIN_AREA')
AesheticCriteriaType.MIN_BENDS = AesheticCriteriaType._CF_enumeration.addEnumeration(unicode_value=u'MIN_BENDS', tag=u'MIN_BENDS')
AesheticCriteriaType.MAX_BENDS = AesheticCriteriaType._CF_enumeration.addEnumeration(unicode_value=u'MAX_BENDS', tag=u'MAX_BENDS')
AesheticCriteriaType.UNIFORM_BENDS = AesheticCriteriaType._CF_enumeration.addEnumeration(unicode_value=u'UNIFORM_BENDS', tag=u'UNIFORM_BENDS')
AesheticCriteriaType.MIN_SLOPES = AesheticCriteriaType._CF_enumeration.addEnumeration(unicode_value=u'MIN_SLOPES', tag=u'MIN_SLOPES')
AesheticCriteriaType.MIN_EDGE_LENGTH = AesheticCriteriaType._CF_enumeration.addEnumeration(unicode_value=u'MIN_EDGE_LENGTH', tag=u'MIN_EDGE_LENGTH')
AesheticCriteriaType.MAX_EDGE_LENGTH = AesheticCriteriaType._CF_enumeration.addEnumeration(unicode_value=u'MAX_EDGE_LENGTH', tag=u'MAX_EDGE_LENGTH')
AesheticCriteriaType.UNIFORM_EDGE_LENGTH = AesheticCriteriaType._CF_enumeration.addEnumeration(unicode_value=u'UNIFORM_EDGE_LENGTH', tag=u'UNIFORM_EDGE_LENGTH')
AesheticCriteriaType.MAX_ANGULAR_RESOLUTION = AesheticCriteriaType._CF_enumeration.addEnumeration(unicode_value=u'MAX_ANGULAR_RESOLUTION', tag=u'MAX_ANGULAR_RESOLUTION')
AesheticCriteriaType.MIN_ASPECT_RATIO = AesheticCriteriaType._CF_enumeration.addEnumeration(unicode_value=u'MIN_ASPECT_RATIO', tag=u'MIN_ASPECT_RATIO')
AesheticCriteriaType.MAX_SYMMETRIES = AesheticCriteriaType._CF_enumeration.addEnumeration(unicode_value=u'MAX_SYMMETRIES', tag=u'MAX_SYMMETRIES')
AesheticCriteriaType._InitializeFacetMap(AesheticCriteriaType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'AesheticCriteriaType', AesheticCriteriaType)

# Atomic SimpleTypeDefinition
class ArcMinutesType (pyxb.binding.datatypes.nonNegativeInteger):

    """Integer number of arc-minutes in a degree-minute-second angular value."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ArcMinutesType')
    _Documentation = u'Integer number of arc-minutes in a degree-minute-second angular value.'
ArcMinutesType._CF_maxInclusive = pyxb.binding.facets.CF_maxInclusive(value_datatype=ArcMinutesType, value=pyxb.binding.datatypes.nonNegativeInteger(59L))
ArcMinutesType._InitializeFacetMap(ArcMinutesType._CF_maxInclusive)
Namespace.addCategoryObject('typeBinding', u'ArcMinutesType', ArcMinutesType)

# Atomic SimpleTypeDefinition
class STD_ANON_10 (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = None
    _Documentation = None
STD_ANON_10._InitializeFacetMap()

# Atomic SimpleTypeDefinition
class STD_ANON_11 (pyxb.binding.datatypes.double):

    """An atomic simple type."""

    _ExpandedName = None
    _Documentation = None
STD_ANON_11._InitializeFacetMap()

# Atomic SimpleTypeDefinition
class GraphTypeType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """Graph-specific styling property."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GraphTypeType')
    _Documentation = u'Graph-specific styling property.'
GraphTypeType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=GraphTypeType, enum_prefix=None)
GraphTypeType.TREE = GraphTypeType._CF_enumeration.addEnumeration(unicode_value=u'TREE', tag=u'TREE')
GraphTypeType.BICONNECTED = GraphTypeType._CF_enumeration.addEnumeration(unicode_value=u'BICONNECTED', tag=u'BICONNECTED')
GraphTypeType._InitializeFacetMap(GraphTypeType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'GraphTypeType', GraphTypeType)

# List SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class booleanList (pyxb.binding.basis.STD_list):

    """XML List based on XML Schema boolean type.  An element of this type contains a space-separated list of boolean values {0,1,true,false}"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'booleanList')
    _Documentation = u'XML List based on XML Schema boolean type.  An element of this type contains a space-separated list of boolean values {0,1,true,false}'

    _ItemType = pyxb.binding.datatypes.boolean
booleanList._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', u'booleanList', booleanList)

# Atomic SimpleTypeDefinition
class QueryGrammarEnumeration (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """Used to specify the grammar of the feature query mechanism."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'QueryGrammarEnumeration')
    _Documentation = u'Used to specify the grammar of the feature query mechanism.'
QueryGrammarEnumeration._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=QueryGrammarEnumeration, enum_prefix=None)
QueryGrammarEnumeration.xpath = QueryGrammarEnumeration._CF_enumeration.addEnumeration(unicode_value=u'xpath', tag=u'xpath')
QueryGrammarEnumeration.xquery = QueryGrammarEnumeration._CF_enumeration.addEnumeration(unicode_value=u'xquery', tag=u'xquery')
QueryGrammarEnumeration.other = QueryGrammarEnumeration._CF_enumeration.addEnumeration(unicode_value=u'other', tag=u'other')
QueryGrammarEnumeration._InitializeFacetMap(QueryGrammarEnumeration._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'QueryGrammarEnumeration', QueryGrammarEnumeration)

# Atomic SimpleTypeDefinition
class DrawingTypeType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """Graph-specific styling property."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DrawingTypeType')
    _Documentation = u'Graph-specific styling property.'
DrawingTypeType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=DrawingTypeType, enum_prefix=None)
DrawingTypeType.POLYLINE = DrawingTypeType._CF_enumeration.addEnumeration(unicode_value=u'POLYLINE', tag=u'POLYLINE')
DrawingTypeType.ORTHOGONAL = DrawingTypeType._CF_enumeration.addEnumeration(unicode_value=u'ORTHOGONAL', tag=u'ORTHOGONAL')
DrawingTypeType._InitializeFacetMap(DrawingTypeType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'DrawingTypeType', DrawingTypeType)

# Atomic SimpleTypeDefinition
class SurfaceInterpolationType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """SurfaceInterpolationType is a list of codes that may be used to identify the interpolation mechanisms specified by an
application schema."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SurfaceInterpolationType')
    _Documentation = u'SurfaceInterpolationType is a list of codes that may be used to identify the interpolation mechanisms specified by an\napplication schema.'
SurfaceInterpolationType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=SurfaceInterpolationType, enum_prefix=None)
SurfaceInterpolationType.none = SurfaceInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'none', tag=u'none')
SurfaceInterpolationType.planar = SurfaceInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'planar', tag=u'planar')
SurfaceInterpolationType.spherical = SurfaceInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'spherical', tag=u'spherical')
SurfaceInterpolationType.elliptical = SurfaceInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'elliptical', tag=u'elliptical')
SurfaceInterpolationType.conic = SurfaceInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'conic', tag=u'conic')
SurfaceInterpolationType.tin = SurfaceInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'tin', tag=u'tin')
SurfaceInterpolationType.parametricCurve = SurfaceInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'parametricCurve', tag=u'parametricCurve')
SurfaceInterpolationType.polynomialSpline = SurfaceInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'polynomialSpline', tag=u'polynomialSpline')
SurfaceInterpolationType.rationalSpline = SurfaceInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'rationalSpline', tag=u'rationalSpline')
SurfaceInterpolationType.triangulatedSpline = SurfaceInterpolationType._CF_enumeration.addEnumeration(unicode_value=u'triangulatedSpline', tag=u'triangulatedSpline')
SurfaceInterpolationType._InitializeFacetMap(SurfaceInterpolationType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'SurfaceInterpolationType', SurfaceInterpolationType)

# Atomic SimpleTypeDefinition
class STD_ANON_12 (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = None
    _Documentation = None
STD_ANON_12._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_12, enum_prefix=None)
STD_ANON_12.sphere = STD_ANON_12._CF_enumeration.addEnumeration(unicode_value=u'sphere', tag=u'sphere')
STD_ANON_12._InitializeFacetMap(STD_ANON_12._CF_enumeration)

# Atomic SimpleTypeDefinition
class SuccessionType (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """Feature succession is a semantic relationship derived from evaluation of observer, and 
			Feature Substitution, Feature Division and Feature Fusion are defined as associations between 
			previous features and next features in the temporal context. 
			Successions shall be represented in either following two ways. 
			* define a temporal topological complex element as a feature element 
			* define an association same as temporal topological complex between features."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SuccessionType')
    _Documentation = u'Feature succession is a semantic relationship derived from evaluation of observer, and \n\t\t\tFeature Substitution, Feature Division and Feature Fusion are defined as associations between \n\t\t\tprevious features and next features in the temporal context. \n\t\t\tSuccessions shall be represented in either following two ways. \n\t\t\t* define a temporal topological complex element as a feature element \n\t\t\t* define an association same as temporal topological complex between features.'
SuccessionType._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=SuccessionType, enum_prefix=None)
SuccessionType.substitution = SuccessionType._CF_enumeration.addEnumeration(unicode_value=u'substitution', tag=u'substitution')
SuccessionType.division = SuccessionType._CF_enumeration.addEnumeration(unicode_value=u'division', tag=u'division')
SuccessionType.fusion = SuccessionType._CF_enumeration.addEnumeration(unicode_value=u'fusion', tag=u'fusion')
SuccessionType.initiation = SuccessionType._CF_enumeration.addEnumeration(unicode_value=u'initiation', tag=u'initiation')
SuccessionType._InitializeFacetMap(SuccessionType._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'SuccessionType', SuccessionType)

# Atomic SimpleTypeDefinition
class STD_ANON_13 (pyxb.binding.datatypes.double):

    """An atomic simple type."""

    _ExpandedName = None
    _Documentation = None
STD_ANON_13._InitializeFacetMap()

# Atomic SimpleTypeDefinition
class STD_ANON_14 (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = None
    _Documentation = None
STD_ANON_14._InitializeFacetMap()

# Atomic SimpleTypeDefinition
class STD_ANON_15 (pyxb.binding.datatypes.double):

    """An atomic simple type."""

    _ExpandedName = None
    _Documentation = None
STD_ANON_15._InitializeFacetMap()

# Atomic SimpleTypeDefinition
class STD_ANON_16 (pyxb.binding.datatypes.double):

    """An atomic simple type."""

    _ExpandedName = None
    _Documentation = None
STD_ANON_16._InitializeFacetMap()

# Atomic SimpleTypeDefinition
class CompassPointEnumeration (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CompassPointEnumeration')
    _Documentation = None
CompassPointEnumeration._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=CompassPointEnumeration, enum_prefix=None)
CompassPointEnumeration.N = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'N', tag=u'N')
CompassPointEnumeration.NNE = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'NNE', tag=u'NNE')
CompassPointEnumeration.NE = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'NE', tag=u'NE')
CompassPointEnumeration.ENE = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'ENE', tag=u'ENE')
CompassPointEnumeration.E = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'E', tag=u'E')
CompassPointEnumeration.ESE = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'ESE', tag=u'ESE')
CompassPointEnumeration.SE = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'SE', tag=u'SE')
CompassPointEnumeration.SSE = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'SSE', tag=u'SSE')
CompassPointEnumeration.S = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'S', tag=u'S')
CompassPointEnumeration.SSW = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'SSW', tag=u'SSW')
CompassPointEnumeration.SW = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'SW', tag=u'SW')
CompassPointEnumeration.WSW = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'WSW', tag=u'WSW')
CompassPointEnumeration.W = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'W', tag=u'W')
CompassPointEnumeration.WNW = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'WNW', tag=u'WNW')
CompassPointEnumeration.NW = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'NW', tag=u'NW')
CompassPointEnumeration.NNW = CompassPointEnumeration._CF_enumeration.addEnumeration(unicode_value=u'NNW', tag=u'NNW')
CompassPointEnumeration._InitializeFacetMap(CompassPointEnumeration._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'CompassPointEnumeration', CompassPointEnumeration)

# Atomic SimpleTypeDefinition
class STD_ANON_17 (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """An atomic simple type."""

    _ExpandedName = None
    _Documentation = None
STD_ANON_17._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_17, enum_prefix=None)
STD_ANON_17.Before = STD_ANON_17._CF_enumeration.addEnumeration(unicode_value=u'Before', tag=u'Before')
STD_ANON_17.After = STD_ANON_17._CF_enumeration.addEnumeration(unicode_value=u'After', tag=u'After')
STD_ANON_17.Begins = STD_ANON_17._CF_enumeration.addEnumeration(unicode_value=u'Begins', tag=u'Begins')
STD_ANON_17.Ends = STD_ANON_17._CF_enumeration.addEnumeration(unicode_value=u'Ends', tag=u'Ends')
STD_ANON_17.During = STD_ANON_17._CF_enumeration.addEnumeration(unicode_value=u'During', tag=u'During')
STD_ANON_17.Equals = STD_ANON_17._CF_enumeration.addEnumeration(unicode_value=u'Equals', tag=u'Equals')
STD_ANON_17.Contains = STD_ANON_17._CF_enumeration.addEnumeration(unicode_value=u'Contains', tag=u'Contains')
STD_ANON_17.Overlaps = STD_ANON_17._CF_enumeration.addEnumeration(unicode_value=u'Overlaps', tag=u'Overlaps')
STD_ANON_17.Meets = STD_ANON_17._CF_enumeration.addEnumeration(unicode_value=u'Meets', tag=u'Meets')
STD_ANON_17.OverlappedBy = STD_ANON_17._CF_enumeration.addEnumeration(unicode_value=u'OverlappedBy', tag=u'OverlappedBy')
STD_ANON_17.MetBy = STD_ANON_17._CF_enumeration.addEnumeration(unicode_value=u'MetBy', tag=u'MetBy')
STD_ANON_17.BegunBy = STD_ANON_17._CF_enumeration.addEnumeration(unicode_value=u'BegunBy', tag=u'BegunBy')
STD_ANON_17.EndedBy = STD_ANON_17._CF_enumeration.addEnumeration(unicode_value=u'EndedBy', tag=u'EndedBy')
STD_ANON_17._InitializeFacetMap(STD_ANON_17._CF_enumeration)

# List SimpleTypeDefinition
# superclasses NameOrNullList
class STD_ANON_18 (pyxb.binding.basis.STD_list):

    """Simple type that is a list of NameOrNull."""

    _ExpandedName = None
    _Documentation = None

    _ItemType = NameOrNull
STD_ANON_18._CF_length = pyxb.binding.facets.CF_length(value=pyxb.binding.datatypes.nonNegativeInteger(2L))
STD_ANON_18._InitializeFacetMap(STD_ANON_18._CF_length)

# List SimpleTypeDefinition
# superclasses doubleOrNullList
class STD_ANON_19 (pyxb.binding.basis.STD_list):

    """Simple type that is a list of doubleOrNull."""

    _ExpandedName = None
    _Documentation = None

    _ItemType = doubleOrNull
STD_ANON_19._CF_length = pyxb.binding.facets.CF_length(value=pyxb.binding.datatypes.nonNegativeInteger(2L))
STD_ANON_19._InitializeFacetMap(STD_ANON_19._CF_length)

# Atomic SimpleTypeDefinition
class STD_ANON_20 (pyxb.binding.datatypes.double):

    """An atomic simple type."""

    _ExpandedName = None
    _Documentation = None
STD_ANON_20._InitializeFacetMap()

# List SimpleTypeDefinition
# superclasses pyxb.binding.datatypes.anySimpleType
class NameList (pyxb.binding.basis.STD_list):

    """XML List based on XML Schema Name type.  An element of this type contains a space-separated list of Name values"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'NameList')
    _Documentation = u'XML List based on XML Schema Name type.  An element of this type contains a space-separated list of Name values'

    _ItemType = pyxb.binding.datatypes.Name
NameList._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', u'NameList', NameList)

# Atomic SimpleTypeDefinition
class STD_ANON_21 (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = None
    _Documentation = None
STD_ANON_21._InitializeFacetMap()

# Atomic SimpleTypeDefinition
class SequenceRuleNames (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """List of codes (adopted from ISO 19123 Annex C) that identifies the rule for traversing a grid to correspond with the sequence of members of the rangeSet."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SequenceRuleNames')
    _Documentation = u'List of codes (adopted from ISO 19123 Annex C) that identifies the rule for traversing a grid to correspond with the sequence of members of the rangeSet.'
SequenceRuleNames._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=SequenceRuleNames, enum_prefix=None)
SequenceRuleNames.Linear = SequenceRuleNames._CF_enumeration.addEnumeration(unicode_value=u'Linear', tag=u'Linear')
SequenceRuleNames.Boustrophedonic = SequenceRuleNames._CF_enumeration.addEnumeration(unicode_value=u'Boustrophedonic', tag=u'Boustrophedonic')
SequenceRuleNames.Cantor_diagonal = SequenceRuleNames._CF_enumeration.addEnumeration(unicode_value=u'Cantor-diagonal', tag=u'Cantor_diagonal')
SequenceRuleNames.Spiral = SequenceRuleNames._CF_enumeration.addEnumeration(unicode_value=u'Spiral', tag=u'Spiral')
SequenceRuleNames.Morton = SequenceRuleNames._CF_enumeration.addEnumeration(unicode_value=u'Morton', tag=u'Morton')
SequenceRuleNames.Hilbert = SequenceRuleNames._CF_enumeration.addEnumeration(unicode_value=u'Hilbert', tag=u'Hilbert')
SequenceRuleNames._InitializeFacetMap(SequenceRuleNames._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'SequenceRuleNames', SequenceRuleNames)

# Atomic SimpleTypeDefinition
class IncrementOrder (pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):

    """The enumeration value here indicates the incrementation order  to be used on the first 2 axes, i.e. "+x-y" means that the points on the first axis are to be traversed from lowest to highest and  the points on the second axis are to be traversed from highest to lowest. The points on all other axes (if any) beyond the first 2 are assumed to increment from lowest to highest."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'IncrementOrder')
    _Documentation = u'The enumeration value here indicates the incrementation order  to be used on the first 2 axes, i.e. "+x-y" means that the points on the first axis are to be traversed from lowest to highest and  the points on the second axis are to be traversed from highest to lowest. The points on all other axes (if any) beyond the first 2 are assumed to increment from lowest to highest.'
IncrementOrder._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=IncrementOrder, enum_prefix=None)
IncrementOrder.xy = IncrementOrder._CF_enumeration.addEnumeration(unicode_value=u'+x+y', tag=u'xy')
IncrementOrder.yx = IncrementOrder._CF_enumeration.addEnumeration(unicode_value=u'+y+x', tag=u'yx')
IncrementOrder.x_y = IncrementOrder._CF_enumeration.addEnumeration(unicode_value=u'+x-y', tag=u'x_y')
IncrementOrder.x_y_ = IncrementOrder._CF_enumeration.addEnumeration(unicode_value=u'-x-y', tag=u'x_y_')
IncrementOrder._InitializeFacetMap(IncrementOrder._CF_enumeration)
Namespace.addCategoryObject('typeBinding', u'IncrementOrder', IncrementOrder)

# Complex type VectorType with content type SIMPLE
class VectorType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = doubleList
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VectorType')
    # Base type is doubleList
    
    # Attribute srsName uses Python identifier srsName
    __srsName = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'srsName'), 'srsName', '__httpwww_opengis_netgml_VectorType_srsName', pyxb.binding.datatypes.anyURI)
    
    srsName = property(__srsName.value, __srsName.set, None, u'In general this reference points to a CRS instance of gml:CoordinateReferenceSystemType \n\t\t\t\t(see coordinateReferenceSystems.xsd). For well known references it is not required that the CRS description exists at the \n\t\t\t\tlocation the URI points to. If no srsName attribute is given, the CRS must be specified as part of the larger context this \n\t\t\t\tgeometry element is part of, e.g. a geometric element like point, curve, etc. It is expected that this attribute will be specified \n\t\t\t\tat the direct position level only in rare cases.')

    
    # Attribute srsDimension uses Python identifier srsDimension
    __srsDimension = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'srsDimension'), 'srsDimension', '__httpwww_opengis_netgml_VectorType_srsDimension', pyxb.binding.datatypes.positiveInteger)
    
    srsDimension = property(__srsDimension.value, __srsDimension.set, None, u'The "srsDimension" is the length of coordinate sequence (the number of entries in the list). This dimension is \n\t\t\t\tspecified by the coordinate reference system. When the srsName attribute is omitted, this attribute shall be omitted.')

    
    # Attribute axisLabels uses Python identifier axisLabels
    __axisLabels = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'axisLabels'), 'axisLabels', '__httpwww_opengis_netgml_VectorType_axisLabels', NCNameList)
    
    axisLabels = property(__axisLabels.value, __axisLabels.set, None, u'Ordered list of labels for all the axes of this CRS. The gml:axisAbbrev value should be used for these axis \n\t\t\t\tlabels, after spaces and forbiddden characters are removed. When the srsName attribute is included, this attribute is optional. \n\t\t\t\tWhen the srsName attribute is omitted, this attribute shall also be omitted.')

    
    # Attribute uomLabels uses Python identifier uomLabels
    __uomLabels = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'uomLabels'), 'uomLabels', '__httpwww_opengis_netgml_VectorType_uomLabels', NCNameList)
    
    uomLabels = property(__uomLabels.value, __uomLabels.set, None, u'Ordered list of unit of measure (uom) labels for all the axes of this CRS. The value of the string in the \n\t\t\t\tgml:catalogSymbol should be used for this uom labels, after spaces and forbiddden characters are removed. When the \n\t\t\t\taxisLabels attribute is included, this attribute shall also be included. When the axisLabels attribute is omitted, this attribute \n\t\t\t\tshall also be omitted.')


    _ElementMap = {
        
    }
    _AttributeMap = {
        __srsName.name() : __srsName,
        __srsDimension.name() : __srsDimension,
        __axisLabels.name() : __axisLabels,
        __uomLabels.name() : __uomLabels
    }
Namespace.addCategoryObject('typeBinding', u'VectorType', VectorType)


# Complex type GeneralConversionRefType with content type ELEMENT_ONLY
class GeneralConversionRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeneralConversionRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_GeneralConversion uses Python identifier GeneralConversion
    __GeneralConversion = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_GeneralConversion'), 'GeneralConversion', '__httpwww_opengis_netgml_GeneralConversionRefType_httpwww_opengis_netgml_GeneralConversion', False)

    
    GeneralConversion = property(__GeneralConversion.value, __GeneralConversion.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_GeneralConversionRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_GeneralConversionRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_GeneralConversionRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_GeneralConversionRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_GeneralConversionRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_GeneralConversionRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_GeneralConversionRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_GeneralConversionRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")


    _ElementMap = {
        __GeneralConversion.name() : __GeneralConversion
    }
    _AttributeMap = {
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role,
        __href.name() : __href,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __actuate.name() : __actuate
    }
Namespace.addCategoryObject('typeBinding', u'GeneralConversionRefType', GeneralConversionRefType)


# Complex type AbstractGMLType with content type ELEMENT_ONLY
class AbstractGMLType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractGMLType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}name uses Python identifier name
    __name = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'name'), 'name', '__httpwww_opengis_netgml_AbstractGMLType_httpwww_opengis_netgmlname', True)

    
    name = property(__name.value, __name.set, None, u'Label for the object, normally a descriptive name. An object may have several names, typically assigned by different authorities.  The authority for a name is indicated by the value of its (optional) codeSpace attribute.  The name may or may not be unique, as determined by the rules of the organization responsible for the codeSpace.')

    
    # Element {http://www.opengis.net/gml}description uses Python identifier description
    __description = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'description'), 'description', '__httpwww_opengis_netgml_AbstractGMLType_httpwww_opengis_netgmldescription', False)

    
    description = property(__description.value, __description.set, None, u'Contains a simple text description of the object, or refers to an external description.')

    
    # Element {http://www.opengis.net/gml}metaDataProperty uses Python identifier metaDataProperty
    __metaDataProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'), 'metaDataProperty', '__httpwww_opengis_netgml_AbstractGMLType_httpwww_opengis_netgmlmetaDataProperty', True)

    
    metaDataProperty = property(__metaDataProperty.value, __metaDataProperty.set, None, u'Contains or refers to a metadata package that contains metadata properties.')

    
    # Attribute {http://www.opengis.net/gml}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'id'), 'id', '__httpwww_opengis_netgml_AbstractGMLType_httpwww_opengis_netgmlid', pyxb.binding.datatypes.ID)
    
    id = property(__id.value, __id.set, None, u'Database handle for the object.  It is of XML type ID, so is constrained to be unique in the XML document within which it occurs.  An external identifier for the object in the form of a URI may be constructed using standard XML and XPointer methods.  This is done by concatenating the URI for the document, a fragment separator, and the value of the id attribute.')


    _ElementMap = {
        __name.name() : __name,
        __description.name() : __description,
        __metaDataProperty.name() : __metaDataProperty
    }
    _AttributeMap = {
        __id.name() : __id
    }
Namespace.addCategoryObject('typeBinding', u'AbstractGMLType', AbstractGMLType)


# Complex type DefinitionType with content type ELEMENT_ONLY
class DefinitionType (AbstractGMLType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DefinitionType')
    # Base type is AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id is restricted from parent
    
    # Attribute {http://www.opengis.net/gml}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'id'), 'id', '__httpwww_opengis_netgml_AbstractGMLType_httpwww_opengis_netgmlid', pyxb.binding.datatypes.ID, required=True)
    
    id = property(__id.value, __id.set, None, u'Database handle for the object.  It is of XML type ID, so is constrained to be unique in the XML document within which it occurs.  An external identifier for the object in the form of a URI may be constructed using standard XML and XPointer methods.  This is done by concatenating the URI for the document, a fragment separator, and the value of the id attribute.')


    _ElementMap = AbstractGMLType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractGMLType._AttributeMap.copy()
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', u'DefinitionType', DefinitionType)


# Complex type DictionaryType with content type ELEMENT_ONLY
class DictionaryType (DefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DictionaryType')
    # Base type is DefinitionType
    
    # Element {http://www.opengis.net/gml}indirectEntry uses Python identifier indirectEntry
    __indirectEntry = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'indirectEntry'), 'indirectEntry', '__httpwww_opengis_netgml_DictionaryType_httpwww_opengis_netgmlindirectEntry', True)

    
    indirectEntry = property(__indirectEntry.value, __indirectEntry.set, None, None)

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}dictionaryEntry uses Python identifier dictionaryEntry
    __dictionaryEntry = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'dictionaryEntry'), 'dictionaryEntry', '__httpwww_opengis_netgml_DictionaryType_httpwww_opengis_netgmldictionaryEntry', True)

    
    dictionaryEntry = property(__dictionaryEntry.value, __dictionaryEntry.set, None, None)

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id_ inherited from {http://www.opengis.net/gml}DefinitionType

    _ElementMap = DefinitionType._ElementMap.copy()
    _ElementMap.update({
        __indirectEntry.name() : __indirectEntry,
        __dictionaryEntry.name() : __dictionaryEntry
    })
    _AttributeMap = DefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'DictionaryType', DictionaryType)


# Complex type MeasureType with content type SIMPLE
class MeasureType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = pyxb.binding.datatypes.double
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MeasureType')
    # Base type is pyxb.binding.datatypes.double
    
    # Attribute uom uses Python identifier uom
    __uom = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'uom'), 'uom', '__httpwww_opengis_netgml_MeasureType_uom', pyxb.binding.datatypes.anyURI, required=True)
    
    uom = property(__uom.value, __uom.set, None, None)


    _ElementMap = {
        
    }
    _AttributeMap = {
        __uom.name() : __uom
    }
Namespace.addCategoryObject('typeBinding', u'MeasureType', MeasureType)


# Complex type AngleType with content type SIMPLE
class AngleType (MeasureType):
    _TypeDefinition = STD_ANON_11
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AngleType')
    # Base type is MeasureType
    
    # Attribute uom inherited from {http://www.opengis.net/gml}MeasureType

    _ElementMap = MeasureType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = MeasureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AngleType', AngleType)


# Complex type TemporalDatumRefType with content type ELEMENT_ONLY
class TemporalDatumRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TemporalDatumRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TemporalDatum uses Python identifier TemporalDatum
    __TemporalDatum = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TemporalDatum'), 'TemporalDatum', '__httpwww_opengis_netgml_TemporalDatumRefType_httpwww_opengis_netgmlTemporalDatum', False)

    
    TemporalDatum = property(__TemporalDatum.value, __TemporalDatum.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_TemporalDatumRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_TemporalDatumRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_TemporalDatumRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_TemporalDatumRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_TemporalDatumRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_TemporalDatumRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_TemporalDatumRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_TemporalDatumRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")


    _ElementMap = {
        __TemporalDatum.name() : __TemporalDatum
    }
    _AttributeMap = {
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __href.name() : __href,
        __show.name() : __show
    }
Namespace.addCategoryObject('typeBinding', u'TemporalDatumRefType', TemporalDatumRefType)


# Complex type LocationPropertyType with content type ELEMENT_ONLY
class LocationPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LocationPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_Geometry uses Python identifier Geometry
    __Geometry = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_Geometry'), 'Geometry', '__httpwww_opengis_netgml_LocationPropertyType_httpwww_opengis_netgml_Geometry', False)

    
    Geometry = property(__Geometry.value, __Geometry.set, None, u'The "_Geometry" element is the abstract head of the substituition group for all geometry elements of GML 3. This \n\t\t\tincludes pre-defined and user-defined geometry elements. Any geometry element must be a direct or indirect extension/restriction \n\t\t\tof AbstractGeometryType and must be directly or indirectly in the substitution group of "_Geometry".')

    
    # Element {http://www.opengis.net/gml}Null uses Python identifier Null
    __Null = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Null'), 'Null', '__httpwww_opengis_netgml_LocationPropertyType_httpwww_opengis_netgmlNull', False)

    
    Null = property(__Null.value, __Null.set, None, None)

    
    # Element {http://www.opengis.net/gml}LocationKeyWord uses Python identifier LocationKeyWord
    __LocationKeyWord = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'LocationKeyWord'), 'LocationKeyWord', '__httpwww_opengis_netgml_LocationPropertyType_httpwww_opengis_netgmlLocationKeyWord', False)

    
    LocationKeyWord = property(__LocationKeyWord.value, __LocationKeyWord.set, None, None)

    
    # Element {http://www.opengis.net/gml}LocationString uses Python identifier LocationString
    __LocationString = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'LocationString'), 'LocationString', '__httpwww_opengis_netgml_LocationPropertyType_httpwww_opengis_netgmlLocationString', False)

    
    LocationString = property(__LocationString.value, __LocationString.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_LocationPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_LocationPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_LocationPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_LocationPropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_LocationPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_LocationPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_LocationPropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_LocationPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')


    _ElementMap = {
        __Geometry.name() : __Geometry,
        __Null.name() : __Null,
        __LocationKeyWord.name() : __LocationKeyWord,
        __LocationString.name() : __LocationString
    }
    _AttributeMap = {
        __arcrole.name() : __arcrole,
        __href.name() : __href,
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema
    }
Namespace.addCategoryObject('typeBinding', u'LocationPropertyType', LocationPropertyType)


# Complex type AbstractTopologyType with content type ELEMENT_ONLY
class AbstractTopologyType (AbstractGMLType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractTopologyType')
    # Base type is AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractGMLType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractGMLType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractTopologyType', AbstractTopologyType)


# Complex type AbstractTopoPrimitiveType with content type ELEMENT_ONLY
class AbstractTopoPrimitiveType (AbstractTopologyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractTopoPrimitiveType')
    # Base type is AbstractTopologyType
    
    # Element {http://www.opengis.net/gml}isolated uses Python identifier isolated
    __isolated = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'isolated'), 'isolated', '__httpwww_opengis_netgml_AbstractTopoPrimitiveType_httpwww_opengis_netgmlisolated', True)

    
    isolated = property(__isolated.value, __isolated.set, None, u'')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}container uses Python identifier container
    __container = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'container'), 'container', '__httpwww_opengis_netgml_AbstractTopoPrimitiveType_httpwww_opengis_netgmlcontainer', False)

    
    container = property(__container.value, __container.set, None, u'')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTopologyType._ElementMap.copy()
    _ElementMap.update({
        __isolated.name() : __isolated,
        __container.name() : __container
    })
    _AttributeMap = AbstractTopologyType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractTopoPrimitiveType', AbstractTopoPrimitiveType)


# Complex type FaceType with content type ELEMENT_ONLY
class FaceType (AbstractTopoPrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'FaceType')
    # Base type is AbstractTopoPrimitiveType
    
    # Element {http://www.opengis.net/gml}surfaceProperty uses Python identifier surfaceProperty
    __surfaceProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'surfaceProperty'), 'surfaceProperty', '__httpwww_opengis_netgml_FaceType_httpwww_opengis_netgmlsurfaceProperty', False)

    
    surfaceProperty = property(__surfaceProperty.value, __surfaceProperty.set, None, u'This property element either references a surface via the XLink-attributes or contains the surface element. surfaceProperty is the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that is substitutable for _Surface.')

    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}directedEdge uses Python identifier directedEdge
    __directedEdge = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'), 'directedEdge', '__httpwww_opengis_netgml_FaceType_httpwww_opengis_netgmldirectedEdge', True)

    
    directedEdge = property(__directedEdge.value, __directedEdge.set, None, u'')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element container ({http://www.opengis.net/gml}container) inherited from {http://www.opengis.net/gml}AbstractTopoPrimitiveType
    
    # Element isolated ({http://www.opengis.net/gml}isolated) inherited from {http://www.opengis.net/gml}AbstractTopoPrimitiveType
    
    # Element {http://www.opengis.net/gml}directedTopoSolid uses Python identifier directedTopoSolid
    __directedTopoSolid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'directedTopoSolid'), 'directedTopoSolid', '__httpwww_opengis_netgml_FaceType_httpwww_opengis_netgmldirectedTopoSolid', True)

    
    directedTopoSolid = property(__directedTopoSolid.value, __directedTopoSolid.set, None, u'')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTopoPrimitiveType._ElementMap.copy()
    _ElementMap.update({
        __surfaceProperty.name() : __surfaceProperty,
        __directedEdge.name() : __directedEdge,
        __directedTopoSolid.name() : __directedTopoSolid
    })
    _AttributeMap = AbstractTopoPrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'FaceType', FaceType)


# Complex type AbstractFeatureType with content type ELEMENT_ONLY
class AbstractFeatureType (AbstractGMLType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractFeatureType')
    # Base type is AbstractGMLType
    
    # Element {http://www.opengis.net/gml}location uses Python identifier location
    __location = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'location'), 'location', '__httpwww_opengis_netgml_AbstractFeatureType_httpwww_opengis_netgmllocation', False)

    
    location = property(__location.value, __location.set, None, u'Deprecated in GML 3.1.0')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}boundedBy uses Python identifier boundedBy
    __boundedBy = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'), 'boundedBy', '__httpwww_opengis_netgml_AbstractFeatureType_httpwww_opengis_netgmlboundedBy', False)

    
    boundedBy = property(__boundedBy.value, __boundedBy.set, None, None)

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractGMLType._ElementMap.copy()
    _ElementMap.update({
        __location.name() : __location,
        __boundedBy.name() : __boundedBy
    })
    _AttributeMap = AbstractGMLType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractFeatureType', AbstractFeatureType)


# Complex type AbstractCoverageType with content type ELEMENT_ONLY
class AbstractCoverageType (AbstractFeatureType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractCoverageType')
    # Base type is AbstractFeatureType
    
    # Element {http://www.opengis.net/gml}rangeSet uses Python identifier rangeSet
    __rangeSet = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'rangeSet'), 'rangeSet', '__httpwww_opengis_netgml_AbstractCoverageType_httpwww_opengis_netgmlrangeSet', False)

    
    rangeSet = property(__rangeSet.value, __rangeSet.set, None, None)

    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element boundedBy ({http://www.opengis.net/gml}boundedBy) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element location ({http://www.opengis.net/gml}location) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element {http://www.opengis.net/gml}domainSet uses Python identifier domainSet
    __domainSet = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'domainSet'), 'domainSet', '__httpwww_opengis_netgml_AbstractCoverageType_httpwww_opengis_netgmldomainSet', False)

    
    domainSet = property(__domainSet.value, __domainSet.set, None, None)

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute dimension uses Python identifier dimension
    __dimension = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'dimension'), 'dimension', '__httpwww_opengis_netgml_AbstractCoverageType_dimension', pyxb.binding.datatypes.positiveInteger)
    
    dimension = property(__dimension.value, __dimension.set, None, None)


    _ElementMap = AbstractFeatureType._ElementMap.copy()
    _ElementMap.update({
        __rangeSet.name() : __rangeSet,
        __domainSet.name() : __domainSet
    })
    _AttributeMap = AbstractFeatureType._AttributeMap.copy()
    _AttributeMap.update({
        __dimension.name() : __dimension
    })
Namespace.addCategoryObject('typeBinding', u'AbstractCoverageType', AbstractCoverageType)


# Complex type AbstractDiscreteCoverageType with content type ELEMENT_ONLY
class AbstractDiscreteCoverageType (AbstractCoverageType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractDiscreteCoverageType')
    # Base type is AbstractCoverageType
    
    # Element {http://www.opengis.net/gml}coverageFunction uses Python identifier coverageFunction
    __coverageFunction = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coverageFunction'), 'coverageFunction', '__httpwww_opengis_netgml_AbstractDiscreteCoverageType_httpwww_opengis_netgmlcoverageFunction', False)

    
    coverageFunction = property(__coverageFunction.value, __coverageFunction.set, None, None)

    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element boundedBy ({http://www.opengis.net/gml}boundedBy) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element location ({http://www.opengis.net/gml}location) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element domainSet ({http://www.opengis.net/gml}domainSet) inherited from {http://www.opengis.net/gml}AbstractCoverageType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element rangeSet ({http://www.opengis.net/gml}rangeSet) inherited from {http://www.opengis.net/gml}AbstractCoverageType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute dimension inherited from {http://www.opengis.net/gml}AbstractCoverageType

    _ElementMap = AbstractCoverageType._ElementMap.copy()
    _ElementMap.update({
        __coverageFunction.name() : __coverageFunction
    })
    _AttributeMap = AbstractCoverageType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractDiscreteCoverageType', AbstractDiscreteCoverageType)


# Complex type MultiCurveCoverageType with content type ELEMENT_ONLY
class MultiCurveCoverageType (AbstractDiscreteCoverageType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiCurveCoverageType')
    # Base type is AbstractDiscreteCoverageType
    
    # Element {http://www.opengis.net/gml}multiCurveDomain uses Python identifier multiCurveDomain
    __multiCurveDomain = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'multiCurveDomain'), 'multiCurveDomain', '__httpwww_opengis_netgml_MultiCurveCoverageType_httpwww_opengis_netgmlmultiCurveDomain', False)

    
    multiCurveDomain = property(__multiCurveDomain.value, __multiCurveDomain.set, None, None)

    
    # Element rangeSet ({http://www.opengis.net/gml}rangeSet) inherited from {http://www.opengis.net/gml}AbstractCoverageType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element boundedBy ({http://www.opengis.net/gml}boundedBy) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element coverageFunction ({http://www.opengis.net/gml}coverageFunction) inherited from {http://www.opengis.net/gml}AbstractDiscreteCoverageType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute dimension inherited from {http://www.opengis.net/gml}AbstractCoverageType

    _ElementMap = AbstractDiscreteCoverageType._ElementMap.copy()
    _ElementMap.update({
        __multiCurveDomain.name() : __multiCurveDomain
    })
    _AttributeMap = AbstractDiscreteCoverageType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MultiCurveCoverageType', MultiCurveCoverageType)


# Complex type AbstractCurveSegmentType with content type EMPTY
class AbstractCurveSegmentType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractCurveSegmentType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute numDerivativesAtEnd uses Python identifier numDerivativesAtEnd
    __numDerivativesAtEnd = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'numDerivativesAtEnd'), 'numDerivativesAtEnd', '__httpwww_opengis_netgml_AbstractCurveSegmentType_numDerivativesAtEnd', pyxb.binding.datatypes.integer, unicode_default=u'0')
    
    numDerivativesAtEnd = property(__numDerivativesAtEnd.value, __numDerivativesAtEnd.set, None, u'The attribute "numDerivativesAtEnd" specifies the type of continuity between this curve segment and its successor. If this is the last curve segment in the curve, one of these values, as appropriate, is ignored. The default value of "0" means simple continuity, which is a mandatory minimum level of continuity. This level is referred to as "C 0 " in mathematical texts. A value of 1 means that the function and its first derivative are continuous at the appropriate end point: "C 1 " continuity. A value of "n" for any integer means the function and its first n derivatives are continuous: "C n " continuity.\nNOTE: Use of these values is only appropriate when the basic curve definition is an underdetermined system. For example, line string segments cannot support continuity above C 0 , since there is no spare control parameter to adjust the incoming angle at the end points of the segment. Spline functions on the other hand often have extra degrees of freedom on end segments that allow them to adjust the values of the derivatives to support C 1 or higher continuity.')

    
    # Attribute numDerivativeInterior uses Python identifier numDerivativeInterior
    __numDerivativeInterior = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'numDerivativeInterior'), 'numDerivativeInterior', '__httpwww_opengis_netgml_AbstractCurveSegmentType_numDerivativeInterior', pyxb.binding.datatypes.integer, unicode_default=u'0')
    
    numDerivativeInterior = property(__numDerivativeInterior.value, __numDerivativeInterior.set, None, u'The attribute "numDerivativesInterior" specifies the type of continuity that is guaranteed interior to the curve. The default value of "0" means simple continuity, which is a mandatory minimum level of continuity. This level is referred to as "C 0 " in mathematical texts. A value of 1 means that the function and its first derivative are continuous at the appropriate end point: "C 1 " continuity. A value of "n" for any integer means the function and its first n derivatives are continuous: "C n " continuity.\nNOTE: Use of these values is only appropriate when the basic curve definition is an underdetermined system. For example, line string segments cannot support continuity above C 0 , since there is no spare control parameter to adjust the incoming angle at the end points of the segment. Spline functions on the other hand often have extra degrees of freedom on end segments that allow them to adjust the values of the derivatives to support C 1 or higher continuity.')

    
    # Attribute numDerivativesAtStart uses Python identifier numDerivativesAtStart
    __numDerivativesAtStart = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'numDerivativesAtStart'), 'numDerivativesAtStart', '__httpwww_opengis_netgml_AbstractCurveSegmentType_numDerivativesAtStart', pyxb.binding.datatypes.integer, unicode_default=u'0')
    
    numDerivativesAtStart = property(__numDerivativesAtStart.value, __numDerivativesAtStart.set, None, u'The attribute "numDerivativesAtStart" specifies the type of continuity between this curve segment and its predecessor. If this is the first curve segment in the curve, one of these values, as appropriate, is ignored. The default value of "0" means simple continuity, which is a mandatory minimum level of continuity. This level is referred to as "C 0 " in mathematical texts. A value of 1 means that the function and its first derivative are continuous at the appropriate end point: "C 1 " continuity. A value of "n" for any integer means the function and its first n derivatives are continuous: "C n " continuity.\nNOTE: Use of these values is only appropriate when the basic curve definition is an underdetermined system. For example, line string segments cannot support continuity above C 0 , since there is no spare control parameter to adjust the incoming angle at the end points of the segment. Spline functions on the other hand often have extra degrees of freedom on end segments that allow them to adjust the values of the derivatives to support C 1 or higher continuity.')


    _ElementMap = {
        
    }
    _AttributeMap = {
        __numDerivativesAtEnd.name() : __numDerivativesAtEnd,
        __numDerivativeInterior.name() : __numDerivativeInterior,
        __numDerivativesAtStart.name() : __numDerivativesAtStart
    }
Namespace.addCategoryObject('typeBinding', u'AbstractCurveSegmentType', AbstractCurveSegmentType)


# Complex type ArcByCenterPointType with content type ELEMENT_ONLY
class ArcByCenterPointType (AbstractCurveSegmentType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ArcByCenterPointType')
    # Base type is AbstractCurveSegmentType
    
    # Element {http://www.opengis.net/gml}pointProperty uses Python identifier pointProperty
    __pointProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), 'pointProperty', '__httpwww_opengis_netgml_ArcByCenterPointType_httpwww_opengis_netgmlpointProperty', False)

    
    pointProperty = property(__pointProperty.value, __pointProperty.set, None, u'This property element either references a point via the XLink-attributes or contains the point element. pointProperty \n\t\t\tis the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that \n\t\t\tis substitutable for Point.')

    
    # Element {http://www.opengis.net/gml}radius uses Python identifier radius
    __radius = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'radius'), 'radius', '__httpwww_opengis_netgml_ArcByCenterPointType_httpwww_opengis_netgmlradius', False)

    
    radius = property(__radius.value, __radius.set, None, u'The radius of the arc.')

    
    # Element {http://www.opengis.net/gml}coordinates uses Python identifier coordinates
    __coordinates = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), 'coordinates', '__httpwww_opengis_netgml_ArcByCenterPointType_httpwww_opengis_netgmlcoordinates', False)

    
    coordinates = property(__coordinates.value, __coordinates.set, None, u'Deprecated with GML version 3.1.0.')

    
    # Element {http://www.opengis.net/gml}pointRep uses Python identifier pointRep
    __pointRep = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), 'pointRep', '__httpwww_opengis_netgml_ArcByCenterPointType_httpwww_opengis_netgmlpointRep', False)

    
    pointRep = property(__pointRep.value, __pointRep.set, None, u'Deprecated with GML version 3.1.0. Use "pointProperty" instead. Included for backwards compatibility with GML 3.0.0.')

    
    # Element {http://www.opengis.net/gml}startAngle uses Python identifier startAngle
    __startAngle = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'startAngle'), 'startAngle', '__httpwww_opengis_netgml_ArcByCenterPointType_httpwww_opengis_netgmlstartAngle', False)

    
    startAngle = property(__startAngle.value, __startAngle.set, None, u'The bearing of the arc at the start.')

    
    # Element {http://www.opengis.net/gml}pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pos'), 'pos', '__httpwww_opengis_netgml_ArcByCenterPointType_httpwww_opengis_netgmlpos', False)

    
    pos = property(__pos.value, __pos.set, None, u'')

    
    # Element {http://www.opengis.net/gml}endAngle uses Python identifier endAngle
    __endAngle = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'endAngle'), 'endAngle', '__httpwww_opengis_netgml_ArcByCenterPointType_httpwww_opengis_netgmlendAngle', False)

    
    endAngle = property(__endAngle.value, __endAngle.set, None, u'The bearing of the arc at the end.')

    
    # Element {http://www.opengis.net/gml}posList uses Python identifier posList
    __posList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'posList'), 'posList', '__httpwww_opengis_netgml_ArcByCenterPointType_httpwww_opengis_netgmlposList', False)

    
    posList = property(__posList.value, __posList.set, None, u'')

    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute interpolation uses Python identifier interpolation
    __interpolation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'interpolation'), 'interpolation', '__httpwww_opengis_netgml_ArcByCenterPointType_interpolation', CurveInterpolationType, fixed=True, unicode_default=u'circularArcCenterPointWithRadius')
    
    interpolation = property(__interpolation.value, __interpolation.set, None, u'The attribute "interpolation" specifies the curve interpolation mechanism used for this segment. This mechanism\nuses the control points and control parameters to determine the position of this curve segment. For an ArcByCenterPoint the interpolation is fixed as "circularArcCenterPointWithRadius".')

    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numArc uses Python identifier numArc
    __numArc = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'numArc'), 'numArc', '__httpwww_opengis_netgml_ArcByCenterPointType_numArc', pyxb.binding.datatypes.integer, fixed=True, unicode_default=u'1', required=True)
    
    numArc = property(__numArc.value, __numArc.set, None, u'Since this type describes always a single arc, the attribute is fixed to "1".')

    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType

    _ElementMap = AbstractCurveSegmentType._ElementMap.copy()
    _ElementMap.update({
        __pointProperty.name() : __pointProperty,
        __radius.name() : __radius,
        __coordinates.name() : __coordinates,
        __pointRep.name() : __pointRep,
        __startAngle.name() : __startAngle,
        __pos.name() : __pos,
        __endAngle.name() : __endAngle,
        __posList.name() : __posList
    })
    _AttributeMap = AbstractCurveSegmentType._AttributeMap.copy()
    _AttributeMap.update({
        __interpolation.name() : __interpolation,
        __numArc.name() : __numArc
    })
Namespace.addCategoryObject('typeBinding', u'ArcByCenterPointType', ArcByCenterPointType)


# Complex type CircleByCenterPointType with content type ELEMENT_ONLY
class CircleByCenterPointType (ArcByCenterPointType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CircleByCenterPointType')
    # Base type is ArcByCenterPointType
    
    # Element pointProperty ({http://www.opengis.net/gml}pointProperty) inherited from {http://www.opengis.net/gml}ArcByCenterPointType
    
    # Element radius ({http://www.opengis.net/gml}radius) inherited from {http://www.opengis.net/gml}ArcByCenterPointType
    
    # Element coordinates ({http://www.opengis.net/gml}coordinates) inherited from {http://www.opengis.net/gml}ArcByCenterPointType
    
    # Element pointRep ({http://www.opengis.net/gml}pointRep) inherited from {http://www.opengis.net/gml}ArcByCenterPointType
    
    # Element startAngle ({http://www.opengis.net/gml}startAngle) inherited from {http://www.opengis.net/gml}ArcByCenterPointType
    
    # Element pos ({http://www.opengis.net/gml}pos) inherited from {http://www.opengis.net/gml}ArcByCenterPointType
    
    # Element endAngle ({http://www.opengis.net/gml}endAngle) inherited from {http://www.opengis.net/gml}ArcByCenterPointType
    
    # Element posList ({http://www.opengis.net/gml}posList) inherited from {http://www.opengis.net/gml}ArcByCenterPointType
    
    # Attribute numArc inherited from {http://www.opengis.net/gml}ArcByCenterPointType
    
    # Attribute interpolation inherited from {http://www.opengis.net/gml}ArcByCenterPointType
    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType

    _ElementMap = ArcByCenterPointType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = ArcByCenterPointType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CircleByCenterPointType', CircleByCenterPointType)


# Complex type IdentifierType with content type ELEMENT_ONLY
class IdentifierType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'IdentifierType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}remarks uses Python identifier remarks
    __remarks = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'remarks'), 'remarks', '__httpwww_opengis_netgml_IdentifierType_httpwww_opengis_netgmlremarks', False)

    
    remarks = property(__remarks.value, __remarks.set, None, u'Information about this object or code. Contains text or refers to external text.')

    
    # Element {http://www.opengis.net/gml}version uses Python identifier version
    __version = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'version'), 'version', '__httpwww_opengis_netgml_IdentifierType_httpwww_opengis_netgmlversion', False)

    
    version = property(__version.value, __version.set, None, u'Identifier of the version of the associated codeSpace or code, as specified by the codeSpace or code authority. This version is included only when the "code" or "codeSpace" uses versions. When appropriate, the version is identified by the effective date, coded using ISO 8601 date format.')

    
    # Element {http://www.opengis.net/gml}name uses Python identifier name
    __name = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'name'), 'name', '__httpwww_opengis_netgml_IdentifierType_httpwww_opengis_netgmlname', False)

    
    name = property(__name.value, __name.set, None, u'Label for the object, normally a descriptive name. An object may have several names, typically assigned by different authorities.  The authority for a name is indicated by the value of its (optional) codeSpace attribute.  The name may or may not be unique, as determined by the rules of the organization responsible for the codeSpace.')


    _ElementMap = {
        __remarks.name() : __remarks,
        __version.name() : __version,
        __name.name() : __name
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'IdentifierType', IdentifierType)


# Complex type StringOrRefType with content type SIMPLE
class StringOrRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'StringOrRefType')
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_StringOrRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_StringOrRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_StringOrRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_StringOrRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_StringOrRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_StringOrRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_StringOrRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_StringOrRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")


    _ElementMap = {
        
    }
    _AttributeMap = {
        __remoteSchema.name() : __remoteSchema,
        __type.name() : __type,
        __arcrole.name() : __arcrole,
        __role.name() : __role,
        __href.name() : __href,
        __title.name() : __title,
        __actuate.name() : __actuate,
        __show.name() : __show
    }
Namespace.addCategoryObject('typeBinding', u'StringOrRefType', StringOrRefType)


# Complex type CodeType with content type SIMPLE
class CodeType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CodeType')
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute codeSpace uses Python identifier codeSpace
    __codeSpace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'codeSpace'), 'codeSpace', '__httpwww_opengis_netgml_CodeType_codeSpace', pyxb.binding.datatypes.anyURI)
    
    codeSpace = property(__codeSpace.value, __codeSpace.set, None, None)


    _ElementMap = {
        
    }
    _AttributeMap = {
        __codeSpace.name() : __codeSpace
    }
Namespace.addCategoryObject('typeBinding', u'CodeType', CodeType)


# Complex type AbstractDatumBaseType with content type ELEMENT_ONLY
class AbstractDatumBaseType (DefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractDatumBaseType')
    # Base type is DefinitionType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}datumName uses Python identifier datumName
    __datumName = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'datumName'), 'datumName', '__httpwww_opengis_netgml_AbstractDatumBaseType_httpwww_opengis_netgmldatumName', False)

    
    datumName = property(__datumName.value, __datumName.set, None, u'The name by which this datum is identified. ')

    
    # Attribute id is restricted from parent
    
    # Attribute {http://www.opengis.net/gml}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'id'), 'id', '__httpwww_opengis_netgml_AbstractGMLType_httpwww_opengis_netgmlid', pyxb.binding.datatypes.ID, required=True)
    
    id = property(__id.value, __id.set, None, u'Database handle for the object.  It is of XML type ID, so is constrained to be unique in the XML document within which it occurs.  An external identifier for the object in the form of a URI may be constructed using standard XML and XPointer methods.  This is done by concatenating the URI for the document, a fragment separator, and the value of the id attribute.')


    _ElementMap = DefinitionType._ElementMap.copy()
    _ElementMap.update({
        __datumName.name() : __datumName
    })
    _AttributeMap = DefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', u'AbstractDatumBaseType', AbstractDatumBaseType)


# Complex type AbstractDatumType with content type ELEMENT_ONLY
class AbstractDatumType (AbstractDatumBaseType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractDatumType')
    # Base type is AbstractDatumBaseType
    
    # Element datumName ({http://www.opengis.net/gml}datumName) inherited from {http://www.opengis.net/gml}AbstractDatumBaseType
    
    # Element {http://www.opengis.net/gml}realizationEpoch uses Python identifier realizationEpoch
    __realizationEpoch = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'realizationEpoch'), 'realizationEpoch', '__httpwww_opengis_netgml_AbstractDatumType_httpwww_opengis_netgmlrealizationEpoch', False)

    
    realizationEpoch = property(__realizationEpoch.value, __realizationEpoch.set, None, u'The time after which this datum definition is valid. This time may be precise (e.g. 1997.0 for IRTF97) or merely a year (e.g. 1983 for NAD83). In the latter case, the epoch usually refers to the year in which a major recalculation of the geodetic control network, underlying the datum, was executed or initiated. An old datum can remain valid after a new datum is defined. Alternatively, a datum may be superseded by a later datum, in which case the realization epoch for the new datum defines the upper limit for the validity of the superseded datum. ')

    
    # Element {http://www.opengis.net/gml}scope uses Python identifier scope
    __scope = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'scope'), 'scope', '__httpwww_opengis_netgml_AbstractDatumType_httpwww_opengis_netgmlscope', False)

    
    scope = property(__scope.value, __scope.set, None, u'Description of domain of usage, or limitations of usage, for which this CRS object is valid.')

    
    # Element {http://www.opengis.net/gml}datumID uses Python identifier datumID
    __datumID = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'datumID'), 'datumID', '__httpwww_opengis_netgml_AbstractDatumType_httpwww_opengis_netgmldatumID', True)

    
    datumID = property(__datumID.value, __datumID.set, None, u'An identification of a datum. ')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}remarks uses Python identifier remarks
    __remarks = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'remarks'), 'remarks', '__httpwww_opengis_netgml_AbstractDatumType_httpwww_opengis_netgmlremarks', False)

    
    remarks = property(__remarks.value, __remarks.set, None, u'Information about this object or code. Contains text or refers to external text.')

    
    # Element {http://www.opengis.net/gml}validArea uses Python identifier validArea
    __validArea = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'validArea'), 'validArea', '__httpwww_opengis_netgml_AbstractDatumType_httpwww_opengis_netgmlvalidArea', False)

    
    validArea = property(__validArea.value, __validArea.set, None, u'Area or region in which this CRS object is valid.')

    
    # Element {http://www.opengis.net/gml}anchorPoint uses Python identifier anchorPoint
    __anchorPoint = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'anchorPoint'), 'anchorPoint', '__httpwww_opengis_netgml_AbstractDatumType_httpwww_opengis_netgmlanchorPoint', False)

    
    anchorPoint = property(__anchorPoint.value, __anchorPoint.set, None, u'Description, possibly including coordinates, of the point or points used to anchor the datum to the Earth. Also known as the "origin", especially for engineering and image datums. The codeSpace attribute can be used to reference a source of more detailed on this point or surface, or on a set of such descriptions. \n- For a geodetic datum, this point is also known as the fundamental point, which is traditionally the point where the relationship between geoid and ellipsoid is defined. In some cases, the "fundamental point" may consist of a number of points. In those cases, the parameters defining the geoid/ellipsoid relationship have been averaged for these points, and the averages adopted as the datum definition.\n- For an engineering datum, the anchor point may be a physical point, or it may be a point with defined coordinates in another CRS. When appropriate, the coordinates of this anchor point can be referenced in another document, such as referencing a GML feature that references or includes a point position.\n- For an image datum, the anchor point is usually either the centre of the image or the corner of the image.\n- For a temporal datum, this attribute is not defined. Instead of the anchor point, a temporal datum carries a separate time origin of type DateTime. ')

    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractDatumBaseType

    _ElementMap = AbstractDatumBaseType._ElementMap.copy()
    _ElementMap.update({
        __realizationEpoch.name() : __realizationEpoch,
        __scope.name() : __scope,
        __datumID.name() : __datumID,
        __remarks.name() : __remarks,
        __validArea.name() : __validArea,
        __anchorPoint.name() : __anchorPoint
    })
    _AttributeMap = AbstractDatumBaseType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractDatumType', AbstractDatumType)


# Complex type TimePrimitivePropertyType with content type ELEMENT_ONLY
class TimePrimitivePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimePrimitivePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_TimePrimitive uses Python identifier TimePrimitive
    __TimePrimitive = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_TimePrimitive'), 'TimePrimitive', '__httpwww_opengis_netgml_TimePrimitivePropertyType_httpwww_opengis_netgml_TimePrimitive', False)

    
    TimePrimitive = property(__TimePrimitive.value, __TimePrimitive.set, None, u'This abstract element acts as the head of the substitution group for temporal primitives.')

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_TimePrimitivePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_TimePrimitivePropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_TimePrimitivePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_TimePrimitivePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_TimePrimitivePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_TimePrimitivePropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_TimePrimitivePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_TimePrimitivePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)


    _ElementMap = {
        __TimePrimitive.name() : __TimePrimitive
    }
    _AttributeMap = {
        __href.name() : __href,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __show.name() : __show,
        __role.name() : __role,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'TimePrimitivePropertyType', TimePrimitivePropertyType)


# Complex type OperationMethodRefType with content type ELEMENT_ONLY
class OperationMethodRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'OperationMethodRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}OperationMethod uses Python identifier OperationMethod
    __OperationMethod = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'OperationMethod'), 'OperationMethod', '__httpwww_opengis_netgml_OperationMethodRefType_httpwww_opengis_netgmlOperationMethod', False)

    
    OperationMethod = property(__OperationMethod.value, __OperationMethod.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_OperationMethodRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_OperationMethodRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_OperationMethodRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_OperationMethodRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_OperationMethodRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_OperationMethodRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_OperationMethodRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_OperationMethodRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)


    _ElementMap = {
        __OperationMethod.name() : __OperationMethod
    }
    _AttributeMap = {
        __show.name() : __show,
        __type.name() : __type,
        __href.name() : __href,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __role.name() : __role,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'OperationMethodRefType', OperationMethodRefType)


# Complex type AngleChoiceType with content type ELEMENT_ONLY
class AngleChoiceType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AngleChoiceType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}dmsAngle uses Python identifier dmsAngle
    __dmsAngle = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'dmsAngle'), 'dmsAngle', '__httpwww_opengis_netgml_AngleChoiceType_httpwww_opengis_netgmldmsAngle', False)

    
    dmsAngle = property(__dmsAngle.value, __dmsAngle.set, None, None)

    
    # Element {http://www.opengis.net/gml}angle uses Python identifier angle
    __angle = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'angle'), 'angle', '__httpwww_opengis_netgml_AngleChoiceType_httpwww_opengis_netgmlangle', False)

    
    angle = property(__angle.value, __angle.set, None, None)


    _ElementMap = {
        __dmsAngle.name() : __dmsAngle,
        __angle.name() : __angle
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'AngleChoiceType', AngleChoiceType)


# Complex type AbstractGeometryType with content type ELEMENT_ONLY
class AbstractGeometryType (AbstractGMLType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometryType')
    # Base type is AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid uses Python identifier gid
    __gid = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'gid'), 'gid', '__httpwww_opengis_netgml_AbstractGeometryType_gid', pyxb.binding.datatypes.string)
    
    gid = property(__gid.value, __gid.set, None, u'This attribute is included for backward compatibility with GML 2 and is deprecated with GML 3. \n\t\t\t\t\t\tThis identifer is superceded by "gml:id" inherited from AbstractGMLType. The attribute "gid" should not be used \n\t\t\t\t\t\tanymore and may be deleted in future versions of GML without further notice.')

    
    # Attribute srsDimension uses Python identifier srsDimension
    __srsDimension = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'srsDimension'), 'srsDimension', '__httpwww_opengis_netgml_AbstractGeometryType_srsDimension', pyxb.binding.datatypes.positiveInteger)
    
    srsDimension = property(__srsDimension.value, __srsDimension.set, None, u'The "srsDimension" is the length of coordinate sequence (the number of entries in the list). This dimension is \n\t\t\t\tspecified by the coordinate reference system. When the srsName attribute is omitted, this attribute shall be omitted.')

    
    # Attribute srsName uses Python identifier srsName
    __srsName = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'srsName'), 'srsName', '__httpwww_opengis_netgml_AbstractGeometryType_srsName', pyxb.binding.datatypes.anyURI)
    
    srsName = property(__srsName.value, __srsName.set, None, u'In general this reference points to a CRS instance of gml:CoordinateReferenceSystemType \n\t\t\t\t(see coordinateReferenceSystems.xsd). For well known references it is not required that the CRS description exists at the \n\t\t\t\tlocation the URI points to. If no srsName attribute is given, the CRS must be specified as part of the larger context this \n\t\t\t\tgeometry element is part of, e.g. a geometric element like point, curve, etc. It is expected that this attribute will be specified \n\t\t\t\tat the direct position level only in rare cases.')

    
    # Attribute axisLabels uses Python identifier axisLabels
    __axisLabels = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'axisLabels'), 'axisLabels', '__httpwww_opengis_netgml_AbstractGeometryType_axisLabels', NCNameList)
    
    axisLabels = property(__axisLabels.value, __axisLabels.set, None, u'Ordered list of labels for all the axes of this CRS. The gml:axisAbbrev value should be used for these axis \n\t\t\t\tlabels, after spaces and forbiddden characters are removed. When the srsName attribute is included, this attribute is optional. \n\t\t\t\tWhen the srsName attribute is omitted, this attribute shall also be omitted.')

    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels uses Python identifier uomLabels
    __uomLabels = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'uomLabels'), 'uomLabels', '__httpwww_opengis_netgml_AbstractGeometryType_uomLabels', NCNameList)
    
    uomLabels = property(__uomLabels.value, __uomLabels.set, None, u'Ordered list of unit of measure (uom) labels for all the axes of this CRS. The value of the string in the \n\t\t\t\tgml:catalogSymbol should be used for this uom labels, after spaces and forbiddden characters are removed. When the \n\t\t\t\taxisLabels attribute is included, this attribute shall also be included. When the axisLabels attribute is omitted, this attribute \n\t\t\t\tshall also be omitted.')


    _ElementMap = AbstractGMLType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractGMLType._AttributeMap.copy()
    _AttributeMap.update({
        __gid.name() : __gid,
        __srsDimension.name() : __srsDimension,
        __srsName.name() : __srsName,
        __axisLabels.name() : __axisLabels,
        __uomLabels.name() : __uomLabels
    })
Namespace.addCategoryObject('typeBinding', u'AbstractGeometryType', AbstractGeometryType)


# Complex type AbstractRingType with content type ELEMENT_ONLY
class AbstractRingType (AbstractGeometryType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractRingType')
    # Base type is AbstractGeometryType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometryType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractGeometryType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractRingType', AbstractRingType)


# Complex type FeatureArrayPropertyType with content type ELEMENT_ONLY
class FeatureArrayPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'FeatureArrayPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_Feature uses Python identifier Feature
    __Feature = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_Feature'), 'Feature', '__httpwww_opengis_netgml_FeatureArrayPropertyType_httpwww_opengis_netgml_Feature', True)

    
    Feature = property(__Feature.value, __Feature.set, None, None)


    _ElementMap = {
        __Feature.name() : __Feature
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'FeatureArrayPropertyType', FeatureArrayPropertyType)


# Complex type CodeOrNullListType with content type SIMPLE
class CodeOrNullListType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = NameOrNullList
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CodeOrNullListType')
    # Base type is NameOrNullList
    
    # Attribute codeSpace uses Python identifier codeSpace
    __codeSpace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'codeSpace'), 'codeSpace', '__httpwww_opengis_netgml_CodeOrNullListType_codeSpace', pyxb.binding.datatypes.anyURI)
    
    codeSpace = property(__codeSpace.value, __codeSpace.set, None, None)


    _ElementMap = {
        
    }
    _AttributeMap = {
        __codeSpace.name() : __codeSpace
    }
Namespace.addCategoryObject('typeBinding', u'CodeOrNullListType', CodeOrNullListType)


# Complex type AbstractGeometricPrimitiveType with content type ELEMENT_ONLY
class AbstractGeometricPrimitiveType (AbstractGeometryType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometricPrimitiveType')
    # Base type is AbstractGeometryType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometryType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractGeometryType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractGeometricPrimitiveType', AbstractGeometricPrimitiveType)


# Complex type AbstractSurfaceType with content type ELEMENT_ONLY
class AbstractSurfaceType (AbstractGeometricPrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractSurfaceType')
    # Base type is AbstractGeometricPrimitiveType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometricPrimitiveType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractGeometricPrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractSurfaceType', AbstractSurfaceType)


# Complex type TopoPointPropertyType with content type ELEMENT_ONLY
class TopoPointPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopoPointPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TopoPoint uses Python identifier TopoPoint
    __TopoPoint = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TopoPoint'), 'TopoPoint', '__httpwww_opengis_netgml_TopoPointPropertyType_httpwww_opengis_netgmlTopoPoint', False)

    
    TopoPoint = property(__TopoPoint.value, __TopoPoint.set, None, None)


    _ElementMap = {
        __TopoPoint.name() : __TopoPoint
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'TopoPointPropertyType', TopoPointPropertyType)


# Complex type AbstractReferenceSystemBaseType with content type ELEMENT_ONLY
class AbstractReferenceSystemBaseType (DefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractReferenceSystemBaseType')
    # Base type is DefinitionType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}srsName uses Python identifier srsName
    __srsName = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'srsName'), 'srsName', '__httpwww_opengis_netgml_AbstractReferenceSystemBaseType_httpwww_opengis_netgmlsrsName', False)

    
    srsName = property(__srsName.value, __srsName.set, None, u'The name by which this reference system is identified.')

    
    # Attribute id is restricted from parent
    
    # Attribute {http://www.opengis.net/gml}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'id'), 'id', '__httpwww_opengis_netgml_AbstractGMLType_httpwww_opengis_netgmlid', pyxb.binding.datatypes.ID, required=True)
    
    id = property(__id.value, __id.set, None, u'Database handle for the object.  It is of XML type ID, so is constrained to be unique in the XML document within which it occurs.  An external identifier for the object in the form of a URI may be constructed using standard XML and XPointer methods.  This is done by concatenating the URI for the document, a fragment separator, and the value of the id attribute.')


    _ElementMap = DefinitionType._ElementMap.copy()
    _ElementMap.update({
        __srsName.name() : __srsName
    })
    _AttributeMap = DefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', u'AbstractReferenceSystemBaseType', AbstractReferenceSystemBaseType)


# Complex type AbstractReferenceSystemType with content type ELEMENT_ONLY
class AbstractReferenceSystemType (AbstractReferenceSystemBaseType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractReferenceSystemType')
    # Base type is AbstractReferenceSystemBaseType
    
    # Element srsName ({http://www.opengis.net/gml}srsName) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemBaseType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}validArea uses Python identifier validArea
    __validArea = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'validArea'), 'validArea', '__httpwww_opengis_netgml_AbstractReferenceSystemType_httpwww_opengis_netgmlvalidArea', False)

    
    validArea = property(__validArea.value, __validArea.set, None, u'Area or region in which this CRS object is valid.')

    
    # Element {http://www.opengis.net/gml}srsID uses Python identifier srsID
    __srsID = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'srsID'), 'srsID', '__httpwww_opengis_netgml_AbstractReferenceSystemType_httpwww_opengis_netgmlsrsID', True)

    
    srsID = property(__srsID.value, __srsID.set, None, u'An identification of a reference system.')

    
    # Element {http://www.opengis.net/gml}scope uses Python identifier scope
    __scope = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'scope'), 'scope', '__httpwww_opengis_netgml_AbstractReferenceSystemType_httpwww_opengis_netgmlscope', False)

    
    scope = property(__scope.value, __scope.set, None, u'Description of domain of usage, or limitations of usage, for which this CRS object is valid.')

    
    # Element {http://www.opengis.net/gml}remarks uses Python identifier remarks
    __remarks = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'remarks'), 'remarks', '__httpwww_opengis_netgml_AbstractReferenceSystemType_httpwww_opengis_netgmlremarks', False)

    
    remarks = property(__remarks.value, __remarks.set, None, u'Information about this object or code. Contains text or refers to external text.')

    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractReferenceSystemBaseType

    _ElementMap = AbstractReferenceSystemBaseType._ElementMap.copy()
    _ElementMap.update({
        __validArea.name() : __validArea,
        __srsID.name() : __srsID,
        __scope.name() : __scope,
        __remarks.name() : __remarks
    })
    _AttributeMap = AbstractReferenceSystemBaseType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractReferenceSystemType', AbstractReferenceSystemType)


# Complex type GeocentricCRSType with content type ELEMENT_ONLY
class GeocentricCRSType (AbstractReferenceSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeocentricCRSType')
    # Base type is AbstractReferenceSystemType
    
    # Element {http://www.opengis.net/gml}usesGeodeticDatum uses Python identifier usesGeodeticDatum
    __usesGeodeticDatum = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesGeodeticDatum'), 'usesGeodeticDatum', '__httpwww_opengis_netgml_GeocentricCRSType_httpwww_opengis_netgmlusesGeodeticDatum', False)

    
    usesGeodeticDatum = property(__usesGeodeticDatum.value, __usesGeodeticDatum.set, None, u'Association to the geodetic datum used by this CRS. ')

    
    # Element srsName ({http://www.opengis.net/gml}srsName) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemBaseType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element validArea ({http://www.opengis.net/gml}validArea) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element {http://www.opengis.net/gml}usesCartesianCS uses Python identifier usesCartesianCS
    __usesCartesianCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesCartesianCS'), 'usesCartesianCS', '__httpwww_opengis_netgml_GeocentricCRSType_httpwww_opengis_netgmlusesCartesianCS', False)

    
    usesCartesianCS = property(__usesCartesianCS.value, __usesCartesianCS.set, None, u'Association to the Cartesian coordinate system used by this CRS. ')

    
    # Element srsID ({http://www.opengis.net/gml}srsID) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element scope ({http://www.opengis.net/gml}scope) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element {http://www.opengis.net/gml}usesSphericalCS uses Python identifier usesSphericalCS
    __usesSphericalCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesSphericalCS'), 'usesSphericalCS', '__httpwww_opengis_netgml_GeocentricCRSType_httpwww_opengis_netgmlusesSphericalCS', False)

    
    usesSphericalCS = property(__usesSphericalCS.value, __usesSphericalCS.set, None, u'Association to the spherical coordinate system used by this CRS.')

    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractReferenceSystemBaseType

    _ElementMap = AbstractReferenceSystemType._ElementMap.copy()
    _ElementMap.update({
        __usesGeodeticDatum.name() : __usesGeodeticDatum,
        __usesCartesianCS.name() : __usesCartesianCS,
        __usesSphericalCS.name() : __usesSphericalCS
    })
    _AttributeMap = AbstractReferenceSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'GeocentricCRSType', GeocentricCRSType)


# Complex type StyleVariationType with content type SIMPLE
class StyleVariationType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'StyleVariationType')
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute featurePropertyRange uses Python identifier featurePropertyRange
    __featurePropertyRange = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'featurePropertyRange'), 'featurePropertyRange', '__httpwww_opengis_netgml_StyleVariationType_featurePropertyRange', pyxb.binding.datatypes.string)
    
    featurePropertyRange = property(__featurePropertyRange.value, __featurePropertyRange.set, None, None)

    
    # Attribute styleProperty uses Python identifier styleProperty
    __styleProperty = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'styleProperty'), 'styleProperty', '__httpwww_opengis_netgml_StyleVariationType_styleProperty', pyxb.binding.datatypes.string, required=True)
    
    styleProperty = property(__styleProperty.value, __styleProperty.set, None, None)


    _ElementMap = {
        
    }
    _AttributeMap = {
        __featurePropertyRange.name() : __featurePropertyRange,
        __styleProperty.name() : __styleProperty
    }
Namespace.addCategoryObject('typeBinding', u'StyleVariationType', StyleVariationType)


# Complex type FeaturePropertyType with content type ELEMENT_ONLY
class FeaturePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'FeaturePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_Feature uses Python identifier Feature
    __Feature = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_Feature'), 'Feature', '__httpwww_opengis_netgml_FeaturePropertyType_httpwww_opengis_netgml_Feature', False)

    
    Feature = property(__Feature.value, __Feature.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_FeaturePropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_FeaturePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_FeaturePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_FeaturePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_FeaturePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_FeaturePropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_FeaturePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_FeaturePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)


    _ElementMap = {
        __Feature.name() : __Feature
    }
    _AttributeMap = {
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __href.name() : __href,
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role
    }
Namespace.addCategoryObject('typeBinding', u'FeaturePropertyType', FeaturePropertyType)


# Complex type AbstractGeometricAggregateType with content type ELEMENT_ONLY
class AbstractGeometricAggregateType (AbstractGeometryType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractGeometricAggregateType')
    # Base type is AbstractGeometryType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometryType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractGeometryType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractGeometricAggregateType', AbstractGeometricAggregateType)


# Complex type EnvelopeType with content type ELEMENT_ONLY
class EnvelopeType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'EnvelopeType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}upperCorner uses Python identifier upperCorner
    __upperCorner = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'upperCorner'), 'upperCorner', '__httpwww_opengis_netgml_EnvelopeType_httpwww_opengis_netgmlupperCorner', False)

    
    upperCorner = property(__upperCorner.value, __upperCorner.set, None, None)

    
    # Element {http://www.opengis.net/gml}pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pos'), 'pos', '__httpwww_opengis_netgml_EnvelopeType_httpwww_opengis_netgmlpos', True)

    
    pos = property(__pos.value, __pos.set, None, u'')

    
    # Element {http://www.opengis.net/gml}coord uses Python identifier coord
    __coord = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coord'), 'coord', '__httpwww_opengis_netgml_EnvelopeType_httpwww_opengis_netgmlcoord', True)

    
    coord = property(__coord.value, __coord.set, None, u'Deprecated with GML 3.0 and included for backwards compatibility with GML 2. Use the "pos" element instead.')

    
    # Element {http://www.opengis.net/gml}coordinates uses Python identifier coordinates
    __coordinates = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), 'coordinates', '__httpwww_opengis_netgml_EnvelopeType_httpwww_opengis_netgmlcoordinates', False)

    
    coordinates = property(__coordinates.value, __coordinates.set, None, u'Deprecated with GML version 3.1.0.')

    
    # Element {http://www.opengis.net/gml}lowerCorner uses Python identifier lowerCorner
    __lowerCorner = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'lowerCorner'), 'lowerCorner', '__httpwww_opengis_netgml_EnvelopeType_httpwww_opengis_netgmllowerCorner', False)

    
    lowerCorner = property(__lowerCorner.value, __lowerCorner.set, None, None)

    
    # Attribute srsName uses Python identifier srsName
    __srsName = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'srsName'), 'srsName', '__httpwww_opengis_netgml_EnvelopeType_srsName', pyxb.binding.datatypes.anyURI)
    
    srsName = property(__srsName.value, __srsName.set, None, u'In general this reference points to a CRS instance of gml:CoordinateReferenceSystemType \n\t\t\t\t(see coordinateReferenceSystems.xsd). For well known references it is not required that the CRS description exists at the \n\t\t\t\tlocation the URI points to. If no srsName attribute is given, the CRS must be specified as part of the larger context this \n\t\t\t\tgeometry element is part of, e.g. a geometric element like point, curve, etc. It is expected that this attribute will be specified \n\t\t\t\tat the direct position level only in rare cases.')

    
    # Attribute axisLabels uses Python identifier axisLabels
    __axisLabels = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'axisLabels'), 'axisLabels', '__httpwww_opengis_netgml_EnvelopeType_axisLabels', NCNameList)
    
    axisLabels = property(__axisLabels.value, __axisLabels.set, None, u'Ordered list of labels for all the axes of this CRS. The gml:axisAbbrev value should be used for these axis \n\t\t\t\tlabels, after spaces and forbiddden characters are removed. When the srsName attribute is included, this attribute is optional. \n\t\t\t\tWhen the srsName attribute is omitted, this attribute shall also be omitted.')

    
    # Attribute srsDimension uses Python identifier srsDimension
    __srsDimension = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'srsDimension'), 'srsDimension', '__httpwww_opengis_netgml_EnvelopeType_srsDimension', pyxb.binding.datatypes.positiveInteger)
    
    srsDimension = property(__srsDimension.value, __srsDimension.set, None, u'The "srsDimension" is the length of coordinate sequence (the number of entries in the list). This dimension is \n\t\t\t\tspecified by the coordinate reference system. When the srsName attribute is omitted, this attribute shall be omitted.')

    
    # Attribute uomLabels uses Python identifier uomLabels
    __uomLabels = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'uomLabels'), 'uomLabels', '__httpwww_opengis_netgml_EnvelopeType_uomLabels', NCNameList)
    
    uomLabels = property(__uomLabels.value, __uomLabels.set, None, u'Ordered list of unit of measure (uom) labels for all the axes of this CRS. The value of the string in the \n\t\t\t\tgml:catalogSymbol should be used for this uom labels, after spaces and forbiddden characters are removed. When the \n\t\t\t\taxisLabels attribute is included, this attribute shall also be included. When the axisLabels attribute is omitted, this attribute \n\t\t\t\tshall also be omitted.')


    _ElementMap = {
        __upperCorner.name() : __upperCorner,
        __pos.name() : __pos,
        __coord.name() : __coord,
        __coordinates.name() : __coordinates,
        __lowerCorner.name() : __lowerCorner
    }
    _AttributeMap = {
        __srsName.name() : __srsName,
        __axisLabels.name() : __axisLabels,
        __srsDimension.name() : __srsDimension,
        __uomLabels.name() : __uomLabels
    }
Namespace.addCategoryObject('typeBinding', u'EnvelopeType', EnvelopeType)


# Complex type BoundingShapeType with content type ELEMENT_ONLY
class BoundingShapeType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'BoundingShapeType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Envelope uses Python identifier Envelope
    __Envelope = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Envelope'), 'Envelope', '__httpwww_opengis_netgml_BoundingShapeType_httpwww_opengis_netgmlEnvelope', False)

    
    Envelope = property(__Envelope.value, __Envelope.set, None, None)

    
    # Element {http://www.opengis.net/gml}Null uses Python identifier Null
    __Null = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Null'), 'Null', '__httpwww_opengis_netgml_BoundingShapeType_httpwww_opengis_netgmlNull', False)

    
    Null = property(__Null.value, __Null.set, None, None)


    _ElementMap = {
        __Envelope.name() : __Envelope,
        __Null.name() : __Null
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'BoundingShapeType', BoundingShapeType)


# Complex type DerivedCRSTypeType with content type SIMPLE
class DerivedCRSTypeType (CodeType):
    _TypeDefinition = STD_ANON_21
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DerivedCRSTypeType')
    # Base type is CodeType
    
    # Attribute codeSpace is restricted from parent
    
    # Attribute codeSpace uses Python identifier codeSpace
    __codeSpace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'codeSpace'), 'codeSpace', '__httpwww_opengis_netgml_CodeType_codeSpace', pyxb.binding.datatypes.anyURI, required=True)
    
    codeSpace = property(__codeSpace.value, __codeSpace.set, None, u'Reference to a source of information specifying the values and meanings of all the allowed string values for this DerivedCRSTypeType. ')


    _ElementMap = CodeType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = CodeType._AttributeMap.copy()
    _AttributeMap.update({
        __codeSpace.name() : __codeSpace
    })
Namespace.addCategoryObject('typeBinding', u'DerivedCRSTypeType', DerivedCRSTypeType)


# Complex type TimeNodePropertyType with content type ELEMENT_ONLY
class TimeNodePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeNodePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TimeNode uses Python identifier TimeNode
    __TimeNode = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TimeNode'), 'TimeNode', '__httpwww_opengis_netgml_TimeNodePropertyType_httpwww_opengis_netgmlTimeNode', False)

    
    TimeNode = property(__TimeNode.value, __TimeNode.set, None, u'"TimeNode" is a zero dimensional temporal topology primitive, \n\t\t\texpresses a position in topological time, and is a start and an end of time edge, which represents states of time.\n\t\t\tTime node may be isolated. However, it cannot describe the ordering relationships with other primitives. \n\t\t\tAn isolated node may not be an element of any temporal topology complex.')

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_TimeNodePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_TimeNodePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_TimeNodePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_TimeNodePropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_TimeNodePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_TimeNodePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_TimeNodePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_TimeNodePropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")


    _ElementMap = {
        __TimeNode.name() : __TimeNode
    }
    _AttributeMap = {
        __type.name() : __type,
        __role.name() : __role,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __arcrole.name() : __arcrole,
        __href.name() : __href,
        __title.name() : __title,
        __show.name() : __show
    }
Namespace.addCategoryObject('typeBinding', u'TimeNodePropertyType', TimeNodePropertyType)


# Complex type LabelStylePropertyType with content type ELEMENT_ONLY
class LabelStylePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LabelStylePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}LabelStyle uses Python identifier LabelStyle
    __LabelStyle = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'LabelStyle'), 'LabelStyle', '__httpwww_opengis_netgml_LabelStylePropertyType_httpwww_opengis_netgmlLabelStyle', False)

    
    LabelStyle = property(__LabelStyle.value, __LabelStyle.set, None, u'The style descriptor for labels of a feature, geometry or topology.')

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_LabelStylePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_LabelStylePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_LabelStylePropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_LabelStylePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_LabelStylePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_LabelStylePropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_LabelStylePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_LabelStylePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute about uses Python identifier about
    __about = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'about'), 'about', '__httpwww_opengis_netgml_LabelStylePropertyType_about', pyxb.binding.datatypes.anyURI)
    
    about = property(__about.value, __about.set, None, None)


    _ElementMap = {
        __LabelStyle.name() : __LabelStyle
    }
    _AttributeMap = {
        __title.name() : __title,
        __type.name() : __type,
        __show.name() : __show,
        __arcrole.name() : __arcrole,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __href.name() : __href,
        __about.name() : __about
    }
Namespace.addCategoryObject('typeBinding', u'LabelStylePropertyType', LabelStylePropertyType)


# Complex type AbstractCoordinateOperationBaseType with content type ELEMENT_ONLY
class AbstractCoordinateOperationBaseType (DefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractCoordinateOperationBaseType')
    # Base type is DefinitionType
    
    # Element {http://www.opengis.net/gml}coordinateOperationName uses Python identifier coordinateOperationName
    __coordinateOperationName = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationName'), 'coordinateOperationName', '__httpwww_opengis_netgml_AbstractCoordinateOperationBaseType_httpwww_opengis_netgmlcoordinateOperationName', False)

    
    coordinateOperationName = property(__coordinateOperationName.value, __coordinateOperationName.set, None, u'The name by which this coordinate operation is identified. ')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id is restricted from parent
    
    # Attribute {http://www.opengis.net/gml}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'id'), 'id', '__httpwww_opengis_netgml_AbstractGMLType_httpwww_opengis_netgmlid', pyxb.binding.datatypes.ID, required=True)
    
    id = property(__id.value, __id.set, None, u'Database handle for the object.  It is of XML type ID, so is constrained to be unique in the XML document within which it occurs.  An external identifier for the object in the form of a URI may be constructed using standard XML and XPointer methods.  This is done by concatenating the URI for the document, a fragment separator, and the value of the id attribute.')


    _ElementMap = DefinitionType._ElementMap.copy()
    _ElementMap.update({
        __coordinateOperationName.name() : __coordinateOperationName
    })
    _AttributeMap = DefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', u'AbstractCoordinateOperationBaseType', AbstractCoordinateOperationBaseType)


# Complex type AbstractCoordinateOperationType with content type ELEMENT_ONLY
class AbstractCoordinateOperationType (AbstractCoordinateOperationBaseType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractCoordinateOperationType')
    # Base type is AbstractCoordinateOperationBaseType
    
    # Element {http://www.opengis.net/gml}coordinateOperationID uses Python identifier coordinateOperationID
    __coordinateOperationID = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationID'), 'coordinateOperationID', '__httpwww_opengis_netgml_AbstractCoordinateOperationType_httpwww_opengis_netgmlcoordinateOperationID', True)

    
    coordinateOperationID = property(__coordinateOperationID.value, __coordinateOperationID.set, None, u'An identification of a coordinate operation. ')

    
    # Element {http://www.opengis.net/gml}_positionalAccuracy uses Python identifier positionalAccuracy
    __positionalAccuracy = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_positionalAccuracy'), 'positionalAccuracy', '__httpwww_opengis_netgml_AbstractCoordinateOperationType_httpwww_opengis_netgml_positionalAccuracy', True)

    
    positionalAccuracy = property(__positionalAccuracy.value, __positionalAccuracy.set, None, None)

    
    # Element coordinateOperationName ({http://www.opengis.net/gml}coordinateOperationName) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationBaseType
    
    # Element {http://www.opengis.net/gml}validArea uses Python identifier validArea
    __validArea = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'validArea'), 'validArea', '__httpwww_opengis_netgml_AbstractCoordinateOperationType_httpwww_opengis_netgmlvalidArea', False)

    
    validArea = property(__validArea.value, __validArea.set, None, u'Area or region in which this CRS object is valid.')

    
    # Element {http://www.opengis.net/gml}remarks uses Python identifier remarks
    __remarks = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'remarks'), 'remarks', '__httpwww_opengis_netgml_AbstractCoordinateOperationType_httpwww_opengis_netgmlremarks', False)

    
    remarks = property(__remarks.value, __remarks.set, None, u'Information about this object or code. Contains text or refers to external text.')

    
    # Element {http://www.opengis.net/gml}sourceCRS uses Python identifier sourceCRS
    __sourceCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'sourceCRS'), 'sourceCRS', '__httpwww_opengis_netgml_AbstractCoordinateOperationType_httpwww_opengis_netgmlsourceCRS', False)

    
    sourceCRS = property(__sourceCRS.value, __sourceCRS.set, None, u'Association to the source CRS (coordinate reference system) of this coordinate operation. ')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}scope uses Python identifier scope
    __scope = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'scope'), 'scope', '__httpwww_opengis_netgml_AbstractCoordinateOperationType_httpwww_opengis_netgmlscope', False)

    
    scope = property(__scope.value, __scope.set, None, u'Description of domain of usage, or limitations of usage, for which this CRS object is valid.')

    
    # Element {http://www.opengis.net/gml}targetCRS uses Python identifier targetCRS
    __targetCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'targetCRS'), 'targetCRS', '__httpwww_opengis_netgml_AbstractCoordinateOperationType_httpwww_opengis_netgmltargetCRS', False)

    
    targetCRS = property(__targetCRS.value, __targetCRS.set, None, u'Association to the target CRS (coordinate reference system) of this coordinate operation. For constraints on multiplicity of "sourceCRS" and "targetCRS", see UML model of Coordinate Operation package in OGC Abstract Specification topic 2. ')

    
    # Element {http://www.opengis.net/gml}operationVersion uses Python identifier operationVersion
    __operationVersion = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'operationVersion'), 'operationVersion', '__httpwww_opengis_netgml_AbstractCoordinateOperationType_httpwww_opengis_netgmloperationVersion', False)

    
    operationVersion = property(__operationVersion.value, __operationVersion.set, None, u'Version of the coordinate transformation (i.e., instantiation due to the stochastic nature of the parameters). Mandatory when describing a transformation, and should not be supplied for a conversion. ')

    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationBaseType

    _ElementMap = AbstractCoordinateOperationBaseType._ElementMap.copy()
    _ElementMap.update({
        __coordinateOperationID.name() : __coordinateOperationID,
        __positionalAccuracy.name() : __positionalAccuracy,
        __validArea.name() : __validArea,
        __remarks.name() : __remarks,
        __sourceCRS.name() : __sourceCRS,
        __scope.name() : __scope,
        __targetCRS.name() : __targetCRS,
        __operationVersion.name() : __operationVersion
    })
    _AttributeMap = AbstractCoordinateOperationBaseType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractCoordinateOperationType', AbstractCoordinateOperationType)


# Complex type AbstractGeneralConversionType with content type ELEMENT_ONLY
class AbstractGeneralConversionType (AbstractCoordinateOperationType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralConversionType')
    # Base type is AbstractCoordinateOperationType
    
    # Element coordinateOperationID ({http://www.opengis.net/gml}coordinateOperationID) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element positionalAccuracy ({http://www.opengis.net/gml}_positionalAccuracy) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element validArea ({http://www.opengis.net/gml}validArea) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element scope ({http://www.opengis.net/gml}scope) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element coordinateOperationName ({http://www.opengis.net/gml}coordinateOperationName) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationBaseType
    
    # Attribute id is restricted from parent
    
    # Attribute {http://www.opengis.net/gml}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'id'), 'id', '__httpwww_opengis_netgml_AbstractGMLType_httpwww_opengis_netgmlid', pyxb.binding.datatypes.ID, required=True)
    
    id = property(__id.value, __id.set, None, u'Database handle for the object.  It is of XML type ID, so is constrained to be unique in the XML document within which it occurs.  An external identifier for the object in the form of a URI may be constructed using standard XML and XPointer methods.  This is done by concatenating the URI for the document, a fragment separator, and the value of the id attribute.')


    _ElementMap = AbstractCoordinateOperationType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractCoordinateOperationType._AttributeMap.copy()
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', u'AbstractGeneralConversionType', AbstractGeneralConversionType)


# Complex type DirectedTopoSolidPropertyType with content type ELEMENT_ONLY
class DirectedTopoSolidPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DirectedTopoSolidPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TopoSolid uses Python identifier TopoSolid
    __TopoSolid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TopoSolid'), 'TopoSolid', '__httpwww_opengis_netgml_DirectedTopoSolidPropertyType_httpwww_opengis_netgmlTopoSolid', False)

    
    TopoSolid = property(__TopoSolid.value, __TopoSolid.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_DirectedTopoSolidPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_DirectedTopoSolidPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_DirectedTopoSolidPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_DirectedTopoSolidPropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_DirectedTopoSolidPropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_DirectedTopoSolidPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_DirectedTopoSolidPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute orientation uses Python identifier orientation
    __orientation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'orientation'), 'orientation', '__httpwww_opengis_netgml_DirectedTopoSolidPropertyType_orientation', SignType, unicode_default=u'+')
    
    orientation = property(__orientation.value, __orientation.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_DirectedTopoSolidPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)


    _ElementMap = {
        __TopoSolid.name() : __TopoSolid
    }
    _AttributeMap = {
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __type.name() : __type,
        __show.name() : __show,
        __actuate.name() : __actuate,
        __role.name() : __role,
        __title.name() : __title,
        __orientation.name() : __orientation,
        __href.name() : __href
    }
Namespace.addCategoryObject('typeBinding', u'DirectedTopoSolidPropertyType', DirectedTopoSolidPropertyType)


# Complex type MultiGeometryPropertyType with content type ELEMENT_ONLY
class MultiGeometryPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiGeometryPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_GeometricAggregate uses Python identifier GeometricAggregate
    __GeometricAggregate = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_GeometricAggregate'), 'GeometricAggregate', '__httpwww_opengis_netgml_MultiGeometryPropertyType_httpwww_opengis_netgml_GeometricAggregate', False)

    
    GeometricAggregate = property(__GeometricAggregate.value, __GeometricAggregate.set, None, u'The "_GeometricAggregate" element is the abstract head of the substituition group for all geometric aggremates.')

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_MultiGeometryPropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_MultiGeometryPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_MultiGeometryPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_MultiGeometryPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_MultiGeometryPropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_MultiGeometryPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_MultiGeometryPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_MultiGeometryPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)


    _ElementMap = {
        __GeometricAggregate.name() : __GeometricAggregate
    }
    _AttributeMap = {
        __show.name() : __show,
        __type.name() : __type,
        __href.name() : __href,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'MultiGeometryPropertyType', MultiGeometryPropertyType)


# Complex type MultiSurfaceCoverageType with content type ELEMENT_ONLY
class MultiSurfaceCoverageType (AbstractDiscreteCoverageType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiSurfaceCoverageType')
    # Base type is AbstractDiscreteCoverageType
    
    # Element rangeSet ({http://www.opengis.net/gml}rangeSet) inherited from {http://www.opengis.net/gml}AbstractCoverageType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element boundedBy ({http://www.opengis.net/gml}boundedBy) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element {http://www.opengis.net/gml}multiSurfaceDomain uses Python identifier multiSurfaceDomain
    __multiSurfaceDomain = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'multiSurfaceDomain'), 'multiSurfaceDomain', '__httpwww_opengis_netgml_MultiSurfaceCoverageType_httpwww_opengis_netgmlmultiSurfaceDomain', False)

    
    multiSurfaceDomain = property(__multiSurfaceDomain.value, __multiSurfaceDomain.set, None, None)

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element coverageFunction ({http://www.opengis.net/gml}coverageFunction) inherited from {http://www.opengis.net/gml}AbstractDiscreteCoverageType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute dimension inherited from {http://www.opengis.net/gml}AbstractCoverageType

    _ElementMap = AbstractDiscreteCoverageType._ElementMap.copy()
    _ElementMap.update({
        __multiSurfaceDomain.name() : __multiSurfaceDomain
    })
    _AttributeMap = AbstractDiscreteCoverageType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MultiSurfaceCoverageType', MultiSurfaceCoverageType)


# Complex type MultiCurveType with content type ELEMENT_ONLY
class MultiCurveType (AbstractGeometricAggregateType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiCurveType')
    # Base type is AbstractGeometricAggregateType
    
    # Element {http://www.opengis.net/gml}curveMember uses Python identifier curveMember
    __curveMember = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'curveMember'), 'curveMember', '__httpwww_opengis_netgml_MultiCurveType_httpwww_opengis_netgmlcurveMember', True)

    
    curveMember = property(__curveMember.value, __curveMember.set, None, u'This property element either references a curve via the XLink-attributes or contains the curve element. A curve element is any element which is substitutable for "_Curve".')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}curveMembers uses Python identifier curveMembers
    __curveMembers = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'curveMembers'), 'curveMembers', '__httpwww_opengis_netgml_MultiCurveType_httpwww_opengis_netgmlcurveMembers', False)

    
    curveMembers = property(__curveMembers.value, __curveMembers.set, None, u'This property element contains a list of curves. The order of the elements is significant and shall be preserved when processing the array.')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometricAggregateType._ElementMap.copy()
    _ElementMap.update({
        __curveMember.name() : __curveMember,
        __curveMembers.name() : __curveMembers
    })
    _AttributeMap = AbstractGeometricAggregateType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MultiCurveType', MultiCurveType)


# Complex type TimeCalendarEraType with content type ELEMENT_ONLY
class TimeCalendarEraType (DefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeCalendarEraType')
    # Base type is DefinitionType
    
    # Element {http://www.opengis.net/gml}referenceEvent uses Python identifier referenceEvent
    __referenceEvent = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'referenceEvent'), 'referenceEvent', '__httpwww_opengis_netgml_TimeCalendarEraType_httpwww_opengis_netgmlreferenceEvent', False)

    
    referenceEvent = property(__referenceEvent.value, __referenceEvent.set, None, u'Name or description of a mythical or historic event which fixes the position of the base scale of the calendar era.')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}epochOfUse uses Python identifier epochOfUse
    __epochOfUse = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'epochOfUse'), 'epochOfUse', '__httpwww_opengis_netgml_TimeCalendarEraType_httpwww_opengis_netgmlepochOfUse', False)

    
    epochOfUse = property(__epochOfUse.value, __epochOfUse.set, None, u'Period for which the calendar era was used as a basis for dating.')

    
    # Element {http://www.opengis.net/gml}julianReference uses Python identifier julianReference
    __julianReference = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'julianReference'), 'julianReference', '__httpwww_opengis_netgml_TimeCalendarEraType_httpwww_opengis_netgmljulianReference', False)

    
    julianReference = property(__julianReference.value, __julianReference.set, None, u'Julian date that corresponds to the reference date.  \n              The Julian day numbering system is a temporal coordinate system that has an \n              origin earlier than any known calendar, \n              at noon on 1 January 4713 BC in the Julian proleptic calendar.  \n              The Julian day number is an integer value; \n              the Julian date is a decimal value that allows greater resolution. \n              Transforming calendar dates to and from Julian dates provides a \n              relatively simple basis for transforming dates from one calendar to another.')

    
    # Element {http://www.opengis.net/gml}referenceDate uses Python identifier referenceDate
    __referenceDate = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'referenceDate'), 'referenceDate', '__httpwww_opengis_netgml_TimeCalendarEraType_httpwww_opengis_netgmlreferenceDate', False)

    
    referenceDate = property(__referenceDate.value, __referenceDate.set, None, u'Date of the referenceEvent expressed as a date in the given calendar. \n              In most calendars, this date is the origin (i.e., the first day) of the scale, but this is not always true.')

    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id_ inherited from {http://www.opengis.net/gml}DefinitionType

    _ElementMap = DefinitionType._ElementMap.copy()
    _ElementMap.update({
        __referenceEvent.name() : __referenceEvent,
        __epochOfUse.name() : __epochOfUse,
        __julianReference.name() : __julianReference,
        __referenceDate.name() : __referenceDate
    })
    _AttributeMap = DefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TimeCalendarEraType', TimeCalendarEraType)


# Complex type AbstractGeneralOperationParameterType with content type ELEMENT_ONLY
class AbstractGeneralOperationParameterType (DefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralOperationParameterType')
    # Base type is DefinitionType
    
    # Element {http://www.opengis.net/gml}minimumOccurs uses Python identifier minimumOccurs
    __minimumOccurs = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'minimumOccurs'), 'minimumOccurs', '__httpwww_opengis_netgml_AbstractGeneralOperationParameterType_httpwww_opengis_netgmlminimumOccurs', False)

    
    minimumOccurs = property(__minimumOccurs.value, __minimumOccurs.set, None, u'The minimum number of times that values for this parameter group or parameter are required. If this attribute is omitted, the minimum number is one. ')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id_ inherited from {http://www.opengis.net/gml}DefinitionType

    _ElementMap = DefinitionType._ElementMap.copy()
    _ElementMap.update({
        __minimumOccurs.name() : __minimumOccurs
    })
    _AttributeMap = DefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractGeneralOperationParameterType', AbstractGeneralOperationParameterType)


# Complex type TopoSolidType with content type ELEMENT_ONLY
class TopoSolidType (AbstractTopoPrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopoSolidType')
    # Base type is AbstractTopoPrimitiveType
    
    # Element isolated ({http://www.opengis.net/gml}isolated) inherited from {http://www.opengis.net/gml}AbstractTopoPrimitiveType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element container ({http://www.opengis.net/gml}container) inherited from {http://www.opengis.net/gml}AbstractTopoPrimitiveType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}directedFace uses Python identifier directedFace
    __directedFace = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'directedFace'), 'directedFace', '__httpwww_opengis_netgml_TopoSolidType_httpwww_opengis_netgmldirectedFace', True)

    
    directedFace = property(__directedFace.value, __directedFace.set, None, u'')

    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTopoPrimitiveType._ElementMap.copy()
    _ElementMap.update({
        __directedFace.name() : __directedFace
    })
    _AttributeMap = AbstractTopoPrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TopoSolidType', TopoSolidType)


# Complex type MultiPointPropertyType with content type ELEMENT_ONLY
class MultiPointPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiPointPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}MultiPoint uses Python identifier MultiPoint
    __MultiPoint = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'MultiPoint'), 'MultiPoint', '__httpwww_opengis_netgml_MultiPointPropertyType_httpwww_opengis_netgmlMultiPoint', False)

    
    MultiPoint = property(__MultiPoint.value, __MultiPoint.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_MultiPointPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_MultiPointPropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_MultiPointPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_MultiPointPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_MultiPointPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_MultiPointPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_MultiPointPropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_MultiPointPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)


    _ElementMap = {
        __MultiPoint.name() : __MultiPoint
    }
    _AttributeMap = {
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __href.name() : __href,
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'MultiPointPropertyType', MultiPointPropertyType)


# Complex type SurfacePatchArrayPropertyType with content type ELEMENT_ONLY
class SurfacePatchArrayPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SurfacePatchArrayPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_SurfacePatch uses Python identifier SurfacePatch
    __SurfacePatch = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_SurfacePatch'), 'SurfacePatch', '__httpwww_opengis_netgml_SurfacePatchArrayPropertyType_httpwww_opengis_netgml_SurfacePatch', True)

    
    SurfacePatch = property(__SurfacePatch.value, __SurfacePatch.set, None, u'The "_SurfacePatch" element is the abstract head of the substituition group for all surface pach elements describing a continuous portion of a surface.')


    _ElementMap = {
        __SurfacePatch.name() : __SurfacePatch
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'SurfacePatchArrayPropertyType', SurfacePatchArrayPropertyType)


# Complex type EnvelopeWithTimePeriodType with content type ELEMENT_ONLY
class EnvelopeWithTimePeriodType (EnvelopeType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'EnvelopeWithTimePeriodType')
    # Base type is EnvelopeType
    
    # Element pos ({http://www.opengis.net/gml}pos) inherited from {http://www.opengis.net/gml}EnvelopeType
    
    # Element coordinates ({http://www.opengis.net/gml}coordinates) inherited from {http://www.opengis.net/gml}EnvelopeType
    
    # Element lowerCorner ({http://www.opengis.net/gml}lowerCorner) inherited from {http://www.opengis.net/gml}EnvelopeType
    
    # Element coord ({http://www.opengis.net/gml}coord) inherited from {http://www.opengis.net/gml}EnvelopeType
    
    # Element upperCorner ({http://www.opengis.net/gml}upperCorner) inherited from {http://www.opengis.net/gml}EnvelopeType
    
    # Element {http://www.opengis.net/gml}timePosition uses Python identifier timePosition
    __timePosition = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'timePosition'), 'timePosition', '__httpwww_opengis_netgml_EnvelopeWithTimePeriodType_httpwww_opengis_netgmltimePosition', True)

    
    timePosition = property(__timePosition.value, __timePosition.set, None, u'Direct representation of a temporal position')

    
    # Attribute srsName inherited from {http://www.opengis.net/gml}EnvelopeType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}EnvelopeType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}EnvelopeType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}EnvelopeType
    
    # Attribute frame uses Python identifier frame
    __frame = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'frame'), 'frame', '__httpwww_opengis_netgml_EnvelopeWithTimePeriodType_frame', pyxb.binding.datatypes.anyURI, unicode_default=u'#ISO-8601')
    
    frame = property(__frame.value, __frame.set, None, None)


    _ElementMap = EnvelopeType._ElementMap.copy()
    _ElementMap.update({
        __timePosition.name() : __timePosition
    })
    _AttributeMap = EnvelopeType._AttributeMap.copy()
    _AttributeMap.update({
        __frame.name() : __frame
    })
Namespace.addCategoryObject('typeBinding', u'EnvelopeWithTimePeriodType', EnvelopeWithTimePeriodType)


# Complex type CoordinatesType with content type SIMPLE
class CoordinatesType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = pyxb.binding.datatypes.string
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CoordinatesType')
    # Base type is pyxb.binding.datatypes.string
    
    # Attribute cs uses Python identifier cs
    __cs = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'cs'), 'cs', '__httpwww_opengis_netgml_CoordinatesType_cs', pyxb.binding.datatypes.string, unicode_default=u',')
    
    cs = property(__cs.value, __cs.set, None, None)

    
    # Attribute ts uses Python identifier ts
    __ts = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'ts'), 'ts', '__httpwww_opengis_netgml_CoordinatesType_ts', pyxb.binding.datatypes.string, unicode_default=u' ')
    
    ts = property(__ts.value, __ts.set, None, None)

    
    # Attribute decimal uses Python identifier decimal
    __decimal = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'decimal'), 'decimal', '__httpwww_opengis_netgml_CoordinatesType_decimal', pyxb.binding.datatypes.string, unicode_default=u'.')
    
    decimal = property(__decimal.value, __decimal.set, None, None)


    _ElementMap = {
        
    }
    _AttributeMap = {
        __cs.name() : __cs,
        __ts.name() : __ts,
        __decimal.name() : __decimal
    }
Namespace.addCategoryObject('typeBinding', u'CoordinatesType', CoordinatesType)


# Complex type MultiCurvePropertyType with content type ELEMENT_ONLY
class MultiCurvePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiCurvePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}MultiCurve uses Python identifier MultiCurve
    __MultiCurve = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'MultiCurve'), 'MultiCurve', '__httpwww_opengis_netgml_MultiCurvePropertyType_httpwww_opengis_netgmlMultiCurve', False)

    
    MultiCurve = property(__MultiCurve.value, __MultiCurve.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_MultiCurvePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_MultiCurvePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_MultiCurvePropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_MultiCurvePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_MultiCurvePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_MultiCurvePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_MultiCurvePropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_MultiCurvePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)


    _ElementMap = {
        __MultiCurve.name() : __MultiCurve
    }
    _AttributeMap = {
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __show.name() : __show,
        __remoteSchema.name() : __remoteSchema,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __href.name() : __href
    }
Namespace.addCategoryObject('typeBinding', u'MultiCurvePropertyType', MultiCurvePropertyType)


# Complex type KnotPropertyType with content type ELEMENT_ONLY
class KnotPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'KnotPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Knot uses Python identifier Knot
    __Knot = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Knot'), 'Knot', '__httpwww_opengis_netgml_KnotPropertyType_httpwww_opengis_netgmlKnot', False)

    
    Knot = property(__Knot.value, __Knot.set, None, None)


    _ElementMap = {
        __Knot.name() : __Knot
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'KnotPropertyType', KnotPropertyType)


# Complex type MeasureListType with content type SIMPLE
class MeasureListType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = doubleList
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MeasureListType')
    # Base type is doubleList
    
    # Attribute uom uses Python identifier uom
    __uom = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'uom'), 'uom', '__httpwww_opengis_netgml_MeasureListType_uom', pyxb.binding.datatypes.anyURI, required=True)
    
    uom = property(__uom.value, __uom.set, None, None)


    _ElementMap = {
        
    }
    _AttributeMap = {
        __uom.name() : __uom
    }
Namespace.addCategoryObject('typeBinding', u'MeasureListType', MeasureListType)


# Complex type TopoSurfacePropertyType with content type ELEMENT_ONLY
class TopoSurfacePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopoSurfacePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TopoSurface uses Python identifier TopoSurface
    __TopoSurface = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TopoSurface'), 'TopoSurface', '__httpwww_opengis_netgml_TopoSurfacePropertyType_httpwww_opengis_netgmlTopoSurface', False)

    
    TopoSurface = property(__TopoSurface.value, __TopoSurface.set, None, None)


    _ElementMap = {
        __TopoSurface.name() : __TopoSurface
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'TopoSurfacePropertyType', TopoSurfacePropertyType)


# Complex type TemporalCRSRefType with content type ELEMENT_ONLY
class TemporalCRSRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TemporalCRSRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TemporalCRS uses Python identifier TemporalCRS
    __TemporalCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TemporalCRS'), 'TemporalCRS', '__httpwww_opengis_netgml_TemporalCRSRefType_httpwww_opengis_netgmlTemporalCRS', False)

    
    TemporalCRS = property(__TemporalCRS.value, __TemporalCRS.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_TemporalCRSRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_TemporalCRSRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_TemporalCRSRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_TemporalCRSRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_TemporalCRSRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_TemporalCRSRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_TemporalCRSRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_TemporalCRSRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")


    _ElementMap = {
        __TemporalCRS.name() : __TemporalCRS
    }
    _AttributeMap = {
        __title.name() : __title,
        __href.name() : __href,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __show.name() : __show
    }
Namespace.addCategoryObject('typeBinding', u'TemporalCRSRefType', TemporalCRSRefType)


# Complex type PrimeMeridianRefType with content type ELEMENT_ONLY
class PrimeMeridianRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PrimeMeridianRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}PrimeMeridian uses Python identifier PrimeMeridian
    __PrimeMeridian = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'PrimeMeridian'), 'PrimeMeridian', '__httpwww_opengis_netgml_PrimeMeridianRefType_httpwww_opengis_netgmlPrimeMeridian', False)

    
    PrimeMeridian = property(__PrimeMeridian.value, __PrimeMeridian.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_PrimeMeridianRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_PrimeMeridianRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_PrimeMeridianRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_PrimeMeridianRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_PrimeMeridianRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_PrimeMeridianRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_PrimeMeridianRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_PrimeMeridianRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)


    _ElementMap = {
        __PrimeMeridian.name() : __PrimeMeridian
    }
    _AttributeMap = {
        __title.name() : __title,
        __href.name() : __href,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __show.name() : __show,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole
    }
Namespace.addCategoryObject('typeBinding', u'PrimeMeridianRefType', PrimeMeridianRefType)


# Complex type CurveArrayPropertyType with content type ELEMENT_ONLY
class CurveArrayPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CurveArrayPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_Curve uses Python identifier Curve
    __Curve = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_Curve'), 'Curve', '__httpwww_opengis_netgml_CurveArrayPropertyType_httpwww_opengis_netgml_Curve', True)

    
    Curve = property(__Curve.value, __Curve.set, None, u'The "_Curve" element is the abstract head of the substituition group for all (continuous) curve elements.')


    _ElementMap = {
        __Curve.name() : __Curve
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'CurveArrayPropertyType', CurveArrayPropertyType)


# Complex type LineStringSegmentType with content type ELEMENT_ONLY
class LineStringSegmentType (AbstractCurveSegmentType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LineStringSegmentType')
    # Base type is AbstractCurveSegmentType
    
    # Element {http://www.opengis.net/gml}posList uses Python identifier posList
    __posList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'posList'), 'posList', '__httpwww_opengis_netgml_LineStringSegmentType_httpwww_opengis_netgmlposList', False)

    
    posList = property(__posList.value, __posList.set, None, u'')

    
    # Element {http://www.opengis.net/gml}pointProperty uses Python identifier pointProperty
    __pointProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), 'pointProperty', '__httpwww_opengis_netgml_LineStringSegmentType_httpwww_opengis_netgmlpointProperty', True)

    
    pointProperty = property(__pointProperty.value, __pointProperty.set, None, u'This property element either references a point via the XLink-attributes or contains the point element. pointProperty \n\t\t\tis the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that \n\t\t\tis substitutable for Point.')

    
    # Element {http://www.opengis.net/gml}coordinates uses Python identifier coordinates
    __coordinates = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), 'coordinates', '__httpwww_opengis_netgml_LineStringSegmentType_httpwww_opengis_netgmlcoordinates', False)

    
    coordinates = property(__coordinates.value, __coordinates.set, None, u'Deprecated with GML version 3.1.0.')

    
    # Element {http://www.opengis.net/gml}pointRep uses Python identifier pointRep
    __pointRep = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), 'pointRep', '__httpwww_opengis_netgml_LineStringSegmentType_httpwww_opengis_netgmlpointRep', True)

    
    pointRep = property(__pointRep.value, __pointRep.set, None, u'Deprecated with GML version 3.1.0. Use "pointProperty" instead. Included for backwards compatibility with GML 3.0.0.')

    
    # Element {http://www.opengis.net/gml}pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pos'), 'pos', '__httpwww_opengis_netgml_LineStringSegmentType_httpwww_opengis_netgmlpos', True)

    
    pos = property(__pos.value, __pos.set, None, u'')

    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute interpolation uses Python identifier interpolation
    __interpolation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'interpolation'), 'interpolation', '__httpwww_opengis_netgml_LineStringSegmentType_interpolation', CurveInterpolationType, fixed=True, unicode_default=u'linear')
    
    interpolation = property(__interpolation.value, __interpolation.set, None, u'The attribute "interpolation" specifies the curve interpolation mechanism used for this segment. This mechanism\nuses the control points and control parameters to determine the position of this curve segment. For a LineStringSegment the interpolation is fixed as "linear".')

    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType

    _ElementMap = AbstractCurveSegmentType._ElementMap.copy()
    _ElementMap.update({
        __posList.name() : __posList,
        __pointProperty.name() : __pointProperty,
        __coordinates.name() : __coordinates,
        __pointRep.name() : __pointRep,
        __pos.name() : __pos
    })
    _AttributeMap = AbstractCurveSegmentType._AttributeMap.copy()
    _AttributeMap.update({
        __interpolation.name() : __interpolation
    })
Namespace.addCategoryObject('typeBinding', u'LineStringSegmentType', LineStringSegmentType)


# Complex type TrianglePatchArrayPropertyType with content type ELEMENT_ONLY
class TrianglePatchArrayPropertyType (SurfacePatchArrayPropertyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TrianglePatchArrayPropertyType')
    # Base type is SurfacePatchArrayPropertyType
    
    # Element {http://www.opengis.net/gml}Triangle uses Python identifier Triangle
    __Triangle = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Triangle'), 'Triangle', '__httpwww_opengis_netgml_TrianglePatchArrayPropertyType_httpwww_opengis_netgmlTriangle', True)

    
    Triangle = property(__Triangle.value, __Triangle.set, None, None)


    _ElementMap = SurfacePatchArrayPropertyType._ElementMap.copy()
    _ElementMap.update({
        __Triangle.name() : __Triangle
    })
    _AttributeMap = SurfacePatchArrayPropertyType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TrianglePatchArrayPropertyType', TrianglePatchArrayPropertyType)


# Complex type EngineeringDatumRefType with content type ELEMENT_ONLY
class EngineeringDatumRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'EngineeringDatumRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}EngineeringDatum uses Python identifier EngineeringDatum
    __EngineeringDatum = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'EngineeringDatum'), 'EngineeringDatum', '__httpwww_opengis_netgml_EngineeringDatumRefType_httpwww_opengis_netgmlEngineeringDatum', False)

    
    EngineeringDatum = property(__EngineeringDatum.value, __EngineeringDatum.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_EngineeringDatumRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_EngineeringDatumRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_EngineeringDatumRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_EngineeringDatumRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_EngineeringDatumRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_EngineeringDatumRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_EngineeringDatumRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_EngineeringDatumRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)


    _ElementMap = {
        __EngineeringDatum.name() : __EngineeringDatum
    }
    _AttributeMap = {
        __title.name() : __title,
        __show.name() : __show,
        __href.name() : __href,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole
    }
Namespace.addCategoryObject('typeBinding', u'EngineeringDatumRefType', EngineeringDatumRefType)


# Complex type AbstractGeneralOperationParameterRefType with content type ELEMENT_ONLY
class AbstractGeneralOperationParameterRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralOperationParameterRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_GeneralOperationParameter uses Python identifier GeneralOperationParameter
    __GeneralOperationParameter = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_GeneralOperationParameter'), 'GeneralOperationParameter', '__httpwww_opengis_netgml_AbstractGeneralOperationParameterRefType_httpwww_opengis_netgml_GeneralOperationParameter', False)

    
    GeneralOperationParameter = property(__GeneralOperationParameter.value, __GeneralOperationParameter.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_AbstractGeneralOperationParameterRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_AbstractGeneralOperationParameterRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_AbstractGeneralOperationParameterRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_AbstractGeneralOperationParameterRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_AbstractGeneralOperationParameterRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_AbstractGeneralOperationParameterRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_AbstractGeneralOperationParameterRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_AbstractGeneralOperationParameterRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)


    _ElementMap = {
        __GeneralOperationParameter.name() : __GeneralOperationParameter
    }
    _AttributeMap = {
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __href.name() : __href,
        __title.name() : __title,
        __show.name() : __show,
        __arcrole.name() : __arcrole,
        __type.name() : __type,
        __role.name() : __role
    }
Namespace.addCategoryObject('typeBinding', u'AbstractGeneralOperationParameterRefType', AbstractGeneralOperationParameterRefType)


# Complex type SurfaceType with content type ELEMENT_ONLY
class SurfaceType (AbstractSurfaceType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SurfaceType')
    # Base type is AbstractSurfaceType
    
    # Element {http://www.opengis.net/gml}patches uses Python identifier patches
    __patches = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'patches'), 'patches', '__httpwww_opengis_netgml_SurfaceType_httpwww_opengis_netgmlpatches', False)

    
    patches = property(__patches.value, __patches.set, None, u'This property element contains a list of surface patches. The order of the elements is significant and shall be preserved when processing the array.')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractSurfaceType._ElementMap.copy()
    _ElementMap.update({
        __patches.name() : __patches
    })
    _AttributeMap = AbstractSurfaceType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SurfaceType', SurfaceType)


# Complex type CRSRefType with content type ELEMENT_ONLY
class CRSRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CRSRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_CRS uses Python identifier CRS
    __CRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_CRS'), 'CRS', '__httpwww_opengis_netgml_CRSRefType_httpwww_opengis_netgml_CRS', False)

    
    CRS = property(__CRS.value, __CRS.set, None, u'Abstract coordinate reference system, usually defined by a coordinate system and a datum. This abstract complexType shall not be used, extended, or restricted, in an Application Schema, to define a concrete subtype with a meaning equivalent to a concrete subtype specified in this document.')

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_CRSRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_CRSRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_CRSRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_CRSRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_CRSRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_CRSRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_CRSRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_CRSRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")


    _ElementMap = {
        __CRS.name() : __CRS
    }
    _AttributeMap = {
        __role.name() : __role,
        __href.name() : __href,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __actuate.name() : __actuate
    }
Namespace.addCategoryObject('typeBinding', u'CRSRefType', CRSRefType)


# Complex type ReferenceType with content type EMPTY
class ReferenceType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ReferenceType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_ReferenceType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_ReferenceType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_ReferenceType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_ReferenceType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_ReferenceType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_ReferenceType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_ReferenceType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_ReferenceType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)


    _ElementMap = {
        
    }
    _AttributeMap = {
        __href.name() : __href,
        __remoteSchema.name() : __remoteSchema,
        __title.name() : __title,
        __show.name() : __show,
        __role.name() : __role,
        __type.name() : __type,
        __actuate.name() : __actuate,
        __arcrole.name() : __arcrole
    }
Namespace.addCategoryObject('typeBinding', u'ReferenceType', ReferenceType)


# Complex type TargetPropertyType with content type ELEMENT_ONLY
class TargetPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TargetPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_Geometry uses Python identifier Geometry
    __Geometry = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_Geometry'), 'Geometry', '__httpwww_opengis_netgml_TargetPropertyType_httpwww_opengis_netgml_Geometry', False)

    
    Geometry = property(__Geometry.value, __Geometry.set, None, u'The "_Geometry" element is the abstract head of the substituition group for all geometry elements of GML 3. This \n\t\t\tincludes pre-defined and user-defined geometry elements. Any geometry element must be a direct or indirect extension/restriction \n\t\t\tof AbstractGeometryType and must be directly or indirectly in the substitution group of "_Geometry".')

    
    # Element {http://www.opengis.net/gml}_Feature uses Python identifier Feature
    __Feature = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_Feature'), 'Feature', '__httpwww_opengis_netgml_TargetPropertyType_httpwww_opengis_netgml_Feature', False)

    
    Feature = property(__Feature.value, __Feature.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_TargetPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_TargetPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_TargetPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_TargetPropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_TargetPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_TargetPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_TargetPropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_TargetPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')


    _ElementMap = {
        __Geometry.name() : __Geometry,
        __Feature.name() : __Feature
    }
    _AttributeMap = {
        __arcrole.name() : __arcrole,
        __type.name() : __type,
        __title.name() : __title,
        __show.name() : __show,
        __href.name() : __href,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema
    }
Namespace.addCategoryObject('typeBinding', u'TargetPropertyType', TargetPropertyType)


# Complex type AbstractTimeReferenceSystemType with content type ELEMENT_ONLY
class AbstractTimeReferenceSystemType (DefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeReferenceSystemType')
    # Base type is DefinitionType
    
    # Element {http://www.opengis.net/gml}domainOfValidity uses Python identifier domainOfValidity
    __domainOfValidity = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'), 'domainOfValidity', '__httpwww_opengis_netgml_AbstractTimeReferenceSystemType_httpwww_opengis_netgmldomainOfValidity', False)

    
    domainOfValidity = property(__domainOfValidity.value, __domainOfValidity.set, None, None)

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id_ inherited from {http://www.opengis.net/gml}DefinitionType

    _ElementMap = DefinitionType._ElementMap.copy()
    _ElementMap.update({
        __domainOfValidity.name() : __domainOfValidity
    })
    _AttributeMap = DefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractTimeReferenceSystemType', AbstractTimeReferenceSystemType)


# Complex type MultiSolidCoverageType with content type ELEMENT_ONLY
class MultiSolidCoverageType (AbstractDiscreteCoverageType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiSolidCoverageType')
    # Base type is AbstractDiscreteCoverageType
    
    # Element rangeSet ({http://www.opengis.net/gml}rangeSet) inherited from {http://www.opengis.net/gml}AbstractCoverageType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element boundedBy ({http://www.opengis.net/gml}boundedBy) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}multiSolidDomain uses Python identifier multiSolidDomain
    __multiSolidDomain = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'multiSolidDomain'), 'multiSolidDomain', '__httpwww_opengis_netgml_MultiSolidCoverageType_httpwww_opengis_netgmlmultiSolidDomain', False)

    
    multiSolidDomain = property(__multiSolidDomain.value, __multiSolidDomain.set, None, None)

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element coverageFunction ({http://www.opengis.net/gml}coverageFunction) inherited from {http://www.opengis.net/gml}AbstractDiscreteCoverageType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute dimension inherited from {http://www.opengis.net/gml}AbstractCoverageType

    _ElementMap = AbstractDiscreteCoverageType._ElementMap.copy()
    _ElementMap.update({
        __multiSolidDomain.name() : __multiSolidDomain
    })
    _AttributeMap = AbstractDiscreteCoverageType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MultiSolidCoverageType', MultiSolidCoverageType)


# Complex type CoverageFunctionType with content type ELEMENT_ONLY
class CoverageFunctionType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CoverageFunctionType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}MappingRule uses Python identifier MappingRule
    __MappingRule = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'MappingRule'), 'MappingRule', '__httpwww_opengis_netgml_CoverageFunctionType_httpwww_opengis_netgmlMappingRule', False)

    
    MappingRule = property(__MappingRule.value, __MappingRule.set, None, u'Description of a rule for associating members from the domainSet with members of the rangeSet.')

    
    # Element {http://www.opengis.net/gml}GridFunction uses Python identifier GridFunction
    __GridFunction = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'GridFunction'), 'GridFunction', '__httpwww_opengis_netgml_CoverageFunctionType_httpwww_opengis_netgmlGridFunction', False)

    
    GridFunction = property(__GridFunction.value, __GridFunction.set, None, None)


    _ElementMap = {
        __MappingRule.name() : __MappingRule,
        __GridFunction.name() : __GridFunction
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'CoverageFunctionType', CoverageFunctionType)


# Complex type OperationParameterBaseType with content type ELEMENT_ONLY
class OperationParameterBaseType (AbstractGeneralOperationParameterType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'OperationParameterBaseType')
    # Base type is AbstractGeneralOperationParameterType
    
    # Element minimumOccurs ({http://www.opengis.net/gml}minimumOccurs) inherited from {http://www.opengis.net/gml}AbstractGeneralOperationParameterType
    
    # Element {http://www.opengis.net/gml}parameterName uses Python identifier parameterName
    __parameterName = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'parameterName'), 'parameterName', '__httpwww_opengis_netgml_OperationParameterBaseType_httpwww_opengis_netgmlparameterName', False)

    
    parameterName = property(__parameterName.value, __parameterName.set, None, u'The name by which this operation parameter is identified. ')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id is restricted from parent
    
    # Attribute {http://www.opengis.net/gml}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'id'), 'id', '__httpwww_opengis_netgml_AbstractGMLType_httpwww_opengis_netgmlid', pyxb.binding.datatypes.ID, required=True)
    
    id = property(__id.value, __id.set, None, u'Database handle for the object.  It is of XML type ID, so is constrained to be unique in the XML document within which it occurs.  An external identifier for the object in the form of a URI may be constructed using standard XML and XPointer methods.  This is done by concatenating the URI for the document, a fragment separator, and the value of the id attribute.')


    _ElementMap = AbstractGeneralOperationParameterType._ElementMap.copy()
    _ElementMap.update({
        __parameterName.name() : __parameterName
    })
    _AttributeMap = AbstractGeneralOperationParameterType._AttributeMap.copy()
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', u'OperationParameterBaseType', OperationParameterBaseType)


# Complex type OperationParameterType with content type ELEMENT_ONLY
class OperationParameterType (OperationParameterBaseType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'OperationParameterType')
    # Base type is OperationParameterBaseType
    
    # Element minimumOccurs ({http://www.opengis.net/gml}minimumOccurs) inherited from {http://www.opengis.net/gml}AbstractGeneralOperationParameterType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}parameterID uses Python identifier parameterID
    __parameterID = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'parameterID'), 'parameterID', '__httpwww_opengis_netgml_OperationParameterType_httpwww_opengis_netgmlparameterID', True)

    
    parameterID = property(__parameterID.value, __parameterID.set, None, u'An identification of an operation parameter. ')

    
    # Element parameterName ({http://www.opengis.net/gml}parameterName) inherited from {http://www.opengis.net/gml}OperationParameterBaseType
    
    # Element {http://www.opengis.net/gml}remarks uses Python identifier remarks
    __remarks = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'remarks'), 'remarks', '__httpwww_opengis_netgml_OperationParameterType_httpwww_opengis_netgmlremarks', False)

    
    remarks = property(__remarks.value, __remarks.set, None, u'Information about this object or code. Contains text or refers to external text.')

    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}OperationParameterBaseType

    _ElementMap = OperationParameterBaseType._ElementMap.copy()
    _ElementMap.update({
        __parameterID.name() : __parameterID,
        __remarks.name() : __remarks
    })
    _AttributeMap = OperationParameterBaseType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'OperationParameterType', OperationParameterType)


# Complex type PolygonType with content type ELEMENT_ONLY
class PolygonType (AbstractSurfaceType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PolygonType')
    # Base type is AbstractSurfaceType
    
    # Element {http://www.opengis.net/gml}interior uses Python identifier interior
    __interior = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'interior'), 'interior', '__httpwww_opengis_netgml_PolygonType_httpwww_opengis_netgmlinterior', True)

    
    interior = property(__interior.value, __interior.set, None, u'A boundary of a surface consists of a number of rings. The "interior" rings seperate the surface / surface patch from the area enclosed by the rings.')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}exterior uses Python identifier exterior
    __exterior = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'exterior'), 'exterior', '__httpwww_opengis_netgml_PolygonType_httpwww_opengis_netgmlexterior', False)

    
    exterior = property(__exterior.value, __exterior.set, None, u'A boundary of a surface consists of a number of rings. In the normal 2D case, one of these rings is distinguished as being the exterior boundary. In a general manifold this is not always possible, in which case all boundaries shall be listed as interior boundaries, and the exterior will be empty.')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractSurfaceType._ElementMap.copy()
    _ElementMap.update({
        __interior.name() : __interior,
        __exterior.name() : __exterior
    })
    _AttributeMap = AbstractSurfaceType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'PolygonType', PolygonType)


# Complex type EllipsoidBaseType with content type ELEMENT_ONLY
class EllipsoidBaseType (DefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'EllipsoidBaseType')
    # Base type is DefinitionType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}ellipsoidName uses Python identifier ellipsoidName
    __ellipsoidName = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'ellipsoidName'), 'ellipsoidName', '__httpwww_opengis_netgml_EllipsoidBaseType_httpwww_opengis_netgmlellipsoidName', False)

    
    ellipsoidName = property(__ellipsoidName.value, __ellipsoidName.set, None, u'The name by which this ellipsoid is identified. ')

    
    # Attribute id is restricted from parent
    
    # Attribute {http://www.opengis.net/gml}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'id'), 'id', '__httpwww_opengis_netgml_AbstractGMLType_httpwww_opengis_netgmlid', pyxb.binding.datatypes.ID, required=True)
    
    id = property(__id.value, __id.set, None, u'Database handle for the object.  It is of XML type ID, so is constrained to be unique in the XML document within which it occurs.  An external identifier for the object in the form of a URI may be constructed using standard XML and XPointer methods.  This is done by concatenating the URI for the document, a fragment separator, and the value of the id attribute.')


    _ElementMap = DefinitionType._ElementMap.copy()
    _ElementMap.update({
        __ellipsoidName.name() : __ellipsoidName
    })
    _AttributeMap = DefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', u'EllipsoidBaseType', EllipsoidBaseType)


# Complex type EllipsoidType with content type ELEMENT_ONLY
class EllipsoidType (EllipsoidBaseType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'EllipsoidType')
    # Base type is EllipsoidBaseType
    
    # Element {http://www.opengis.net/gml}ellipsoidID uses Python identifier ellipsoidID
    __ellipsoidID = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'ellipsoidID'), 'ellipsoidID', '__httpwww_opengis_netgml_EllipsoidType_httpwww_opengis_netgmlellipsoidID', True)

    
    ellipsoidID = property(__ellipsoidID.value, __ellipsoidID.set, None, u'An identification of an ellipsoid. ')

    
    # Element {http://www.opengis.net/gml}secondDefiningParameter uses Python identifier secondDefiningParameter
    __secondDefiningParameter = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'secondDefiningParameter'), 'secondDefiningParameter', '__httpwww_opengis_netgml_EllipsoidType_httpwww_opengis_netgmlsecondDefiningParameter', False)

    
    secondDefiningParameter = property(__secondDefiningParameter.value, __secondDefiningParameter.set, None, None)

    
    # Element {http://www.opengis.net/gml}remarks uses Python identifier remarks
    __remarks = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'remarks'), 'remarks', '__httpwww_opengis_netgml_EllipsoidType_httpwww_opengis_netgmlremarks', False)

    
    remarks = property(__remarks.value, __remarks.set, None, u'Information about this object or code. Contains text or refers to external text.')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element ellipsoidName ({http://www.opengis.net/gml}ellipsoidName) inherited from {http://www.opengis.net/gml}EllipsoidBaseType
    
    # Element {http://www.opengis.net/gml}semiMajorAxis uses Python identifier semiMajorAxis
    __semiMajorAxis = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'semiMajorAxis'), 'semiMajorAxis', '__httpwww_opengis_netgml_EllipsoidType_httpwww_opengis_netgmlsemiMajorAxis', False)

    
    semiMajorAxis = property(__semiMajorAxis.value, __semiMajorAxis.set, None, u'Length of the semi-major axis of the ellipsoid, with its units. Uses the MeasureType with the restriction that the unit of measure referenced by uom must be suitable for a length, such as metres or feet. ')

    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}EllipsoidBaseType

    _ElementMap = EllipsoidBaseType._ElementMap.copy()
    _ElementMap.update({
        __ellipsoidID.name() : __ellipsoidID,
        __secondDefiningParameter.name() : __secondDefiningParameter,
        __remarks.name() : __remarks,
        __semiMajorAxis.name() : __semiMajorAxis
    })
    _AttributeMap = EllipsoidBaseType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'EllipsoidType', EllipsoidType)


# Complex type UnitDefinitionType with content type ELEMENT_ONLY
class UnitDefinitionType (DefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'UnitDefinitionType')
    # Base type is DefinitionType
    
    # Element {http://www.opengis.net/gml}catalogSymbol uses Python identifier catalogSymbol
    __catalogSymbol = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'catalogSymbol'), 'catalogSymbol', '__httpwww_opengis_netgml_UnitDefinitionType_httpwww_opengis_netgmlcatalogSymbol', False)

    
    catalogSymbol = property(__catalogSymbol.value, __catalogSymbol.set, None, u'For global understanding of a unit of measure, it is often possible to reference an item in a catalog of units, using a symbol in that catalog. The "codeSpace" attribute in "CodeType" identifies a namespace for the catalog symbol value, and might reference the catalog. The "string" value in "CodeType" contains the value of a symbol that is unique within this catalog namespace. This symbol often appears explicitly in the catalog, but it could be a combination of symbols using a specified algebra of units. For example, the symbol "cm" might indicate that it is the "m" symbol combined with the "c" prefix.')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}quantityType uses Python identifier quantityType
    __quantityType = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'quantityType'), 'quantityType', '__httpwww_opengis_netgml_UnitDefinitionType_httpwww_opengis_netgmlquantityType', False)

    
    quantityType = property(__quantityType.value, __quantityType.set, None, u'Informal description of the phenomenon or type of quantity that is measured or observed. For example, "length", "angle", "time", "pressure", or "temperature". When the quantity is the result of an observation or measurement, this term is known as Observable Type or Measurand.')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id_ inherited from {http://www.opengis.net/gml}DefinitionType

    _ElementMap = DefinitionType._ElementMap.copy()
    _ElementMap.update({
        __catalogSymbol.name() : __catalogSymbol,
        __quantityType.name() : __quantityType
    })
    _AttributeMap = DefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'UnitDefinitionType', UnitDefinitionType)


# Complex type AbstractCoordinateSystemBaseType with content type ELEMENT_ONLY
class AbstractCoordinateSystemBaseType (DefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractCoordinateSystemBaseType')
    # Base type is DefinitionType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}csName uses Python identifier csName
    __csName = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'csName'), 'csName', '__httpwww_opengis_netgml_AbstractCoordinateSystemBaseType_httpwww_opengis_netgmlcsName', False)

    
    csName = property(__csName.value, __csName.set, None, u'The name by which this coordinate system is identified. ')

    
    # Attribute id is restricted from parent
    
    # Attribute {http://www.opengis.net/gml}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'id'), 'id', '__httpwww_opengis_netgml_AbstractGMLType_httpwww_opengis_netgmlid', pyxb.binding.datatypes.ID, required=True)
    
    id = property(__id.value, __id.set, None, u'Database handle for the object.  It is of XML type ID, so is constrained to be unique in the XML document within which it occurs.  An external identifier for the object in the form of a URI may be constructed using standard XML and XPointer methods.  This is done by concatenating the URI for the document, a fragment separator, and the value of the id attribute.')


    _ElementMap = DefinitionType._ElementMap.copy()
    _ElementMap.update({
        __csName.name() : __csName
    })
    _AttributeMap = DefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', u'AbstractCoordinateSystemBaseType', AbstractCoordinateSystemBaseType)


# Complex type AbstractCoordinateSystemType with content type ELEMENT_ONLY
class AbstractCoordinateSystemType (AbstractCoordinateSystemBaseType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractCoordinateSystemType')
    # Base type is AbstractCoordinateSystemBaseType
    
    # Element {http://www.opengis.net/gml}usesAxis uses Python identifier usesAxis
    __usesAxis = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesAxis'), 'usesAxis', '__httpwww_opengis_netgml_AbstractCoordinateSystemType_httpwww_opengis_netgmlusesAxis', True)

    
    usesAxis = property(__usesAxis.value, __usesAxis.set, None, u'Association to a coordinate system axis. ')

    
    # Element {http://www.opengis.net/gml}remarks uses Python identifier remarks
    __remarks = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'remarks'), 'remarks', '__httpwww_opengis_netgml_AbstractCoordinateSystemType_httpwww_opengis_netgmlremarks', False)

    
    remarks = property(__remarks.value, __remarks.set, None, u'Information about this object or code. Contains text or refers to external text.')

    
    # Element {http://www.opengis.net/gml}csID uses Python identifier csID
    __csID = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'csID'), 'csID', '__httpwww_opengis_netgml_AbstractCoordinateSystemType_httpwww_opengis_netgmlcsID', True)

    
    csID = property(__csID.value, __csID.set, None, u'An identification of a coordinate system. ')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element csName ({http://www.opengis.net/gml}csName) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemBaseType
    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemBaseType

    _ElementMap = AbstractCoordinateSystemBaseType._ElementMap.copy()
    _ElementMap.update({
        __usesAxis.name() : __usesAxis,
        __remarks.name() : __remarks,
        __csID.name() : __csID
    })
    _AttributeMap = AbstractCoordinateSystemBaseType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractCoordinateSystemType', AbstractCoordinateSystemType)


# Complex type ObliqueCartesianCSType with content type ELEMENT_ONLY
class ObliqueCartesianCSType (AbstractCoordinateSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ObliqueCartesianCSType')
    # Base type is AbstractCoordinateSystemType
    
    # Element usesAxis ({http://www.opengis.net/gml}usesAxis) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element csID ({http://www.opengis.net/gml}csID) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element csName ({http://www.opengis.net/gml}csName) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemBaseType
    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemBaseType

    _ElementMap = AbstractCoordinateSystemType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractCoordinateSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ObliqueCartesianCSType', ObliqueCartesianCSType)


# Complex type AbstractPositionalAccuracyType with content type ELEMENT_ONLY
class AbstractPositionalAccuracyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractPositionalAccuracyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}measureDescription uses Python identifier measureDescription
    __measureDescription = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'measureDescription'), 'measureDescription', '__httpwww_opengis_netgml_AbstractPositionalAccuracyType_httpwww_opengis_netgmlmeasureDescription', False)

    
    measureDescription = property(__measureDescription.value, __measureDescription.set, None, u'A description of the position accuracy parameter(s) provided. ')


    _ElementMap = {
        __measureDescription.name() : __measureDescription
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'AbstractPositionalAccuracyType', AbstractPositionalAccuracyType)


# Complex type RelativeInternalPositionalAccuracyType with content type ELEMENT_ONLY
class RelativeInternalPositionalAccuracyType (AbstractPositionalAccuracyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'RelativeInternalPositionalAccuracyType')
    # Base type is AbstractPositionalAccuracyType
    
    # Element {http://www.opengis.net/gml}result uses Python identifier result
    __result = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'result'), 'result', '__httpwww_opengis_netgml_RelativeInternalPositionalAccuracyType_httpwww_opengis_netgmlresult', False)

    
    result = property(__result.value, __result.set, None, u'A quantitative result defined by the evaluation procedure used, and identified by the measureDescription. ')

    
    # Element measureDescription ({http://www.opengis.net/gml}measureDescription) inherited from {http://www.opengis.net/gml}AbstractPositionalAccuracyType

    _ElementMap = AbstractPositionalAccuracyType._ElementMap.copy()
    _ElementMap.update({
        __result.name() : __result
    })
    _AttributeMap = AbstractPositionalAccuracyType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'RelativeInternalPositionalAccuracyType', RelativeInternalPositionalAccuracyType)


# Complex type TopoComplexMemberType with content type ELEMENT_ONLY
class TopoComplexMemberType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopoComplexMemberType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TopoComplex uses Python identifier TopoComplex
    __TopoComplex = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TopoComplex'), 'TopoComplex', '__httpwww_opengis_netgml_TopoComplexMemberType_httpwww_opengis_netgmlTopoComplex', False)

    
    TopoComplex = property(__TopoComplex.value, __TopoComplex.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_TopoComplexMemberType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_TopoComplexMemberType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_TopoComplexMemberType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_TopoComplexMemberType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_TopoComplexMemberType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_TopoComplexMemberType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_TopoComplexMemberType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_TopoComplexMemberType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)


    _ElementMap = {
        __TopoComplex.name() : __TopoComplex
    }
    _AttributeMap = {
        __role.name() : __role,
        __show.name() : __show,
        __actuate.name() : __actuate,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __remoteSchema.name() : __remoteSchema,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'TopoComplexMemberType', TopoComplexMemberType)


# Complex type ObservationType with content type ELEMENT_ONLY
class ObservationType (AbstractFeatureType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ObservationType')
    # Base type is AbstractFeatureType
    
    # Element {http://www.opengis.net/gml}using uses Python identifier using
    __using = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'using'), 'using', '__httpwww_opengis_netgml_ObservationType_httpwww_opengis_netgmlusing', False)

    
    using = property(__using.value, __using.set, None, u'This element contains or points to a description of a sensor, instrument or procedure used for the observation')

    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element boundedBy ({http://www.opengis.net/gml}boundedBy) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element {http://www.opengis.net/gml}target uses Python identifier target
    __target = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'target'), 'target', '__httpwww_opengis_netgml_ObservationType_httpwww_opengis_netgmltarget', False)

    
    target = property(__target.value, __target.set, None, u'This element contains or points to the specimen, region or station which is the object of the observation')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}validTime uses Python identifier validTime
    __validTime = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'validTime'), 'validTime', '__httpwww_opengis_netgml_ObservationType_httpwww_opengis_netgmlvalidTime', False)

    
    validTime = property(__validTime.value, __validTime.set, None, None)

    
    # Element location ({http://www.opengis.net/gml}location) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element {http://www.opengis.net/gml}resultOf uses Python identifier resultOf
    __resultOf = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'resultOf'), 'resultOf', '__httpwww_opengis_netgml_ObservationType_httpwww_opengis_netgmlresultOf', False)

    
    resultOf = property(__resultOf.value, __resultOf.set, None, u'The result of the observation: an image, external object, etc')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractFeatureType._ElementMap.copy()
    _ElementMap.update({
        __using.name() : __using,
        __target.name() : __target,
        __validTime.name() : __validTime,
        __resultOf.name() : __resultOf
    })
    _AttributeMap = AbstractFeatureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ObservationType', ObservationType)


# Complex type DirectedObservationType with content type ELEMENT_ONLY
class DirectedObservationType (ObservationType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DirectedObservationType')
    # Base type is ObservationType
    
    # Element using ({http://www.opengis.net/gml}using) inherited from {http://www.opengis.net/gml}ObservationType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element boundedBy ({http://www.opengis.net/gml}boundedBy) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element target ({http://www.opengis.net/gml}target) inherited from {http://www.opengis.net/gml}ObservationType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element location ({http://www.opengis.net/gml}location) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element validTime ({http://www.opengis.net/gml}validTime) inherited from {http://www.opengis.net/gml}ObservationType
    
    # Element resultOf ({http://www.opengis.net/gml}resultOf) inherited from {http://www.opengis.net/gml}ObservationType
    
    # Element {http://www.opengis.net/gml}direction uses Python identifier direction
    __direction = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'direction'), 'direction', '__httpwww_opengis_netgml_DirectedObservationType_httpwww_opengis_netgmldirection', False)

    
    direction = property(__direction.value, __direction.set, None, None)

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = ObservationType._ElementMap.copy()
    _ElementMap.update({
        __direction.name() : __direction
    })
    _AttributeMap = ObservationType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'DirectedObservationType', DirectedObservationType)


# Complex type DirectedObservationAtDistanceType with content type ELEMENT_ONLY
class DirectedObservationAtDistanceType (DirectedObservationType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DirectedObservationAtDistanceType')
    # Base type is DirectedObservationType
    
    # Element using ({http://www.opengis.net/gml}using) inherited from {http://www.opengis.net/gml}ObservationType
    
    # Element {http://www.opengis.net/gml}distance uses Python identifier distance
    __distance = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'distance'), 'distance', '__httpwww_opengis_netgml_DirectedObservationAtDistanceType_httpwww_opengis_netgmldistance', False)

    
    distance = property(__distance.value, __distance.set, None, None)

    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element target ({http://www.opengis.net/gml}target) inherited from {http://www.opengis.net/gml}ObservationType
    
    # Element boundedBy ({http://www.opengis.net/gml}boundedBy) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element location ({http://www.opengis.net/gml}location) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element validTime ({http://www.opengis.net/gml}validTime) inherited from {http://www.opengis.net/gml}ObservationType
    
    # Element resultOf ({http://www.opengis.net/gml}resultOf) inherited from {http://www.opengis.net/gml}ObservationType
    
    # Element direction ({http://www.opengis.net/gml}direction) inherited from {http://www.opengis.net/gml}DirectedObservationType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = DirectedObservationType._ElementMap.copy()
    _ElementMap.update({
        __distance.name() : __distance
    })
    _AttributeMap = DirectedObservationType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'DirectedObservationAtDistanceType', DirectedObservationAtDistanceType)


# Complex type BaseStyleDescriptorType with content type ELEMENT_ONLY
class BaseStyleDescriptorType (AbstractGMLType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'BaseStyleDescriptorType')
    # Base type is AbstractGMLType
    
    # Element {http://www.opengis.net/gml}styleVariation uses Python identifier styleVariation
    __styleVariation = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'styleVariation'), 'styleVariation', '__httpwww_opengis_netgml_BaseStyleDescriptorType_httpwww_opengis_netgmlstyleVariation', True)

    
    styleVariation = property(__styleVariation.value, __styleVariation.set, None, None)

    
    # Element {http://www.w3.org/2001/SMIL20/}animate uses Python identifier animate
    __animate = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'animate'), 'animate', '__httpwww_opengis_netgml_BaseStyleDescriptorType_httpwww_w3_org2001SMIL20animate', True)

    
    animate = property(__animate.value, __animate.set, None, None)

    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.w3.org/2001/SMIL20/}animateMotion uses Python identifier animateMotion
    __animateMotion = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'animateMotion'), 'animateMotion', '__httpwww_opengis_netgml_BaseStyleDescriptorType_httpwww_w3_org2001SMIL20animateMotion', True)

    
    animateMotion = property(__animateMotion.value, __animateMotion.set, None, None)

    
    # Element {http://www.opengis.net/gml}spatialResolution uses Python identifier spatialResolution
    __spatialResolution = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'spatialResolution'), 'spatialResolution', '__httpwww_opengis_netgml_BaseStyleDescriptorType_httpwww_opengis_netgmlspatialResolution', False)

    
    spatialResolution = property(__spatialResolution.value, __spatialResolution.set, None, None)

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.w3.org/2001/SMIL20/}animateColor uses Python identifier animateColor
    __animateColor = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'animateColor'), 'animateColor', '__httpwww_opengis_netgml_BaseStyleDescriptorType_httpwww_w3_org2001SMIL20animateColor', True)

    
    animateColor = property(__animateColor.value, __animateColor.set, None, None)

    
    # Element {http://www.w3.org/2001/SMIL20/}set uses Python identifier set
    __set = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'set'), 'set', '__httpwww_opengis_netgml_BaseStyleDescriptorType_httpwww_w3_org2001SMIL20set', True)

    
    set = property(__set.value, __set.set, None, None)

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractGMLType._ElementMap.copy()
    _ElementMap.update({
        __styleVariation.name() : __styleVariation,
        __animate.name() : __animate,
        __animateMotion.name() : __animateMotion,
        __spatialResolution.name() : __spatialResolution,
        __animateColor.name() : __animateColor,
        __set.name() : __set
    })
    _AttributeMap = AbstractGMLType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'BaseStyleDescriptorType', BaseStyleDescriptorType)


# Complex type GraphStyleType with content type ELEMENT_ONLY
class GraphStyleType (BaseStyleDescriptorType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GraphStyleType')
    # Base type is BaseStyleDescriptorType
    
    # Element {http://www.opengis.net/gml}aestheticCriteria uses Python identifier aestheticCriteria
    __aestheticCriteria = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'aestheticCriteria'), 'aestheticCriteria', '__httpwww_opengis_netgml_GraphStyleType_httpwww_opengis_netgmlaestheticCriteria', True)

    
    aestheticCriteria = property(__aestheticCriteria.value, __aestheticCriteria.set, None, None)

    
    # Element {http://www.opengis.net/gml}directed uses Python identifier directed
    __directed = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'directed'), 'directed', '__httpwww_opengis_netgml_GraphStyleType_httpwww_opengis_netgmldirected', False)

    
    directed = property(__directed.value, __directed.set, None, None)

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}graphType uses Python identifier graphType
    __graphType = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'graphType'), 'graphType', '__httpwww_opengis_netgml_GraphStyleType_httpwww_opengis_netgmlgraphType', False)

    
    graphType = property(__graphType.value, __graphType.set, None, None)

    
    # Element {http://www.opengis.net/gml}minDistance uses Python identifier minDistance
    __minDistance = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'minDistance'), 'minDistance', '__httpwww_opengis_netgml_GraphStyleType_httpwww_opengis_netgmlminDistance', False)

    
    minDistance = property(__minDistance.value, __minDistance.set, None, None)

    
    # Element {http://www.opengis.net/gml}grid uses Python identifier grid
    __grid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'grid'), 'grid', '__httpwww_opengis_netgml_GraphStyleType_httpwww_opengis_netgmlgrid', False)

    
    grid = property(__grid.value, __grid.set, None, None)

    
    # Element {http://www.opengis.net/gml}minAngle uses Python identifier minAngle
    __minAngle = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'minAngle'), 'minAngle', '__httpwww_opengis_netgml_GraphStyleType_httpwww_opengis_netgmlminAngle', False)

    
    minAngle = property(__minAngle.value, __minAngle.set, None, None)

    
    # Element animate ({http://www.w3.org/2001/SMIL20/}animate) inherited from {http://www.opengis.net/gml}BaseStyleDescriptorType
    
    # Element animateColor ({http://www.w3.org/2001/SMIL20/}animateColor) inherited from {http://www.opengis.net/gml}BaseStyleDescriptorType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}lineType uses Python identifier lineType
    __lineType = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'lineType'), 'lineType', '__httpwww_opengis_netgml_GraphStyleType_httpwww_opengis_netgmllineType', False)

    
    lineType = property(__lineType.value, __lineType.set, None, None)

    
    # Element {http://www.opengis.net/gml}planar uses Python identifier planar
    __planar = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'planar'), 'planar', '__httpwww_opengis_netgml_GraphStyleType_httpwww_opengis_netgmlplanar', False)

    
    planar = property(__planar.value, __planar.set, None, None)

    
    # Element animateMotion ({http://www.w3.org/2001/SMIL20/}animateMotion) inherited from {http://www.opengis.net/gml}BaseStyleDescriptorType
    
    # Element {http://www.opengis.net/gml}drawingType uses Python identifier drawingType
    __drawingType = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'drawingType'), 'drawingType', '__httpwww_opengis_netgml_GraphStyleType_httpwww_opengis_netgmldrawingType', False)

    
    drawingType = property(__drawingType.value, __drawingType.set, None, None)

    
    # Element spatialResolution ({http://www.opengis.net/gml}spatialResolution) inherited from {http://www.opengis.net/gml}BaseStyleDescriptorType
    
    # Element set ({http://www.w3.org/2001/SMIL20/}set) inherited from {http://www.opengis.net/gml}BaseStyleDescriptorType
    
    # Element styleVariation ({http://www.opengis.net/gml}styleVariation) inherited from {http://www.opengis.net/gml}BaseStyleDescriptorType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = BaseStyleDescriptorType._ElementMap.copy()
    _ElementMap.update({
        __aestheticCriteria.name() : __aestheticCriteria,
        __directed.name() : __directed,
        __graphType.name() : __graphType,
        __minDistance.name() : __minDistance,
        __grid.name() : __grid,
        __minAngle.name() : __minAngle,
        __lineType.name() : __lineType,
        __planar.name() : __planar,
        __drawingType.name() : __drawingType
    })
    _AttributeMap = BaseStyleDescriptorType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'GraphStyleType', GraphStyleType)


# Complex type RangeSetType with content type ELEMENT_ONLY
class RangeSetType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'RangeSetType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}QuantityList uses Python identifier QuantityList
    __QuantityList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'QuantityList'), 'QuantityList', '__httpwww_opengis_netgml_RangeSetType_httpwww_opengis_netgmlQuantityList', True)

    
    QuantityList = property(__QuantityList.value, __QuantityList.set, None, u'A space separated list of amounts or nulls.  The amounts use the XML Schema type double.  A single XML attribute uom (unit of measure) is required, whose value is a URI which identifies the definition of the scale or units by which all the amounts in the list must be multiplied.')

    
    # Element {http://www.opengis.net/gml}CountList uses Python identifier CountList
    __CountList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CountList'), 'CountList', '__httpwww_opengis_netgml_RangeSetType_httpwww_opengis_netgmlCountList', True)

    
    CountList = property(__CountList.value, __CountList.set, None, u'A space-separated list of integers or nulls.')

    
    # Element {http://www.opengis.net/gml}BooleanList uses Python identifier BooleanList
    __BooleanList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'BooleanList'), 'BooleanList', '__httpwww_opengis_netgml_RangeSetType_httpwww_opengis_netgmlBooleanList', True)

    
    BooleanList = property(__BooleanList.value, __BooleanList.set, None, u'XML List based on XML Schema boolean type.  An element of this type contains a space-separated list of boolean values {0,1,true,false}')

    
    # Element {http://www.opengis.net/gml}ValueArray uses Python identifier ValueArray
    __ValueArray = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'ValueArray'), 'ValueArray', '__httpwww_opengis_netgml_RangeSetType_httpwww_opengis_netgmlValueArray', True)

    
    ValueArray = property(__ValueArray.value, __ValueArray.set, None, u'A Value Array is used for homogeneous arrays of primitive and aggregate values.   _ScalarValueList is preferred for arrays of Scalar Values since this is more efficient.  Since "choice" is not available for attribute groups, an external constraint (e.g. Schematron) would be required to enforce the selection of only one of these through schema validation')

    
    # Element {http://www.opengis.net/gml}CategoryList uses Python identifier CategoryList
    __CategoryList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CategoryList'), 'CategoryList', '__httpwww_opengis_netgml_RangeSetType_httpwww_opengis_netgmlCategoryList', True)

    
    CategoryList = property(__CategoryList.value, __CategoryList.set, None, u'A space-separated list of terms or nulls.  A single XML attribute codeSpace may be provided, which authorises all the terms in the list.')

    
    # Element {http://www.opengis.net/gml}DataBlock uses Python identifier DataBlock
    __DataBlock = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'DataBlock'), 'DataBlock', '__httpwww_opengis_netgml_RangeSetType_httpwww_opengis_netgmlDataBlock', False)

    
    DataBlock = property(__DataBlock.value, __DataBlock.set, None, None)

    
    # Element {http://www.opengis.net/gml}File uses Python identifier File
    __File = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'File'), 'File', '__httpwww_opengis_netgml_RangeSetType_httpwww_opengis_netgmlFile', False)

    
    File = property(__File.value, __File.set, None, None)


    _ElementMap = {
        __QuantityList.name() : __QuantityList,
        __CountList.name() : __CountList,
        __BooleanList.name() : __BooleanList,
        __ValueArray.name() : __ValueArray,
        __CategoryList.name() : __CategoryList,
        __DataBlock.name() : __DataBlock,
        __File.name() : __File
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'RangeSetType', RangeSetType)


# Complex type DefinitionProxyType with content type ELEMENT_ONLY
class DefinitionProxyType (DefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DefinitionProxyType')
    # Base type is DefinitionType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}definitionRef uses Python identifier definitionRef
    __definitionRef = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'definitionRef'), 'definitionRef', '__httpwww_opengis_netgml_DefinitionProxyType_httpwww_opengis_netgmldefinitionRef', False)

    
    definitionRef = property(__definitionRef.value, __definitionRef.set, None, None)

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id_ inherited from {http://www.opengis.net/gml}DefinitionType

    _ElementMap = DefinitionType._ElementMap.copy()
    _ElementMap.update({
        __definitionRef.name() : __definitionRef
    })
    _AttributeMap = DefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'DefinitionProxyType', DefinitionProxyType)


# Complex type UnitOfMeasureType with content type EMPTY
class UnitOfMeasureType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'UnitOfMeasureType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute uom uses Python identifier uom
    __uom = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'uom'), 'uom', '__httpwww_opengis_netgml_UnitOfMeasureType_uom', pyxb.binding.datatypes.anyURI, required=True)
    
    uom = property(__uom.value, __uom.set, None, u'Reference to a unit of measure definition, usually within the same XML document but possibly outside the XML document which contains this reference. For a reference within the same XML document, the "#" symbol should be used, followed by a text abbreviation of the unit name. However, the "#" symbol may be optional, and still may be interpreted as a reference.')


    _ElementMap = {
        
    }
    _AttributeMap = {
        __uom.name() : __uom
    }
Namespace.addCategoryObject('typeBinding', u'UnitOfMeasureType', UnitOfMeasureType)


# Complex type DerivationUnitTermType with content type EMPTY
class DerivationUnitTermType (UnitOfMeasureType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DerivationUnitTermType')
    # Base type is UnitOfMeasureType
    
    # Attribute exponent uses Python identifier exponent
    __exponent = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'exponent'), 'exponent', '__httpwww_opengis_netgml_DerivationUnitTermType_exponent', pyxb.binding.datatypes.integer)
    
    exponent = property(__exponent.value, __exponent.set, None, None)

    
    # Attribute uom inherited from {http://www.opengis.net/gml}UnitOfMeasureType

    _ElementMap = UnitOfMeasureType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = UnitOfMeasureType._AttributeMap.copy()
    _AttributeMap.update({
        __exponent.name() : __exponent
    })
Namespace.addCategoryObject('typeBinding', u'DerivationUnitTermType', DerivationUnitTermType)


# Complex type OperationParameterGroupRefType with content type ELEMENT_ONLY
class OperationParameterGroupRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'OperationParameterGroupRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}OperationParameterGroup uses Python identifier OperationParameterGroup
    __OperationParameterGroup = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'OperationParameterGroup'), 'OperationParameterGroup', '__httpwww_opengis_netgml_OperationParameterGroupRefType_httpwww_opengis_netgmlOperationParameterGroup', False)

    
    OperationParameterGroup = property(__OperationParameterGroup.value, __OperationParameterGroup.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_OperationParameterGroupRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_OperationParameterGroupRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_OperationParameterGroupRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_OperationParameterGroupRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_OperationParameterGroupRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_OperationParameterGroupRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_OperationParameterGroupRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_OperationParameterGroupRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)


    _ElementMap = {
        __OperationParameterGroup.name() : __OperationParameterGroup
    }
    _AttributeMap = {
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __title.name() : __title,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __href.name() : __href
    }
Namespace.addCategoryObject('typeBinding', u'OperationParameterGroupRefType', OperationParameterGroupRefType)


# Complex type PointPropertyType with content type ELEMENT_ONLY
class PointPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PointPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Point uses Python identifier Point
    __Point = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Point'), 'Point', '__httpwww_opengis_netgml_PointPropertyType_httpwww_opengis_netgmlPoint', False)

    
    Point = property(__Point.value, __Point.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_PointPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_PointPropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_PointPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_PointPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_PointPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_PointPropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_PointPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_PointPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)


    _ElementMap = {
        __Point.name() : __Point
    }
    _AttributeMap = {
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __href.name() : __href,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole
    }
Namespace.addCategoryObject('typeBinding', u'PointPropertyType', PointPropertyType)


# Complex type AbstractGeneralTransformationType with content type ELEMENT_ONLY
class AbstractGeneralTransformationType (AbstractCoordinateOperationType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralTransformationType')
    # Base type is AbstractCoordinateOperationType
    
    # Element coordinateOperationID ({http://www.opengis.net/gml}coordinateOperationID) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element positionalAccuracy ({http://www.opengis.net/gml}_positionalAccuracy) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element coordinateOperationName ({http://www.opengis.net/gml}coordinateOperationName) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationBaseType
    
    # Element validArea ({http://www.opengis.net/gml}validArea) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element sourceCRS ({http://www.opengis.net/gml}sourceCRS) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element scope ({http://www.opengis.net/gml}scope) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element targetCRS ({http://www.opengis.net/gml}targetCRS) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element operationVersion ({http://www.opengis.net/gml}operationVersion) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Attribute id is restricted from parent
    
    # Attribute {http://www.opengis.net/gml}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'id'), 'id', '__httpwww_opengis_netgml_AbstractGMLType_httpwww_opengis_netgmlid', pyxb.binding.datatypes.ID, required=True)
    
    id = property(__id.value, __id.set, None, u'Database handle for the object.  It is of XML type ID, so is constrained to be unique in the XML document within which it occurs.  An external identifier for the object in the form of a URI may be constructed using standard XML and XPointer methods.  This is done by concatenating the URI for the document, a fragment separator, and the value of the id attribute.')


    _ElementMap = AbstractCoordinateOperationType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractCoordinateOperationType._AttributeMap.copy()
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', u'AbstractGeneralTransformationType', AbstractGeneralTransformationType)


# Complex type GeometryStyleType with content type ELEMENT_ONLY
class GeometryStyleType (BaseStyleDescriptorType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeometryStyleType')
    # Base type is BaseStyleDescriptorType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element styleVariation ({http://www.opengis.net/gml}styleVariation) inherited from {http://www.opengis.net/gml}BaseStyleDescriptorType
    
    # Element animate ({http://www.w3.org/2001/SMIL20/}animate) inherited from {http://www.opengis.net/gml}BaseStyleDescriptorType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element animateMotion ({http://www.w3.org/2001/SMIL20/}animateMotion) inherited from {http://www.opengis.net/gml}BaseStyleDescriptorType
    
    # Element spatialResolution ({http://www.opengis.net/gml}spatialResolution) inherited from {http://www.opengis.net/gml}BaseStyleDescriptorType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}labelStyle uses Python identifier labelStyle
    __labelStyle = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'labelStyle'), 'labelStyle', '__httpwww_opengis_netgml_GeometryStyleType_httpwww_opengis_netgmllabelStyle', False)

    
    labelStyle = property(__labelStyle.value, __labelStyle.set, None, u'')

    
    # Element set ({http://www.w3.org/2001/SMIL20/}set) inherited from {http://www.opengis.net/gml}BaseStyleDescriptorType
    
    # Element {http://www.opengis.net/gml}style uses Python identifier style
    __style = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'style'), 'style', '__httpwww_opengis_netgml_GeometryStyleType_httpwww_opengis_netgmlstyle', False)

    
    style = property(__style.value, __style.set, None, u'Deprecated in GML version 3.1.0. Use symbol with inline content instead.')

    
    # Element animateColor ({http://www.w3.org/2001/SMIL20/}animateColor) inherited from {http://www.opengis.net/gml}BaseStyleDescriptorType
    
    # Element {http://www.opengis.net/gml}symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'symbol'), 'symbol', '__httpwww_opengis_netgml_GeometryStyleType_httpwww_opengis_netgmlsymbol', False)

    
    symbol = property(__symbol.value, __symbol.set, None, u'The symbol property. Extends the gml:AssociationType to allow for remote referencing of symbols.')

    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute geometryType uses Python identifier geometryType
    __geometryType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'geometryType'), 'geometryType', '__httpwww_opengis_netgml_GeometryStyleType_geometryType', pyxb.binding.datatypes.string)
    
    geometryType = property(__geometryType.value, __geometryType.set, None, None)

    
    # Attribute geometryProperty uses Python identifier geometryProperty
    __geometryProperty = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'geometryProperty'), 'geometryProperty', '__httpwww_opengis_netgml_GeometryStyleType_geometryProperty', pyxb.binding.datatypes.string)
    
    geometryProperty = property(__geometryProperty.value, __geometryProperty.set, None, None)


    _ElementMap = BaseStyleDescriptorType._ElementMap.copy()
    _ElementMap.update({
        __labelStyle.name() : __labelStyle,
        __style.name() : __style,
        __symbol.name() : __symbol
    })
    _AttributeMap = BaseStyleDescriptorType._AttributeMap.copy()
    _AttributeMap.update({
        __geometryType.name() : __geometryType,
        __geometryProperty.name() : __geometryProperty
    })
Namespace.addCategoryObject('typeBinding', u'GeometryStyleType', GeometryStyleType)


# Complex type BaseUnitType with content type ELEMENT_ONLY
class BaseUnitType (UnitDefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'BaseUnitType')
    # Base type is UnitDefinitionType
    
    # Element {http://www.opengis.net/gml}unitsSystem uses Python identifier unitsSystem
    __unitsSystem = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'unitsSystem'), 'unitsSystem', '__httpwww_opengis_netgml_BaseUnitType_httpwww_opengis_netgmlunitsSystem', False)

    
    unitsSystem = property(__unitsSystem.value, __unitsSystem.set, None, None)

    
    # Element quantityType ({http://www.opengis.net/gml}quantityType) inherited from {http://www.opengis.net/gml}UnitDefinitionType
    
    # Element catalogSymbol ({http://www.opengis.net/gml}catalogSymbol) inherited from {http://www.opengis.net/gml}UnitDefinitionType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id_ inherited from {http://www.opengis.net/gml}DefinitionType

    _ElementMap = UnitDefinitionType._ElementMap.copy()
    _ElementMap.update({
        __unitsSystem.name() : __unitsSystem
    })
    _AttributeMap = UnitDefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'BaseUnitType', BaseUnitType)


# Complex type GeodeticDatumRefType with content type ELEMENT_ONLY
class GeodeticDatumRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeodeticDatumRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}GeodeticDatum uses Python identifier GeodeticDatum
    __GeodeticDatum = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'GeodeticDatum'), 'GeodeticDatum', '__httpwww_opengis_netgml_GeodeticDatumRefType_httpwww_opengis_netgmlGeodeticDatum', False)

    
    GeodeticDatum = property(__GeodeticDatum.value, __GeodeticDatum.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_GeodeticDatumRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_GeodeticDatumRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_GeodeticDatumRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_GeodeticDatumRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_GeodeticDatumRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_GeodeticDatumRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_GeodeticDatumRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_GeodeticDatumRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")


    _ElementMap = {
        __GeodeticDatum.name() : __GeodeticDatum
    }
    _AttributeMap = {
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate
    }
Namespace.addCategoryObject('typeBinding', u'GeodeticDatumRefType', GeodeticDatumRefType)


# Complex type TopologyStyleType with content type ELEMENT_ONLY
class TopologyStyleType (BaseStyleDescriptorType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopologyStyleType')
    # Base type is BaseStyleDescriptorType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element styleVariation ({http://www.opengis.net/gml}styleVariation) inherited from {http://www.opengis.net/gml}BaseStyleDescriptorType
    
    # Element animate ({http://www.w3.org/2001/SMIL20/}animate) inherited from {http://www.opengis.net/gml}BaseStyleDescriptorType
    
    # Element {http://www.opengis.net/gml}labelStyle uses Python identifier labelStyle
    __labelStyle = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'labelStyle'), 'labelStyle', '__httpwww_opengis_netgml_TopologyStyleType_httpwww_opengis_netgmllabelStyle', False)

    
    labelStyle = property(__labelStyle.value, __labelStyle.set, None, u'')

    
    # Element animateMotion ({http://www.w3.org/2001/SMIL20/}animateMotion) inherited from {http://www.opengis.net/gml}BaseStyleDescriptorType
    
    # Element spatialResolution ({http://www.opengis.net/gml}spatialResolution) inherited from {http://www.opengis.net/gml}BaseStyleDescriptorType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'symbol'), 'symbol', '__httpwww_opengis_netgml_TopologyStyleType_httpwww_opengis_netgmlsymbol', False)

    
    symbol = property(__symbol.value, __symbol.set, None, u'The symbol property. Extends the gml:AssociationType to allow for remote referencing of symbols.')

    
    # Element animateColor ({http://www.w3.org/2001/SMIL20/}animateColor) inherited from {http://www.opengis.net/gml}BaseStyleDescriptorType
    
    # Element set ({http://www.w3.org/2001/SMIL20/}set) inherited from {http://www.opengis.net/gml}BaseStyleDescriptorType
    
    # Element {http://www.opengis.net/gml}style uses Python identifier style
    __style = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'style'), 'style', '__httpwww_opengis_netgml_TopologyStyleType_httpwww_opengis_netgmlstyle', False)

    
    style = property(__style.value, __style.set, None, u'Deprecated in GML version 3.1.0. Use symbol with inline content instead.')

    
    # Attribute topologyProperty uses Python identifier topologyProperty
    __topologyProperty = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'topologyProperty'), 'topologyProperty', '__httpwww_opengis_netgml_TopologyStyleType_topologyProperty', pyxb.binding.datatypes.string)
    
    topologyProperty = property(__topologyProperty.value, __topologyProperty.set, None, None)

    
    # Attribute topologyType uses Python identifier topologyType
    __topologyType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'topologyType'), 'topologyType', '__httpwww_opengis_netgml_TopologyStyleType_topologyType', pyxb.binding.datatypes.string)
    
    topologyType = property(__topologyType.value, __topologyType.set, None, None)

    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = BaseStyleDescriptorType._ElementMap.copy()
    _ElementMap.update({
        __labelStyle.name() : __labelStyle,
        __symbol.name() : __symbol,
        __style.name() : __style
    })
    _AttributeMap = BaseStyleDescriptorType._AttributeMap.copy()
    _AttributeMap.update({
        __topologyProperty.name() : __topologyProperty,
        __topologyType.name() : __topologyType
    })
Namespace.addCategoryObject('typeBinding', u'TopologyStyleType', TopologyStyleType)


# Complex type DomainSetType with content type ELEMENT_ONLY
class DomainSetType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DomainSetType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_Geometry uses Python identifier Geometry
    __Geometry = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_Geometry'), 'Geometry', '__httpwww_opengis_netgml_DomainSetType_httpwww_opengis_netgml_Geometry', False)

    
    Geometry = property(__Geometry.value, __Geometry.set, None, u'The "_Geometry" element is the abstract head of the substituition group for all geometry elements of GML 3. This \n\t\t\tincludes pre-defined and user-defined geometry elements. Any geometry element must be a direct or indirect extension/restriction \n\t\t\tof AbstractGeometryType and must be directly or indirectly in the substitution group of "_Geometry".')

    
    # Element {http://www.opengis.net/gml}_TimeObject uses Python identifier TimeObject
    __TimeObject = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_TimeObject'), 'TimeObject', '__httpwww_opengis_netgml_DomainSetType_httpwww_opengis_netgml_TimeObject', False)

    
    TimeObject = property(__TimeObject.value, __TimeObject.set, None, u'This abstract element acts as the head of the substitution group for temporal primitives and complexes.')

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_DomainSetType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")


    _ElementMap = {
        __Geometry.name() : __Geometry,
        __TimeObject.name() : __TimeObject
    }
    _AttributeMap = {
        __role.name() : __role,
        __remoteSchema.name() : __remoteSchema,
        __href.name() : __href,
        __type.name() : __type,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __actuate.name() : __actuate,
        __show.name() : __show
    }
Namespace.addCategoryObject('typeBinding', u'DomainSetType', DomainSetType)


# Complex type ConversionType with content type ELEMENT_ONLY
class ConversionType (AbstractGeneralConversionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ConversionType')
    # Base type is AbstractGeneralConversionType
    
    # Element {http://www.opengis.net/gml}usesValue uses Python identifier usesValue
    __usesValue = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesValue'), 'usesValue', '__httpwww_opengis_netgml_ConversionType_httpwww_opengis_netgmlusesValue', True)

    
    usesValue = property(__usesValue.value, __usesValue.set, None, u'Composition association to a parameter value used by this coordinate operation. ')

    
    # Element positionalAccuracy ({http://www.opengis.net/gml}_positionalAccuracy) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element validArea ({http://www.opengis.net/gml}validArea) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}usesMethod uses Python identifier usesMethod
    __usesMethod = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesMethod'), 'usesMethod', '__httpwww_opengis_netgml_ConversionType_httpwww_opengis_netgmlusesMethod', False)

    
    usesMethod = property(__usesMethod.value, __usesMethod.set, None, u'Association to the operation method used by this coordinate operation. ')

    
    # Element coordinateOperationName ({http://www.opengis.net/gml}coordinateOperationName) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationBaseType
    
    # Element coordinateOperationID ({http://www.opengis.net/gml}coordinateOperationID) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element scope ({http://www.opengis.net/gml}scope) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Attribute id_3 inherited from {http://www.opengis.net/gml}AbstractGeneralConversionType

    _ElementMap = AbstractGeneralConversionType._ElementMap.copy()
    _ElementMap.update({
        __usesValue.name() : __usesValue,
        __usesMethod.name() : __usesMethod
    })
    _AttributeMap = AbstractGeneralConversionType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ConversionType', ConversionType)


# Complex type ArcStringType with content type ELEMENT_ONLY
class ArcStringType (AbstractCurveSegmentType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ArcStringType')
    # Base type is AbstractCurveSegmentType
    
    # Element {http://www.opengis.net/gml}pointProperty uses Python identifier pointProperty
    __pointProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), 'pointProperty', '__httpwww_opengis_netgml_ArcStringType_httpwww_opengis_netgmlpointProperty', True)

    
    pointProperty = property(__pointProperty.value, __pointProperty.set, None, u'This property element either references a point via the XLink-attributes or contains the point element. pointProperty \n\t\t\tis the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that \n\t\t\tis substitutable for Point.')

    
    # Element {http://www.opengis.net/gml}posList uses Python identifier posList
    __posList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'posList'), 'posList', '__httpwww_opengis_netgml_ArcStringType_httpwww_opengis_netgmlposList', False)

    
    posList = property(__posList.value, __posList.set, None, u'')

    
    # Element {http://www.opengis.net/gml}coordinates uses Python identifier coordinates
    __coordinates = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), 'coordinates', '__httpwww_opengis_netgml_ArcStringType_httpwww_opengis_netgmlcoordinates', False)

    
    coordinates = property(__coordinates.value, __coordinates.set, None, u'Deprecated with GML version 3.1.0.')

    
    # Element {http://www.opengis.net/gml}pointRep uses Python identifier pointRep
    __pointRep = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), 'pointRep', '__httpwww_opengis_netgml_ArcStringType_httpwww_opengis_netgmlpointRep', True)

    
    pointRep = property(__pointRep.value, __pointRep.set, None, u'Deprecated with GML version 3.1.0. Use "pointProperty" instead. Included for backwards compatibility with GML 3.0.0.')

    
    # Element {http://www.opengis.net/gml}pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pos'), 'pos', '__httpwww_opengis_netgml_ArcStringType_httpwww_opengis_netgmlpos', True)

    
    pos = property(__pos.value, __pos.set, None, u'')

    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute interpolation uses Python identifier interpolation
    __interpolation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'interpolation'), 'interpolation', '__httpwww_opengis_netgml_ArcStringType_interpolation', CurveInterpolationType, fixed=True, unicode_default=u'circularArc3Points')
    
    interpolation = property(__interpolation.value, __interpolation.set, None, u'The attribute "interpolation" specifies the curve interpolation mechanism used for this segment. This mechanism\nuses the control points and control parameters to determine the position of this curve segment. For an ArcString the interpolation is fixed as "circularArc3Points".')

    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numArc uses Python identifier numArc
    __numArc = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'numArc'), 'numArc', '__httpwww_opengis_netgml_ArcStringType_numArc', pyxb.binding.datatypes.integer)
    
    numArc = property(__numArc.value, __numArc.set, None, u'The number of arcs in the arc string can be explicitly stated in this attribute. The number of control points in the arc string must be 2 * numArc + 1.')


    _ElementMap = AbstractCurveSegmentType._ElementMap.copy()
    _ElementMap.update({
        __pointProperty.name() : __pointProperty,
        __posList.name() : __posList,
        __coordinates.name() : __coordinates,
        __pointRep.name() : __pointRep,
        __pos.name() : __pos
    })
    _AttributeMap = AbstractCurveSegmentType._AttributeMap.copy()
    _AttributeMap.update({
        __interpolation.name() : __interpolation,
        __numArc.name() : __numArc
    })
Namespace.addCategoryObject('typeBinding', u'ArcStringType', ArcStringType)


# Complex type SpeedType with content type SIMPLE
class SpeedType (MeasureType):
    _TypeDefinition = STD_ANON_6
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SpeedType')
    # Base type is MeasureType
    
    # Attribute uom inherited from {http://www.opengis.net/gml}MeasureType

    _ElementMap = MeasureType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = MeasureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SpeedType', SpeedType)


# Complex type AbstractRingPropertyType with content type ELEMENT_ONLY
class AbstractRingPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractRingPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_Ring uses Python identifier Ring
    __Ring = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_Ring'), 'Ring', '__httpwww_opengis_netgml_AbstractRingPropertyType_httpwww_opengis_netgml_Ring', False)

    
    Ring = property(__Ring.value, __Ring.set, None, u'The "_Ring" element is the abstract head of the substituition group for all closed boundaries of a surface patch.')


    _ElementMap = {
        __Ring.name() : __Ring
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'AbstractRingPropertyType', AbstractRingPropertyType)


# Complex type GridCoverageType with content type ELEMENT_ONLY
class GridCoverageType (AbstractDiscreteCoverageType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GridCoverageType')
    # Base type is AbstractDiscreteCoverageType
    
    # Element rangeSet ({http://www.opengis.net/gml}rangeSet) inherited from {http://www.opengis.net/gml}AbstractCoverageType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element boundedBy ({http://www.opengis.net/gml}boundedBy) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}gridDomain uses Python identifier gridDomain
    __gridDomain = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'gridDomain'), 'gridDomain', '__httpwww_opengis_netgml_GridCoverageType_httpwww_opengis_netgmlgridDomain', False)

    
    gridDomain = property(__gridDomain.value, __gridDomain.set, None, None)

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element coverageFunction ({http://www.opengis.net/gml}coverageFunction) inherited from {http://www.opengis.net/gml}AbstractDiscreteCoverageType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute dimension inherited from {http://www.opengis.net/gml}AbstractCoverageType

    _ElementMap = AbstractDiscreteCoverageType._ElementMap.copy()
    _ElementMap.update({
        __gridDomain.name() : __gridDomain
    })
    _AttributeMap = AbstractDiscreteCoverageType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'GridCoverageType', GridCoverageType)


# Complex type LineStringSegmentArrayPropertyType with content type ELEMENT_ONLY
class LineStringSegmentArrayPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LineStringSegmentArrayPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}LineStringSegment uses Python identifier LineStringSegment
    __LineStringSegment = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'LineStringSegment'), 'LineStringSegment', '__httpwww_opengis_netgml_LineStringSegmentArrayPropertyType_httpwww_opengis_netgmlLineStringSegment', True)

    
    LineStringSegment = property(__LineStringSegment.value, __LineStringSegment.set, None, None)


    _ElementMap = {
        __LineStringSegment.name() : __LineStringSegment
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'LineStringSegmentArrayPropertyType', LineStringSegmentArrayPropertyType)


# Complex type CartesianCSRefType with content type ELEMENT_ONLY
class CartesianCSRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CartesianCSRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}CartesianCS uses Python identifier CartesianCS
    __CartesianCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CartesianCS'), 'CartesianCS', '__httpwww_opengis_netgml_CartesianCSRefType_httpwww_opengis_netgmlCartesianCS', False)

    
    CartesianCS = property(__CartesianCS.value, __CartesianCS.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_CartesianCSRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_CartesianCSRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_CartesianCSRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_CartesianCSRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_CartesianCSRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_CartesianCSRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_CartesianCSRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_CartesianCSRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)


    _ElementMap = {
        __CartesianCS.name() : __CartesianCS
    }
    _AttributeMap = {
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __actuate.name() : __actuate,
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role,
        __href.name() : __href
    }
Namespace.addCategoryObject('typeBinding', u'CartesianCSRefType', CartesianCSRefType)


# Complex type AbstractFeatureCollectionType with content type ELEMENT_ONLY
class AbstractFeatureCollectionType (AbstractFeatureType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractFeatureCollectionType')
    # Base type is AbstractFeatureType
    
    # Element {http://www.opengis.net/gml}featureMember uses Python identifier featureMember
    __featureMember = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'featureMember'), 'featureMember', '__httpwww_opengis_netgml_AbstractFeatureCollectionType_httpwww_opengis_netgmlfeatureMember', True)

    
    featureMember = property(__featureMember.value, __featureMember.set, None, None)

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element boundedBy ({http://www.opengis.net/gml}boundedBy) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element {http://www.opengis.net/gml}featureMembers uses Python identifier featureMembers
    __featureMembers = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'featureMembers'), 'featureMembers', '__httpwww_opengis_netgml_AbstractFeatureCollectionType_httpwww_opengis_netgmlfeatureMembers', False)

    
    featureMembers = property(__featureMembers.value, __featureMembers.set, None, None)

    
    # Element location ({http://www.opengis.net/gml}location) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractFeatureType._ElementMap.copy()
    _ElementMap.update({
        __featureMember.name() : __featureMember,
        __featureMembers.name() : __featureMembers
    })
    _AttributeMap = AbstractFeatureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractFeatureCollectionType', AbstractFeatureCollectionType)


# Complex type FeatureCollectionType with content type ELEMENT_ONLY
class FeatureCollectionType (AbstractFeatureCollectionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'FeatureCollectionType')
    # Base type is AbstractFeatureCollectionType
    
    # Element featureMember ({http://www.opengis.net/gml}featureMember) inherited from {http://www.opengis.net/gml}AbstractFeatureCollectionType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element boundedBy ({http://www.opengis.net/gml}boundedBy) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element featureMembers ({http://www.opengis.net/gml}featureMembers) inherited from {http://www.opengis.net/gml}AbstractFeatureCollectionType
    
    # Element location ({http://www.opengis.net/gml}location) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractFeatureCollectionType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractFeatureCollectionType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'FeatureCollectionType', FeatureCollectionType)


# Complex type MultiSurfacePropertyType with content type ELEMENT_ONLY
class MultiSurfacePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiSurfacePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}MultiSurface uses Python identifier MultiSurface
    __MultiSurface = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'MultiSurface'), 'MultiSurface', '__httpwww_opengis_netgml_MultiSurfacePropertyType_httpwww_opengis_netgmlMultiSurface', False)

    
    MultiSurface = property(__MultiSurface.value, __MultiSurface.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_MultiSurfacePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_MultiSurfacePropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_MultiSurfacePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_MultiSurfacePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_MultiSurfacePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_MultiSurfacePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_MultiSurfacePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_MultiSurfacePropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")


    _ElementMap = {
        __MultiSurface.name() : __MultiSurface
    }
    _AttributeMap = {
        __type.name() : __type,
        __actuate.name() : __actuate,
        __role.name() : __role,
        __title.name() : __title,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __href.name() : __href,
        __show.name() : __show
    }
Namespace.addCategoryObject('typeBinding', u'MultiSurfacePropertyType', MultiSurfacePropertyType)


# Complex type PrimeMeridianBaseType with content type ELEMENT_ONLY
class PrimeMeridianBaseType (DefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PrimeMeridianBaseType')
    # Base type is DefinitionType
    
    # Element {http://www.opengis.net/gml}meridianName uses Python identifier meridianName
    __meridianName = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'meridianName'), 'meridianName', '__httpwww_opengis_netgml_PrimeMeridianBaseType_httpwww_opengis_netgmlmeridianName', False)

    
    meridianName = property(__meridianName.value, __meridianName.set, None, u'The name by which this prime meridian is identified. The meridianName most common value is Greenwich, and that value shall be used when the greenwichLongitude value is zero. ')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id is restricted from parent
    
    # Attribute {http://www.opengis.net/gml}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'id'), 'id', '__httpwww_opengis_netgml_AbstractGMLType_httpwww_opengis_netgmlid', pyxb.binding.datatypes.ID, required=True)
    
    id = property(__id.value, __id.set, None, u'Database handle for the object.  It is of XML type ID, so is constrained to be unique in the XML document within which it occurs.  An external identifier for the object in the form of a URI may be constructed using standard XML and XPointer methods.  This is done by concatenating the URI for the document, a fragment separator, and the value of the id attribute.')


    _ElementMap = DefinitionType._ElementMap.copy()
    _ElementMap.update({
        __meridianName.name() : __meridianName
    })
    _AttributeMap = DefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', u'PrimeMeridianBaseType', PrimeMeridianBaseType)


# Complex type PrimeMeridianType with content type ELEMENT_ONLY
class PrimeMeridianType (PrimeMeridianBaseType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PrimeMeridianType')
    # Base type is PrimeMeridianBaseType
    
    # Element meridianName ({http://www.opengis.net/gml}meridianName) inherited from {http://www.opengis.net/gml}PrimeMeridianBaseType
    
    # Element {http://www.opengis.net/gml}greenwichLongitude uses Python identifier greenwichLongitude
    __greenwichLongitude = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'greenwichLongitude'), 'greenwichLongitude', '__httpwww_opengis_netgml_PrimeMeridianType_httpwww_opengis_netgmlgreenwichLongitude', False)

    
    greenwichLongitude = property(__greenwichLongitude.value, __greenwichLongitude.set, None, u'Longitude of the prime meridian measured from the Greenwich meridian, positive eastward. The greenwichLongitude most common value is zero, and that value shall be used when the meridianName value is Greenwich. ')

    
    # Element {http://www.opengis.net/gml}remarks uses Python identifier remarks
    __remarks = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'remarks'), 'remarks', '__httpwww_opengis_netgml_PrimeMeridianType_httpwww_opengis_netgmlremarks', False)

    
    remarks = property(__remarks.value, __remarks.set, None, u'Information about this object or code. Contains text or refers to external text.')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}meridianID uses Python identifier meridianID
    __meridianID = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'meridianID'), 'meridianID', '__httpwww_opengis_netgml_PrimeMeridianType_httpwww_opengis_netgmlmeridianID', True)

    
    meridianID = property(__meridianID.value, __meridianID.set, None, u'An identification of a prime meridian. ')

    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}PrimeMeridianBaseType

    _ElementMap = PrimeMeridianBaseType._ElementMap.copy()
    _ElementMap.update({
        __greenwichLongitude.name() : __greenwichLongitude,
        __remarks.name() : __remarks,
        __meridianID.name() : __meridianID
    })
    _AttributeMap = PrimeMeridianBaseType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'PrimeMeridianType', PrimeMeridianType)


# Complex type GridDomainType with content type ELEMENT_ONLY
class GridDomainType (DomainSetType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GridDomainType')
    # Base type is DomainSetType
    
    # Element {http://www.opengis.net/gml}Grid uses Python identifier Grid
    __Grid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Grid'), 'Grid', '__httpwww_opengis_netgml_GridDomainType_httpwww_opengis_netgmlGrid', False)

    
    Grid = property(__Grid.value, __Grid.set, None, None)

    
    # Attribute role is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute arcrole is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute remoteSchema is restricted from parent
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_DomainSetType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute type is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute href is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute title is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute actuate is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute show is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")


    _ElementMap = DomainSetType._ElementMap.copy()
    _ElementMap.update({
        __Grid.name() : __Grid
    })
    _AttributeMap = DomainSetType._AttributeMap.copy()
    _AttributeMap.update({
        __role.name() : __role,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __type.name() : __type,
        __href.name() : __href,
        __title.name() : __title,
        __actuate.name() : __actuate,
        __show.name() : __show
    })
Namespace.addCategoryObject('typeBinding', u'GridDomainType', GridDomainType)


# Complex type DirectPositionType with content type SIMPLE
class DirectPositionType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = doubleList
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DirectPositionType')
    # Base type is doubleList
    
    # Attribute axisLabels uses Python identifier axisLabels
    __axisLabels = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'axisLabels'), 'axisLabels', '__httpwww_opengis_netgml_DirectPositionType_axisLabels', NCNameList)
    
    axisLabels = property(__axisLabels.value, __axisLabels.set, None, u'Ordered list of labels for all the axes of this CRS. The gml:axisAbbrev value should be used for these axis \n\t\t\t\tlabels, after spaces and forbiddden characters are removed. When the srsName attribute is included, this attribute is optional. \n\t\t\t\tWhen the srsName attribute is omitted, this attribute shall also be omitted.')

    
    # Attribute srsDimension uses Python identifier srsDimension
    __srsDimension = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'srsDimension'), 'srsDimension', '__httpwww_opengis_netgml_DirectPositionType_srsDimension', pyxb.binding.datatypes.positiveInteger)
    
    srsDimension = property(__srsDimension.value, __srsDimension.set, None, u'The "srsDimension" is the length of coordinate sequence (the number of entries in the list). This dimension is \n\t\t\t\tspecified by the coordinate reference system. When the srsName attribute is omitted, this attribute shall be omitted.')

    
    # Attribute srsName uses Python identifier srsName
    __srsName = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'srsName'), 'srsName', '__httpwww_opengis_netgml_DirectPositionType_srsName', pyxb.binding.datatypes.anyURI)
    
    srsName = property(__srsName.value, __srsName.set, None, u'In general this reference points to a CRS instance of gml:CoordinateReferenceSystemType \n\t\t\t\t(see coordinateReferenceSystems.xsd). For well known references it is not required that the CRS description exists at the \n\t\t\t\tlocation the URI points to. If no srsName attribute is given, the CRS must be specified as part of the larger context this \n\t\t\t\tgeometry element is part of, e.g. a geometric element like point, curve, etc. It is expected that this attribute will be specified \n\t\t\t\tat the direct position level only in rare cases.')

    
    # Attribute uomLabels uses Python identifier uomLabels
    __uomLabels = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'uomLabels'), 'uomLabels', '__httpwww_opengis_netgml_DirectPositionType_uomLabels', NCNameList)
    
    uomLabels = property(__uomLabels.value, __uomLabels.set, None, u'Ordered list of unit of measure (uom) labels for all the axes of this CRS. The value of the string in the \n\t\t\t\tgml:catalogSymbol should be used for this uom labels, after spaces and forbiddden characters are removed. When the \n\t\t\t\taxisLabels attribute is included, this attribute shall also be included. When the axisLabels attribute is omitted, this attribute \n\t\t\t\tshall also be omitted.')


    _ElementMap = {
        
    }
    _AttributeMap = {
        __axisLabels.name() : __axisLabels,
        __srsDimension.name() : __srsDimension,
        __srsName.name() : __srsName,
        __uomLabels.name() : __uomLabels
    }
Namespace.addCategoryObject('typeBinding', u'DirectPositionType', DirectPositionType)


# Complex type CurvePropertyType with content type ELEMENT_ONLY
class CurvePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CurvePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_Curve uses Python identifier Curve
    __Curve = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_Curve'), 'Curve', '__httpwww_opengis_netgml_CurvePropertyType_httpwww_opengis_netgml_Curve', False)

    
    Curve = property(__Curve.value, __Curve.set, None, u'The "_Curve" element is the abstract head of the substituition group for all (continuous) curve elements.')

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_CurvePropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_CurvePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_CurvePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_CurvePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_CurvePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_CurvePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_CurvePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_CurvePropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")


    _ElementMap = {
        __Curve.name() : __Curve
    }
    _AttributeMap = {
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __href.name() : __href,
        __title.name() : __title,
        __type.name() : __type,
        __role.name() : __role,
        __show.name() : __show
    }
Namespace.addCategoryObject('typeBinding', u'CurvePropertyType', CurvePropertyType)


# Complex type PolyhedralSurfaceType with content type ELEMENT_ONLY
class PolyhedralSurfaceType (SurfaceType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PolyhedralSurfaceType')
    # Base type is SurfaceType
    
    # Element {http://www.opengis.net/gml}polygonPatches uses Python identifier polygonPatches
    __polygonPatches = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'polygonPatches'), 'polygonPatches', '__httpwww_opengis_netgml_PolyhedralSurfaceType_httpwww_opengis_netgmlpolygonPatches', False)

    
    polygonPatches = property(__polygonPatches.value, __polygonPatches.set, None, u'This property element contains a list of\n   polygon patches. The order of the patches is significant and \n   shall be preserved when processing the list.')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = SurfaceType._ElementMap.copy()
    _ElementMap.update({
        __polygonPatches.name() : __polygonPatches
    })
    _AttributeMap = SurfaceType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'PolyhedralSurfaceType', PolyhedralSurfaceType)


# Complex type SurfacePropertyType with content type ELEMENT_ONLY
class SurfacePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SurfacePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_Surface uses Python identifier Surface
    __Surface = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_Surface'), 'Surface', '__httpwww_opengis_netgml_SurfacePropertyType_httpwww_opengis_netgml_Surface', False)

    
    Surface = property(__Surface.value, __Surface.set, None, u'The "_Surface" element is the abstract head of the substituition group for all (continuous) surface elements.')

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_SurfacePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_SurfacePropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_SurfacePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_SurfacePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_SurfacePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_SurfacePropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_SurfacePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_SurfacePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)


    _ElementMap = {
        __Surface.name() : __Surface
    }
    _AttributeMap = {
        __title.name() : __title,
        __show.name() : __show,
        __href.name() : __href,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole
    }
Namespace.addCategoryObject('typeBinding', u'SurfacePropertyType', SurfacePropertyType)


# Complex type BoundedFeatureType with content type ELEMENT_ONLY
class BoundedFeatureType (AbstractFeatureType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'BoundedFeatureType')
    # Base type is AbstractFeatureType
    
    # Element location ({http://www.opengis.net/gml}location) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element boundedBy ({http://www.opengis.net/gml}boundedBy) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractFeatureType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractFeatureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'BoundedFeatureType', BoundedFeatureType)


# Complex type ClothoidType with content type ELEMENT_ONLY
class ClothoidType (AbstractCurveSegmentType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ClothoidType')
    # Base type is AbstractCurveSegmentType
    
    # Element {http://www.opengis.net/gml}endParameter uses Python identifier endParameter
    __endParameter = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'endParameter'), 'endParameter', '__httpwww_opengis_netgml_ClothoidType_httpwww_opengis_netgmlendParameter', False)

    
    endParameter = property(__endParameter.value, __endParameter.set, None, u'The endParameter is the arc length\n       distance from the inflection point that will be the end\n       point for this curve segment. This shall be upper limit\n       used in the Fresnel integral and is the value of the\n       constructive parameter of this curve segment at its\n       start point. The startParameter can either be positive\n       or negative.')

    
    # Element {http://www.opengis.net/gml}startParameter uses Python identifier startParameter
    __startParameter = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'startParameter'), 'startParameter', '__httpwww_opengis_netgml_ClothoidType_httpwww_opengis_netgmlstartParameter', False)

    
    startParameter = property(__startParameter.value, __startParameter.set, None, u"The startParameter is the arc length\n       distance from the inflection point that will be the start\n       point for this curve segment. This shall be lower limit\n       used in the Fresnel integral and is the value of the\n       constructive parameter of this curve segment at its start\n       point. The startParameter can either be positive or\n       negative. \n       NOTE! If 0.0 (zero), lies between the startParameter and\n       the endParameter of the clothoid, then the curve goes\n       through the clothoid's inflection point, and the direction\n       of its radius of curvature, given by the second\n       derivative vector, changes sides with respect to the\n       tangent vector. The term length distance for the")

    
    # Element {http://www.opengis.net/gml}refLocation uses Python identifier refLocation
    __refLocation = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'refLocation'), 'refLocation', '__httpwww_opengis_netgml_ClothoidType_httpwww_opengis_netgmlrefLocation', False)

    
    refLocation = property(__refLocation.value, __refLocation.set, None, None)

    
    # Element {http://www.opengis.net/gml}scaleFactor uses Python identifier scaleFactor
    __scaleFactor = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'scaleFactor'), 'scaleFactor', '__httpwww_opengis_netgml_ClothoidType_httpwww_opengis_netgmlscaleFactor', False)

    
    scaleFactor = property(__scaleFactor.value, __scaleFactor.set, None, u"The element gives the value for the\n       constant in the Fresnel's integrals.")

    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType

    _ElementMap = AbstractCurveSegmentType._ElementMap.copy()
    _ElementMap.update({
        __endParameter.name() : __endParameter,
        __startParameter.name() : __startParameter,
        __refLocation.name() : __refLocation,
        __scaleFactor.name() : __scaleFactor
    })
    _AttributeMap = AbstractCurveSegmentType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ClothoidType', ClothoidType)


# Complex type ArcType with content type ELEMENT_ONLY
class ArcType (ArcStringType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ArcType')
    # Base type is ArcStringType
    
    # Element pointProperty ({http://www.opengis.net/gml}pointProperty) inherited from {http://www.opengis.net/gml}ArcStringType
    
    # Element posList ({http://www.opengis.net/gml}posList) inherited from {http://www.opengis.net/gml}ArcStringType
    
    # Element coordinates ({http://www.opengis.net/gml}coordinates) inherited from {http://www.opengis.net/gml}ArcStringType
    
    # Element pointRep ({http://www.opengis.net/gml}pointRep) inherited from {http://www.opengis.net/gml}ArcStringType
    
    # Element pos ({http://www.opengis.net/gml}pos) inherited from {http://www.opengis.net/gml}ArcStringType
    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute interpolation inherited from {http://www.opengis.net/gml}ArcStringType
    
    # Attribute numArc is restricted from parent
    
    # Attribute numArc uses Python identifier numArc
    __numArc = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'numArc'), 'numArc', '__httpwww_opengis_netgml_ArcStringType_numArc', pyxb.binding.datatypes.integer, fixed=True, unicode_default=u'1')
    
    numArc = property(__numArc.value, __numArc.set, None, u'An arc is an arc string consiting of a single arc, the attribute is fixed to "1".')

    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType

    _ElementMap = ArcStringType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = ArcStringType._AttributeMap.copy()
    _AttributeMap.update({
        __numArc.name() : __numArc
    })
Namespace.addCategoryObject('typeBinding', u'ArcType', ArcType)


# Complex type RectifiedGridCoverageType with content type ELEMENT_ONLY
class RectifiedGridCoverageType (AbstractDiscreteCoverageType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'RectifiedGridCoverageType')
    # Base type is AbstractDiscreteCoverageType
    
    # Element rangeSet ({http://www.opengis.net/gml}rangeSet) inherited from {http://www.opengis.net/gml}AbstractCoverageType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element boundedBy ({http://www.opengis.net/gml}boundedBy) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}rectifiedGridDomain uses Python identifier rectifiedGridDomain
    __rectifiedGridDomain = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'rectifiedGridDomain'), 'rectifiedGridDomain', '__httpwww_opengis_netgml_RectifiedGridCoverageType_httpwww_opengis_netgmlrectifiedGridDomain', False)

    
    rectifiedGridDomain = property(__rectifiedGridDomain.value, __rectifiedGridDomain.set, None, None)

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element coverageFunction ({http://www.opengis.net/gml}coverageFunction) inherited from {http://www.opengis.net/gml}AbstractDiscreteCoverageType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute dimension inherited from {http://www.opengis.net/gml}AbstractCoverageType

    _ElementMap = AbstractDiscreteCoverageType._ElementMap.copy()
    _ElementMap.update({
        __rectifiedGridDomain.name() : __rectifiedGridDomain
    })
    _AttributeMap = AbstractDiscreteCoverageType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'RectifiedGridCoverageType', RectifiedGridCoverageType)


# Complex type VerticalCSRefType with content type ELEMENT_ONLY
class VerticalCSRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VerticalCSRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}VerticalCS uses Python identifier VerticalCS
    __VerticalCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'VerticalCS'), 'VerticalCS', '__httpwww_opengis_netgml_VerticalCSRefType_httpwww_opengis_netgmlVerticalCS', False)

    
    VerticalCS = property(__VerticalCS.value, __VerticalCS.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_VerticalCSRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_VerticalCSRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_VerticalCSRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_VerticalCSRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_VerticalCSRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_VerticalCSRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_VerticalCSRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_VerticalCSRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)


    _ElementMap = {
        __VerticalCS.name() : __VerticalCS
    }
    _AttributeMap = {
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __href.name() : __href,
        __arcrole.name() : __arcrole
    }
Namespace.addCategoryObject('typeBinding', u'VerticalCSRefType', VerticalCSRefType)


# Complex type DictionaryEntryType with content type ELEMENT_ONLY
class DictionaryEntryType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DictionaryEntryType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Definition uses Python identifier Definition
    __Definition = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Definition'), 'Definition', '__httpwww_opengis_netgml_DictionaryEntryType_httpwww_opengis_netgmlDefinition', False)

    
    Definition = property(__Definition.value, __Definition.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_DictionaryEntryType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_DictionaryEntryType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_DictionaryEntryType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_DictionaryEntryType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_DictionaryEntryType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_DictionaryEntryType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_DictionaryEntryType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_DictionaryEntryType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')


    _ElementMap = {
        __Definition.name() : __Definition
    }
    _AttributeMap = {
        __arcrole.name() : __arcrole,
        __type.name() : __type,
        __show.name() : __show,
        __href.name() : __href,
        __role.name() : __role,
        __title.name() : __title,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema
    }
Namespace.addCategoryObject('typeBinding', u'DictionaryEntryType', DictionaryEntryType)


# Complex type TemporalCSRefType with content type ELEMENT_ONLY
class TemporalCSRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TemporalCSRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TemporalCS uses Python identifier TemporalCS
    __TemporalCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TemporalCS'), 'TemporalCS', '__httpwww_opengis_netgml_TemporalCSRefType_httpwww_opengis_netgmlTemporalCS', False)

    
    TemporalCS = property(__TemporalCS.value, __TemporalCS.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_TemporalCSRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_TemporalCSRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_TemporalCSRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_TemporalCSRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_TemporalCSRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_TemporalCSRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_TemporalCSRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_TemporalCSRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)


    _ElementMap = {
        __TemporalCS.name() : __TemporalCS
    }
    _AttributeMap = {
        __href.name() : __href,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __show.name() : __show,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'TemporalCSRefType', TemporalCSRefType)


# Complex type VerticalDatumRefType with content type ELEMENT_ONLY
class VerticalDatumRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VerticalDatumRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}VerticalDatum uses Python identifier VerticalDatum
    __VerticalDatum = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'VerticalDatum'), 'VerticalDatum', '__httpwww_opengis_netgml_VerticalDatumRefType_httpwww_opengis_netgmlVerticalDatum', False)

    
    VerticalDatum = property(__VerticalDatum.value, __VerticalDatum.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_VerticalDatumRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_VerticalDatumRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_VerticalDatumRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_VerticalDatumRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_VerticalDatumRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_VerticalDatumRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_VerticalDatumRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_VerticalDatumRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")


    _ElementMap = {
        __VerticalDatum.name() : __VerticalDatum
    }
    _AttributeMap = {
        __title.name() : __title,
        __href.name() : __href,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __show.name() : __show
    }
Namespace.addCategoryObject('typeBinding', u'VerticalDatumRefType', VerticalDatumRefType)


# Complex type TopoComplexType with content type ELEMENT_ONLY
class TopoComplexType (AbstractTopologyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopoComplexType')
    # Base type is AbstractTopologyType
    
    # Element {http://www.opengis.net/gml}superComplex uses Python identifier superComplex
    __superComplex = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'superComplex'), 'superComplex', '__httpwww_opengis_netgml_TopoComplexType_httpwww_opengis_netgmlsuperComplex', True)

    
    superComplex = property(__superComplex.value, __superComplex.set, None, u'')

    
    # Element {http://www.opengis.net/gml}topoPrimitiveMembers uses Python identifier topoPrimitiveMembers
    __topoPrimitiveMembers = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'topoPrimitiveMembers'), 'topoPrimitiveMembers', '__httpwww_opengis_netgml_TopoComplexType_httpwww_opengis_netgmltopoPrimitiveMembers', False)

    
    topoPrimitiveMembers = property(__topoPrimitiveMembers.value, __topoPrimitiveMembers.set, None, u'')

    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}subComplex uses Python identifier subComplex
    __subComplex = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'subComplex'), 'subComplex', '__httpwww_opengis_netgml_TopoComplexType_httpwww_opengis_netgmlsubComplex', True)

    
    subComplex = property(__subComplex.value, __subComplex.set, None, u'')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}maximalComplex uses Python identifier maximalComplex
    __maximalComplex = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'maximalComplex'), 'maximalComplex', '__httpwww_opengis_netgml_TopoComplexType_httpwww_opengis_netgmlmaximalComplex', False)

    
    maximalComplex = property(__maximalComplex.value, __maximalComplex.set, None, u'Need schamatron test here that isMaximal attribute value is true')

    
    # Element {http://www.opengis.net/gml}topoPrimitiveMember uses Python identifier topoPrimitiveMember
    __topoPrimitiveMember = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'topoPrimitiveMember'), 'topoPrimitiveMember', '__httpwww_opengis_netgml_TopoComplexType_httpwww_opengis_netgmltopoPrimitiveMember', True)

    
    topoPrimitiveMember = property(__topoPrimitiveMember.value, __topoPrimitiveMember.set, None, u'')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute isMaximal uses Python identifier isMaximal
    __isMaximal = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'isMaximal'), 'isMaximal', '__httpwww_opengis_netgml_TopoComplexType_isMaximal', pyxb.binding.datatypes.boolean, unicode_default=u'false')
    
    isMaximal = property(__isMaximal.value, __isMaximal.set, None, None)


    _ElementMap = AbstractTopologyType._ElementMap.copy()
    _ElementMap.update({
        __superComplex.name() : __superComplex,
        __topoPrimitiveMembers.name() : __topoPrimitiveMembers,
        __subComplex.name() : __subComplex,
        __maximalComplex.name() : __maximalComplex,
        __topoPrimitiveMember.name() : __topoPrimitiveMember
    })
    _AttributeMap = AbstractTopologyType._AttributeMap.copy()
    _AttributeMap.update({
        __isMaximal.name() : __isMaximal
    })
Namespace.addCategoryObject('typeBinding', u'TopoComplexType', TopoComplexType)


# Complex type AbstractContinuousCoverageType with content type ELEMENT_ONLY
class AbstractContinuousCoverageType (AbstractCoverageType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractContinuousCoverageType')
    # Base type is AbstractCoverageType
    
    # Element rangeSet ({http://www.opengis.net/gml}rangeSet) inherited from {http://www.opengis.net/gml}AbstractCoverageType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element boundedBy ({http://www.opengis.net/gml}boundedBy) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}coverageFunction uses Python identifier coverageFunction
    __coverageFunction = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coverageFunction'), 'coverageFunction', '__httpwww_opengis_netgml_AbstractContinuousCoverageType_httpwww_opengis_netgmlcoverageFunction', False)

    
    coverageFunction = property(__coverageFunction.value, __coverageFunction.set, None, None)

    
    # Element domainSet ({http://www.opengis.net/gml}domainSet) inherited from {http://www.opengis.net/gml}AbstractCoverageType
    
    # Element location ({http://www.opengis.net/gml}location) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute dimension inherited from {http://www.opengis.net/gml}AbstractCoverageType

    _ElementMap = AbstractCoverageType._ElementMap.copy()
    _ElementMap.update({
        __coverageFunction.name() : __coverageFunction
    })
    _AttributeMap = AbstractCoverageType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractContinuousCoverageType', AbstractContinuousCoverageType)


# Complex type AbstractGeneralDerivedCRSType with content type ELEMENT_ONLY
class AbstractGeneralDerivedCRSType (AbstractReferenceSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralDerivedCRSType')
    # Base type is AbstractReferenceSystemType
    
    # Element srsName ({http://www.opengis.net/gml}srsName) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemBaseType
    
    # Element srsID ({http://www.opengis.net/gml}srsID) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element validArea ({http://www.opengis.net/gml}validArea) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element {http://www.opengis.net/gml}baseCRS uses Python identifier baseCRS
    __baseCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'baseCRS'), 'baseCRS', '__httpwww_opengis_netgml_AbstractGeneralDerivedCRSType_httpwww_opengis_netgmlbaseCRS', False)

    
    baseCRS = property(__baseCRS.value, __baseCRS.set, None, u'Association to the coordinate reference system used by this derived CRS. ')

    
    # Element scope ({http://www.opengis.net/gml}scope) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}definedByConversion uses Python identifier definedByConversion
    __definedByConversion = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'definedByConversion'), 'definedByConversion', '__httpwww_opengis_netgml_AbstractGeneralDerivedCRSType_httpwww_opengis_netgmldefinedByConversion', False)

    
    definedByConversion = property(__definedByConversion.value, __definedByConversion.set, None, u'Association to the coordinate conversion used to define this derived CRS. ')

    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractReferenceSystemBaseType

    _ElementMap = AbstractReferenceSystemType._ElementMap.copy()
    _ElementMap.update({
        __baseCRS.name() : __baseCRS,
        __definedByConversion.name() : __definedByConversion
    })
    _AttributeMap = AbstractReferenceSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractGeneralDerivedCRSType', AbstractGeneralDerivedCRSType)


# Complex type ProjectedCRSType with content type ELEMENT_ONLY
class ProjectedCRSType (AbstractGeneralDerivedCRSType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ProjectedCRSType')
    # Base type is AbstractGeneralDerivedCRSType
    
    # Element srsName ({http://www.opengis.net/gml}srsName) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemBaseType
    
    # Element baseCRS ({http://www.opengis.net/gml}baseCRS) inherited from {http://www.opengis.net/gml}AbstractGeneralDerivedCRSType
    
    # Element {http://www.opengis.net/gml}usesCartesianCS uses Python identifier usesCartesianCS
    __usesCartesianCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesCartesianCS'), 'usesCartesianCS', '__httpwww_opengis_netgml_ProjectedCRSType_httpwww_opengis_netgmlusesCartesianCS', False)

    
    usesCartesianCS = property(__usesCartesianCS.value, __usesCartesianCS.set, None, u'Association to the Cartesian coordinate system used by this CRS. ')

    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element srsID ({http://www.opengis.net/gml}srsID) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element scope ({http://www.opengis.net/gml}scope) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element validArea ({http://www.opengis.net/gml}validArea) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element definedByConversion ({http://www.opengis.net/gml}definedByConversion) inherited from {http://www.opengis.net/gml}AbstractGeneralDerivedCRSType
    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractReferenceSystemBaseType

    _ElementMap = AbstractGeneralDerivedCRSType._ElementMap.copy()
    _ElementMap.update({
        __usesCartesianCS.name() : __usesCartesianCS
    })
    _AttributeMap = AbstractGeneralDerivedCRSType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ProjectedCRSType', ProjectedCRSType)


# Complex type AbstractTimeObjectType with content type ELEMENT_ONLY
class AbstractTimeObjectType (AbstractGMLType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeObjectType')
    # Base type is AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractGMLType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractGMLType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractTimeObjectType', AbstractTimeObjectType)


# Complex type AbstractTimeComplexType with content type ELEMENT_ONLY
class AbstractTimeComplexType (AbstractTimeObjectType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeComplexType')
    # Base type is AbstractTimeObjectType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTimeObjectType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractTimeObjectType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractTimeComplexType', AbstractTimeComplexType)


# Complex type TimeTopologyComplexType with content type ELEMENT_ONLY
class TimeTopologyComplexType (AbstractTimeComplexType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeTopologyComplexType')
    # Base type is AbstractTimeComplexType
    
    # Element {http://www.opengis.net/gml}primitive uses Python identifier primitive
    __primitive = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'primitive'), 'primitive', '__httpwww_opengis_netgml_TimeTopologyComplexType_httpwww_opengis_netgmlprimitive', True)

    
    primitive = property(__primitive.value, __primitive.set, None, None)

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTimeComplexType._ElementMap.copy()
    _ElementMap.update({
        __primitive.name() : __primitive
    })
    _AttributeMap = AbstractTimeComplexType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TimeTopologyComplexType', TimeTopologyComplexType)


# Complex type DerivedCRSType with content type ELEMENT_ONLY
class DerivedCRSType (AbstractGeneralDerivedCRSType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DerivedCRSType')
    # Base type is AbstractGeneralDerivedCRSType
    
    # Element {http://www.opengis.net/gml}usesCS uses Python identifier usesCS
    __usesCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesCS'), 'usesCS', '__httpwww_opengis_netgml_DerivedCRSType_httpwww_opengis_netgmlusesCS', False)

    
    usesCS = property(__usesCS.value, __usesCS.set, None, u'Association to the coordinate system used by this CRS. ')

    
    # Element srsID ({http://www.opengis.net/gml}srsID) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element validArea ({http://www.opengis.net/gml}validArea) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element baseCRS ({http://www.opengis.net/gml}baseCRS) inherited from {http://www.opengis.net/gml}AbstractGeneralDerivedCRSType
    
    # Element scope ({http://www.opengis.net/gml}scope) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element {http://www.opengis.net/gml}derivedCRSType uses Python identifier derivedCRSType
    __derivedCRSType = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'derivedCRSType'), 'derivedCRSType', '__httpwww_opengis_netgml_DerivedCRSType_httpwww_opengis_netgmlderivedCRSType', False)

    
    derivedCRSType = property(__derivedCRSType.value, __derivedCRSType.set, None, None)

    
    # Element definedByConversion ({http://www.opengis.net/gml}definedByConversion) inherited from {http://www.opengis.net/gml}AbstractGeneralDerivedCRSType
    
    # Element srsName ({http://www.opengis.net/gml}srsName) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemBaseType
    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractReferenceSystemBaseType

    _ElementMap = AbstractGeneralDerivedCRSType._ElementMap.copy()
    _ElementMap.update({
        __usesCS.name() : __usesCS,
        __derivedCRSType.name() : __derivedCRSType
    })
    _AttributeMap = AbstractGeneralDerivedCRSType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'DerivedCRSType', DerivedCRSType)


# Complex type EdgeType with content type ELEMENT_ONLY
class EdgeType (AbstractTopoPrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'EdgeType')
    # Base type is AbstractTopoPrimitiveType
    
    # Element {http://www.opengis.net/gml}curveProperty uses Python identifier curveProperty
    __curveProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'curveProperty'), 'curveProperty', '__httpwww_opengis_netgml_EdgeType_httpwww_opengis_netgmlcurveProperty', False)

    
    curveProperty = property(__curveProperty.value, __curveProperty.set, None, u'This property element either references a curve via the XLink-attributes or contains the curve element. curveProperty is the \n\t\t\tpredefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that is \n\t\t\tsubstitutable for _Curve.')

    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}directedFace uses Python identifier directedFace
    __directedFace = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'directedFace'), 'directedFace', '__httpwww_opengis_netgml_EdgeType_httpwww_opengis_netgmldirectedFace', True)

    
    directedFace = property(__directedFace.value, __directedFace.set, None, u'')

    
    # Element isolated ({http://www.opengis.net/gml}isolated) inherited from {http://www.opengis.net/gml}AbstractTopoPrimitiveType
    
    # Element {http://www.opengis.net/gml}directedNode uses Python identifier directedNode
    __directedNode = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'directedNode'), 'directedNode', '__httpwww_opengis_netgml_EdgeType_httpwww_opengis_netgmldirectedNode', True)

    
    directedNode = property(__directedNode.value, __directedNode.set, None, u'')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element container ({http://www.opengis.net/gml}container) inherited from {http://www.opengis.net/gml}AbstractTopoPrimitiveType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTopoPrimitiveType._ElementMap.copy()
    _ElementMap.update({
        __curveProperty.name() : __curveProperty,
        __directedFace.name() : __directedFace,
        __directedNode.name() : __directedNode
    })
    _AttributeMap = AbstractTopoPrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'EdgeType', EdgeType)


# Complex type ObliqueCartesianCSRefType with content type ELEMENT_ONLY
class ObliqueCartesianCSRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ObliqueCartesianCSRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}ObliqueCartesianCS uses Python identifier ObliqueCartesianCS
    __ObliqueCartesianCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'ObliqueCartesianCS'), 'ObliqueCartesianCS', '__httpwww_opengis_netgml_ObliqueCartesianCSRefType_httpwww_opengis_netgmlObliqueCartesianCS', False)

    
    ObliqueCartesianCS = property(__ObliqueCartesianCS.value, __ObliqueCartesianCS.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_ObliqueCartesianCSRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_ObliqueCartesianCSRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_ObliqueCartesianCSRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_ObliqueCartesianCSRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_ObliqueCartesianCSRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_ObliqueCartesianCSRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_ObliqueCartesianCSRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_ObliqueCartesianCSRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")


    _ElementMap = {
        __ObliqueCartesianCS.name() : __ObliqueCartesianCS
    }
    _AttributeMap = {
        __type.name() : __type,
        __role.name() : __role,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __href.name() : __href,
        __show.name() : __show
    }
Namespace.addCategoryObject('typeBinding', u'ObliqueCartesianCSRefType', ObliqueCartesianCSRefType)


# Complex type VerticalCSType with content type ELEMENT_ONLY
class VerticalCSType (AbstractCoordinateSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VerticalCSType')
    # Base type is AbstractCoordinateSystemType
    
    # Element usesAxis ({http://www.opengis.net/gml}usesAxis) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element csID ({http://www.opengis.net/gml}csID) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element csName ({http://www.opengis.net/gml}csName) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemBaseType
    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemBaseType

    _ElementMap = AbstractCoordinateSystemType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractCoordinateSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'VerticalCSType', VerticalCSType)


# Complex type TimeInstantPropertyType with content type ELEMENT_ONLY
class TimeInstantPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeInstantPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TimeInstant uses Python identifier TimeInstant
    __TimeInstant = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TimeInstant'), 'TimeInstant', '__httpwww_opengis_netgml_TimeInstantPropertyType_httpwww_opengis_netgmlTimeInstant', False)

    
    TimeInstant = property(__TimeInstant.value, __TimeInstant.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_TimeInstantPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_TimeInstantPropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_TimeInstantPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_TimeInstantPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_TimeInstantPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_TimeInstantPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_TimeInstantPropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_TimeInstantPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)


    _ElementMap = {
        __TimeInstant.name() : __TimeInstant
    }
    _AttributeMap = {
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __href.name() : __href,
        __show.name() : __show,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'TimeInstantPropertyType', TimeInstantPropertyType)


# Complex type CylindricalCSType with content type ELEMENT_ONLY
class CylindricalCSType (AbstractCoordinateSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CylindricalCSType')
    # Base type is AbstractCoordinateSystemType
    
    # Element usesAxis ({http://www.opengis.net/gml}usesAxis) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element csID ({http://www.opengis.net/gml}csID) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element csName ({http://www.opengis.net/gml}csName) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemBaseType
    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemBaseType

    _ElementMap = AbstractCoordinateSystemType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractCoordinateSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CylindricalCSType', CylindricalCSType)


# Complex type MultiSurfaceType with content type ELEMENT_ONLY
class MultiSurfaceType (AbstractGeometricAggregateType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiSurfaceType')
    # Base type is AbstractGeometricAggregateType
    
    # Element {http://www.opengis.net/gml}surfaceMember uses Python identifier surfaceMember
    __surfaceMember = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'surfaceMember'), 'surfaceMember', '__httpwww_opengis_netgml_MultiSurfaceType_httpwww_opengis_netgmlsurfaceMember', True)

    
    surfaceMember = property(__surfaceMember.value, __surfaceMember.set, None, u'This property element either references a surface via the XLink-attributes or contains the surface element. A surface element is any element which is substitutable for "_Surface".')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}surfaceMembers uses Python identifier surfaceMembers
    __surfaceMembers = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'surfaceMembers'), 'surfaceMembers', '__httpwww_opengis_netgml_MultiSurfaceType_httpwww_opengis_netgmlsurfaceMembers', False)

    
    surfaceMembers = property(__surfaceMembers.value, __surfaceMembers.set, None, u'This property element contains a list of surfaces. The order of the elements is significant and shall be preserved when processing the array.')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometricAggregateType._ElementMap.copy()
    _ElementMap.update({
        __surfaceMember.name() : __surfaceMember,
        __surfaceMembers.name() : __surfaceMembers
    })
    _AttributeMap = AbstractGeometricAggregateType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MultiSurfaceType', MultiSurfaceType)


# Complex type DegreesType with content type SIMPLE
class DegreesType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = DegreeValueType
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DegreesType')
    # Base type is DegreeValueType
    
    # Attribute direction uses Python identifier direction
    __direction = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'direction'), 'direction', '__httpwww_opengis_netgml_DegreesType_direction', STD_ANON_4)
    
    direction = property(__direction.value, __direction.set, None, None)


    _ElementMap = {
        
    }
    _AttributeMap = {
        __direction.name() : __direction
    }
Namespace.addCategoryObject('typeBinding', u'DegreesType', DegreesType)


# Complex type DirectedEdgePropertyType with content type ELEMENT_ONLY
class DirectedEdgePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DirectedEdgePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Edge uses Python identifier Edge
    __Edge = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Edge'), 'Edge', '__httpwww_opengis_netgml_DirectedEdgePropertyType_httpwww_opengis_netgmlEdge', False)

    
    Edge = property(__Edge.value, __Edge.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_DirectedEdgePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_DirectedEdgePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute orientation uses Python identifier orientation
    __orientation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'orientation'), 'orientation', '__httpwww_opengis_netgml_DirectedEdgePropertyType_orientation', SignType, unicode_default=u'+')
    
    orientation = property(__orientation.value, __orientation.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_DirectedEdgePropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_DirectedEdgePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_DirectedEdgePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_DirectedEdgePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_DirectedEdgePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_DirectedEdgePropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")


    _ElementMap = {
        __Edge.name() : __Edge
    }
    _AttributeMap = {
        __type.name() : __type,
        __role.name() : __role,
        __orientation.name() : __orientation,
        __actuate.name() : __actuate,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __title.name() : __title,
        __show.name() : __show
    }
Namespace.addCategoryObject('typeBinding', u'DirectedEdgePropertyType', DirectedEdgePropertyType)


# Complex type HistoryPropertyType with content type ELEMENT_ONLY
class HistoryPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'HistoryPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_TimeSlice uses Python identifier TimeSlice
    __TimeSlice = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_TimeSlice'), 'TimeSlice', '__httpwww_opengis_netgml_HistoryPropertyType_httpwww_opengis_netgml_TimeSlice', True)

    
    TimeSlice = property(__TimeSlice.value, __TimeSlice.set, None, None)


    _ElementMap = {
        __TimeSlice.name() : __TimeSlice
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'HistoryPropertyType', HistoryPropertyType)


# Complex type MultiCurveDomainType with content type ELEMENT_ONLY
class MultiCurveDomainType (DomainSetType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiCurveDomainType')
    # Base type is DomainSetType
    
    # Element {http://www.opengis.net/gml}MultiCurve uses Python identifier MultiCurve
    __MultiCurve = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'MultiCurve'), 'MultiCurve', '__httpwww_opengis_netgml_MultiCurveDomainType_httpwww_opengis_netgmlMultiCurve', False)

    
    MultiCurve = property(__MultiCurve.value, __MultiCurve.set, None, None)

    
    # Attribute role is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute actuate is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute remoteSchema is restricted from parent
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_DomainSetType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute href is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute arcrole is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute title is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute show is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute type is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)


    _ElementMap = DomainSetType._ElementMap.copy()
    _ElementMap.update({
        __MultiCurve.name() : __MultiCurve
    })
    _AttributeMap = DomainSetType._AttributeMap.copy()
    _AttributeMap.update({
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type
    })
Namespace.addCategoryObject('typeBinding', u'MultiCurveDomainType', MultiCurveDomainType)


# Complex type ConversionRefType with content type ELEMENT_ONLY
class ConversionRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ConversionRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Conversion uses Python identifier Conversion
    __Conversion = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Conversion'), 'Conversion', '__httpwww_opengis_netgml_ConversionRefType_httpwww_opengis_netgmlConversion', False)

    
    Conversion = property(__Conversion.value, __Conversion.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_ConversionRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_ConversionRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_ConversionRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_ConversionRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_ConversionRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_ConversionRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_ConversionRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_ConversionRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)


    _ElementMap = {
        __Conversion.name() : __Conversion
    }
    _AttributeMap = {
        __type.name() : __type,
        __role.name() : __role,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __show.name() : __show,
        __href.name() : __href
    }
Namespace.addCategoryObject('typeBinding', u'ConversionRefType', ConversionRefType)


# Complex type MultiPointType with content type ELEMENT_ONLY
class MultiPointType (AbstractGeometricAggregateType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiPointType')
    # Base type is AbstractGeometricAggregateType
    
    # Element {http://www.opengis.net/gml}pointMembers uses Python identifier pointMembers
    __pointMembers = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointMembers'), 'pointMembers', '__httpwww_opengis_netgml_MultiPointType_httpwww_opengis_netgmlpointMembers', False)

    
    pointMembers = property(__pointMembers.value, __pointMembers.set, None, u'This property element contains a list of points. The order of the elements is significant and shall be preserved when processing the array.')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}pointMember uses Python identifier pointMember
    __pointMember = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointMember'), 'pointMember', '__httpwww_opengis_netgml_MultiPointType_httpwww_opengis_netgmlpointMember', True)

    
    pointMember = property(__pointMember.value, __pointMember.set, None, u'This property element either references a Point via the XLink-attributes or contains the Point element.')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometricAggregateType._ElementMap.copy()
    _ElementMap.update({
        __pointMembers.name() : __pointMembers,
        __pointMember.name() : __pointMember
    })
    _AttributeMap = AbstractGeometricAggregateType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MultiPointType', MultiPointType)


# Complex type MetaDataPropertyType with content type ELEMENT_ONLY
class MetaDataPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MetaDataPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_MetaDataPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_MetaDataPropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_MetaDataPropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_MetaDataPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute about uses Python identifier about
    __about = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'about'), 'about', '__httpwww_opengis_netgml_MetaDataPropertyType_about', pyxb.binding.datatypes.anyURI)
    
    about = property(__about.value, __about.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_MetaDataPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_MetaDataPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_MetaDataPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_MetaDataPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    _HasWildcardElement = True

    _ElementMap = {
        
    }
    _AttributeMap = {
        __href.name() : __href,
        __actuate.name() : __actuate,
        __show.name() : __show,
        __remoteSchema.name() : __remoteSchema,
        __about.name() : __about,
        __role.name() : __role,
        __title.name() : __title,
        __arcrole.name() : __arcrole,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'MetaDataPropertyType', MetaDataPropertyType)


# Complex type PointType with content type ELEMENT_ONLY
class PointType (AbstractGeometricPrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PointType')
    # Base type is AbstractGeometricPrimitiveType
    
    # Element {http://www.opengis.net/gml}coordinates uses Python identifier coordinates
    __coordinates = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), 'coordinates', '__httpwww_opengis_netgml_PointType_httpwww_opengis_netgmlcoordinates', False)

    
    coordinates = property(__coordinates.value, __coordinates.set, None, u'Deprecated with GML version 3.1.0.')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}coord uses Python identifier coord
    __coord = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coord'), 'coord', '__httpwww_opengis_netgml_PointType_httpwww_opengis_netgmlcoord', False)

    
    coord = property(__coord.value, __coord.set, None, u'Deprecated with GML 3.0 and included for backwards compatibility with GML 2. Use the "pos" element instead.')

    
    # Element {http://www.opengis.net/gml}pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pos'), 'pos', '__httpwww_opengis_netgml_PointType_httpwww_opengis_netgmlpos', False)

    
    pos = property(__pos.value, __pos.set, None, u'')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometricPrimitiveType._ElementMap.copy()
    _ElementMap.update({
        __coordinates.name() : __coordinates,
        __coord.name() : __coord,
        __pos.name() : __pos
    })
    _AttributeMap = AbstractGeometricPrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'PointType', PointType)


# Complex type GeodesicStringType with content type ELEMENT_ONLY
class GeodesicStringType (AbstractCurveSegmentType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeodesicStringType')
    # Base type is AbstractCurveSegmentType
    
    # Element {http://www.opengis.net/gml}posList uses Python identifier posList
    __posList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'posList'), 'posList', '__httpwww_opengis_netgml_GeodesicStringType_httpwww_opengis_netgmlposList', False)

    
    posList = property(__posList.value, __posList.set, None, u'')

    
    # Element {http://www.opengis.net/gml}pointProperty uses Python identifier pointProperty
    __pointProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), 'pointProperty', '__httpwww_opengis_netgml_GeodesicStringType_httpwww_opengis_netgmlpointProperty', True)

    
    pointProperty = property(__pointProperty.value, __pointProperty.set, None, u'This property element either references a point via the XLink-attributes or contains the point element. pointProperty \n\t\t\tis the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that \n\t\t\tis substitutable for Point.')

    
    # Element {http://www.opengis.net/gml}pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pos'), 'pos', '__httpwww_opengis_netgml_GeodesicStringType_httpwww_opengis_netgmlpos', True)

    
    pos = property(__pos.value, __pos.set, None, u'')

    
    # Attribute interpolation uses Python identifier interpolation
    __interpolation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'interpolation'), 'interpolation', '__httpwww_opengis_netgml_GeodesicStringType_interpolation', CurveInterpolationType, fixed=True, unicode_default=u'geodesic')
    
    interpolation = property(__interpolation.value, __interpolation.set, None, u'The attribute "interpolation" specifies the\n     curve interpolation mechanism used for this segment. This\n     mechanism uses the control points and control parameters to\n     determine the position of this curve segment. For an \n     GeodesicString the interpolation is fixed as "geodesic".')

    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType

    _ElementMap = AbstractCurveSegmentType._ElementMap.copy()
    _ElementMap.update({
        __posList.name() : __posList,
        __pointProperty.name() : __pointProperty,
        __pos.name() : __pos
    })
    _AttributeMap = AbstractCurveSegmentType._AttributeMap.copy()
    _AttributeMap.update({
        __interpolation.name() : __interpolation
    })
Namespace.addCategoryObject('typeBinding', u'GeodesicStringType', GeodesicStringType)


# Complex type AffinePlacementType with content type ELEMENT_ONLY
class AffinePlacementType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AffinePlacementType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}outDimension uses Python identifier outDimension
    __outDimension = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'outDimension'), 'outDimension', '__httpwww_opengis_netgml_AffinePlacementType_httpwww_opengis_netgmloutDimension', False)

    
    outDimension = property(__outDimension.value, __outDimension.set, None, u'Dimension of the co-ordinate space.')

    
    # Element {http://www.opengis.net/gml}location uses Python identifier location
    __location = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'location'), 'location', '__httpwww_opengis_netgml_AffinePlacementType_httpwww_opengis_netgmllocation', False)

    
    location = property(__location.value, __location.set, None, u'The location property gives \n     the target of the parameter space origin. This is the vector  \n    (x0, y0, z0) in the formulae above.')

    
    # Element {http://www.opengis.net/gml}inDimension uses Python identifier inDimension
    __inDimension = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'inDimension'), 'inDimension', '__httpwww_opengis_netgml_AffinePlacementType_httpwww_opengis_netgmlinDimension', False)

    
    inDimension = property(__inDimension.value, __inDimension.set, None, u'Dimension of the constructive parameter \n     space.')

    
    # Element {http://www.opengis.net/gml}refDirection uses Python identifier refDirection
    __refDirection = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'refDirection'), 'refDirection', '__httpwww_opengis_netgml_AffinePlacementType_httpwww_opengis_netgmlrefDirection', True)

    
    refDirection = property(__refDirection.value, __refDirection.set, None, u'The attribute refDirection gives the    \ntarget directions for the co-ordinate basis vectors of the  \nparameter space. These are the columns of the matrix in the \nformulae given above. The number of directions given shall be \ninDimension. The dimension of the directions shall be \noutDimension.')


    _ElementMap = {
        __outDimension.name() : __outDimension,
        __location.name() : __location,
        __inDimension.name() : __inDimension,
        __refDirection.name() : __refDirection
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'AffinePlacementType', AffinePlacementType)


# Complex type AbstractSolidType with content type ELEMENT_ONLY
class AbstractSolidType (AbstractGeometricPrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractSolidType')
    # Base type is AbstractGeometricPrimitiveType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometricPrimitiveType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractGeometricPrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractSolidType', AbstractSolidType)


# Complex type SolidType with content type ELEMENT_ONLY
class SolidType (AbstractSolidType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SolidType')
    # Base type is AbstractSolidType
    
    # Element {http://www.opengis.net/gml}interior uses Python identifier interior
    __interior = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'interior'), 'interior', '__httpwww_opengis_netgml_SolidType_httpwww_opengis_netgmlinterior', True)

    
    interior = property(__interior.value, __interior.set, None, u'Boundaries of solids are similar to surface boundaries.')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}exterior uses Python identifier exterior
    __exterior = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'exterior'), 'exterior', '__httpwww_opengis_netgml_SolidType_httpwww_opengis_netgmlexterior', False)

    
    exterior = property(__exterior.value, __exterior.set, None, u'Boundaries of solids are similar to surface boundaries. In normal 3-dimensional Euclidean space, one (composite) surface is distinguished as the exterior. In the more general case, this is not always possible.')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractSolidType._ElementMap.copy()
    _ElementMap.update({
        __interior.name() : __interior,
        __exterior.name() : __exterior
    })
    _AttributeMap = AbstractSolidType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SolidType', SolidType)


# Complex type CoordType with content type ELEMENT_ONLY
class CoordType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CoordType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Z uses Python identifier Z
    __Z = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Z'), 'Z', '__httpwww_opengis_netgml_CoordType_httpwww_opengis_netgmlZ', False)

    
    Z = property(__Z.value, __Z.set, None, None)

    
    # Element {http://www.opengis.net/gml}X uses Python identifier X
    __X = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'X'), 'X', '__httpwww_opengis_netgml_CoordType_httpwww_opengis_netgmlX', False)

    
    X = property(__X.value, __X.set, None, None)

    
    # Element {http://www.opengis.net/gml}Y uses Python identifier Y
    __Y = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Y'), 'Y', '__httpwww_opengis_netgml_CoordType_httpwww_opengis_netgmlY', False)

    
    Y = property(__Y.value, __Y.set, None, None)


    _ElementMap = {
        __Z.name() : __Z,
        __X.name() : __X,
        __Y.name() : __Y
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'CoordType', CoordType)


# Complex type CoordinateSystemAxisBaseType with content type ELEMENT_ONLY
class CoordinateSystemAxisBaseType (DefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CoordinateSystemAxisBaseType')
    # Base type is DefinitionType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id is restricted from parent
    
    # Attribute {http://www.opengis.net/gml}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'id'), 'id', '__httpwww_opengis_netgml_AbstractGMLType_httpwww_opengis_netgmlid', pyxb.binding.datatypes.ID, required=True)
    
    id = property(__id.value, __id.set, None, u'Database handle for the object.  It is of XML type ID, so is constrained to be unique in the XML document within which it occurs.  An external identifier for the object in the form of a URI may be constructed using standard XML and XPointer methods.  This is done by concatenating the URI for the document, a fragment separator, and the value of the id attribute.')


    _ElementMap = DefinitionType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = DefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', u'CoordinateSystemAxisBaseType', CoordinateSystemAxisBaseType)


# Complex type CoordinateSystemAxisType with content type ELEMENT_ONLY
class CoordinateSystemAxisType (CoordinateSystemAxisBaseType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CoordinateSystemAxisType')
    # Base type is CoordinateSystemAxisBaseType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}axisID uses Python identifier axisID
    __axisID = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'axisID'), 'axisID', '__httpwww_opengis_netgml_CoordinateSystemAxisType_httpwww_opengis_netgmlaxisID', True)

    
    axisID = property(__axisID.value, __axisID.set, None, u'An identification of a coordinate system axis. ')

    
    # Element {http://www.opengis.net/gml}axisDirection uses Python identifier axisDirection
    __axisDirection = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'axisDirection'), 'axisDirection', '__httpwww_opengis_netgml_CoordinateSystemAxisType_httpwww_opengis_netgmlaxisDirection', False)

    
    axisDirection = property(__axisDirection.value, __axisDirection.set, None, u'Direction of this coordinate system axis (or in the case of Cartesian projected coordinates, the direction of this coordinate system axis at the origin). Examples: north or south, east or west, up or down. Within any set of coordinate system axes, only one of each pair of terms can be used. For earth-fixed CRSs, this direction is often approximate and intended to provide a human interpretable meaning to the axis. When a geodetic datum is used, the precise directions of the axes may therefore vary slightly from this approximate direction. Note that an EngineeringCRS can include specific descriptions of the directions of its coordinate system axes. For example, the path of a linear CRS axis can be referenced in another document, such as referencing a GML feature that references or includes a curve geometry. The codeSpace attribute can reference a source of more information on a set of standardized directions, or on this direction. ')

    
    # Element {http://www.opengis.net/gml}axisAbbrev uses Python identifier axisAbbrev
    __axisAbbrev = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'axisAbbrev'), 'axisAbbrev', '__httpwww_opengis_netgml_CoordinateSystemAxisType_httpwww_opengis_netgmlaxisAbbrev', False)

    
    axisAbbrev = property(__axisAbbrev.value, __axisAbbrev.set, None, u'The abbreviation used for this coordinate system axis. This abbreviation can be used to identify the ordinates in a coordinate tuple. Examples are X and Y. The codeSpace attribute can reference a source of more information on a set of standardized abbreviations, or on this abbreviation. ')

    
    # Element {http://www.opengis.net/gml}remarks uses Python identifier remarks
    __remarks = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'remarks'), 'remarks', '__httpwww_opengis_netgml_CoordinateSystemAxisType_httpwww_opengis_netgmlremarks', False)

    
    remarks = property(__remarks.value, __remarks.set, None, u'Information about this object or code. Contains text or refers to external text.')

    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}CoordinateSystemAxisBaseType
    
    # Attribute {http://www.opengis.net/gml}uom uses Python identifier uom
    __uom = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'uom'), 'uom', '__httpwww_opengis_netgml_CoordinateSystemAxisType_httpwww_opengis_netgmluom', pyxb.binding.datatypes.anyURI, required=True)
    
    uom = property(__uom.value, __uom.set, None, u'Identifier of the unit of measure used for this coordinate system axis. The value of this coordinate in a coordinate tuple shall be recorded using this unit of measure, whenever those coordinates use a coordinate reference system that uses a coordinate system that uses this axis.')


    _ElementMap = CoordinateSystemAxisBaseType._ElementMap.copy()
    _ElementMap.update({
        __axisID.name() : __axisID,
        __axisDirection.name() : __axisDirection,
        __axisAbbrev.name() : __axisAbbrev,
        __remarks.name() : __remarks
    })
    _AttributeMap = CoordinateSystemAxisBaseType._AttributeMap.copy()
    _AttributeMap.update({
        __uom.name() : __uom
    })
Namespace.addCategoryObject('typeBinding', u'CoordinateSystemAxisType', CoordinateSystemAxisType)


# Complex type AbstractTimePrimitiveType with content type ELEMENT_ONLY
class AbstractTimePrimitiveType (AbstractTimeObjectType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractTimePrimitiveType')
    # Base type is AbstractTimeObjectType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}relatedTime uses Python identifier relatedTime
    __relatedTime = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'), 'relatedTime', '__httpwww_opengis_netgml_AbstractTimePrimitiveType_httpwww_opengis_netgmlrelatedTime', True)

    
    relatedTime = property(__relatedTime.value, __relatedTime.set, None, None)

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTimeObjectType._ElementMap.copy()
    _ElementMap.update({
        __relatedTime.name() : __relatedTime
    })
    _AttributeMap = AbstractTimeObjectType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractTimePrimitiveType', AbstractTimePrimitiveType)


# Complex type AbstractTimeGeometricPrimitiveType with content type ELEMENT_ONLY
class AbstractTimeGeometricPrimitiveType (AbstractTimePrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeGeometricPrimitiveType')
    # Base type is AbstractTimePrimitiveType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element relatedTime ({http://www.opengis.net/gml}relatedTime) inherited from {http://www.opengis.net/gml}AbstractTimePrimitiveType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute frame uses Python identifier frame
    __frame = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'frame'), 'frame', '__httpwww_opengis_netgml_AbstractTimeGeometricPrimitiveType_frame', pyxb.binding.datatypes.anyURI, unicode_default=u'#ISO-8601')
    
    frame = property(__frame.value, __frame.set, None, None)


    _ElementMap = AbstractTimePrimitiveType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractTimePrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        __frame.name() : __frame
    })
Namespace.addCategoryObject('typeBinding', u'AbstractTimeGeometricPrimitiveType', AbstractTimeGeometricPrimitiveType)


# Complex type TimePeriodType with content type ELEMENT_ONLY
class TimePeriodType (AbstractTimeGeometricPrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimePeriodType')
    # Base type is AbstractTimeGeometricPrimitiveType
    
    # Element {http://www.opengis.net/gml}timeInterval uses Python identifier timeInterval
    __timeInterval = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'timeInterval'), 'timeInterval', '__httpwww_opengis_netgml_TimePeriodType_httpwww_opengis_netgmltimeInterval', False)

    
    timeInterval = property(__timeInterval.value, __timeInterval.set, None, u'This element is a valid subtype of TimeDurationType \n\t\t\taccording to section 3.14.6, rule 2.2.4 in XML Schema, Part 1.')

    
    # Element {http://www.opengis.net/gml}end uses Python identifier end
    __end = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'end'), 'end', '__httpwww_opengis_netgml_TimePeriodType_httpwww_opengis_netgmlend', False)

    
    end = property(__end.value, __end.set, None, None)

    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element relatedTime ({http://www.opengis.net/gml}relatedTime) inherited from {http://www.opengis.net/gml}AbstractTimePrimitiveType
    
    # Element {http://www.opengis.net/gml}endPosition uses Python identifier endPosition
    __endPosition = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'endPosition'), 'endPosition', '__httpwww_opengis_netgml_TimePeriodType_httpwww_opengis_netgmlendPosition', False)

    
    endPosition = property(__endPosition.value, __endPosition.set, None, None)

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}beginPosition uses Python identifier beginPosition
    __beginPosition = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'beginPosition'), 'beginPosition', '__httpwww_opengis_netgml_TimePeriodType_httpwww_opengis_netgmlbeginPosition', False)

    
    beginPosition = property(__beginPosition.value, __beginPosition.set, None, None)

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}begin uses Python identifier begin
    __begin = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'begin'), 'begin', '__httpwww_opengis_netgml_TimePeriodType_httpwww_opengis_netgmlbegin', False)

    
    begin = property(__begin.value, __begin.set, None, None)

    
    # Element {http://www.opengis.net/gml}duration uses Python identifier duration
    __duration = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'duration'), 'duration', '__httpwww_opengis_netgml_TimePeriodType_httpwww_opengis_netgmlduration', False)

    
    duration = property(__duration.value, __duration.set, None, u'This element is an instance of the primitive xsd:duration simple type to \n      enable use of the ISO 8601 syntax for temporal length (e.g. P5DT4H30M). \n      It is a valid subtype of TimeDurationType according to section 3.14.6, \n      rule 2.2.4 in XML Schema, Part 1.')

    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute frame inherited from {http://www.opengis.net/gml}AbstractTimeGeometricPrimitiveType

    _ElementMap = AbstractTimeGeometricPrimitiveType._ElementMap.copy()
    _ElementMap.update({
        __timeInterval.name() : __timeInterval,
        __end.name() : __end,
        __endPosition.name() : __endPosition,
        __beginPosition.name() : __beginPosition,
        __begin.name() : __begin,
        __duration.name() : __duration
    })
    _AttributeMap = AbstractTimeGeometricPrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TimePeriodType', TimePeriodType)


# Complex type TimePeriodPropertyType with content type ELEMENT_ONLY
class TimePeriodPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimePeriodPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TimePeriod uses Python identifier TimePeriod
    __TimePeriod = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TimePeriod'), 'TimePeriod', '__httpwww_opengis_netgml_TimePeriodPropertyType_httpwww_opengis_netgmlTimePeriod', False)

    
    TimePeriod = property(__TimePeriod.value, __TimePeriod.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_TimePeriodPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_TimePeriodPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_TimePeriodPropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_TimePeriodPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_TimePeriodPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_TimePeriodPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_TimePeriodPropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_TimePeriodPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)


    _ElementMap = {
        __TimePeriod.name() : __TimePeriod
    }
    _AttributeMap = {
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __show.name() : __show,
        __remoteSchema.name() : __remoteSchema,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __href.name() : __href
    }
Namespace.addCategoryObject('typeBinding', u'TimePeriodPropertyType', TimePeriodPropertyType)


# Complex type ProjectedCRSRefType with content type ELEMENT_ONLY
class ProjectedCRSRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ProjectedCRSRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}ProjectedCRS uses Python identifier ProjectedCRS
    __ProjectedCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'ProjectedCRS'), 'ProjectedCRS', '__httpwww_opengis_netgml_ProjectedCRSRefType_httpwww_opengis_netgmlProjectedCRS', False)

    
    ProjectedCRS = property(__ProjectedCRS.value, __ProjectedCRS.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_ProjectedCRSRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_ProjectedCRSRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_ProjectedCRSRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_ProjectedCRSRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_ProjectedCRSRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_ProjectedCRSRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_ProjectedCRSRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_ProjectedCRSRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)


    _ElementMap = {
        __ProjectedCRS.name() : __ProjectedCRS
    }
    _AttributeMap = {
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __href.name() : __href,
        __arcrole.name() : __arcrole
    }
Namespace.addCategoryObject('typeBinding', u'ProjectedCRSRefType', ProjectedCRSRefType)


# Complex type OperationParameterGroupBaseType with content type ELEMENT_ONLY
class OperationParameterGroupBaseType (AbstractGeneralOperationParameterType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'OperationParameterGroupBaseType')
    # Base type is AbstractGeneralOperationParameterType
    
    # Element minimumOccurs ({http://www.opengis.net/gml}minimumOccurs) inherited from {http://www.opengis.net/gml}AbstractGeneralOperationParameterType
    
    # Element {http://www.opengis.net/gml}groupName uses Python identifier groupName
    __groupName = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'groupName'), 'groupName', '__httpwww_opengis_netgml_OperationParameterGroupBaseType_httpwww_opengis_netgmlgroupName', False)

    
    groupName = property(__groupName.value, __groupName.set, None, u'The name by which this operation parameter group is identified. ')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id is restricted from parent
    
    # Attribute {http://www.opengis.net/gml}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'id'), 'id', '__httpwww_opengis_netgml_AbstractGMLType_httpwww_opengis_netgmlid', pyxb.binding.datatypes.ID, required=True)
    
    id = property(__id.value, __id.set, None, u'Database handle for the object.  It is of XML type ID, so is constrained to be unique in the XML document within which it occurs.  An external identifier for the object in the form of a URI may be constructed using standard XML and XPointer methods.  This is done by concatenating the URI for the document, a fragment separator, and the value of the id attribute.')


    _ElementMap = AbstractGeneralOperationParameterType._ElementMap.copy()
    _ElementMap.update({
        __groupName.name() : __groupName
    })
    _AttributeMap = AbstractGeneralOperationParameterType._AttributeMap.copy()
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', u'OperationParameterGroupBaseType', OperationParameterGroupBaseType)


# Complex type OperationParameterGroupType with content type ELEMENT_ONLY
class OperationParameterGroupType (OperationParameterGroupBaseType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'OperationParameterGroupType')
    # Base type is OperationParameterGroupBaseType
    
    # Element {http://www.opengis.net/gml}maximumOccurs uses Python identifier maximumOccurs
    __maximumOccurs = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'maximumOccurs'), 'maximumOccurs', '__httpwww_opengis_netgml_OperationParameterGroupType_httpwww_opengis_netgmlmaximumOccurs', False)

    
    maximumOccurs = property(__maximumOccurs.value, __maximumOccurs.set, None, u'The maximum number of times that values for this parameter group can be included. If this attribute is omitted, the maximum number is one. ')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}groupID uses Python identifier groupID
    __groupID = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'groupID'), 'groupID', '__httpwww_opengis_netgml_OperationParameterGroupType_httpwww_opengis_netgmlgroupID', True)

    
    groupID = property(__groupID.value, __groupID.set, None, u'An identification of an operation parameter group. ')

    
    # Element {http://www.opengis.net/gml}includesParameter uses Python identifier includesParameter
    __includesParameter = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'includesParameter'), 'includesParameter', '__httpwww_opengis_netgml_OperationParameterGroupType_httpwww_opengis_netgmlincludesParameter', True)

    
    includesParameter = property(__includesParameter.value, __includesParameter.set, None, u'Association to an operation parameter that is a member of a group. ')

    
    # Element groupName ({http://www.opengis.net/gml}groupName) inherited from {http://www.opengis.net/gml}OperationParameterGroupBaseType
    
    # Element minimumOccurs ({http://www.opengis.net/gml}minimumOccurs) inherited from {http://www.opengis.net/gml}AbstractGeneralOperationParameterType
    
    # Element {http://www.opengis.net/gml}remarks uses Python identifier remarks
    __remarks = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'remarks'), 'remarks', '__httpwww_opengis_netgml_OperationParameterGroupType_httpwww_opengis_netgmlremarks', False)

    
    remarks = property(__remarks.value, __remarks.set, None, u'Information about this object or code. Contains text or refers to external text.')

    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}OperationParameterGroupBaseType

    _ElementMap = OperationParameterGroupBaseType._ElementMap.copy()
    _ElementMap.update({
        __maximumOccurs.name() : __maximumOccurs,
        __groupID.name() : __groupID,
        __includesParameter.name() : __includesParameter,
        __remarks.name() : __remarks
    })
    _AttributeMap = OperationParameterGroupBaseType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'OperationParameterGroupType', OperationParameterGroupType)


# Complex type PointArrayPropertyType with content type ELEMENT_ONLY
class PointArrayPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PointArrayPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Point uses Python identifier Point
    __Point = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Point'), 'Point', '__httpwww_opengis_netgml_PointArrayPropertyType_httpwww_opengis_netgmlPoint', True)

    
    Point = property(__Point.value, __Point.set, None, None)


    _ElementMap = {
        __Point.name() : __Point
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'PointArrayPropertyType', PointArrayPropertyType)


# Complex type EllipsoidalCSType with content type ELEMENT_ONLY
class EllipsoidalCSType (AbstractCoordinateSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'EllipsoidalCSType')
    # Base type is AbstractCoordinateSystemType
    
    # Element usesAxis ({http://www.opengis.net/gml}usesAxis) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element csID ({http://www.opengis.net/gml}csID) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element csName ({http://www.opengis.net/gml}csName) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemBaseType
    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemBaseType

    _ElementMap = AbstractCoordinateSystemType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractCoordinateSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'EllipsoidalCSType', EllipsoidalCSType)


# Complex type SphericalCSRefType with content type ELEMENT_ONLY
class SphericalCSRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SphericalCSRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}SphericalCS uses Python identifier SphericalCS
    __SphericalCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'SphericalCS'), 'SphericalCS', '__httpwww_opengis_netgml_SphericalCSRefType_httpwww_opengis_netgmlSphericalCS', False)

    
    SphericalCS = property(__SphericalCS.value, __SphericalCS.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_SphericalCSRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_SphericalCSRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_SphericalCSRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_SphericalCSRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_SphericalCSRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_SphericalCSRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_SphericalCSRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_SphericalCSRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")


    _ElementMap = {
        __SphericalCS.name() : __SphericalCS
    }
    _AttributeMap = {
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __href.name() : __href,
        __title.name() : __title,
        __show.name() : __show
    }
Namespace.addCategoryObject('typeBinding', u'SphericalCSRefType', SphericalCSRefType)


# Complex type GeographicCRSType with content type ELEMENT_ONLY
class GeographicCRSType (AbstractReferenceSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeographicCRSType')
    # Base type is AbstractReferenceSystemType
    
    # Element srsName ({http://www.opengis.net/gml}srsName) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemBaseType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element validArea ({http://www.opengis.net/gml}validArea) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element {http://www.opengis.net/gml}usesEllipsoidalCS uses Python identifier usesEllipsoidalCS
    __usesEllipsoidalCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesEllipsoidalCS'), 'usesEllipsoidalCS', '__httpwww_opengis_netgml_GeographicCRSType_httpwww_opengis_netgmlusesEllipsoidalCS', False)

    
    usesEllipsoidalCS = property(__usesEllipsoidalCS.value, __usesEllipsoidalCS.set, None, u'Association to the ellipsoidal coordinate system used by this CRS. ')

    
    # Element srsID ({http://www.opengis.net/gml}srsID) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element scope ({http://www.opengis.net/gml}scope) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element {http://www.opengis.net/gml}usesGeodeticDatum uses Python identifier usesGeodeticDatum
    __usesGeodeticDatum = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesGeodeticDatum'), 'usesGeodeticDatum', '__httpwww_opengis_netgml_GeographicCRSType_httpwww_opengis_netgmlusesGeodeticDatum', False)

    
    usesGeodeticDatum = property(__usesGeodeticDatum.value, __usesGeodeticDatum.set, None, u'Association to the geodetic datum used by this CRS. ')

    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractReferenceSystemBaseType

    _ElementMap = AbstractReferenceSystemType._ElementMap.copy()
    _ElementMap.update({
        __usesEllipsoidalCS.name() : __usesEllipsoidalCS,
        __usesGeodeticDatum.name() : __usesGeodeticDatum
    })
    _AttributeMap = AbstractReferenceSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'GeographicCRSType', GeographicCRSType)


# Complex type TimeTopologyComplexPropertyType with content type ELEMENT_ONLY
class TimeTopologyComplexPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeTopologyComplexPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TimeTopologyComplex uses Python identifier TimeTopologyComplex
    __TimeTopologyComplex = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TimeTopologyComplex'), 'TimeTopologyComplex', '__httpwww_opengis_netgml_TimeTopologyComplexPropertyType_httpwww_opengis_netgmlTimeTopologyComplex', False)

    
    TimeTopologyComplex = property(__TimeTopologyComplex.value, __TimeTopologyComplex.set, None, u'This element represents temporal topology complex. It shall be the connected acyclic directed graph composed of time nodes and time edges.')

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_TimeTopologyComplexPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_TimeTopologyComplexPropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_TimeTopologyComplexPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_TimeTopologyComplexPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_TimeTopologyComplexPropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_TimeTopologyComplexPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_TimeTopologyComplexPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_TimeTopologyComplexPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)


    _ElementMap = {
        __TimeTopologyComplex.name() : __TimeTopologyComplex
    }
    _AttributeMap = {
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __show.name() : __show,
        __role.name() : __role,
        __href.name() : __href,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'TimeTopologyComplexPropertyType', TimeTopologyComplexPropertyType)


# Complex type DirectPositionListType with content type SIMPLE
class DirectPositionListType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = doubleList
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DirectPositionListType')
    # Base type is doubleList
    
    # Attribute count uses Python identifier count
    __count = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'count'), 'count', '__httpwww_opengis_netgml_DirectPositionListType_count', pyxb.binding.datatypes.positiveInteger)
    
    count = property(__count.value, __count.set, None, u'"count" allows to specify the number of direct positions in the list. If the attribute count is present then \n\t\t\t\t\t\tthe attribute srsDimension shall be present, too.')

    
    # Attribute uomLabels uses Python identifier uomLabels
    __uomLabels = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'uomLabels'), 'uomLabels', '__httpwww_opengis_netgml_DirectPositionListType_uomLabels', NCNameList)
    
    uomLabels = property(__uomLabels.value, __uomLabels.set, None, u'Ordered list of unit of measure (uom) labels for all the axes of this CRS. The value of the string in the \n\t\t\t\tgml:catalogSymbol should be used for this uom labels, after spaces and forbiddden characters are removed. When the \n\t\t\t\taxisLabels attribute is included, this attribute shall also be included. When the axisLabels attribute is omitted, this attribute \n\t\t\t\tshall also be omitted.')

    
    # Attribute srsDimension uses Python identifier srsDimension
    __srsDimension = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'srsDimension'), 'srsDimension', '__httpwww_opengis_netgml_DirectPositionListType_srsDimension', pyxb.binding.datatypes.positiveInteger)
    
    srsDimension = property(__srsDimension.value, __srsDimension.set, None, u'The "srsDimension" is the length of coordinate sequence (the number of entries in the list). This dimension is \n\t\t\t\tspecified by the coordinate reference system. When the srsName attribute is omitted, this attribute shall be omitted.')

    
    # Attribute axisLabels uses Python identifier axisLabels
    __axisLabels = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'axisLabels'), 'axisLabels', '__httpwww_opengis_netgml_DirectPositionListType_axisLabels', NCNameList)
    
    axisLabels = property(__axisLabels.value, __axisLabels.set, None, u'Ordered list of labels for all the axes of this CRS. The gml:axisAbbrev value should be used for these axis \n\t\t\t\tlabels, after spaces and forbiddden characters are removed. When the srsName attribute is included, this attribute is optional. \n\t\t\t\tWhen the srsName attribute is omitted, this attribute shall also be omitted.')

    
    # Attribute srsName uses Python identifier srsName
    __srsName = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'srsName'), 'srsName', '__httpwww_opengis_netgml_DirectPositionListType_srsName', pyxb.binding.datatypes.anyURI)
    
    srsName = property(__srsName.value, __srsName.set, None, u'In general this reference points to a CRS instance of gml:CoordinateReferenceSystemType \n\t\t\t\t(see coordinateReferenceSystems.xsd). For well known references it is not required that the CRS description exists at the \n\t\t\t\tlocation the URI points to. If no srsName attribute is given, the CRS must be specified as part of the larger context this \n\t\t\t\tgeometry element is part of, e.g. a geometric element like point, curve, etc. It is expected that this attribute will be specified \n\t\t\t\tat the direct position level only in rare cases.')


    _ElementMap = {
        
    }
    _AttributeMap = {
        __count.name() : __count,
        __uomLabels.name() : __uomLabels,
        __srsDimension.name() : __srsDimension,
        __axisLabels.name() : __axisLabels,
        __srsName.name() : __srsName
    }
Namespace.addCategoryObject('typeBinding', u'DirectPositionListType', DirectPositionListType)


# Complex type AbstractStyleType with content type ELEMENT_ONLY
class AbstractStyleType (AbstractGMLType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractStyleType')
    # Base type is AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractGMLType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractGMLType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractStyleType', AbstractStyleType)


# Complex type TimeClockType with content type ELEMENT_ONLY
class TimeClockType (AbstractTimeReferenceSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeClockType')
    # Base type is AbstractTimeReferenceSystemType
    
    # Element {http://www.opengis.net/gml}referenceTime uses Python identifier referenceTime
    __referenceTime = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'referenceTime'), 'referenceTime', '__httpwww_opengis_netgml_TimeClockType_httpwww_opengis_netgmlreferenceTime', False)

    
    referenceTime = property(__referenceTime.value, __referenceTime.set, None, u'time of day associated with the reference event expressed as \n              a time of day in the given clock. The reference time is usually the origin of the clock scale.')

    
    # Element {http://www.opengis.net/gml}utcReference uses Python identifier utcReference
    __utcReference = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'utcReference'), 'utcReference', '__httpwww_opengis_netgml_TimeClockType_httpwww_opengis_netgmlutcReference', False)

    
    utcReference = property(__utcReference.value, __utcReference.set, None, u'24 hour local or UTC time that corresponds to the reference time.')

    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element domainOfValidity ({http://www.opengis.net/gml}domainOfValidity) inherited from {http://www.opengis.net/gml}AbstractTimeReferenceSystemType
    
    # Element {http://www.opengis.net/gml}referenceEvent uses Python identifier referenceEvent
    __referenceEvent = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'referenceEvent'), 'referenceEvent', '__httpwww_opengis_netgml_TimeClockType_httpwww_opengis_netgmlreferenceEvent', False)

    
    referenceEvent = property(__referenceEvent.value, __referenceEvent.set, None, u'Name or description of an event, such as solar noon or sunrise, \n              which fixes the position of the base scale of the clock.')

    
    # Element {http://www.opengis.net/gml}dateBasis uses Python identifier dateBasis
    __dateBasis = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'dateBasis'), 'dateBasis', '__httpwww_opengis_netgml_TimeClockType_httpwww_opengis_netgmldateBasis', True)

    
    dateBasis = property(__dateBasis.value, __dateBasis.set, None, None)

    
    # Attribute id_ inherited from {http://www.opengis.net/gml}DefinitionType

    _ElementMap = AbstractTimeReferenceSystemType._ElementMap.copy()
    _ElementMap.update({
        __referenceTime.name() : __referenceTime,
        __utcReference.name() : __utcReference,
        __referenceEvent.name() : __referenceEvent,
        __dateBasis.name() : __dateBasis
    })
    _AttributeMap = AbstractTimeReferenceSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TimeClockType', TimeClockType)


# Complex type MeasureOrNullListType with content type SIMPLE
class MeasureOrNullListType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = doubleOrNullList
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MeasureOrNullListType')
    # Base type is doubleOrNullList
    
    # Attribute uom uses Python identifier uom
    __uom = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'uom'), 'uom', '__httpwww_opengis_netgml_MeasureOrNullListType_uom', pyxb.binding.datatypes.anyURI, required=True)
    
    uom = property(__uom.value, __uom.set, None, None)


    _ElementMap = {
        
    }
    _AttributeMap = {
        __uom.name() : __uom
    }
Namespace.addCategoryObject('typeBinding', u'MeasureOrNullListType', MeasureOrNullListType)


# Complex type TimeIntervalLengthType with content type SIMPLE
class TimeIntervalLengthType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = pyxb.binding.datatypes.decimal
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeIntervalLengthType')
    # Base type is pyxb.binding.datatypes.decimal
    
    # Attribute radix uses Python identifier radix
    __radix = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'radix'), 'radix', '__httpwww_opengis_netgml_TimeIntervalLengthType_radix', pyxb.binding.datatypes.positiveInteger)
    
    radix = property(__radix.value, __radix.set, None, None)

    
    # Attribute factor uses Python identifier factor
    __factor = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'factor'), 'factor', '__httpwww_opengis_netgml_TimeIntervalLengthType_factor', pyxb.binding.datatypes.integer)
    
    factor = property(__factor.value, __factor.set, None, None)

    
    # Attribute unit uses Python identifier unit
    __unit = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'unit'), 'unit', '__httpwww_opengis_netgml_TimeIntervalLengthType_unit', TimeUnitType, required=True)
    
    unit = property(__unit.value, __unit.set, None, None)


    _ElementMap = {
        
    }
    _AttributeMap = {
        __radix.name() : __radix,
        __factor.name() : __factor,
        __unit.name() : __unit
    }
Namespace.addCategoryObject('typeBinding', u'TimeIntervalLengthType', TimeIntervalLengthType)


# Complex type AssociationType with content type ELEMENT_ONLY
class AssociationType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AssociationType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_Object uses Python identifier Object
    __Object = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_Object'), 'Object', '__httpwww_opengis_netgml_AssociationType_httpwww_opengis_netgml_Object', False)

    
    Object = property(__Object.value, __Object.set, None, u'This abstract element is the head of a substitutionGroup hierararchy which may contain either simpleContent or complexContent elements.  It is used to assert the model position of "class" elements declared in other GML schemas.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_AssociationType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_AssociationType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_AssociationType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_AssociationType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_AssociationType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_AssociationType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_AssociationType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_AssociationType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")


    _ElementMap = {
        __Object.name() : __Object
    }
    _AttributeMap = {
        __arcrole.name() : __arcrole,
        __show.name() : __show,
        __title.name() : __title,
        __remoteSchema.name() : __remoteSchema,
        __type.name() : __type,
        __role.name() : __role,
        __href.name() : __href,
        __actuate.name() : __actuate
    }
Namespace.addCategoryObject('typeBinding', u'AssociationType', AssociationType)


# Complex type IndirectEntryType with content type ELEMENT_ONLY
class IndirectEntryType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'IndirectEntryType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}DefinitionProxy uses Python identifier DefinitionProxy
    __DefinitionProxy = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'DefinitionProxy'), 'DefinitionProxy', '__httpwww_opengis_netgml_IndirectEntryType_httpwww_opengis_netgmlDefinitionProxy', False)

    
    DefinitionProxy = property(__DefinitionProxy.value, __DefinitionProxy.set, None, None)


    _ElementMap = {
        __DefinitionProxy.name() : __DefinitionProxy
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'IndirectEntryType', IndirectEntryType)


# Complex type CompositeValueType with content type ELEMENT_ONLY
class CompositeValueType (AbstractGMLType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CompositeValueType')
    # Base type is AbstractGMLType
    
    # Element {http://www.opengis.net/gml}valueComponents uses Python identifier valueComponents
    __valueComponents = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'valueComponents'), 'valueComponents', '__httpwww_opengis_netgml_CompositeValueType_httpwww_opengis_netgmlvalueComponents', False)

    
    valueComponents = property(__valueComponents.value, __valueComponents.set, None, u'Element which refers to, or contains, a set of homogeneously typed Values.')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}valueComponent uses Python identifier valueComponent
    __valueComponent = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'valueComponent'), 'valueComponent', '__httpwww_opengis_netgml_CompositeValueType_httpwww_opengis_netgmlvalueComponent', True)

    
    valueComponent = property(__valueComponent.value, __valueComponent.set, None, u'Element which refers to, or contains, a Value.  This version is used in CompositeValues.')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractGMLType._ElementMap.copy()
    _ElementMap.update({
        __valueComponents.name() : __valueComponents,
        __valueComponent.name() : __valueComponent
    })
    _AttributeMap = AbstractGMLType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CompositeValueType', CompositeValueType)


# Complex type OperationParameterRefType with content type ELEMENT_ONLY
class OperationParameterRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'OperationParameterRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}OperationParameter uses Python identifier OperationParameter
    __OperationParameter = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'OperationParameter'), 'OperationParameter', '__httpwww_opengis_netgml_OperationParameterRefType_httpwww_opengis_netgmlOperationParameter', False)

    
    OperationParameter = property(__OperationParameter.value, __OperationParameter.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_OperationParameterRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_OperationParameterRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_OperationParameterRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_OperationParameterRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_OperationParameterRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_OperationParameterRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_OperationParameterRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_OperationParameterRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)


    _ElementMap = {
        __OperationParameter.name() : __OperationParameter
    }
    _AttributeMap = {
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __show.name() : __show,
        __remoteSchema.name() : __remoteSchema,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __href.name() : __href
    }
Namespace.addCategoryObject('typeBinding', u'OperationParameterRefType', OperationParameterRefType)


# Complex type GraphStylePropertyType with content type ELEMENT_ONLY
class GraphStylePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GraphStylePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}GraphStyle uses Python identifier GraphStyle
    __GraphStyle = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'GraphStyle'), 'GraphStyle', '__httpwww_opengis_netgml_GraphStylePropertyType_httpwww_opengis_netgmlGraphStyle', False)

    
    GraphStyle = property(__GraphStyle.value, __GraphStyle.set, None, u'The style descriptor for a graph consisting of a number of features. Describes graph-specific style attributes.')

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_GraphStylePropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_GraphStylePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_GraphStylePropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_GraphStylePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_GraphStylePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute about uses Python identifier about
    __about = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'about'), 'about', '__httpwww_opengis_netgml_GraphStylePropertyType_about', pyxb.binding.datatypes.anyURI)
    
    about = property(__about.value, __about.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_GraphStylePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_GraphStylePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_GraphStylePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)


    _ElementMap = {
        __GraphStyle.name() : __GraphStyle
    }
    _AttributeMap = {
        __actuate.name() : __actuate,
        __arcrole.name() : __arcrole,
        __show.name() : __show,
        __role.name() : __role,
        __remoteSchema.name() : __remoteSchema,
        __about.name() : __about,
        __href.name() : __href,
        __type.name() : __type,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'GraphStylePropertyType', GraphStylePropertyType)


# Complex type BSplineType with content type ELEMENT_ONLY
class BSplineType (AbstractCurveSegmentType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'BSplineType')
    # Base type is AbstractCurveSegmentType
    
    # Element {http://www.opengis.net/gml}pointRep uses Python identifier pointRep
    __pointRep = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), 'pointRep', '__httpwww_opengis_netgml_BSplineType_httpwww_opengis_netgmlpointRep', True)

    
    pointRep = property(__pointRep.value, __pointRep.set, None, u'Deprecated with GML version 3.1.0. Use "pointProperty" instead. Included for backwards compatibility with GML 3.0.0.')

    
    # Element {http://www.opengis.net/gml}knot uses Python identifier knot
    __knot = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'knot'), 'knot', '__httpwww_opengis_netgml_BSplineType_httpwww_opengis_netgmlknot', True)

    
    knot = property(__knot.value, __knot.set, None, u'The property "knot" shall be the sequence of distinct knots used to define the spline basis functions.')

    
    # Element {http://www.opengis.net/gml}posList uses Python identifier posList
    __posList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'posList'), 'posList', '__httpwww_opengis_netgml_BSplineType_httpwww_opengis_netgmlposList', False)

    
    posList = property(__posList.value, __posList.set, None, u'')

    
    # Element {http://www.opengis.net/gml}degree uses Python identifier degree
    __degree = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'degree'), 'degree', '__httpwww_opengis_netgml_BSplineType_httpwww_opengis_netgmldegree', False)

    
    degree = property(__degree.value, __degree.set, None, u'The attribute "degree" shall be the degree of the polynomial used for interpolation in this spline.')

    
    # Element {http://www.opengis.net/gml}pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pos'), 'pos', '__httpwww_opengis_netgml_BSplineType_httpwww_opengis_netgmlpos', True)

    
    pos = property(__pos.value, __pos.set, None, u'')

    
    # Element {http://www.opengis.net/gml}coordinates uses Python identifier coordinates
    __coordinates = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), 'coordinates', '__httpwww_opengis_netgml_BSplineType_httpwww_opengis_netgmlcoordinates', False)

    
    coordinates = property(__coordinates.value, __coordinates.set, None, u'Deprecated with GML version 3.1.0.')

    
    # Element {http://www.opengis.net/gml}pointProperty uses Python identifier pointProperty
    __pointProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), 'pointProperty', '__httpwww_opengis_netgml_BSplineType_httpwww_opengis_netgmlpointProperty', True)

    
    pointProperty = property(__pointProperty.value, __pointProperty.set, None, u'This property element either references a point via the XLink-attributes or contains the point element. pointProperty \n\t\t\tis the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that \n\t\t\tis substitutable for Point.')

    
    # Attribute interpolation uses Python identifier interpolation
    __interpolation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'interpolation'), 'interpolation', '__httpwww_opengis_netgml_BSplineType_interpolation', CurveInterpolationType, unicode_default=u'polynomialSpline')
    
    interpolation = property(__interpolation.value, __interpolation.set, None, u'The attribute "interpolation" specifies the curve interpolation mechanism used for this segment. This mechanism\nuses the control points and control parameters to determine the position of this curve segment. For a BSpline the interpolation can be either "polynomialSpline" or "rationalSpline", default is "polynomialSpline".')

    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute isPolynomial uses Python identifier isPolynomial
    __isPolynomial = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'isPolynomial'), 'isPolynomial', '__httpwww_opengis_netgml_BSplineType_isPolynomial', pyxb.binding.datatypes.boolean)
    
    isPolynomial = property(__isPolynomial.value, __isPolynomial.set, None, u'The attribute isPolynomial is set to true if this is a polynomial spline.')

    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute knotType uses Python identifier knotType
    __knotType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'knotType'), 'knotType', '__httpwww_opengis_netgml_BSplineType_knotType', KnotTypesType)
    
    knotType = property(__knotType.value, __knotType.set, None, u'The attribute "knotType" gives the type of knot distribution used in defining this spline. This is for information only\nand is set according to the different construction-functions.')


    _ElementMap = AbstractCurveSegmentType._ElementMap.copy()
    _ElementMap.update({
        __pointRep.name() : __pointRep,
        __knot.name() : __knot,
        __posList.name() : __posList,
        __degree.name() : __degree,
        __pos.name() : __pos,
        __coordinates.name() : __coordinates,
        __pointProperty.name() : __pointProperty
    })
    _AttributeMap = AbstractCurveSegmentType._AttributeMap.copy()
    _AttributeMap.update({
        __interpolation.name() : __interpolation,
        __isPolynomial.name() : __isPolynomial,
        __knotType.name() : __knotType
    })
Namespace.addCategoryObject('typeBinding', u'BSplineType', BSplineType)


# Complex type BezierType with content type ELEMENT_ONLY
class BezierType (BSplineType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'BezierType')
    # Base type is BSplineType
    
    # Element pointRep ({http://www.opengis.net/gml}pointRep) inherited from {http://www.opengis.net/gml}BSplineType
    
    # Element knot ({http://www.opengis.net/gml}knot) inherited from {http://www.opengis.net/gml}BSplineType
    
    # Element posList ({http://www.opengis.net/gml}posList) inherited from {http://www.opengis.net/gml}BSplineType
    
    # Element degree ({http://www.opengis.net/gml}degree) inherited from {http://www.opengis.net/gml}BSplineType
    
    # Element pos ({http://www.opengis.net/gml}pos) inherited from {http://www.opengis.net/gml}BSplineType
    
    # Element coordinates ({http://www.opengis.net/gml}coordinates) inherited from {http://www.opengis.net/gml}BSplineType
    
    # Element pointProperty ({http://www.opengis.net/gml}pointProperty) inherited from {http://www.opengis.net/gml}BSplineType
    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute isPolynomial is restricted from parent
    
    # Attribute isPolynomial uses Python identifier isPolynomial
    __isPolynomial = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'isPolynomial'), 'isPolynomial', '__httpwww_opengis_netgml_BSplineType_isPolynomial', pyxb.binding.datatypes.boolean, fixed=True, unicode_default=u'true')
    
    isPolynomial = property(__isPolynomial.value, __isPolynomial.set, None, u'The attribute isPolynomial is set to true as this is a polynomial spline.')

    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute knotType is restricted from parent
    
    # Attribute knotType uses Python identifier knotType
    __knotType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'knotType'), 'knotType', '__httpwww_opengis_netgml_BSplineType_knotType', KnotTypesType, prohibited=True)
    
    knotType = property()

    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute interpolation is restricted from parent
    
    # Attribute interpolation uses Python identifier interpolation
    __interpolation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'interpolation'), 'interpolation', '__httpwww_opengis_netgml_BSplineType_interpolation', CurveInterpolationType, fixed=True, unicode_default=u'polynomialSpline')
    
    interpolation = property(__interpolation.value, __interpolation.set, None, u'The attribute "interpolation" specifies the curve interpolation mechanism used for this segment. This mechanism\nuses the control points and control parameters to determine the position of this curve segment. For a Bezier the interpolation is fixed as "polynomialSpline".')


    _ElementMap = BSplineType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = BSplineType._AttributeMap.copy()
    _AttributeMap.update({
        __isPolynomial.name() : __isPolynomial,
        __knotType.name() : __knotType,
        __interpolation.name() : __interpolation
    })
Namespace.addCategoryObject('typeBinding', u'BezierType', BezierType)


# Complex type CategoryExtentType with content type SIMPLE
class CategoryExtentType (CodeOrNullListType):
    _TypeDefinition = STD_ANON_18
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CategoryExtentType')
    # Base type is CodeOrNullListType
    
    # Attribute codeSpace inherited from {http://www.opengis.net/gml}CodeOrNullListType

    _ElementMap = CodeOrNullListType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = CodeOrNullListType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CategoryExtentType', CategoryExtentType)


# Complex type TimePositionType with content type SIMPLE
class TimePositionType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = TimePositionUnion
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimePositionType')
    # Base type is TimePositionUnion
    
    # Attribute frame uses Python identifier frame
    __frame = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'frame'), 'frame', '__httpwww_opengis_netgml_TimePositionType_frame', pyxb.binding.datatypes.anyURI, unicode_default=u'#ISO-8601')
    
    frame = property(__frame.value, __frame.set, None, None)

    
    # Attribute calendarEraName uses Python identifier calendarEraName
    __calendarEraName = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'calendarEraName'), 'calendarEraName', '__httpwww_opengis_netgml_TimePositionType_calendarEraName', pyxb.binding.datatypes.string)
    
    calendarEraName = property(__calendarEraName.value, __calendarEraName.set, None, None)

    
    # Attribute indeterminatePosition uses Python identifier indeterminatePosition
    __indeterminatePosition = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'indeterminatePosition'), 'indeterminatePosition', '__httpwww_opengis_netgml_TimePositionType_indeterminatePosition', TimeIndeterminateValueType)
    
    indeterminatePosition = property(__indeterminatePosition.value, __indeterminatePosition.set, None, None)


    _ElementMap = {
        
    }
    _AttributeMap = {
        __frame.name() : __frame,
        __calendarEraName.name() : __calendarEraName,
        __indeterminatePosition.name() : __indeterminatePosition
    }
Namespace.addCategoryObject('typeBinding', u'TimePositionType', TimePositionType)


# Complex type DirectionVectorType with content type ELEMENT_ONLY
class DirectionVectorType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DirectionVectorType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}horizontalAngle uses Python identifier horizontalAngle
    __horizontalAngle = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'horizontalAngle'), 'horizontalAngle', '__httpwww_opengis_netgml_DirectionVectorType_httpwww_opengis_netgmlhorizontalAngle', False)

    
    horizontalAngle = property(__horizontalAngle.value, __horizontalAngle.set, None, None)

    
    # Element {http://www.opengis.net/gml}vector uses Python identifier vector
    __vector = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'vector'), 'vector', '__httpwww_opengis_netgml_DirectionVectorType_httpwww_opengis_netgmlvector', False)

    
    vector = property(__vector.value, __vector.set, None, u'')

    
    # Element {http://www.opengis.net/gml}verticalAngle uses Python identifier verticalAngle
    __verticalAngle = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'verticalAngle'), 'verticalAngle', '__httpwww_opengis_netgml_DirectionVectorType_httpwww_opengis_netgmlverticalAngle', False)

    
    verticalAngle = property(__verticalAngle.value, __verticalAngle.set, None, None)


    _ElementMap = {
        __horizontalAngle.name() : __horizontalAngle,
        __vector.name() : __vector,
        __verticalAngle.name() : __verticalAngle
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'DirectionVectorType', DirectionVectorType)


# Complex type FeatureStylePropertyType with content type ELEMENT_ONLY
class FeatureStylePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'FeatureStylePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}FeatureStyle uses Python identifier FeatureStyle
    __FeatureStyle = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'FeatureStyle'), 'FeatureStyle', '__httpwww_opengis_netgml_FeatureStylePropertyType_httpwww_opengis_netgmlFeatureStyle', False)

    
    FeatureStyle = property(__FeatureStyle.value, __FeatureStyle.set, None, u'The style descriptor for features.')

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_FeatureStylePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_FeatureStylePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_FeatureStylePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute about uses Python identifier about
    __about = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'about'), 'about', '__httpwww_opengis_netgml_FeatureStylePropertyType_about', pyxb.binding.datatypes.anyURI)
    
    about = property(__about.value, __about.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_FeatureStylePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_FeatureStylePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_FeatureStylePropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_FeatureStylePropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_FeatureStylePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)


    _ElementMap = {
        __FeatureStyle.name() : __FeatureStyle
    }
    _AttributeMap = {
        __title.name() : __title,
        __type.name() : __type,
        __remoteSchema.name() : __remoteSchema,
        __about.name() : __about,
        __role.name() : __role,
        __href.name() : __href,
        __actuate.name() : __actuate,
        __show.name() : __show,
        __arcrole.name() : __arcrole
    }
Namespace.addCategoryObject('typeBinding', u'FeatureStylePropertyType', FeatureStylePropertyType)


# Complex type QuantityExtentType with content type SIMPLE
class QuantityExtentType (MeasureOrNullListType):
    _TypeDefinition = STD_ANON_19
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'QuantityExtentType')
    # Base type is MeasureOrNullListType
    
    # Attribute uom inherited from {http://www.opengis.net/gml}MeasureOrNullListType

    _ElementMap = MeasureOrNullListType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = MeasureOrNullListType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'QuantityExtentType', QuantityExtentType)


# Complex type TransformationType with content type ELEMENT_ONLY
class TransformationType (AbstractGeneralTransformationType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TransformationType')
    # Base type is AbstractGeneralTransformationType
    
    # Element positionalAccuracy ({http://www.opengis.net/gml}_positionalAccuracy) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element {http://www.opengis.net/gml}usesMethod uses Python identifier usesMethod
    __usesMethod = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesMethod'), 'usesMethod', '__httpwww_opengis_netgml_TransformationType_httpwww_opengis_netgmlusesMethod', False)

    
    usesMethod = property(__usesMethod.value, __usesMethod.set, None, u'Association to the operation method used by this coordinate operation. ')

    
    # Element coordinateOperationID ({http://www.opengis.net/gml}coordinateOperationID) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element coordinateOperationName ({http://www.opengis.net/gml}coordinateOperationName) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationBaseType
    
    # Element validArea ({http://www.opengis.net/gml}validArea) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element sourceCRS ({http://www.opengis.net/gml}sourceCRS) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element {http://www.opengis.net/gml}usesValue uses Python identifier usesValue
    __usesValue = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesValue'), 'usesValue', '__httpwww_opengis_netgml_TransformationType_httpwww_opengis_netgmlusesValue', True)

    
    usesValue = property(__usesValue.value, __usesValue.set, None, u'Composition association to a parameter value used by this coordinate operation. ')

    
    # Element scope ({http://www.opengis.net/gml}scope) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element targetCRS ({http://www.opengis.net/gml}targetCRS) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element operationVersion ({http://www.opengis.net/gml}operationVersion) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id_3 inherited from {http://www.opengis.net/gml}AbstractGeneralTransformationType

    _ElementMap = AbstractGeneralTransformationType._ElementMap.copy()
    _ElementMap.update({
        __usesMethod.name() : __usesMethod,
        __usesValue.name() : __usesValue
    })
    _AttributeMap = AbstractGeneralTransformationType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TransformationType', TransformationType)


# Complex type AbstractCurveType with content type ELEMENT_ONLY
class AbstractCurveType (AbstractGeometricPrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractCurveType')
    # Base type is AbstractGeometricPrimitiveType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometricPrimitiveType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractGeometricPrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractCurveType', AbstractCurveType)


# Complex type ExtentType with content type ELEMENT_ONLY
class ExtentType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ExtentType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}boundingPolygon uses Python identifier boundingPolygon
    __boundingPolygon = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'boundingPolygon'), 'boundingPolygon', '__httpwww_opengis_netgml_ExtentType_httpwww_opengis_netgmlboundingPolygon', True)

    
    boundingPolygon = property(__boundingPolygon.value, __boundingPolygon.set, None, u'A bounding polygon defining the horizontal spatial domain of this object.')

    
    # Element {http://www.opengis.net/gml}verticalExtent uses Python identifier verticalExtent
    __verticalExtent = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'verticalExtent'), 'verticalExtent', '__httpwww_opengis_netgml_ExtentType_httpwww_opengis_netgmlverticalExtent', True)

    
    verticalExtent = property(__verticalExtent.value, __verticalExtent.set, None, u'An interval defining the vertical spatial domain of this object.')

    
    # Element {http://www.opengis.net/gml}boundingBox uses Python identifier boundingBox
    __boundingBox = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'boundingBox'), 'boundingBox', '__httpwww_opengis_netgml_ExtentType_httpwww_opengis_netgmlboundingBox', True)

    
    boundingBox = property(__boundingBox.value, __boundingBox.set, None, u'A bounding box (or envelope) defining the spatial domain of this object.')

    
    # Element {http://www.opengis.net/gml}description uses Python identifier description
    __description = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'description'), 'description', '__httpwww_opengis_netgml_ExtentType_httpwww_opengis_netgmldescription', False)

    
    description = property(__description.value, __description.set, None, u'Contains a simple text description of the object, or refers to an external description.')

    
    # Element {http://www.opengis.net/gml}temporalExtent uses Python identifier temporalExtent
    __temporalExtent = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'temporalExtent'), 'temporalExtent', '__httpwww_opengis_netgml_ExtentType_httpwww_opengis_netgmltemporalExtent', True)

    
    temporalExtent = property(__temporalExtent.value, __temporalExtent.set, None, u'A time period defining the temporal domain of this object.')


    _ElementMap = {
        __boundingPolygon.name() : __boundingPolygon,
        __verticalExtent.name() : __verticalExtent,
        __boundingBox.name() : __boundingBox,
        __description.name() : __description,
        __temporalExtent.name() : __temporalExtent
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'ExtentType', ExtentType)


# Complex type TransformationRefType with content type ELEMENT_ONLY
class TransformationRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TransformationRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Transformation uses Python identifier Transformation
    __Transformation = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Transformation'), 'Transformation', '__httpwww_opengis_netgml_TransformationRefType_httpwww_opengis_netgmlTransformation', False)

    
    Transformation = property(__Transformation.value, __Transformation.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_TransformationRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_TransformationRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_TransformationRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_TransformationRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_TransformationRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_TransformationRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_TransformationRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_TransformationRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)


    _ElementMap = {
        __Transformation.name() : __Transformation
    }
    _AttributeMap = {
        __title.name() : __title,
        __show.name() : __show,
        __href.name() : __href,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole
    }
Namespace.addCategoryObject('typeBinding', u'TransformationRefType', TransformationRefType)


# Complex type CurveSegmentArrayPropertyType with content type ELEMENT_ONLY
class CurveSegmentArrayPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CurveSegmentArrayPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_CurveSegment uses Python identifier CurveSegment
    __CurveSegment = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_CurveSegment'), 'CurveSegment', '__httpwww_opengis_netgml_CurveSegmentArrayPropertyType_httpwww_opengis_netgml_CurveSegment', True)

    
    CurveSegment = property(__CurveSegment.value, __CurveSegment.set, None, u'The "_CurveSegment" element is the abstract head of the substituition group for all curve segment elements, i.e. continuous segments of the same interpolation mechanism.')


    _ElementMap = {
        __CurveSegment.name() : __CurveSegment
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'CurveSegmentArrayPropertyType', CurveSegmentArrayPropertyType)


# Complex type DirectedNodePropertyType with content type ELEMENT_ONLY
class DirectedNodePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DirectedNodePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Node uses Python identifier Node
    __Node = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Node'), 'Node', '__httpwww_opengis_netgml_DirectedNodePropertyType_httpwww_opengis_netgmlNode', False)

    
    Node = property(__Node.value, __Node.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_DirectedNodePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_DirectedNodePropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_DirectedNodePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_DirectedNodePropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_DirectedNodePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_DirectedNodePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_DirectedNodePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_DirectedNodePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute orientation uses Python identifier orientation
    __orientation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'orientation'), 'orientation', '__httpwww_opengis_netgml_DirectedNodePropertyType_orientation', SignType, unicode_default=u'+')
    
    orientation = property(__orientation.value, __orientation.set, None, None)


    _ElementMap = {
        __Node.name() : __Node
    }
    _AttributeMap = {
        __type.name() : __type,
        __actuate.name() : __actuate,
        __role.name() : __role,
        __show.name() : __show,
        __arcrole.name() : __arcrole,
        __href.name() : __href,
        __title.name() : __title,
        __remoteSchema.name() : __remoteSchema,
        __orientation.name() : __orientation
    }
Namespace.addCategoryObject('typeBinding', u'DirectedNodePropertyType', DirectedNodePropertyType)


# Complex type CompositeSolidType with content type ELEMENT_ONLY
class CompositeSolidType (AbstractSolidType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CompositeSolidType')
    # Base type is AbstractSolidType
    
    # Element {http://www.opengis.net/gml}solidMember uses Python identifier solidMember
    __solidMember = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'solidMember'), 'solidMember', '__httpwww_opengis_netgml_CompositeSolidType_httpwww_opengis_netgmlsolidMember', True)

    
    solidMember = property(__solidMember.value, __solidMember.set, None, u'This property element either references a solid via the XLink-attributes or contains the solid element. A solid element is any element which is substitutable for "_Solid".')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractSolidType._ElementMap.copy()
    _ElementMap.update({
        __solidMember.name() : __solidMember
    })
    _AttributeMap = AbstractSolidType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CompositeSolidType', CompositeSolidType)


# Complex type ValuePropertyType with content type ELEMENT_ONLY
class ValuePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ValuePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}CompositeValue uses Python identifier CompositeValue
    __CompositeValue = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CompositeValue'), 'CompositeValue', '__httpwww_opengis_netgml_ValuePropertyType_httpwww_opengis_netgmlCompositeValue', False)

    
    CompositeValue = property(__CompositeValue.value, __CompositeValue.set, None, u'Aggregate value built using the Composite pattern.')

    
    # Element {http://www.opengis.net/gml}BooleanList uses Python identifier BooleanList
    __BooleanList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'BooleanList'), 'BooleanList', '__httpwww_opengis_netgml_ValuePropertyType_httpwww_opengis_netgmlBooleanList', False)

    
    BooleanList = property(__BooleanList.value, __BooleanList.set, None, u'XML List based on XML Schema boolean type.  An element of this type contains a space-separated list of boolean values {0,1,true,false}')

    
    # Element {http://www.opengis.net/gml}CountList uses Python identifier CountList
    __CountList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CountList'), 'CountList', '__httpwww_opengis_netgml_ValuePropertyType_httpwww_opengis_netgmlCountList', False)

    
    CountList = property(__CountList.value, __CountList.set, None, u'A space-separated list of integers or nulls.')

    
    # Element {http://www.opengis.net/gml}Quantity uses Python identifier Quantity
    __Quantity = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Quantity'), 'Quantity', '__httpwww_opengis_netgml_ValuePropertyType_httpwww_opengis_netgmlQuantity', False)

    
    Quantity = property(__Quantity.value, __Quantity.set, None, u'A numeric value with a scale.  The content of the element is an amount using the XML Schema type double which permits decimal or scientific notation.  An XML attribute uom (unit of measure) is required, whose value is a URI which identifies the definition of the scale or units by which the numeric value must be multiplied.')

    
    # Element {http://www.opengis.net/gml}Boolean uses Python identifier Boolean
    __Boolean = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Boolean'), 'Boolean', '__httpwww_opengis_netgml_ValuePropertyType_httpwww_opengis_netgmlBoolean', False)

    
    Boolean = property(__Boolean.value, __Boolean.set, None, u'A value from two-valued logic, using the XML Schema boolean type.  An instance may take the values {true, false, 1, 0}.')

    
    # Element {http://www.opengis.net/gml}CategoryList uses Python identifier CategoryList
    __CategoryList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CategoryList'), 'CategoryList', '__httpwww_opengis_netgml_ValuePropertyType_httpwww_opengis_netgmlCategoryList', False)

    
    CategoryList = property(__CategoryList.value, __CategoryList.set, None, u'A space-separated list of terms or nulls.  A single XML attribute codeSpace may be provided, which authorises all the terms in the list.')

    
    # Element {http://www.opengis.net/gml}Count uses Python identifier Count
    __Count = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Count'), 'Count', '__httpwww_opengis_netgml_ValuePropertyType_httpwww_opengis_netgmlCount', False)

    
    Count = property(__Count.value, __Count.set, None, u'An integer representing a frequency of occurrence.')

    
    # Element {http://www.opengis.net/gml}CountExtent uses Python identifier CountExtent
    __CountExtent = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CountExtent'), 'CountExtent', '__httpwww_opengis_netgml_ValuePropertyType_httpwww_opengis_netgmlCountExtent', False)

    
    CountExtent = property(__CountExtent.value, __CountExtent.set, None, u'Utility element to store a 2-point range of frequency values. If one member is a null, then this is a single ended interval.')

    
    # Element {http://www.opengis.net/gml}_Object uses Python identifier Object
    __Object = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_Object'), 'Object', '__httpwww_opengis_netgml_ValuePropertyType_httpwww_opengis_netgml_Object', False)

    
    Object = property(__Object.value, __Object.set, None, u'This abstract element is the head of a substitutionGroup hierararchy which may contain either simpleContent or complexContent elements.  It is used to assert the model position of "class" elements declared in other GML schemas.')

    
    # Element {http://www.opengis.net/gml}Category uses Python identifier Category
    __Category = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Category'), 'Category', '__httpwww_opengis_netgml_ValuePropertyType_httpwww_opengis_netgmlCategory', False)

    
    Category = property(__Category.value, __Category.set, None, u'A term representing a classification.  It has an optional XML attribute codeSpace, whose value is a URI which identifies a dictionary, codelist or authority for the term.')

    
    # Element {http://www.opengis.net/gml}CategoryExtent uses Python identifier CategoryExtent
    __CategoryExtent = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CategoryExtent'), 'CategoryExtent', '__httpwww_opengis_netgml_ValuePropertyType_httpwww_opengis_netgmlCategoryExtent', False)

    
    CategoryExtent = property(__CategoryExtent.value, __CategoryExtent.set, None, u'Utility element to store a 2-point range of ordinal values. If one member is a null, then this is a single ended interval.')

    
    # Element {http://www.opengis.net/gml}QuantityList uses Python identifier QuantityList
    __QuantityList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'QuantityList'), 'QuantityList', '__httpwww_opengis_netgml_ValuePropertyType_httpwww_opengis_netgmlQuantityList', False)

    
    QuantityList = property(__QuantityList.value, __QuantityList.set, None, u'A space separated list of amounts or nulls.  The amounts use the XML Schema type double.  A single XML attribute uom (unit of measure) is required, whose value is a URI which identifies the definition of the scale or units by which all the amounts in the list must be multiplied.')

    
    # Element {http://www.opengis.net/gml}Null uses Python identifier Null
    __Null = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Null'), 'Null', '__httpwww_opengis_netgml_ValuePropertyType_httpwww_opengis_netgmlNull', False)

    
    Null = property(__Null.value, __Null.set, None, None)

    
    # Element {http://www.opengis.net/gml}QuantityExtent uses Python identifier QuantityExtent
    __QuantityExtent = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'QuantityExtent'), 'QuantityExtent', '__httpwww_opengis_netgml_ValuePropertyType_httpwww_opengis_netgmlQuantityExtent', False)

    
    QuantityExtent = property(__QuantityExtent.value, __QuantityExtent.set, None, u'Utility element to store a 2-point range of numeric values. If one member is a null, then this is a single ended interval.')

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_ValuePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_ValuePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_ValuePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_ValuePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_ValuePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_ValuePropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_ValuePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_ValuePropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")


    _ElementMap = {
        __CompositeValue.name() : __CompositeValue,
        __BooleanList.name() : __BooleanList,
        __CountList.name() : __CountList,
        __Quantity.name() : __Quantity,
        __Boolean.name() : __Boolean,
        __CategoryList.name() : __CategoryList,
        __Count.name() : __Count,
        __CountExtent.name() : __CountExtent,
        __Object.name() : __Object,
        __Category.name() : __Category,
        __CategoryExtent.name() : __CategoryExtent,
        __QuantityList.name() : __QuantityList,
        __Null.name() : __Null,
        __QuantityExtent.name() : __QuantityExtent
    }
    _AttributeMap = {
        __role.name() : __role,
        __remoteSchema.name() : __remoteSchema,
        __type.name() : __type,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __actuate.name() : __actuate,
        __href.name() : __href,
        __show.name() : __show
    }
Namespace.addCategoryObject('typeBinding', u'ValuePropertyType', ValuePropertyType)


# Complex type BooleanPropertyType with content type ELEMENT_ONLY
class BooleanPropertyType (ValuePropertyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'BooleanPropertyType')
    # Base type is ValuePropertyType
    
    # Element Boolean ({http://www.opengis.net/gml}Boolean) inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute role inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute remoteSchema inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute type inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute arcrole inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute title inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute actuate inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute href inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute show inherited from {http://www.opengis.net/gml}ValuePropertyType

    _ElementMap = ValuePropertyType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = ValuePropertyType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'BooleanPropertyType', BooleanPropertyType)


# Complex type TimeEdgePropertyType with content type ELEMENT_ONLY
class TimeEdgePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeEdgePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TimeEdge uses Python identifier TimeEdge
    __TimeEdge = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TimeEdge'), 'TimeEdge', '__httpwww_opengis_netgml_TimeEdgePropertyType_httpwww_opengis_netgmlTimeEdge', False)

    
    TimeEdge = property(__TimeEdge.value, __TimeEdge.set, None, u'TimeEdge is one dimensional temporal topology primitive,\n\t\t\t expresses a state in topological time. It has an orientation from its start toward the end, \n\t\t\t and its boundaries shall associate with two different time nodes.')

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_TimeEdgePropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_TimeEdgePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_TimeEdgePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_TimeEdgePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_TimeEdgePropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_TimeEdgePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_TimeEdgePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_TimeEdgePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')


    _ElementMap = {
        __TimeEdge.name() : __TimeEdge
    }
    _AttributeMap = {
        __actuate.name() : __actuate,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role,
        __remoteSchema.name() : __remoteSchema
    }
Namespace.addCategoryObject('typeBinding', u'TimeEdgePropertyType', TimeEdgePropertyType)


# Complex type AbstractSurfacePatchType with content type EMPTY
class AbstractSurfacePatchType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractSurfacePatchType')
    # Base type is pyxb.binding.datatypes.anyType

    _ElementMap = {
        
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'AbstractSurfacePatchType', AbstractSurfacePatchType)


# Complex type ContainerPropertyType with content type ELEMENT_ONLY
class ContainerPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ContainerPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TopoSolid uses Python identifier TopoSolid
    __TopoSolid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TopoSolid'), 'TopoSolid', '__httpwww_opengis_netgml_ContainerPropertyType_httpwww_opengis_netgmlTopoSolid', False)

    
    TopoSolid = property(__TopoSolid.value, __TopoSolid.set, None, None)

    
    # Element {http://www.opengis.net/gml}Face uses Python identifier Face
    __Face = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Face'), 'Face', '__httpwww_opengis_netgml_ContainerPropertyType_httpwww_opengis_netgmlFace', False)

    
    Face = property(__Face.value, __Face.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_ContainerPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_ContainerPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_ContainerPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_ContainerPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_ContainerPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_ContainerPropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_ContainerPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_ContainerPropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")


    _ElementMap = {
        __TopoSolid.name() : __TopoSolid,
        __Face.name() : __Face
    }
    _AttributeMap = {
        __href.name() : __href,
        __title.name() : __title,
        __type.name() : __type,
        __role.name() : __role,
        __remoteSchema.name() : __remoteSchema,
        __show.name() : __show,
        __arcrole.name() : __arcrole,
        __actuate.name() : __actuate
    }
Namespace.addCategoryObject('typeBinding', u'ContainerPropertyType', ContainerPropertyType)


# Complex type CategoryPropertyType with content type ELEMENT_ONLY
class CategoryPropertyType (ValuePropertyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CategoryPropertyType')
    # Base type is ValuePropertyType
    
    # Element Category ({http://www.opengis.net/gml}Category) inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute role inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute remoteSchema inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute type inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute arcrole inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute title inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute actuate inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute href inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute show inherited from {http://www.opengis.net/gml}ValuePropertyType

    _ElementMap = ValuePropertyType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = ValuePropertyType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CategoryPropertyType', CategoryPropertyType)


# Complex type AbstractMetaDataType with content type MIXED
class AbstractMetaDataType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_MIXED
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractMetaDataType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute {http://www.opengis.net/gml}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'id'), 'id', '__httpwww_opengis_netgml_AbstractMetaDataType_httpwww_opengis_netgmlid', pyxb.binding.datatypes.ID)
    
    id = property(__id.value, __id.set, None, u'Database handle for the object.  It is of XML type ID, so is constrained to be unique in the XML document within which it occurs.  An external identifier for the object in the form of a URI may be constructed using standard XML and XPointer methods.  This is done by concatenating the URI for the document, a fragment separator, and the value of the id attribute.')


    _ElementMap = {
        
    }
    _AttributeMap = {
        __id.name() : __id
    }
Namespace.addCategoryObject('typeBinding', u'AbstractMetaDataType', AbstractMetaDataType)


# Complex type GenericMetaDataType with content type MIXED
class GenericMetaDataType (AbstractMetaDataType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_MIXED
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GenericMetaDataType')
    # Base type is AbstractMetaDataType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractMetaDataType
    _HasWildcardElement = True

    _ElementMap = AbstractMetaDataType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractMetaDataType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'GenericMetaDataType', GenericMetaDataType)


# Complex type NodeType with content type ELEMENT_ONLY
class NodeType (AbstractTopoPrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'NodeType')
    # Base type is AbstractTopoPrimitiveType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}directedEdge uses Python identifier directedEdge
    __directedEdge = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'), 'directedEdge', '__httpwww_opengis_netgml_NodeType_httpwww_opengis_netgmldirectedEdge', True)

    
    directedEdge = property(__directedEdge.value, __directedEdge.set, None, u'')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element container ({http://www.opengis.net/gml}container) inherited from {http://www.opengis.net/gml}AbstractTopoPrimitiveType
    
    # Element isolated ({http://www.opengis.net/gml}isolated) inherited from {http://www.opengis.net/gml}AbstractTopoPrimitiveType
    
    # Element {http://www.opengis.net/gml}pointProperty uses Python identifier pointProperty
    __pointProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), 'pointProperty', '__httpwww_opengis_netgml_NodeType_httpwww_opengis_netgmlpointProperty', False)

    
    pointProperty = property(__pointProperty.value, __pointProperty.set, None, u'This property element either references a point via the XLink-attributes or contains the point element. pointProperty \n\t\t\tis the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that \n\t\t\tis substitutable for Point.')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTopoPrimitiveType._ElementMap.copy()
    _ElementMap.update({
        __directedEdge.name() : __directedEdge,
        __pointProperty.name() : __pointProperty
    })
    _AttributeMap = AbstractTopoPrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'NodeType', NodeType)


# Complex type DatumRefType with content type ELEMENT_ONLY
class DatumRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DatumRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_Datum uses Python identifier Datum
    __Datum = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_Datum'), 'Datum', '__httpwww_opengis_netgml_DatumRefType_httpwww_opengis_netgml_Datum', False)

    
    Datum = property(__Datum.value, __Datum.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_DatumRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_DatumRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_DatumRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_DatumRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_DatumRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_DatumRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_DatumRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_DatumRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')


    _ElementMap = {
        __Datum.name() : __Datum
    }
    _AttributeMap = {
        __actuate.name() : __actuate,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role,
        __remoteSchema.name() : __remoteSchema
    }
Namespace.addCategoryObject('typeBinding', u'DatumRefType', DatumRefType)


# Complex type QuantityPropertyType with content type ELEMENT_ONLY
class QuantityPropertyType (ValuePropertyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'QuantityPropertyType')
    # Base type is ValuePropertyType
    
    # Element Quantity ({http://www.opengis.net/gml}Quantity) inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute role inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute remoteSchema inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute type inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute arcrole inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute title inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute actuate inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute href inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute show inherited from {http://www.opengis.net/gml}ValuePropertyType

    _ElementMap = ValuePropertyType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = ValuePropertyType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'QuantityPropertyType', QuantityPropertyType)


# Complex type MultiPolygonType with content type ELEMENT_ONLY
class MultiPolygonType (AbstractGeometricAggregateType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiPolygonType')
    # Base type is AbstractGeometricAggregateType
    
    # Element {http://www.opengis.net/gml}polygonMember uses Python identifier polygonMember
    __polygonMember = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'polygonMember'), 'polygonMember', '__httpwww_opengis_netgml_MultiPolygonType_httpwww_opengis_netgmlpolygonMember', True)

    
    polygonMember = property(__polygonMember.value, __polygonMember.set, None, u'Deprecated with GML 3.0 and included only for backwards compatibility with GML 2.0. Use "surfaceMember" instead.\nThis property element either references a polygon via the XLink-attributes or contains the polygon element.')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometricAggregateType._ElementMap.copy()
    _ElementMap.update({
        __polygonMember.name() : __polygonMember
    })
    _AttributeMap = AbstractGeometricAggregateType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MultiPolygonType', MultiPolygonType)


# Complex type CountPropertyType with content type ELEMENT_ONLY
class CountPropertyType (ValuePropertyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CountPropertyType')
    # Base type is ValuePropertyType
    
    # Element Count ({http://www.opengis.net/gml}Count) inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute role inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute remoteSchema inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute type inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute arcrole inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute title inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute actuate inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute href inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute show inherited from {http://www.opengis.net/gml}ValuePropertyType

    _ElementMap = ValuePropertyType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = ValuePropertyType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CountPropertyType', CountPropertyType)


# Complex type PolygonPropertyType with content type ELEMENT_ONLY
class PolygonPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PolygonPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Polygon uses Python identifier Polygon
    __Polygon = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Polygon'), 'Polygon', '__httpwww_opengis_netgml_PolygonPropertyType_httpwww_opengis_netgmlPolygon', False)

    
    Polygon = property(__Polygon.value, __Polygon.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_PolygonPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_PolygonPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_PolygonPropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_PolygonPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_PolygonPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_PolygonPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_PolygonPropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_PolygonPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)


    _ElementMap = {
        __Polygon.name() : __Polygon
    }
    _AttributeMap = {
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __show.name() : __show,
        __href.name() : __href
    }
Namespace.addCategoryObject('typeBinding', u'PolygonPropertyType', PolygonPropertyType)


# Complex type GeneralTransformationRefType with content type ELEMENT_ONLY
class GeneralTransformationRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeneralTransformationRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_GeneralTransformation uses Python identifier GeneralTransformation
    __GeneralTransformation = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_GeneralTransformation'), 'GeneralTransformation', '__httpwww_opengis_netgml_GeneralTransformationRefType_httpwww_opengis_netgml_GeneralTransformation', False)

    
    GeneralTransformation = property(__GeneralTransformation.value, __GeneralTransformation.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_GeneralTransformationRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_GeneralTransformationRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_GeneralTransformationRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_GeneralTransformationRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_GeneralTransformationRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_GeneralTransformationRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_GeneralTransformationRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_GeneralTransformationRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')


    _ElementMap = {
        __GeneralTransformation.name() : __GeneralTransformation
    }
    _AttributeMap = {
        __actuate.name() : __actuate,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role,
        __remoteSchema.name() : __remoteSchema
    }
Namespace.addCategoryObject('typeBinding', u'GeneralTransformationRefType', GeneralTransformationRefType)


# Complex type UserDefinedCSRefType with content type ELEMENT_ONLY
class UserDefinedCSRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'UserDefinedCSRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}UserDefinedCS uses Python identifier UserDefinedCS
    __UserDefinedCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'UserDefinedCS'), 'UserDefinedCS', '__httpwww_opengis_netgml_UserDefinedCSRefType_httpwww_opengis_netgmlUserDefinedCS', False)

    
    UserDefinedCS = property(__UserDefinedCS.value, __UserDefinedCS.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_UserDefinedCSRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_UserDefinedCSRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_UserDefinedCSRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_UserDefinedCSRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_UserDefinedCSRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_UserDefinedCSRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_UserDefinedCSRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_UserDefinedCSRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)


    _ElementMap = {
        __UserDefinedCS.name() : __UserDefinedCS
    }
    _AttributeMap = {
        __href.name() : __href,
        __type.name() : __type,
        __actuate.name() : __actuate,
        __role.name() : __role,
        __remoteSchema.name() : __remoteSchema,
        __show.name() : __show,
        __arcrole.name() : __arcrole,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'UserDefinedCSRefType', UserDefinedCSRefType)


# Complex type ImageDatumType with content type ELEMENT_ONLY
class ImageDatumType (AbstractDatumType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ImageDatumType')
    # Base type is AbstractDatumType
    
    # Element {http://www.opengis.net/gml}pixelInCell uses Python identifier pixelInCell
    __pixelInCell = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pixelInCell'), 'pixelInCell', '__httpwww_opengis_netgml_ImageDatumType_httpwww_opengis_netgmlpixelInCell', False)

    
    pixelInCell = property(__pixelInCell.value, __pixelInCell.set, None, None)

    
    # Element datumName ({http://www.opengis.net/gml}datumName) inherited from {http://www.opengis.net/gml}AbstractDatumBaseType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element scope ({http://www.opengis.net/gml}scope) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element datumID ({http://www.opengis.net/gml}datumID) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element realizationEpoch ({http://www.opengis.net/gml}realizationEpoch) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element validArea ({http://www.opengis.net/gml}validArea) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element anchorPoint ({http://www.opengis.net/gml}anchorPoint) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractDatumBaseType

    _ElementMap = AbstractDatumType._ElementMap.copy()
    _ElementMap.update({
        __pixelInCell.name() : __pixelInCell
    })
    _AttributeMap = AbstractDatumType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ImageDatumType', ImageDatumType)


# Complex type OperationMethodBaseType with content type ELEMENT_ONLY
class OperationMethodBaseType (DefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'OperationMethodBaseType')
    # Base type is DefinitionType
    
    # Element {http://www.opengis.net/gml}methodName uses Python identifier methodName
    __methodName = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'methodName'), 'methodName', '__httpwww_opengis_netgml_OperationMethodBaseType_httpwww_opengis_netgmlmethodName', False)

    
    methodName = property(__methodName.value, __methodName.set, None, u'The name by which this operation method is identified. ')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id is restricted from parent
    
    # Attribute {http://www.opengis.net/gml}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'id'), 'id', '__httpwww_opengis_netgml_AbstractGMLType_httpwww_opengis_netgmlid', pyxb.binding.datatypes.ID, required=True)
    
    id = property(__id.value, __id.set, None, u'Database handle for the object.  It is of XML type ID, so is constrained to be unique in the XML document within which it occurs.  An external identifier for the object in the form of a URI may be constructed using standard XML and XPointer methods.  This is done by concatenating the URI for the document, a fragment separator, and the value of the id attribute.')


    _ElementMap = DefinitionType._ElementMap.copy()
    _ElementMap.update({
        __methodName.name() : __methodName
    })
    _AttributeMap = DefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', u'OperationMethodBaseType', OperationMethodBaseType)


# Complex type OperationMethodType with content type ELEMENT_ONLY
class OperationMethodType (OperationMethodBaseType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'OperationMethodType')
    # Base type is OperationMethodBaseType
    
    # Element {http://www.opengis.net/gml}remarks uses Python identifier remarks
    __remarks = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'remarks'), 'remarks', '__httpwww_opengis_netgml_OperationMethodType_httpwww_opengis_netgmlremarks', False)

    
    remarks = property(__remarks.value, __remarks.set, None, u'Information about this object or code. Contains text or refers to external text.')

    
    # Element {http://www.opengis.net/gml}targetDimensions uses Python identifier targetDimensions
    __targetDimensions = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'targetDimensions'), 'targetDimensions', '__httpwww_opengis_netgml_OperationMethodType_httpwww_opengis_netgmltargetDimensions', False)

    
    targetDimensions = property(__targetDimensions.value, __targetDimensions.set, None, u'Number of dimensions in the target CRS of this operation method. ')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element methodName ({http://www.opengis.net/gml}methodName) inherited from {http://www.opengis.net/gml}OperationMethodBaseType
    
    # Element {http://www.opengis.net/gml}methodFormula uses Python identifier methodFormula
    __methodFormula = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'methodFormula'), 'methodFormula', '__httpwww_opengis_netgml_OperationMethodType_httpwww_opengis_netgmlmethodFormula', False)

    
    methodFormula = property(__methodFormula.value, __methodFormula.set, None, u'Formula(s) used by this operation method. The value may be a reference to a publication. Note that the operation method may not be analytic, in which case this element references or contains the procedure, not an analytic formula.')

    
    # Element {http://www.opengis.net/gml}usesParameter uses Python identifier usesParameter
    __usesParameter = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesParameter'), 'usesParameter', '__httpwww_opengis_netgml_OperationMethodType_httpwww_opengis_netgmlusesParameter', True)

    
    usesParameter = property(__usesParameter.value, __usesParameter.set, None, u'Association to an operation parameter or parameter group used by this operation method. ')

    
    # Element {http://www.opengis.net/gml}methodID uses Python identifier methodID
    __methodID = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'methodID'), 'methodID', '__httpwww_opengis_netgml_OperationMethodType_httpwww_opengis_netgmlmethodID', True)

    
    methodID = property(__methodID.value, __methodID.set, None, u'An identification of an operation method. ')

    
    # Element {http://www.opengis.net/gml}sourceDimensions uses Python identifier sourceDimensions
    __sourceDimensions = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'sourceDimensions'), 'sourceDimensions', '__httpwww_opengis_netgml_OperationMethodType_httpwww_opengis_netgmlsourceDimensions', False)

    
    sourceDimensions = property(__sourceDimensions.value, __sourceDimensions.set, None, u'Number of dimensions in the source CRS of this operation method. ')

    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}OperationMethodBaseType

    _ElementMap = OperationMethodBaseType._ElementMap.copy()
    _ElementMap.update({
        __remarks.name() : __remarks,
        __targetDimensions.name() : __targetDimensions,
        __methodFormula.name() : __methodFormula,
        __usesParameter.name() : __usesParameter,
        __methodID.name() : __methodID,
        __sourceDimensions.name() : __sourceDimensions
    })
    _AttributeMap = OperationMethodBaseType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'OperationMethodType', OperationMethodType)


# Complex type CoordinateOperationRefType with content type ELEMENT_ONLY
class CoordinateOperationRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CoordinateOperationRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_CoordinateOperation uses Python identifier CoordinateOperation
    __CoordinateOperation = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_CoordinateOperation'), 'CoordinateOperation', '__httpwww_opengis_netgml_CoordinateOperationRefType_httpwww_opengis_netgml_CoordinateOperation', False)

    
    CoordinateOperation = property(__CoordinateOperation.value, __CoordinateOperation.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_CoordinateOperationRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_CoordinateOperationRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_CoordinateOperationRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_CoordinateOperationRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_CoordinateOperationRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_CoordinateOperationRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_CoordinateOperationRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_CoordinateOperationRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)


    _ElementMap = {
        __CoordinateOperation.name() : __CoordinateOperation
    }
    _AttributeMap = {
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __show.name() : __show,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __href.name() : __href,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'CoordinateOperationRefType', CoordinateOperationRefType)


# Complex type GridType with content type ELEMENT_ONLY
class GridType (AbstractGeometryType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GridType')
    # Base type is AbstractGeometryType
    
    # Element {http://www.opengis.net/gml}axisName uses Python identifier axisName
    __axisName = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'axisName'), 'axisName', '__httpwww_opengis_netgml_GridType_httpwww_opengis_netgmlaxisName', True)

    
    axisName = property(__axisName.value, __axisName.set, None, None)

    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}limits uses Python identifier limits
    __limits = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'limits'), 'limits', '__httpwww_opengis_netgml_GridType_httpwww_opengis_netgmllimits', False)

    
    limits = property(__limits.value, __limits.set, None, None)

    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute dimension uses Python identifier dimension
    __dimension = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'dimension'), 'dimension', '__httpwww_opengis_netgml_GridType_dimension', pyxb.binding.datatypes.positiveInteger, required=True)
    
    dimension = property(__dimension.value, __dimension.set, None, None)

    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometryType._ElementMap.copy()
    _ElementMap.update({
        __axisName.name() : __axisName,
        __limits.name() : __limits
    })
    _AttributeMap = AbstractGeometryType._AttributeMap.copy()
    _AttributeMap.update({
        __dimension.name() : __dimension
    })
Namespace.addCategoryObject('typeBinding', u'GridType', GridType)


# Complex type CoordinateReferenceSystemRefType with content type ELEMENT_ONLY
class CoordinateReferenceSystemRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CoordinateReferenceSystemRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_CoordinateReferenceSystem uses Python identifier CoordinateReferenceSystem
    __CoordinateReferenceSystem = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_CoordinateReferenceSystem'), 'CoordinateReferenceSystem', '__httpwww_opengis_netgml_CoordinateReferenceSystemRefType_httpwww_opengis_netgml_CoordinateReferenceSystem', False)

    
    CoordinateReferenceSystem = property(__CoordinateReferenceSystem.value, __CoordinateReferenceSystem.set, None, u'A coordinate reference system consists of an ordered sequence of coordinate system axes that are related to the earth through a datum. A coordinate reference system is defined by one datum and by one coordinate system. Most coordinate reference system do not move relative to the earth, except for engineering coordinate reference systems defined on moving platforms such as cars, ships, aircraft, and spacecraft. For further information, see OGC Abstract Specification Topic 2.\n\nCoordinate reference systems are commonly divided into sub-types. The common classification criterion for sub-typing of coordinate reference systems is the way in which they deal with earth curvature. This has a direct effect on the portion of the earth\'s surface that can be covered by that type of CRS with an acceptable degree of error. The exception to the rule is the subtype "Temporal" which has been added by analogy. ')

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_CoordinateReferenceSystemRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_CoordinateReferenceSystemRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_CoordinateReferenceSystemRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_CoordinateReferenceSystemRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_CoordinateReferenceSystemRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_CoordinateReferenceSystemRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_CoordinateReferenceSystemRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_CoordinateReferenceSystemRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)


    _ElementMap = {
        __CoordinateReferenceSystem.name() : __CoordinateReferenceSystem
    }
    _AttributeMap = {
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'CoordinateReferenceSystemRefType', CoordinateReferenceSystemRefType)


# Complex type EngineeringCRSType with content type ELEMENT_ONLY
class EngineeringCRSType (AbstractReferenceSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'EngineeringCRSType')
    # Base type is AbstractReferenceSystemType
    
    # Element srsName ({http://www.opengis.net/gml}srsName) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemBaseType
    
    # Element srsID ({http://www.opengis.net/gml}srsID) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element validArea ({http://www.opengis.net/gml}validArea) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element {http://www.opengis.net/gml}usesCS uses Python identifier usesCS
    __usesCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesCS'), 'usesCS', '__httpwww_opengis_netgml_EngineeringCRSType_httpwww_opengis_netgmlusesCS', False)

    
    usesCS = property(__usesCS.value, __usesCS.set, None, u'Association to the coordinate system used by this CRS. ')

    
    # Element scope ({http://www.opengis.net/gml}scope) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}usesEngineeringDatum uses Python identifier usesEngineeringDatum
    __usesEngineeringDatum = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesEngineeringDatum'), 'usesEngineeringDatum', '__httpwww_opengis_netgml_EngineeringCRSType_httpwww_opengis_netgmlusesEngineeringDatum', False)

    
    usesEngineeringDatum = property(__usesEngineeringDatum.value, __usesEngineeringDatum.set, None, u'Association to the engineering datum used by this CRS. ')

    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractReferenceSystemBaseType

    _ElementMap = AbstractReferenceSystemType._ElementMap.copy()
    _ElementMap.update({
        __usesCS.name() : __usesCS,
        __usesEngineeringDatum.name() : __usesEngineeringDatum
    })
    _AttributeMap = AbstractReferenceSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'EngineeringCRSType', EngineeringCRSType)


# Complex type VerticalCRSType with content type ELEMENT_ONLY
class VerticalCRSType (AbstractReferenceSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VerticalCRSType')
    # Base type is AbstractReferenceSystemType
    
    # Element srsName ({http://www.opengis.net/gml}srsName) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemBaseType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element validArea ({http://www.opengis.net/gml}validArea) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element srsID ({http://www.opengis.net/gml}srsID) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element {http://www.opengis.net/gml}usesVerticalDatum uses Python identifier usesVerticalDatum
    __usesVerticalDatum = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesVerticalDatum'), 'usesVerticalDatum', '__httpwww_opengis_netgml_VerticalCRSType_httpwww_opengis_netgmlusesVerticalDatum', False)

    
    usesVerticalDatum = property(__usesVerticalDatum.value, __usesVerticalDatum.set, None, u'Association to the vertical datum used by this CRS. ')

    
    # Element {http://www.opengis.net/gml}usesVerticalCS uses Python identifier usesVerticalCS
    __usesVerticalCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesVerticalCS'), 'usesVerticalCS', '__httpwww_opengis_netgml_VerticalCRSType_httpwww_opengis_netgmlusesVerticalCS', False)

    
    usesVerticalCS = property(__usesVerticalCS.value, __usesVerticalCS.set, None, u'Association to the vertical coordinate system used by this CRS. ')

    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element scope ({http://www.opengis.net/gml}scope) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractReferenceSystemBaseType

    _ElementMap = AbstractReferenceSystemType._ElementMap.copy()
    _ElementMap.update({
        __usesVerticalDatum.name() : __usesVerticalDatum,
        __usesVerticalCS.name() : __usesVerticalCS
    })
    _AttributeMap = AbstractReferenceSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'VerticalCRSType', VerticalCRSType)


# Complex type AbstractTimeSliceType with content type ELEMENT_ONLY
class AbstractTimeSliceType (AbstractGMLType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeSliceType')
    # Base type is AbstractGMLType
    
    # Element {http://www.opengis.net/gml}validTime uses Python identifier validTime
    __validTime = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'validTime'), 'validTime', '__httpwww_opengis_netgml_AbstractTimeSliceType_httpwww_opengis_netgmlvalidTime', False)

    
    validTime = property(__validTime.value, __validTime.set, None, None)

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}dataSource uses Python identifier dataSource
    __dataSource = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'dataSource'), 'dataSource', '__httpwww_opengis_netgml_AbstractTimeSliceType_httpwww_opengis_netgmldataSource', False)

    
    dataSource = property(__dataSource.value, __dataSource.set, None, None)

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractGMLType._ElementMap.copy()
    _ElementMap.update({
        __validTime.name() : __validTime,
        __dataSource.name() : __dataSource
    })
    _AttributeMap = AbstractGMLType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractTimeSliceType', AbstractTimeSliceType)


# Complex type TopoCurveType with content type ELEMENT_ONLY
class TopoCurveType (AbstractTopologyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopoCurveType')
    # Base type is AbstractTopologyType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}directedEdge uses Python identifier directedEdge
    __directedEdge = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'), 'directedEdge', '__httpwww_opengis_netgml_TopoCurveType_httpwww_opengis_netgmldirectedEdge', True)

    
    directedEdge = property(__directedEdge.value, __directedEdge.set, None, u'')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTopologyType._ElementMap.copy()
    _ElementMap.update({
        __directedEdge.name() : __directedEdge
    })
    _AttributeMap = AbstractTopologyType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TopoCurveType', TopoCurveType)


# Complex type GridFunctionType with content type ELEMENT_ONLY
class GridFunctionType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GridFunctionType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}sequenceRule uses Python identifier sequenceRule
    __sequenceRule = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'sequenceRule'), 'sequenceRule', '__httpwww_opengis_netgml_GridFunctionType_httpwww_opengis_netgmlsequenceRule', False)

    
    sequenceRule = property(__sequenceRule.value, __sequenceRule.set, None, u'If absent, the implied value is "Linear".')

    
    # Element {http://www.opengis.net/gml}startPoint uses Python identifier startPoint
    __startPoint = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'startPoint'), 'startPoint', '__httpwww_opengis_netgml_GridFunctionType_httpwww_opengis_netgmlstartPoint', False)

    
    startPoint = property(__startPoint.value, __startPoint.set, None, u'Index position of the first grid post, which must lie somwhere in the GridEnvelope.  If absent, the startPoint is equal to the value of gridEnvelope::low from the grid definition.')


    _ElementMap = {
        __sequenceRule.name() : __sequenceRule,
        __startPoint.name() : __startPoint
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'GridFunctionType', GridFunctionType)


# Complex type ValueArrayPropertyType with content type ELEMENT_ONLY
class ValueArrayPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ValueArrayPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}QuantityExtent uses Python identifier QuantityExtent
    __QuantityExtent = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'QuantityExtent'), 'QuantityExtent', '__httpwww_opengis_netgml_ValueArrayPropertyType_httpwww_opengis_netgmlQuantityExtent', True)

    
    QuantityExtent = property(__QuantityExtent.value, __QuantityExtent.set, None, u'Utility element to store a 2-point range of numeric values. If one member is a null, then this is a single ended interval.')

    
    # Element {http://www.opengis.net/gml}Boolean uses Python identifier Boolean
    __Boolean = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Boolean'), 'Boolean', '__httpwww_opengis_netgml_ValueArrayPropertyType_httpwww_opengis_netgmlBoolean', True)

    
    Boolean = property(__Boolean.value, __Boolean.set, None, u'A value from two-valued logic, using the XML Schema boolean type.  An instance may take the values {true, false, 1, 0}.')

    
    # Element {http://www.opengis.net/gml}CountList uses Python identifier CountList
    __CountList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CountList'), 'CountList', '__httpwww_opengis_netgml_ValueArrayPropertyType_httpwww_opengis_netgmlCountList', True)

    
    CountList = property(__CountList.value, __CountList.set, None, u'A space-separated list of integers or nulls.')

    
    # Element {http://www.opengis.net/gml}CategoryList uses Python identifier CategoryList
    __CategoryList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CategoryList'), 'CategoryList', '__httpwww_opengis_netgml_ValueArrayPropertyType_httpwww_opengis_netgmlCategoryList', True)

    
    CategoryList = property(__CategoryList.value, __CategoryList.set, None, u'A space-separated list of terms or nulls.  A single XML attribute codeSpace may be provided, which authorises all the terms in the list.')

    
    # Element {http://www.opengis.net/gml}_Object uses Python identifier Object
    __Object = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_Object'), 'Object', '__httpwww_opengis_netgml_ValueArrayPropertyType_httpwww_opengis_netgml_Object', True)

    
    Object = property(__Object.value, __Object.set, None, u'This abstract element is the head of a substitutionGroup hierararchy which may contain either simpleContent or complexContent elements.  It is used to assert the model position of "class" elements declared in other GML schemas.')

    
    # Element {http://www.opengis.net/gml}CountExtent uses Python identifier CountExtent
    __CountExtent = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CountExtent'), 'CountExtent', '__httpwww_opengis_netgml_ValueArrayPropertyType_httpwww_opengis_netgmlCountExtent', True)

    
    CountExtent = property(__CountExtent.value, __CountExtent.set, None, u'Utility element to store a 2-point range of frequency values. If one member is a null, then this is a single ended interval.')

    
    # Element {http://www.opengis.net/gml}Null uses Python identifier Null
    __Null = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Null'), 'Null', '__httpwww_opengis_netgml_ValueArrayPropertyType_httpwww_opengis_netgmlNull', True)

    
    Null = property(__Null.value, __Null.set, None, None)

    
    # Element {http://www.opengis.net/gml}Category uses Python identifier Category
    __Category = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Category'), 'Category', '__httpwww_opengis_netgml_ValueArrayPropertyType_httpwww_opengis_netgmlCategory', True)

    
    Category = property(__Category.value, __Category.set, None, u'A term representing a classification.  It has an optional XML attribute codeSpace, whose value is a URI which identifies a dictionary, codelist or authority for the term.')

    
    # Element {http://www.opengis.net/gml}CompositeValue uses Python identifier CompositeValue
    __CompositeValue = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CompositeValue'), 'CompositeValue', '__httpwww_opengis_netgml_ValueArrayPropertyType_httpwww_opengis_netgmlCompositeValue', True)

    
    CompositeValue = property(__CompositeValue.value, __CompositeValue.set, None, u'Aggregate value built using the Composite pattern.')

    
    # Element {http://www.opengis.net/gml}Count uses Python identifier Count
    __Count = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Count'), 'Count', '__httpwww_opengis_netgml_ValueArrayPropertyType_httpwww_opengis_netgmlCount', True)

    
    Count = property(__Count.value, __Count.set, None, u'An integer representing a frequency of occurrence.')

    
    # Element {http://www.opengis.net/gml}QuantityList uses Python identifier QuantityList
    __QuantityList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'QuantityList'), 'QuantityList', '__httpwww_opengis_netgml_ValueArrayPropertyType_httpwww_opengis_netgmlQuantityList', True)

    
    QuantityList = property(__QuantityList.value, __QuantityList.set, None, u'A space separated list of amounts or nulls.  The amounts use the XML Schema type double.  A single XML attribute uom (unit of measure) is required, whose value is a URI which identifies the definition of the scale or units by which all the amounts in the list must be multiplied.')

    
    # Element {http://www.opengis.net/gml}CategoryExtent uses Python identifier CategoryExtent
    __CategoryExtent = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CategoryExtent'), 'CategoryExtent', '__httpwww_opengis_netgml_ValueArrayPropertyType_httpwww_opengis_netgmlCategoryExtent', True)

    
    CategoryExtent = property(__CategoryExtent.value, __CategoryExtent.set, None, u'Utility element to store a 2-point range of ordinal values. If one member is a null, then this is a single ended interval.')

    
    # Element {http://www.opengis.net/gml}BooleanList uses Python identifier BooleanList
    __BooleanList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'BooleanList'), 'BooleanList', '__httpwww_opengis_netgml_ValueArrayPropertyType_httpwww_opengis_netgmlBooleanList', True)

    
    BooleanList = property(__BooleanList.value, __BooleanList.set, None, u'XML List based on XML Schema boolean type.  An element of this type contains a space-separated list of boolean values {0,1,true,false}')

    
    # Element {http://www.opengis.net/gml}Quantity uses Python identifier Quantity
    __Quantity = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Quantity'), 'Quantity', '__httpwww_opengis_netgml_ValueArrayPropertyType_httpwww_opengis_netgmlQuantity', True)

    
    Quantity = property(__Quantity.value, __Quantity.set, None, u'A numeric value with a scale.  The content of the element is an amount using the XML Schema type double which permits decimal or scientific notation.  An XML attribute uom (unit of measure) is required, whose value is a URI which identifies the definition of the scale or units by which the numeric value must be multiplied.')


    _ElementMap = {
        __QuantityExtent.name() : __QuantityExtent,
        __Boolean.name() : __Boolean,
        __CountList.name() : __CountList,
        __CategoryList.name() : __CategoryList,
        __Object.name() : __Object,
        __CountExtent.name() : __CountExtent,
        __Null.name() : __Null,
        __Category.name() : __Category,
        __CompositeValue.name() : __CompositeValue,
        __Count.name() : __Count,
        __QuantityList.name() : __QuantityList,
        __CategoryExtent.name() : __CategoryExtent,
        __BooleanList.name() : __BooleanList,
        __Quantity.name() : __Quantity
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'ValueArrayPropertyType', ValueArrayPropertyType)


# Complex type MultiSolidDomainType with content type ELEMENT_ONLY
class MultiSolidDomainType (DomainSetType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiSolidDomainType')
    # Base type is DomainSetType
    
    # Element {http://www.opengis.net/gml}MultiSolid uses Python identifier MultiSolid
    __MultiSolid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'MultiSolid'), 'MultiSolid', '__httpwww_opengis_netgml_MultiSolidDomainType_httpwww_opengis_netgmlMultiSolid', False)

    
    MultiSolid = property(__MultiSolid.value, __MultiSolid.set, None, None)

    
    # Attribute title is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute show is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute type is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute role is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute actuate is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute remoteSchema is restricted from parent
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_DomainSetType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute href is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute arcrole is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)


    _ElementMap = DomainSetType._ElementMap.copy()
    _ElementMap.update({
        __MultiSolid.name() : __MultiSolid
    })
    _AttributeMap = DomainSetType._AttributeMap.copy()
    _AttributeMap.update({
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __href.name() : __href,
        __arcrole.name() : __arcrole
    })
Namespace.addCategoryObject('typeBinding', u'MultiSolidDomainType', MultiSolidDomainType)


# Complex type RectifiedGridDomainType with content type ELEMENT_ONLY
class RectifiedGridDomainType (DomainSetType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'RectifiedGridDomainType')
    # Base type is DomainSetType
    
    # Element {http://www.opengis.net/gml}RectifiedGrid uses Python identifier RectifiedGrid
    __RectifiedGrid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'RectifiedGrid'), 'RectifiedGrid', '__httpwww_opengis_netgml_RectifiedGridDomainType_httpwww_opengis_netgmlRectifiedGrid', False)

    
    RectifiedGrid = property(__RectifiedGrid.value, __RectifiedGrid.set, None, u'Should be substitutionGroup="gml:Grid" but changed in order to accomplish Xerces-J schema validation')

    
    # Attribute remoteSchema is restricted from parent
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_DomainSetType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute arcrole is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute href is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute title is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute show is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute type is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute role is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute actuate is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")


    _ElementMap = DomainSetType._ElementMap.copy()
    _ElementMap.update({
        __RectifiedGrid.name() : __RectifiedGrid
    })
    _AttributeMap = DomainSetType._AttributeMap.copy()
    _AttributeMap.update({
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __href.name() : __href,
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate
    })
Namespace.addCategoryObject('typeBinding', u'RectifiedGridDomainType', RectifiedGridDomainType)


# Complex type ImageCRSType with content type ELEMENT_ONLY
class ImageCRSType (AbstractReferenceSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ImageCRSType')
    # Base type is AbstractReferenceSystemType
    
    # Element srsName ({http://www.opengis.net/gml}srsName) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemBaseType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element validArea ({http://www.opengis.net/gml}validArea) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element {http://www.opengis.net/gml}usesImageDatum uses Python identifier usesImageDatum
    __usesImageDatum = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesImageDatum'), 'usesImageDatum', '__httpwww_opengis_netgml_ImageCRSType_httpwww_opengis_netgmlusesImageDatum', False)

    
    usesImageDatum = property(__usesImageDatum.value, __usesImageDatum.set, None, u'Association to the image datum used by this CRS. ')

    
    # Element srsID ({http://www.opengis.net/gml}srsID) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element scope ({http://www.opengis.net/gml}scope) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element {http://www.opengis.net/gml}usesCartesianCS uses Python identifier usesCartesianCS
    __usesCartesianCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesCartesianCS'), 'usesCartesianCS', '__httpwww_opengis_netgml_ImageCRSType_httpwww_opengis_netgmlusesCartesianCS', False)

    
    usesCartesianCS = property(__usesCartesianCS.value, __usesCartesianCS.set, None, u'Association to the Cartesian coordinate system used by this CRS. ')

    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element {http://www.opengis.net/gml}usesObliqueCartesianCS uses Python identifier usesObliqueCartesianCS
    __usesObliqueCartesianCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesObliqueCartesianCS'), 'usesObliqueCartesianCS', '__httpwww_opengis_netgml_ImageCRSType_httpwww_opengis_netgmlusesObliqueCartesianCS', False)

    
    usesObliqueCartesianCS = property(__usesObliqueCartesianCS.value, __usesObliqueCartesianCS.set, None, u'Association to the oblique Cartesian coordinate system used by this CRS.')

    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractReferenceSystemBaseType

    _ElementMap = AbstractReferenceSystemType._ElementMap.copy()
    _ElementMap.update({
        __usesImageDatum.name() : __usesImageDatum,
        __usesCartesianCS.name() : __usesCartesianCS,
        __usesObliqueCartesianCS.name() : __usesObliqueCartesianCS
    })
    _AttributeMap = AbstractReferenceSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ImageCRSType', ImageCRSType)


# Complex type RectifiedGridType with content type ELEMENT_ONLY
class RectifiedGridType (GridType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'RectifiedGridType')
    # Base type is GridType
    
    # Element limits ({http://www.opengis.net/gml}limits) inherited from {http://www.opengis.net/gml}GridType
    
    # Element {http://www.opengis.net/gml}origin uses Python identifier origin
    __origin = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'origin'), 'origin', '__httpwww_opengis_netgml_RectifiedGridType_httpwww_opengis_netgmlorigin', False)

    
    origin = property(__origin.value, __origin.set, None, None)

    
    # Element axisName ({http://www.opengis.net/gml}axisName) inherited from {http://www.opengis.net/gml}GridType
    
    # Element {http://www.opengis.net/gml}offsetVector uses Python identifier offsetVector
    __offsetVector = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'offsetVector'), 'offsetVector', '__httpwww_opengis_netgml_RectifiedGridType_httpwww_opengis_netgmloffsetVector', True)

    
    offsetVector = property(__offsetVector.value, __offsetVector.set, None, None)

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute dimension inherited from {http://www.opengis.net/gml}GridType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = GridType._ElementMap.copy()
    _ElementMap.update({
        __origin.name() : __origin,
        __offsetVector.name() : __offsetVector
    })
    _AttributeMap = GridType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'RectifiedGridType', RectifiedGridType)


# Complex type TimeCalendarPropertyType with content type ELEMENT_ONLY
class TimeCalendarPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeCalendarPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TimeCalendar uses Python identifier TimeCalendar
    __TimeCalendar = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TimeCalendar'), 'TimeCalendar', '__httpwww_opengis_netgml_TimeCalendarPropertyType_httpwww_opengis_netgmlTimeCalendar', False)

    
    TimeCalendar = property(__TimeCalendar.value, __TimeCalendar.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_TimeCalendarPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_TimeCalendarPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_TimeCalendarPropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_TimeCalendarPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_TimeCalendarPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_TimeCalendarPropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_TimeCalendarPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_TimeCalendarPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)


    _ElementMap = {
        __TimeCalendar.name() : __TimeCalendar
    }
    _AttributeMap = {
        __href.name() : __href,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role
    }
Namespace.addCategoryObject('typeBinding', u'TimeCalendarPropertyType', TimeCalendarPropertyType)


# Complex type TimeClockPropertyType with content type ELEMENT_ONLY
class TimeClockPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeClockPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TimeClock uses Python identifier TimeClock
    __TimeClock = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TimeClock'), 'TimeClock', '__httpwww_opengis_netgml_TimeClockPropertyType_httpwww_opengis_netgmlTimeClock', False)

    
    TimeClock = property(__TimeClock.value, __TimeClock.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_TimeClockPropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_TimeClockPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_TimeClockPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_TimeClockPropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_TimeClockPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_TimeClockPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_TimeClockPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_TimeClockPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)


    _ElementMap = {
        __TimeClock.name() : __TimeClock
    }
    _AttributeMap = {
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __href.name() : __href,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'TimeClockPropertyType', TimeClockPropertyType)


# Complex type DirectedFacePropertyType with content type ELEMENT_ONLY
class DirectedFacePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DirectedFacePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Face uses Python identifier Face
    __Face = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Face'), 'Face', '__httpwww_opengis_netgml_DirectedFacePropertyType_httpwww_opengis_netgmlFace', False)

    
    Face = property(__Face.value, __Face.set, None, None)

    
    # Attribute orientation uses Python identifier orientation
    __orientation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'orientation'), 'orientation', '__httpwww_opengis_netgml_DirectedFacePropertyType_orientation', SignType, unicode_default=u'+')
    
    orientation = property(__orientation.value, __orientation.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_DirectedFacePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_DirectedFacePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_DirectedFacePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_DirectedFacePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_DirectedFacePropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_DirectedFacePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_DirectedFacePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_DirectedFacePropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")


    _ElementMap = {
        __Face.name() : __Face
    }
    _AttributeMap = {
        __orientation.name() : __orientation,
        __href.name() : __href,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate
    }
Namespace.addCategoryObject('typeBinding', u'DirectedFacePropertyType', DirectedFacePropertyType)


# Complex type UserDefinedCSType with content type ELEMENT_ONLY
class UserDefinedCSType (AbstractCoordinateSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'UserDefinedCSType')
    # Base type is AbstractCoordinateSystemType
    
    # Element usesAxis ({http://www.opengis.net/gml}usesAxis) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element csID ({http://www.opengis.net/gml}csID) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element csName ({http://www.opengis.net/gml}csName) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemBaseType
    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemBaseType

    _ElementMap = AbstractCoordinateSystemType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractCoordinateSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'UserDefinedCSType', UserDefinedCSType)


# Complex type EllipsoidRefType with content type ELEMENT_ONLY
class EllipsoidRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'EllipsoidRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Ellipsoid uses Python identifier Ellipsoid
    __Ellipsoid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Ellipsoid'), 'Ellipsoid', '__httpwww_opengis_netgml_EllipsoidRefType_httpwww_opengis_netgmlEllipsoid', False)

    
    Ellipsoid = property(__Ellipsoid.value, __Ellipsoid.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_EllipsoidRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_EllipsoidRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_EllipsoidRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_EllipsoidRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_EllipsoidRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_EllipsoidRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_EllipsoidRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_EllipsoidRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")


    _ElementMap = {
        __Ellipsoid.name() : __Ellipsoid
    }
    _AttributeMap = {
        __type.name() : __type,
        __role.name() : __role,
        __arcrole.name() : __arcrole,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __href.name() : __href,
        __title.name() : __title,
        __show.name() : __show
    }
Namespace.addCategoryObject('typeBinding', u'EllipsoidRefType', EllipsoidRefType)


# Complex type CurveType with content type ELEMENT_ONLY
class CurveType (AbstractCurveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CurveType')
    # Base type is AbstractCurveType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}segments uses Python identifier segments
    __segments = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'segments'), 'segments', '__httpwww_opengis_netgml_CurveType_httpwww_opengis_netgmlsegments', False)

    
    segments = property(__segments.value, __segments.set, None, u'This property element contains a list of curve segments. The order of the elements is significant and shall be preserved when processing the array.')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractCurveType._ElementMap.copy()
    _ElementMap.update({
        __segments.name() : __segments
    })
    _AttributeMap = AbstractCurveType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CurveType', CurveType)


# Complex type LinearCSType with content type ELEMENT_ONLY
class LinearCSType (AbstractCoordinateSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LinearCSType')
    # Base type is AbstractCoordinateSystemType
    
    # Element usesAxis ({http://www.opengis.net/gml}usesAxis) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element csID ({http://www.opengis.net/gml}csID) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element csName ({http://www.opengis.net/gml}csName) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemBaseType
    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemBaseType

    _ElementMap = AbstractCoordinateSystemType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractCoordinateSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'LinearCSType', LinearCSType)


# Complex type SymbolType with content type ELEMENT_ONLY
class SymbolType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SymbolType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_SymbolType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute about uses Python identifier about
    __about = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'about'), 'about', '__httpwww_opengis_netgml_SymbolType_about', pyxb.binding.datatypes.anyURI)
    
    about = property(__about.value, __about.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_SymbolType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_SymbolType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_SymbolType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_SymbolType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_SymbolType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_SymbolType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute symbolType uses Python identifier symbolType
    __symbolType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbolType'), 'symbolType', '__httpwww_opengis_netgml_SymbolType_symbolType', SymbolTypeEnumeration, required=True)
    
    symbolType = property(__symbolType.value, __symbolType.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_SymbolType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}transform uses Python identifier transform
    __transform = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'transform'), 'transform', '__httpwww_opengis_netgml_SymbolType_httpwww_opengis_netgmltransform', pyxb.binding.datatypes.string)
    
    transform = property(__transform.value, __transform.set, None, u'Defines the geometric transformation of entities. There is no particular grammar defined for this value.')

    _HasWildcardElement = True

    _ElementMap = {
        
    }
    _AttributeMap = {
        __show.name() : __show,
        __about.name() : __about,
        __actuate.name() : __actuate,
        __role.name() : __role,
        __type.name() : __type,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __remoteSchema.name() : __remoteSchema,
        __symbolType.name() : __symbolType,
        __title.name() : __title,
        __transform.name() : __transform
    }
Namespace.addCategoryObject('typeBinding', u'SymbolType', SymbolType)


# Complex type MultiSurfaceDomainType with content type ELEMENT_ONLY
class MultiSurfaceDomainType (DomainSetType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiSurfaceDomainType')
    # Base type is DomainSetType
    
    # Element {http://www.opengis.net/gml}MultiSurface uses Python identifier MultiSurface
    __MultiSurface = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'MultiSurface'), 'MultiSurface', '__httpwww_opengis_netgml_MultiSurfaceDomainType_httpwww_opengis_netgmlMultiSurface', False)

    
    MultiSurface = property(__MultiSurface.value, __MultiSurface.set, None, None)

    
    # Attribute arcrole is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute show is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute title is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute remoteSchema is restricted from parent
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_DomainSetType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute type is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute href is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute role is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute actuate is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")


    _ElementMap = DomainSetType._ElementMap.copy()
    _ElementMap.update({
        __MultiSurface.name() : __MultiSurface
    })
    _AttributeMap = DomainSetType._AttributeMap.copy()
    _AttributeMap.update({
        __arcrole.name() : __arcrole,
        __show.name() : __show,
        __title.name() : __title,
        __remoteSchema.name() : __remoteSchema,
        __type.name() : __type,
        __href.name() : __href,
        __role.name() : __role,
        __actuate.name() : __actuate
    })
Namespace.addCategoryObject('typeBinding', u'MultiSurfaceDomainType', MultiSurfaceDomainType)


# Complex type AbstractParametricCurveSurfaceType with content type EMPTY
class AbstractParametricCurveSurfaceType (AbstractSurfacePatchType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractParametricCurveSurfaceType')
    # Base type is AbstractSurfacePatchType

    _ElementMap = AbstractSurfacePatchType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractSurfacePatchType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractParametricCurveSurfaceType', AbstractParametricCurveSurfaceType)


# Complex type AbstractGriddedSurfaceType with content type ELEMENT_ONLY
class AbstractGriddedSurfaceType (AbstractParametricCurveSurfaceType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractGriddedSurfaceType')
    # Base type is AbstractParametricCurveSurfaceType
    
    # Element {http://www.opengis.net/gml}row uses Python identifier row
    __row = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'row'), 'row', '__httpwww_opengis_netgml_AbstractGriddedSurfaceType_httpwww_opengis_netgmlrow', True)

    
    row = property(__row.value, __row.set, None, None)

    
    # Element {http://www.opengis.net/gml}columns uses Python identifier columns
    __columns = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'columns'), 'columns', '__httpwww_opengis_netgml_AbstractGriddedSurfaceType_httpwww_opengis_netgmlcolumns', False)

    
    columns = property(__columns.value, __columns.set, None, u'The attribute columns gives the number\n        of columns in the parameter grid.')

    
    # Element {http://www.opengis.net/gml}rows uses Python identifier rows
    __rows = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'rows'), 'rows', '__httpwww_opengis_netgml_AbstractGriddedSurfaceType_httpwww_opengis_netgmlrows', False)

    
    rows = property(__rows.value, __rows.set, None, u'The attribute rows gives the number\n         of rows in the parameter grid.')


    _ElementMap = AbstractParametricCurveSurfaceType._ElementMap.copy()
    _ElementMap.update({
        __row.name() : __row,
        __columns.name() : __columns,
        __rows.name() : __rows
    })
    _AttributeMap = AbstractParametricCurveSurfaceType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractGriddedSurfaceType', AbstractGriddedSurfaceType)


# Complex type SphereType with content type ELEMENT_ONLY
class SphereType (AbstractGriddedSurfaceType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SphereType')
    # Base type is AbstractGriddedSurfaceType
    
    # Element row ({http://www.opengis.net/gml}row) inherited from {http://www.opengis.net/gml}AbstractGriddedSurfaceType
    
    # Element columns ({http://www.opengis.net/gml}columns) inherited from {http://www.opengis.net/gml}AbstractGriddedSurfaceType
    
    # Element rows ({http://www.opengis.net/gml}rows) inherited from {http://www.opengis.net/gml}AbstractGriddedSurfaceType
    
    # Attribute horizontalCurveType uses Python identifier horizontalCurveType
    __horizontalCurveType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'horizontalCurveType'), 'horizontalCurveType', '__httpwww_opengis_netgml_SphereType_horizontalCurveType', CurveInterpolationType, fixed=True, unicode_default=u'circularArc3Points')
    
    horizontalCurveType = property(__horizontalCurveType.value, __horizontalCurveType.set, None, None)

    
    # Attribute verticalCurveType uses Python identifier verticalCurveType
    __verticalCurveType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'verticalCurveType'), 'verticalCurveType', '__httpwww_opengis_netgml_SphereType_verticalCurveType', CurveInterpolationType, fixed=True, unicode_default=u'circularArc3Points')
    
    verticalCurveType = property(__verticalCurveType.value, __verticalCurveType.set, None, None)


    _ElementMap = AbstractGriddedSurfaceType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractGriddedSurfaceType._AttributeMap.copy()
    _AttributeMap.update({
        __horizontalCurveType.name() : __horizontalCurveType,
        __verticalCurveType.name() : __verticalCurveType
    })
Namespace.addCategoryObject('typeBinding', u'SphereType', SphereType)


# Complex type SurfaceArrayPropertyType with content type ELEMENT_ONLY
class SurfaceArrayPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SurfaceArrayPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_Surface uses Python identifier Surface
    __Surface = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_Surface'), 'Surface', '__httpwww_opengis_netgml_SurfaceArrayPropertyType_httpwww_opengis_netgml_Surface', True)

    
    Surface = property(__Surface.value, __Surface.set, None, u'The "_Surface" element is the abstract head of the substituition group for all (continuous) surface elements.')


    _ElementMap = {
        __Surface.name() : __Surface
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'SurfaceArrayPropertyType', SurfaceArrayPropertyType)


# Complex type SphericalCSType with content type ELEMENT_ONLY
class SphericalCSType (AbstractCoordinateSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SphericalCSType')
    # Base type is AbstractCoordinateSystemType
    
    # Element usesAxis ({http://www.opengis.net/gml}usesAxis) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element csID ({http://www.opengis.net/gml}csID) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element csName ({http://www.opengis.net/gml}csName) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemBaseType
    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemBaseType

    _ElementMap = AbstractCoordinateSystemType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractCoordinateSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SphericalCSType', SphericalCSType)


# Complex type FeatureStyleType with content type ELEMENT_ONLY
class FeatureStyleType (AbstractGMLType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'FeatureStyleType')
    # Base type is AbstractGMLType
    
    # Element {http://www.opengis.net/gml}topologyStyle uses Python identifier topologyStyle
    __topologyStyle = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'topologyStyle'), 'topologyStyle', '__httpwww_opengis_netgml_FeatureStyleType_httpwww_opengis_netgmltopologyStyle', True)

    
    topologyStyle = property(__topologyStyle.value, __topologyStyle.set, None, u'')

    
    # Element {http://www.opengis.net/gml}featureConstraint uses Python identifier featureConstraint
    __featureConstraint = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'featureConstraint'), 'featureConstraint', '__httpwww_opengis_netgml_FeatureStyleType_httpwww_opengis_netgmlfeatureConstraint', False)

    
    featureConstraint = property(__featureConstraint.value, __featureConstraint.set, None, None)

    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}labelStyle uses Python identifier labelStyle
    __labelStyle = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'labelStyle'), 'labelStyle', '__httpwww_opengis_netgml_FeatureStyleType_httpwww_opengis_netgmllabelStyle', False)

    
    labelStyle = property(__labelStyle.value, __labelStyle.set, None, u'')

    
    # Element {http://www.opengis.net/gml}geometryStyle uses Python identifier geometryStyle
    __geometryStyle = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'geometryStyle'), 'geometryStyle', '__httpwww_opengis_netgml_FeatureStyleType_httpwww_opengis_netgmlgeometryStyle', True)

    
    geometryStyle = property(__geometryStyle.value, __geometryStyle.set, None, u'')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute featureType uses Python identifier featureType
    __featureType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'featureType'), 'featureType', '__httpwww_opengis_netgml_FeatureStyleType_featureType', pyxb.binding.datatypes.string)
    
    featureType = property(__featureType.value, __featureType.set, None, None)

    
    # Attribute queryGrammar uses Python identifier queryGrammar
    __queryGrammar = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'queryGrammar'), 'queryGrammar', '__httpwww_opengis_netgml_FeatureStyleType_queryGrammar', QueryGrammarEnumeration)
    
    queryGrammar = property(__queryGrammar.value, __queryGrammar.set, None, None)

    
    # Attribute baseType uses Python identifier baseType
    __baseType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'baseType'), 'baseType', '__httpwww_opengis_netgml_FeatureStyleType_baseType', pyxb.binding.datatypes.string)
    
    baseType = property(__baseType.value, __baseType.set, None, None)


    _ElementMap = AbstractGMLType._ElementMap.copy()
    _ElementMap.update({
        __topologyStyle.name() : __topologyStyle,
        __featureConstraint.name() : __featureConstraint,
        __labelStyle.name() : __labelStyle,
        __geometryStyle.name() : __geometryStyle
    })
    _AttributeMap = AbstractGMLType._AttributeMap.copy()
    _AttributeMap.update({
        __featureType.name() : __featureType,
        __queryGrammar.name() : __queryGrammar,
        __baseType.name() : __baseType
    })
Namespace.addCategoryObject('typeBinding', u'FeatureStyleType', FeatureStyleType)


# Complex type StyleType with content type ELEMENT_ONLY
class StyleType (AbstractStyleType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'StyleType')
    # Base type is AbstractStyleType
    
    # Element {http://www.opengis.net/gml}featureStyle uses Python identifier featureStyle
    __featureStyle = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'featureStyle'), 'featureStyle', '__httpwww_opengis_netgml_StyleType_httpwww_opengis_netgmlfeatureStyle', True)

    
    featureStyle = property(__featureStyle.value, __featureStyle.set, None, u'')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}graphStyle uses Python identifier graphStyle
    __graphStyle = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'graphStyle'), 'graphStyle', '__httpwww_opengis_netgml_StyleType_httpwww_opengis_netgmlgraphStyle', False)

    
    graphStyle = property(__graphStyle.value, __graphStyle.set, None, u'')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractStyleType._ElementMap.copy()
    _ElementMap.update({
        __featureStyle.name() : __featureStyle,
        __graphStyle.name() : __graphStyle
    })
    _AttributeMap = AbstractStyleType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'StyleType', StyleType)


# Complex type SolidPropertyType with content type ELEMENT_ONLY
class SolidPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SolidPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_Solid uses Python identifier Solid
    __Solid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_Solid'), 'Solid', '__httpwww_opengis_netgml_SolidPropertyType_httpwww_opengis_netgml_Solid', False)

    
    Solid = property(__Solid.value, __Solid.set, None, u'The "_Solid" element is the abstract head of the substituition group for all (continuous) solid elements.')

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_SolidPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_SolidPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_SolidPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_SolidPropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_SolidPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_SolidPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_SolidPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_SolidPropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")


    _ElementMap = {
        __Solid.name() : __Solid
    }
    _AttributeMap = {
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __href.name() : __href,
        __role.name() : __role,
        __actuate.name() : __actuate
    }
Namespace.addCategoryObject('typeBinding', u'SolidPropertyType', SolidPropertyType)


# Complex type TopoSurfaceType with content type ELEMENT_ONLY
class TopoSurfaceType (AbstractTopologyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopoSurfaceType')
    # Base type is AbstractTopologyType
    
    # Element {http://www.opengis.net/gml}directedFace uses Python identifier directedFace
    __directedFace = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'directedFace'), 'directedFace', '__httpwww_opengis_netgml_TopoSurfaceType_httpwww_opengis_netgmldirectedFace', True)

    
    directedFace = property(__directedFace.value, __directedFace.set, None, u'')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTopologyType._ElementMap.copy()
    _ElementMap.update({
        __directedFace.name() : __directedFace
    })
    _AttributeMap = AbstractTopologyType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TopoSurfaceType', TopoSurfaceType)


# Complex type LineStringType with content type ELEMENT_ONLY
class LineStringType (AbstractCurveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LineStringType')
    # Base type is AbstractCurveType
    
    # Element {http://www.opengis.net/gml}coord uses Python identifier coord
    __coord = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coord'), 'coord', '__httpwww_opengis_netgml_LineStringType_httpwww_opengis_netgmlcoord', True)

    
    coord = property(__coord.value, __coord.set, None, u'Deprecated with GML 3.0 and included for backwards compatibility with GML 2. Use the "pos" element instead.')

    
    # Element {http://www.opengis.net/gml}pointProperty uses Python identifier pointProperty
    __pointProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), 'pointProperty', '__httpwww_opengis_netgml_LineStringType_httpwww_opengis_netgmlpointProperty', True)

    
    pointProperty = property(__pointProperty.value, __pointProperty.set, None, u'This property element either references a point via the XLink-attributes or contains the point element. pointProperty \n\t\t\tis the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that \n\t\t\tis substitutable for Point.')

    
    # Element {http://www.opengis.net/gml}posList uses Python identifier posList
    __posList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'posList'), 'posList', '__httpwww_opengis_netgml_LineStringType_httpwww_opengis_netgmlposList', False)

    
    posList = property(__posList.value, __posList.set, None, u'')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}pointRep uses Python identifier pointRep
    __pointRep = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), 'pointRep', '__httpwww_opengis_netgml_LineStringType_httpwww_opengis_netgmlpointRep', True)

    
    pointRep = property(__pointRep.value, __pointRep.set, None, u'Deprecated with GML version 3.1.0. Use "pointProperty" instead. Included for backwards compatibility with GML 3.0.0.')

    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pos'), 'pos', '__httpwww_opengis_netgml_LineStringType_httpwww_opengis_netgmlpos', True)

    
    pos = property(__pos.value, __pos.set, None, u'')

    
    # Element {http://www.opengis.net/gml}coordinates uses Python identifier coordinates
    __coordinates = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), 'coordinates', '__httpwww_opengis_netgml_LineStringType_httpwww_opengis_netgmlcoordinates', False)

    
    coordinates = property(__coordinates.value, __coordinates.set, None, u'Deprecated with GML version 3.1.0.')

    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractCurveType._ElementMap.copy()
    _ElementMap.update({
        __coord.name() : __coord,
        __pointProperty.name() : __pointProperty,
        __posList.name() : __posList,
        __pointRep.name() : __pointRep,
        __pos.name() : __pos,
        __coordinates.name() : __coordinates
    })
    _AttributeMap = AbstractCurveType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'LineStringType', LineStringType)


# Complex type CompoundCRSType with content type ELEMENT_ONLY
class CompoundCRSType (AbstractReferenceSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CompoundCRSType')
    # Base type is AbstractReferenceSystemType
    
    # Element {http://www.opengis.net/gml}includesCRS uses Python identifier includesCRS
    __includesCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'includesCRS'), 'includesCRS', '__httpwww_opengis_netgml_CompoundCRSType_httpwww_opengis_netgmlincludesCRS', True)

    
    includesCRS = property(__includesCRS.value, __includesCRS.set, None, u'An association to a component coordinate reference system included in this compound coordinate reference system. ')

    
    # Element srsName ({http://www.opengis.net/gml}srsName) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemBaseType
    
    # Element srsID ({http://www.opengis.net/gml}srsID) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element validArea ({http://www.opengis.net/gml}validArea) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element scope ({http://www.opengis.net/gml}scope) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractReferenceSystemBaseType

    _ElementMap = AbstractReferenceSystemType._ElementMap.copy()
    _ElementMap.update({
        __includesCRS.name() : __includesCRS
    })
    _AttributeMap = AbstractReferenceSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CompoundCRSType', CompoundCRSType)


# Complex type CompositeCurveType with content type ELEMENT_ONLY
class CompositeCurveType (AbstractCurveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CompositeCurveType')
    # Base type is AbstractCurveType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}curveMember uses Python identifier curveMember
    __curveMember = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'curveMember'), 'curveMember', '__httpwww_opengis_netgml_CompositeCurveType_httpwww_opengis_netgmlcurveMember', True)

    
    curveMember = property(__curveMember.value, __curveMember.set, None, u'This property element either references a curve via the XLink-attributes or contains the curve element. A curve element is any element which is substitutable for "_Curve".')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractCurveType._ElementMap.copy()
    _ElementMap.update({
        __curveMember.name() : __curveMember
    })
    _AttributeMap = AbstractCurveType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CompositeCurveType', CompositeCurveType)


# Complex type RectangleType with content type ELEMENT_ONLY
class RectangleType (AbstractSurfacePatchType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'RectangleType')
    # Base type is AbstractSurfacePatchType
    
    # Element {http://www.opengis.net/gml}exterior uses Python identifier exterior
    __exterior = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'exterior'), 'exterior', '__httpwww_opengis_netgml_RectangleType_httpwww_opengis_netgmlexterior', False)

    
    exterior = property(__exterior.value, __exterior.set, None, u'A boundary of a surface consists of a number of rings. In the normal 2D case, one of these rings is distinguished as being the exterior boundary. In a general manifold this is not always possible, in which case all boundaries shall be listed as interior boundaries, and the exterior will be empty.')

    
    # Attribute interpolation uses Python identifier interpolation
    __interpolation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'interpolation'), 'interpolation', '__httpwww_opengis_netgml_RectangleType_interpolation', SurfaceInterpolationType, fixed=True, unicode_default=u'planar')
    
    interpolation = property(__interpolation.value, __interpolation.set, None, u'The attribute "interpolation" specifies the interpolation mechanism used for this surface patch. Currently only planar surface patches are defined in GML 3, the attribute is fixed to "planar", i.e. the interpolation method shall return points on a single plane. The boundary of the patch shall be contained within that plane.')


    _ElementMap = AbstractSurfacePatchType._ElementMap.copy()
    _ElementMap.update({
        __exterior.name() : __exterior
    })
    _AttributeMap = AbstractSurfacePatchType._AttributeMap.copy()
    _AttributeMap.update({
        __interpolation.name() : __interpolation
    })
Namespace.addCategoryObject('typeBinding', u'RectangleType', RectangleType)


# Complex type LineStringPropertyType with content type ELEMENT_ONLY
class LineStringPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LineStringPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}LineString uses Python identifier LineString
    __LineString = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'LineString'), 'LineString', '__httpwww_opengis_netgml_LineStringPropertyType_httpwww_opengis_netgmlLineString', False)

    
    LineString = property(__LineString.value, __LineString.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_LineStringPropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_LineStringPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_LineStringPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_LineStringPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_LineStringPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_LineStringPropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_LineStringPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_LineStringPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)


    _ElementMap = {
        __LineString.name() : __LineString
    }
    _AttributeMap = {
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __role.name() : __role,
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __href.name() : __href
    }
Namespace.addCategoryObject('typeBinding', u'LineStringPropertyType', LineStringPropertyType)


# Complex type FormulaType with content type ELEMENT_ONLY
class FormulaType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'FormulaType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}d uses Python identifier d
    __d = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'd'), 'd', '__httpwww_opengis_netgml_FormulaType_httpwww_opengis_netgmld', False)

    
    d = property(__d.value, __d.set, None, None)

    
    # Element {http://www.opengis.net/gml}b uses Python identifier b
    __b = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'b'), 'b', '__httpwww_opengis_netgml_FormulaType_httpwww_opengis_netgmlb', False)

    
    b = property(__b.value, __b.set, None, None)

    
    # Element {http://www.opengis.net/gml}a uses Python identifier a
    __a = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'a'), 'a', '__httpwww_opengis_netgml_FormulaType_httpwww_opengis_netgmla', False)

    
    a = property(__a.value, __a.set, None, None)

    
    # Element {http://www.opengis.net/gml}c uses Python identifier c
    __c = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'c'), 'c', '__httpwww_opengis_netgml_FormulaType_httpwww_opengis_netgmlc', False)

    
    c = property(__c.value, __c.set, None, None)


    _ElementMap = {
        __d.name() : __d,
        __b.name() : __b,
        __a.name() : __a,
        __c.name() : __c
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'FormulaType', FormulaType)


# Complex type GeodeticDatumType with content type ELEMENT_ONLY
class GeodeticDatumType (AbstractDatumType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeodeticDatumType')
    # Base type is AbstractDatumType
    
    # Element datumName ({http://www.opengis.net/gml}datumName) inherited from {http://www.opengis.net/gml}AbstractDatumBaseType
    
    # Element realizationEpoch ({http://www.opengis.net/gml}realizationEpoch) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element scope ({http://www.opengis.net/gml}scope) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element datumID ({http://www.opengis.net/gml}datumID) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element validArea ({http://www.opengis.net/gml}validArea) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}usesPrimeMeridian uses Python identifier usesPrimeMeridian
    __usesPrimeMeridian = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesPrimeMeridian'), 'usesPrimeMeridian', '__httpwww_opengis_netgml_GeodeticDatumType_httpwww_opengis_netgmlusesPrimeMeridian', False)

    
    usesPrimeMeridian = property(__usesPrimeMeridian.value, __usesPrimeMeridian.set, None, u'Association to the prime meridian used by this geodetic datum. ')

    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element {http://www.opengis.net/gml}usesEllipsoid uses Python identifier usesEllipsoid
    __usesEllipsoid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesEllipsoid'), 'usesEllipsoid', '__httpwww_opengis_netgml_GeodeticDatumType_httpwww_opengis_netgmlusesEllipsoid', False)

    
    usesEllipsoid = property(__usesEllipsoid.value, __usesEllipsoid.set, None, u'Association to the ellipsoid used by this geodetic datum. ')

    
    # Element anchorPoint ({http://www.opengis.net/gml}anchorPoint) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractDatumBaseType

    _ElementMap = AbstractDatumType._ElementMap.copy()
    _ElementMap.update({
        __usesPrimeMeridian.name() : __usesPrimeMeridian,
        __usesEllipsoid.name() : __usesEllipsoid
    })
    _AttributeMap = AbstractDatumType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'GeodeticDatumType', GeodeticDatumType)


# Complex type SingleOperationRefType with content type ELEMENT_ONLY
class SingleOperationRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SingleOperationRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_SingleOperation uses Python identifier SingleOperation
    __SingleOperation = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_SingleOperation'), 'SingleOperation', '__httpwww_opengis_netgml_SingleOperationRefType_httpwww_opengis_netgml_SingleOperation', False)

    
    SingleOperation = property(__SingleOperation.value, __SingleOperation.set, None, u'A single (not concatenated) coordinate operation. ')

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_SingleOperationRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_SingleOperationRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_SingleOperationRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_SingleOperationRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_SingleOperationRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_SingleOperationRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_SingleOperationRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_SingleOperationRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)


    _ElementMap = {
        __SingleOperation.name() : __SingleOperation
    }
    _AttributeMap = {
        __href.name() : __href,
        __type.name() : __type,
        __actuate.name() : __actuate,
        __role.name() : __role,
        __remoteSchema.name() : __remoteSchema,
        __show.name() : __show,
        __arcrole.name() : __arcrole,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'SingleOperationRefType', SingleOperationRefType)


# Complex type AbstractGeneralParameterValueType with content type EMPTY
class AbstractGeneralParameterValueType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractGeneralParameterValueType')
    # Base type is pyxb.binding.datatypes.anyType

    _ElementMap = {
        
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'AbstractGeneralParameterValueType', AbstractGeneralParameterValueType)


# Complex type VerticalDatumTypeType with content type SIMPLE
class VerticalDatumTypeType (CodeType):
    _TypeDefinition = STD_ANON_10
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VerticalDatumTypeType')
    # Base type is CodeType
    
    # Attribute codeSpace is restricted from parent
    
    # Attribute codeSpace uses Python identifier codeSpace
    __codeSpace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'codeSpace'), 'codeSpace', '__httpwww_opengis_netgml_CodeType_codeSpace', pyxb.binding.datatypes.anyURI, required=True)
    
    codeSpace = property(__codeSpace.value, __codeSpace.set, None, u'Reference to a source of information specifying the values and meanings of all the allowed string values for this VerticalDatumTypeType. ')


    _ElementMap = CodeType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = CodeType._AttributeMap.copy()
    _AttributeMap.update({
        __codeSpace.name() : __codeSpace
    })
Namespace.addCategoryObject('typeBinding', u'VerticalDatumTypeType', VerticalDatumTypeType)


# Complex type MultiLineStringType with content type ELEMENT_ONLY
class MultiLineStringType (AbstractGeometricAggregateType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiLineStringType')
    # Base type is AbstractGeometricAggregateType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}lineStringMember uses Python identifier lineStringMember
    __lineStringMember = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'lineStringMember'), 'lineStringMember', '__httpwww_opengis_netgml_MultiLineStringType_httpwww_opengis_netgmllineStringMember', True)

    
    lineStringMember = property(__lineStringMember.value, __lineStringMember.set, None, u'Deprecated with GML 3.0 and included only for backwards compatibility with GML 2.0. Use "curveMember" instead.\nThis property element either references a line string via the XLink-attributes or contains the line string element.')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometricAggregateType._ElementMap.copy()
    _ElementMap.update({
        __lineStringMember.name() : __lineStringMember
    })
    _AttributeMap = AbstractGeometricAggregateType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MultiLineStringType', MultiLineStringType)


# Complex type TriangulatedSurfaceType with content type ELEMENT_ONLY
class TriangulatedSurfaceType (SurfaceType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TriangulatedSurfaceType')
    # Base type is SurfaceType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}trianglePatches uses Python identifier trianglePatches
    __trianglePatches = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'trianglePatches'), 'trianglePatches', '__httpwww_opengis_netgml_TriangulatedSurfaceType_httpwww_opengis_netgmltrianglePatches', False)

    
    trianglePatches = property(__trianglePatches.value, __trianglePatches.set, None, u'This property element contains a list of\n   triangle patches. The order of the patches is significant and \n   shall be preserved when processing the list.')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = SurfaceType._ElementMap.copy()
    _ElementMap.update({
        __trianglePatches.name() : __trianglePatches
    })
    _AttributeMap = SurfaceType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TriangulatedSurfaceType', TriangulatedSurfaceType)


# Complex type RingType with content type ELEMENT_ONLY
class RingType (AbstractRingType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'RingType')
    # Base type is AbstractRingType
    
    # Element {http://www.opengis.net/gml}curveMember uses Python identifier curveMember
    __curveMember = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'curveMember'), 'curveMember', '__httpwww_opengis_netgml_RingType_httpwww_opengis_netgmlcurveMember', True)

    
    curveMember = property(__curveMember.value, __curveMember.set, None, u'This property element either references a curve via the XLink-attributes or contains the curve element. A curve element is any element which is substitutable for "_Curve".')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractRingType._ElementMap.copy()
    _ElementMap.update({
        __curveMember.name() : __curveMember
    })
    _AttributeMap = AbstractRingType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'RingType', RingType)


# Complex type EllipsoidalCSRefType with content type ELEMENT_ONLY
class EllipsoidalCSRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'EllipsoidalCSRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}EllipsoidalCS uses Python identifier EllipsoidalCS
    __EllipsoidalCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'EllipsoidalCS'), 'EllipsoidalCS', '__httpwww_opengis_netgml_EllipsoidalCSRefType_httpwww_opengis_netgmlEllipsoidalCS', False)

    
    EllipsoidalCS = property(__EllipsoidalCS.value, __EllipsoidalCS.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_EllipsoidalCSRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_EllipsoidalCSRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_EllipsoidalCSRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_EllipsoidalCSRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_EllipsoidalCSRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_EllipsoidalCSRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_EllipsoidalCSRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_EllipsoidalCSRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)


    _ElementMap = {
        __EllipsoidalCS.name() : __EllipsoidalCS
    }
    _AttributeMap = {
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __href.name() : __href,
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'EllipsoidalCSRefType', EllipsoidalCSRefType)


# Complex type GeometryPropertyType with content type ELEMENT_ONLY
class GeometryPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeometryPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_Geometry uses Python identifier Geometry
    __Geometry = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_Geometry'), 'Geometry', '__httpwww_opengis_netgml_GeometryPropertyType_httpwww_opengis_netgml_Geometry', False)

    
    Geometry = property(__Geometry.value, __Geometry.set, None, u'The "_Geometry" element is the abstract head of the substituition group for all geometry elements of GML 3. This \n\t\t\tincludes pre-defined and user-defined geometry elements. Any geometry element must be a direct or indirect extension/restriction \n\t\t\tof AbstractGeometryType and must be directly or indirectly in the substitution group of "_Geometry".')

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_GeometryPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_GeometryPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_GeometryPropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_GeometryPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_GeometryPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_GeometryPropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_GeometryPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_GeometryPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)


    _ElementMap = {
        __Geometry.name() : __Geometry
    }
    _AttributeMap = {
        __title.name() : __title,
        __role.name() : __role,
        __show.name() : __show,
        __type.name() : __type,
        __href.name() : __href,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole
    }
Namespace.addCategoryObject('typeBinding', u'GeometryPropertyType', GeometryPropertyType)


# Complex type TopoVolumeType with content type ELEMENT_ONLY
class TopoVolumeType (AbstractTopologyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopoVolumeType')
    # Base type is AbstractTopologyType
    
    # Element {http://www.opengis.net/gml}directedTopoSolid uses Python identifier directedTopoSolid
    __directedTopoSolid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'directedTopoSolid'), 'directedTopoSolid', '__httpwww_opengis_netgml_TopoVolumeType_httpwww_opengis_netgmldirectedTopoSolid', True)

    
    directedTopoSolid = property(__directedTopoSolid.value, __directedTopoSolid.set, None, u'')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTopologyType._ElementMap.copy()
    _ElementMap.update({
        __directedTopoSolid.name() : __directedTopoSolid
    })
    _AttributeMap = AbstractTopologyType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TopoVolumeType', TopoVolumeType)


# Complex type CTD_ANON with content type ELEMENT_ONLY
class CTD_ANON (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}posList uses Python identifier posList
    __posList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'posList'), 'posList', '__httpwww_opengis_netgml_CTD_ANON_httpwww_opengis_netgmlposList', False)

    
    posList = property(__posList.value, __posList.set, None, u'')

    
    # Element {http://www.opengis.net/gml}pointProperty uses Python identifier pointProperty
    __pointProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), 'pointProperty', '__httpwww_opengis_netgml_CTD_ANON_httpwww_opengis_netgmlpointProperty', True)

    
    pointProperty = property(__pointProperty.value, __pointProperty.set, None, u'This property element either references a point via the XLink-attributes or contains the point element. pointProperty \n\t\t\tis the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that \n\t\t\tis substitutable for Point.')

    
    # Element {http://www.opengis.net/gml}pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pos'), 'pos', '__httpwww_opengis_netgml_CTD_ANON_httpwww_opengis_netgmlpos', True)

    
    pos = property(__pos.value, __pos.set, None, u'')


    _ElementMap = {
        __posList.name() : __posList,
        __pointProperty.name() : __pointProperty,
        __pos.name() : __pos
    }
    _AttributeMap = {
        
    }



# Complex type GeometricComplexType with content type ELEMENT_ONLY
class GeometricComplexType (AbstractGeometryType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeometricComplexType')
    # Base type is AbstractGeometryType
    
    # Element {http://www.opengis.net/gml}element uses Python identifier element
    __element = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'element'), 'element', '__httpwww_opengis_netgml_GeometricComplexType_httpwww_opengis_netgmlelement', True)

    
    element = property(__element.value, __element.set, None, None)

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometryType._ElementMap.copy()
    _ElementMap.update({
        __element.name() : __element
    })
    _AttributeMap = AbstractGeometryType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'GeometricComplexType', GeometricComplexType)


# Complex type ConcatenatedOperationRefType with content type ELEMENT_ONLY
class ConcatenatedOperationRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ConcatenatedOperationRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}ConcatenatedOperation uses Python identifier ConcatenatedOperation
    __ConcatenatedOperation = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'ConcatenatedOperation'), 'ConcatenatedOperation', '__httpwww_opengis_netgml_ConcatenatedOperationRefType_httpwww_opengis_netgmlConcatenatedOperation', False)

    
    ConcatenatedOperation = property(__ConcatenatedOperation.value, __ConcatenatedOperation.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_ConcatenatedOperationRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_ConcatenatedOperationRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_ConcatenatedOperationRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_ConcatenatedOperationRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_ConcatenatedOperationRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_ConcatenatedOperationRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_ConcatenatedOperationRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_ConcatenatedOperationRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")


    _ElementMap = {
        __ConcatenatedOperation.name() : __ConcatenatedOperation
    }
    _AttributeMap = {
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __href.name() : __href,
        __role.name() : __role,
        __actuate.name() : __actuate
    }
Namespace.addCategoryObject('typeBinding', u'ConcatenatedOperationRefType', ConcatenatedOperationRefType)


# Complex type AbstractTimeTopologyPrimitiveType with content type ELEMENT_ONLY
class AbstractTimeTopologyPrimitiveType (AbstractTimePrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbstractTimeTopologyPrimitiveType')
    # Base type is AbstractTimePrimitiveType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element relatedTime ({http://www.opengis.net/gml}relatedTime) inherited from {http://www.opengis.net/gml}AbstractTimePrimitiveType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}complex uses Python identifier complex
    __complex = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'complex'), 'complex', '__httpwww_opengis_netgml_AbstractTimeTopologyPrimitiveType_httpwww_opengis_netgmlcomplex', False)

    
    complex = property(__complex.value, __complex.set, None, None)

    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTimePrimitiveType._ElementMap.copy()
    _ElementMap.update({
        __complex.name() : __complex
    })
    _AttributeMap = AbstractTimePrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbstractTimeTopologyPrimitiveType', AbstractTimeTopologyPrimitiveType)


# Complex type LinearRingType with content type ELEMENT_ONLY
class LinearRingType (AbstractRingType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LinearRingType')
    # Base type is AbstractRingType
    
    # Element {http://www.opengis.net/gml}pointProperty uses Python identifier pointProperty
    __pointProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), 'pointProperty', '__httpwww_opengis_netgml_LinearRingType_httpwww_opengis_netgmlpointProperty', True)

    
    pointProperty = property(__pointProperty.value, __pointProperty.set, None, u'This property element either references a point via the XLink-attributes or contains the point element. pointProperty \n\t\t\tis the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that \n\t\t\tis substitutable for Point.')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}coord uses Python identifier coord
    __coord = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coord'), 'coord', '__httpwww_opengis_netgml_LinearRingType_httpwww_opengis_netgmlcoord', True)

    
    coord = property(__coord.value, __coord.set, None, u'Deprecated with GML 3.0 and included for backwards compatibility with GML 2. Use the "pos" element instead.')

    
    # Element {http://www.opengis.net/gml}pointRep uses Python identifier pointRep
    __pointRep = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), 'pointRep', '__httpwww_opengis_netgml_LinearRingType_httpwww_opengis_netgmlpointRep', True)

    
    pointRep = property(__pointRep.value, __pointRep.set, None, u'Deprecated with GML version 3.1.0. Use "pointProperty" instead. Included for backwards compatibility with GML 3.0.0.')

    
    # Element {http://www.opengis.net/gml}posList uses Python identifier posList
    __posList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'posList'), 'posList', '__httpwww_opengis_netgml_LinearRingType_httpwww_opengis_netgmlposList', False)

    
    posList = property(__posList.value, __posList.set, None, u'')

    
    # Element {http://www.opengis.net/gml}pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pos'), 'pos', '__httpwww_opengis_netgml_LinearRingType_httpwww_opengis_netgmlpos', True)

    
    pos = property(__pos.value, __pos.set, None, u'')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}coordinates uses Python identifier coordinates
    __coordinates = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), 'coordinates', '__httpwww_opengis_netgml_LinearRingType_httpwww_opengis_netgmlcoordinates', False)

    
    coordinates = property(__coordinates.value, __coordinates.set, None, u'Deprecated with GML version 3.1.0.')

    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractRingType._ElementMap.copy()
    _ElementMap.update({
        __pointProperty.name() : __pointProperty,
        __coord.name() : __coord,
        __pointRep.name() : __pointRep,
        __posList.name() : __posList,
        __pos.name() : __pos,
        __coordinates.name() : __coordinates
    })
    _AttributeMap = AbstractRingType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'LinearRingType', LinearRingType)


# Complex type GeometryArrayPropertyType with content type ELEMENT_ONLY
class GeometryArrayPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeometryArrayPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_Geometry uses Python identifier Geometry
    __Geometry = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_Geometry'), 'Geometry', '__httpwww_opengis_netgml_GeometryArrayPropertyType_httpwww_opengis_netgml_Geometry', True)

    
    Geometry = property(__Geometry.value, __Geometry.set, None, u'The "_Geometry" element is the abstract head of the substituition group for all geometry elements of GML 3. This \n\t\t\tincludes pre-defined and user-defined geometry elements. Any geometry element must be a direct or indirect extension/restriction \n\t\t\tof AbstractGeometryType and must be directly or indirectly in the substitution group of "_Geometry".')


    _ElementMap = {
        __Geometry.name() : __Geometry
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'GeometryArrayPropertyType', GeometryArrayPropertyType)


# Complex type ParameterValueType with content type ELEMENT_ONLY
class ParameterValueType (AbstractGeneralParameterValueType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ParameterValueType')
    # Base type is AbstractGeneralParameterValueType
    
    # Element {http://www.opengis.net/gml}stringValue uses Python identifier stringValue
    __stringValue = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'stringValue'), 'stringValue', '__httpwww_opengis_netgml_ParameterValueType_httpwww_opengis_netgmlstringValue', False)

    
    stringValue = property(__stringValue.value, __stringValue.set, None, u'String value of an operation parameter. A string value does not have an associated unit of measure. ')

    
    # Element {http://www.opengis.net/gml}valueOfParameter uses Python identifier valueOfParameter
    __valueOfParameter = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'valueOfParameter'), 'valueOfParameter', '__httpwww_opengis_netgml_ParameterValueType_httpwww_opengis_netgmlvalueOfParameter', False)

    
    valueOfParameter = property(__valueOfParameter.value, __valueOfParameter.set, None, u'Association to the operation parameter that this is a value of. ')

    
    # Element {http://www.opengis.net/gml}value uses Python identifier value_
    __value = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'value'), 'value_', '__httpwww_opengis_netgml_ParameterValueType_httpwww_opengis_netgmlvalue', False)

    
    value_ = property(__value.value, __value.set, None, u'Numeric value of an operation parameter, with its associated unit of measure. ')

    
    # Element {http://www.opengis.net/gml}integerValue uses Python identifier integerValue
    __integerValue = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'integerValue'), 'integerValue', '__httpwww_opengis_netgml_ParameterValueType_httpwww_opengis_netgmlintegerValue', False)

    
    integerValue = property(__integerValue.value, __integerValue.set, None, u'Positive integer value of an operation parameter, usually used for a count. An integer value does not have an associated unit of measure. ')

    
    # Element {http://www.opengis.net/gml}integerValueList uses Python identifier integerValueList
    __integerValueList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'integerValueList'), 'integerValueList', '__httpwww_opengis_netgml_ParameterValueType_httpwww_opengis_netgmlintegerValueList', False)

    
    integerValueList = property(__integerValueList.value, __integerValueList.set, None, u'Ordered sequence of two or more integer values of an operation parameter list, usually used for counts. These integer values do not have an associated unit of measure. An element of this type contains a space-separated sequence of integer values. ')

    
    # Element {http://www.opengis.net/gml}dmsAngleValue uses Python identifier dmsAngleValue
    __dmsAngleValue = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'dmsAngleValue'), 'dmsAngleValue', '__httpwww_opengis_netgml_ParameterValueType_httpwww_opengis_netgmldmsAngleValue', False)

    
    dmsAngleValue = property(__dmsAngleValue.value, __dmsAngleValue.set, None, u'Value of an angle operation parameter, in either degree-minute-second format or single value format. ')

    
    # Element {http://www.opengis.net/gml}booleanValue uses Python identifier booleanValue
    __booleanValue = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'booleanValue'), 'booleanValue', '__httpwww_opengis_netgml_ParameterValueType_httpwww_opengis_netgmlbooleanValue', False)

    
    booleanValue = property(__booleanValue.value, __booleanValue.set, None, u'Boolean value of an operation parameter. A Boolean value does not have an associated unit of measure. ')

    
    # Element {http://www.opengis.net/gml}valueFile uses Python identifier valueFile
    __valueFile = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'valueFile'), 'valueFile', '__httpwww_opengis_netgml_ParameterValueType_httpwww_opengis_netgmlvalueFile', False)

    
    valueFile = property(__valueFile.value, __valueFile.set, None, u'Reference to a file or a part of a file containing one or more parameter values, each numeric value with its associated unit of measure. When referencing a part of a file, that file must contain multiple identified parts, such as an XML encoded document. Furthermore, the referenced file or part of a file can reference another part of the same or different files, as allowed in XML documents. ')

    
    # Element {http://www.opengis.net/gml}valueList uses Python identifier valueList
    __valueList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'valueList'), 'valueList', '__httpwww_opengis_netgml_ParameterValueType_httpwww_opengis_netgmlvalueList', False)

    
    valueList = property(__valueList.value, __valueList.set, None, u'Ordered sequence of two or more numeric values of an operation parameter list, where each value has the same associated unit of measure. An element of this type contains a space-separated sequence of double values. ')


    _ElementMap = AbstractGeneralParameterValueType._ElementMap.copy()
    _ElementMap.update({
        __stringValue.name() : __stringValue,
        __valueOfParameter.name() : __valueOfParameter,
        __value.name() : __value,
        __integerValue.name() : __integerValue,
        __integerValueList.name() : __integerValueList,
        __dmsAngleValue.name() : __dmsAngleValue,
        __booleanValue.name() : __booleanValue,
        __valueFile.name() : __valueFile,
        __valueList.name() : __valueList
    })
    _AttributeMap = AbstractGeneralParameterValueType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ParameterValueType', ParameterValueType)


# Complex type PolygonPatchType with content type ELEMENT_ONLY
class PolygonPatchType (AbstractSurfacePatchType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PolygonPatchType')
    # Base type is AbstractSurfacePatchType
    
    # Element {http://www.opengis.net/gml}interior uses Python identifier interior
    __interior = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'interior'), 'interior', '__httpwww_opengis_netgml_PolygonPatchType_httpwww_opengis_netgmlinterior', True)

    
    interior = property(__interior.value, __interior.set, None, u'A boundary of a surface consists of a number of rings. The "interior" rings seperate the surface / surface patch from the area enclosed by the rings.')

    
    # Element {http://www.opengis.net/gml}exterior uses Python identifier exterior
    __exterior = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'exterior'), 'exterior', '__httpwww_opengis_netgml_PolygonPatchType_httpwww_opengis_netgmlexterior', False)

    
    exterior = property(__exterior.value, __exterior.set, None, u'A boundary of a surface consists of a number of rings. In the normal 2D case, one of these rings is distinguished as being the exterior boundary. In a general manifold this is not always possible, in which case all boundaries shall be listed as interior boundaries, and the exterior will be empty.')

    
    # Attribute interpolation uses Python identifier interpolation
    __interpolation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'interpolation'), 'interpolation', '__httpwww_opengis_netgml_PolygonPatchType_interpolation', SurfaceInterpolationType, fixed=True, unicode_default=u'planar')
    
    interpolation = property(__interpolation.value, __interpolation.set, None, u'The attribute "interpolation" specifies the interpolation mechanism used for this surface patch. Currently only planar surface patches are defined in GML 3, the attribute is fixed to "planar", i.e. the interpolation method shall return points on a single plane. The boundary of the patch shall be contained within that plane.')


    _ElementMap = AbstractSurfacePatchType._ElementMap.copy()
    _ElementMap.update({
        __interior.name() : __interior,
        __exterior.name() : __exterior
    })
    _AttributeMap = AbstractSurfacePatchType._AttributeMap.copy()
    _AttributeMap.update({
        __interpolation.name() : __interpolation
    })
Namespace.addCategoryObject('typeBinding', u'PolygonPatchType', PolygonPatchType)


# Complex type EngineeringCRSRefType with content type ELEMENT_ONLY
class EngineeringCRSRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'EngineeringCRSRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}EngineeringCRS uses Python identifier EngineeringCRS
    __EngineeringCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'EngineeringCRS'), 'EngineeringCRS', '__httpwww_opengis_netgml_EngineeringCRSRefType_httpwww_opengis_netgmlEngineeringCRS', False)

    
    EngineeringCRS = property(__EngineeringCRS.value, __EngineeringCRS.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_EngineeringCRSRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_EngineeringCRSRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_EngineeringCRSRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_EngineeringCRSRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_EngineeringCRSRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_EngineeringCRSRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_EngineeringCRSRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_EngineeringCRSRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)


    _ElementMap = {
        __EngineeringCRS.name() : __EngineeringCRS
    }
    _AttributeMap = {
        __role.name() : __role,
        __actuate.name() : __actuate,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __remoteSchema.name() : __remoteSchema,
        __show.name() : __show,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'EngineeringCRSRefType', EngineeringCRSRefType)


# Complex type OffsetCurveType with content type ELEMENT_ONLY
class OffsetCurveType (AbstractCurveSegmentType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'OffsetCurveType')
    # Base type is AbstractCurveSegmentType
    
    # Element {http://www.opengis.net/gml}refDirection uses Python identifier refDirection
    __refDirection = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'refDirection'), 'refDirection', '__httpwww_opengis_netgml_OffsetCurveType_httpwww_opengis_netgmlrefDirection', False)

    
    refDirection = property(__refDirection.value, __refDirection.set, None, u'refDistance is used to define the vector\n       direction of the offset curve from the basis curve. It can\n       be omitted in the 2D case, where the distance can be \n       positive or negative. In that case, distance defines left\n       side (positive distance) or right side (negative distance)\n       with respect to the tangent to the basis curve.\n\n       In 3D the basis curve shall have a well defined tangent \n       direction for every point. The offset curve at any point \n       in 3D, the basis curve shall have a well-defined tangent\n       direction for every point. The offset curve at any point\n       (parameter) on the basis curve c is in the direction\n       -   -   -         -               \n       s = v x t  where  v = c.refDirection()  \n       and\n       -\n       t = c.tangent()\n                                                    -\n       For the offset direction to be well-defined, v shall not\n       on any point of the curve be in the same, or opposite, \n       direction as\n       - \n       t.\n\n       The default value of the refDirection shall be the local\n       co-ordinate axis vector for elevation, which indicates up for\n       the curve in a geographic sense.\n\n       NOTE! If the refDirection is the positive tangent to the\n       local elevation axis ("points upward"), then the offset\n       vector points to the left of the curve when viewed from\n       above.')

    
    # Element {http://www.opengis.net/gml}distance uses Python identifier distance
    __distance = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'distance'), 'distance', '__httpwww_opengis_netgml_OffsetCurveType_httpwww_opengis_netgmldistance', False)

    
    distance = property(__distance.value, __distance.set, None, u'distance is the distance at which the\n\t\t\t\t\t\t\t offset curve is generated from the basis curve. In 2D systems, positive distances\n\t\t\t\t\t\t\t are to be to the left of the basis curve, and the negative distances are to be to the \n\t\t\t\t\t\t\t right of the basis curve.')

    
    # Element {http://www.opengis.net/gml}offsetBase uses Python identifier offsetBase
    __offsetBase = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'offsetBase'), 'offsetBase', '__httpwww_opengis_netgml_OffsetCurveType_httpwww_opengis_netgmloffsetBase', False)

    
    offsetBase = property(__offsetBase.value, __offsetBase.set, None, u'offsetBase is a reference to thecurve from which this\n\t\t\t\t\t\t\t curve is define\tas an offset.')

    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType

    _ElementMap = AbstractCurveSegmentType._ElementMap.copy()
    _ElementMap.update({
        __refDirection.name() : __refDirection,
        __distance.name() : __distance,
        __offsetBase.name() : __offsetBase
    })
    _AttributeMap = AbstractCurveSegmentType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'OffsetCurveType', OffsetCurveType)


# Complex type ConversionToPreferredUnitType with content type ELEMENT_ONLY
class ConversionToPreferredUnitType (UnitOfMeasureType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ConversionToPreferredUnitType')
    # Base type is UnitOfMeasureType
    
    # Element {http://www.opengis.net/gml}factor uses Python identifier factor
    __factor = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'factor'), 'factor', '__httpwww_opengis_netgml_ConversionToPreferredUnitType_httpwww_opengis_netgmlfactor', False)

    
    factor = property(__factor.value, __factor.set, None, u'Specification of the scale factor by which a value using this unit of measure can be multiplied to obtain the corresponding value using the preferred unit of measure.')

    
    # Element {http://www.opengis.net/gml}formula uses Python identifier formula
    __formula = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'formula'), 'formula', '__httpwww_opengis_netgml_ConversionToPreferredUnitType_httpwww_opengis_netgmlformula', False)

    
    formula = property(__formula.value, __formula.set, None, u'Specification of the formula by which a value using this unit of measure can be converted to obtain the corresponding value using the preferred unit of measure.')

    
    # Attribute uom inherited from {http://www.opengis.net/gml}UnitOfMeasureType

    _ElementMap = UnitOfMeasureType._ElementMap.copy()
    _ElementMap.update({
        __factor.name() : __factor,
        __formula.name() : __formula
    })
    _AttributeMap = UnitOfMeasureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ConversionToPreferredUnitType', ConversionToPreferredUnitType)


# Complex type GridLimitsType with content type ELEMENT_ONLY
class GridLimitsType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GridLimitsType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}GridEnvelope uses Python identifier GridEnvelope
    __GridEnvelope = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'GridEnvelope'), 'GridEnvelope', '__httpwww_opengis_netgml_GridLimitsType_httpwww_opengis_netgmlGridEnvelope', False)

    
    GridEnvelope = property(__GridEnvelope.value, __GridEnvelope.set, None, None)


    _ElementMap = {
        __GridEnvelope.name() : __GridEnvelope
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'GridLimitsType', GridLimitsType)


# Complex type CoordinateSystemRefType with content type ELEMENT_ONLY
class CoordinateSystemRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CoordinateSystemRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_CoordinateSystem uses Python identifier CoordinateSystem
    __CoordinateSystem = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_CoordinateSystem'), 'CoordinateSystem', '__httpwww_opengis_netgml_CoordinateSystemRefType_httpwww_opengis_netgml_CoordinateSystem', False)

    
    CoordinateSystem = property(__CoordinateSystem.value, __CoordinateSystem.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_CoordinateSystemRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_CoordinateSystemRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_CoordinateSystemRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_CoordinateSystemRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_CoordinateSystemRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_CoordinateSystemRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_CoordinateSystemRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_CoordinateSystemRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)


    _ElementMap = {
        __CoordinateSystem.name() : __CoordinateSystem
    }
    _AttributeMap = {
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __href.name() : __href,
        __arcrole.name() : __arcrole
    }
Namespace.addCategoryObject('typeBinding', u'CoordinateSystemRefType', CoordinateSystemRefType)


# Complex type CompositeCurvePropertyType with content type ELEMENT_ONLY
class CompositeCurvePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CompositeCurvePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}CompositeCurve uses Python identifier CompositeCurve
    __CompositeCurve = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CompositeCurve'), 'CompositeCurve', '__httpwww_opengis_netgml_CompositeCurvePropertyType_httpwww_opengis_netgmlCompositeCurve', False)

    
    CompositeCurve = property(__CompositeCurve.value, __CompositeCurve.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_CompositeCurvePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_CompositeCurvePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_CompositeCurvePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_CompositeCurvePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_CompositeCurvePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_CompositeCurvePropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_CompositeCurvePropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_CompositeCurvePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)


    _ElementMap = {
        __CompositeCurve.name() : __CompositeCurve
    }
    _AttributeMap = {
        __role.name() : __role,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __href.name() : __href,
        __title.name() : __title,
        __actuate.name() : __actuate,
        __show.name() : __show,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'CompositeCurvePropertyType', CompositeCurvePropertyType)


# Complex type DirectionPropertyType with content type ELEMENT_ONLY
class DirectionPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DirectionPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}DirectionVector uses Python identifier DirectionVector
    __DirectionVector = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'DirectionVector'), 'DirectionVector', '__httpwww_opengis_netgml_DirectionPropertyType_httpwww_opengis_netgmlDirectionVector', False)

    
    DirectionVector = property(__DirectionVector.value, __DirectionVector.set, None, None)

    
    # Element {http://www.opengis.net/gml}DirectionString uses Python identifier DirectionString
    __DirectionString = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'DirectionString'), 'DirectionString', '__httpwww_opengis_netgml_DirectionPropertyType_httpwww_opengis_netgmlDirectionString', False)

    
    DirectionString = property(__DirectionString.value, __DirectionString.set, None, None)

    
    # Element {http://www.opengis.net/gml}CompassPoint uses Python identifier CompassPoint
    __CompassPoint = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CompassPoint'), 'CompassPoint', '__httpwww_opengis_netgml_DirectionPropertyType_httpwww_opengis_netgmlCompassPoint', False)

    
    CompassPoint = property(__CompassPoint.value, __CompassPoint.set, None, None)

    
    # Element {http://www.opengis.net/gml}DirectionKeyword uses Python identifier DirectionKeyword
    __DirectionKeyword = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'DirectionKeyword'), 'DirectionKeyword', '__httpwww_opengis_netgml_DirectionPropertyType_httpwww_opengis_netgmlDirectionKeyword', False)

    
    DirectionKeyword = property(__DirectionKeyword.value, __DirectionKeyword.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_DirectionPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_DirectionPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_DirectionPropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_DirectionPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_DirectionPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_DirectionPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_DirectionPropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_DirectionPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')


    _ElementMap = {
        __DirectionVector.name() : __DirectionVector,
        __DirectionString.name() : __DirectionString,
        __CompassPoint.name() : __CompassPoint,
        __DirectionKeyword.name() : __DirectionKeyword
    }
    _AttributeMap = {
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role,
        __href.name() : __href,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema
    }
Namespace.addCategoryObject('typeBinding', u'DirectionPropertyType', DirectionPropertyType)


# Complex type CompositeSurfaceType with content type ELEMENT_ONLY
class CompositeSurfaceType (AbstractSurfaceType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CompositeSurfaceType')
    # Base type is AbstractSurfaceType
    
    # Element {http://www.opengis.net/gml}surfaceMember uses Python identifier surfaceMember
    __surfaceMember = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'surfaceMember'), 'surfaceMember', '__httpwww_opengis_netgml_CompositeSurfaceType_httpwww_opengis_netgmlsurfaceMember', True)

    
    surfaceMember = property(__surfaceMember.value, __surfaceMember.set, None, u'This property element either references a surface via the XLink-attributes or contains the surface element. A surface element is any element which is substitutable for "_Surface".')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractSurfaceType._ElementMap.copy()
    _ElementMap.update({
        __surfaceMember.name() : __surfaceMember
    })
    _AttributeMap = AbstractSurfaceType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CompositeSurfaceType', CompositeSurfaceType)


# Complex type LinearRingPropertyType with content type ELEMENT_ONLY
class LinearRingPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LinearRingPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}LinearRing uses Python identifier LinearRing
    __LinearRing = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'LinearRing'), 'LinearRing', '__httpwww_opengis_netgml_LinearRingPropertyType_httpwww_opengis_netgmlLinearRing', False)

    
    LinearRing = property(__LinearRing.value, __LinearRing.set, None, None)


    _ElementMap = {
        __LinearRing.name() : __LinearRing
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'LinearRingPropertyType', LinearRingPropertyType)


# Complex type GeometricComplexPropertyType with content type ELEMENT_ONLY
class GeometricComplexPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeometricComplexPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}GeometricComplex uses Python identifier GeometricComplex
    __GeometricComplex = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'GeometricComplex'), 'GeometricComplex', '__httpwww_opengis_netgml_GeometricComplexPropertyType_httpwww_opengis_netgmlGeometricComplex', False)

    
    GeometricComplex = property(__GeometricComplex.value, __GeometricComplex.set, None, None)

    
    # Element {http://www.opengis.net/gml}CompositeCurve uses Python identifier CompositeCurve
    __CompositeCurve = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CompositeCurve'), 'CompositeCurve', '__httpwww_opengis_netgml_GeometricComplexPropertyType_httpwww_opengis_netgmlCompositeCurve', False)

    
    CompositeCurve = property(__CompositeCurve.value, __CompositeCurve.set, None, None)

    
    # Element {http://www.opengis.net/gml}CompositeSolid uses Python identifier CompositeSolid
    __CompositeSolid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CompositeSolid'), 'CompositeSolid', '__httpwww_opengis_netgml_GeometricComplexPropertyType_httpwww_opengis_netgmlCompositeSolid', False)

    
    CompositeSolid = property(__CompositeSolid.value, __CompositeSolid.set, None, None)

    
    # Element {http://www.opengis.net/gml}CompositeSurface uses Python identifier CompositeSurface
    __CompositeSurface = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CompositeSurface'), 'CompositeSurface', '__httpwww_opengis_netgml_GeometricComplexPropertyType_httpwww_opengis_netgmlCompositeSurface', False)

    
    CompositeSurface = property(__CompositeSurface.value, __CompositeSurface.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_GeometricComplexPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_GeometricComplexPropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_GeometricComplexPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_GeometricComplexPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_GeometricComplexPropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_GeometricComplexPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_GeometricComplexPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_GeometricComplexPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)


    _ElementMap = {
        __GeometricComplex.name() : __GeometricComplex,
        __CompositeCurve.name() : __CompositeCurve,
        __CompositeSolid.name() : __CompositeSolid,
        __CompositeSurface.name() : __CompositeSurface
    }
    _AttributeMap = {
        __href.name() : __href,
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'GeometricComplexPropertyType', GeometricComplexPropertyType)


# Complex type LinearCSRefType with content type ELEMENT_ONLY
class LinearCSRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LinearCSRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}LinearCS uses Python identifier LinearCS
    __LinearCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'LinearCS'), 'LinearCS', '__httpwww_opengis_netgml_LinearCSRefType_httpwww_opengis_netgmlLinearCS', False)

    
    LinearCS = property(__LinearCS.value, __LinearCS.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_LinearCSRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_LinearCSRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_LinearCSRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_LinearCSRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_LinearCSRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_LinearCSRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_LinearCSRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_LinearCSRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")


    _ElementMap = {
        __LinearCS.name() : __LinearCS
    }
    _AttributeMap = {
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __href.name() : __href,
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate
    }
Namespace.addCategoryObject('typeBinding', u'LinearCSRefType', LinearCSRefType)


# Complex type MultiSolidType with content type ELEMENT_ONLY
class MultiSolidType (AbstractGeometricAggregateType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiSolidType')
    # Base type is AbstractGeometricAggregateType
    
    # Element {http://www.opengis.net/gml}solidMember uses Python identifier solidMember
    __solidMember = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'solidMember'), 'solidMember', '__httpwww_opengis_netgml_MultiSolidType_httpwww_opengis_netgmlsolidMember', True)

    
    solidMember = property(__solidMember.value, __solidMember.set, None, u'This property element either references a solid via the XLink-attributes or contains the solid element. A solid element is any element which is substitutable for "_Solid".')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}solidMembers uses Python identifier solidMembers
    __solidMembers = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'solidMembers'), 'solidMembers', '__httpwww_opengis_netgml_MultiSolidType_httpwww_opengis_netgmlsolidMembers', False)

    
    solidMembers = property(__solidMembers.value, __solidMembers.set, None, u'This property element contains a list of solids. The order of the elements is significant and shall be preserved when processing the array.')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometricAggregateType._ElementMap.copy()
    _ElementMap.update({
        __solidMember.name() : __solidMember,
        __solidMembers.name() : __solidMembers
    })
    _AttributeMap = AbstractGeometricAggregateType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MultiSolidType', MultiSolidType)


# Complex type MultiLineStringPropertyType with content type ELEMENT_ONLY
class MultiLineStringPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiLineStringPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}MultiLineString uses Python identifier MultiLineString
    __MultiLineString = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'MultiLineString'), 'MultiLineString', '__httpwww_opengis_netgml_MultiLineStringPropertyType_httpwww_opengis_netgmlMultiLineString', False)

    
    MultiLineString = property(__MultiLineString.value, __MultiLineString.set, None, u'Deprecated with GML 3.0 and included for backwards compatibility with GML 2. Use the "MultiCurve" element instead.')

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_MultiLineStringPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_MultiLineStringPropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_MultiLineStringPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_MultiLineStringPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_MultiLineStringPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_MultiLineStringPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_MultiLineStringPropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_MultiLineStringPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)


    _ElementMap = {
        __MultiLineString.name() : __MultiLineString
    }
    _AttributeMap = {
        __href.name() : __href,
        __show.name() : __show,
        __title.name() : __title,
        __remoteSchema.name() : __remoteSchema,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __arcrole.name() : __arcrole
    }
Namespace.addCategoryObject('typeBinding', u'MultiLineStringPropertyType', MultiLineStringPropertyType)


# Complex type DataBlockType with content type ELEMENT_ONLY
class DataBlockType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DataBlockType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}tupleList uses Python identifier tupleList
    __tupleList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'tupleList'), 'tupleList', '__httpwww_opengis_netgml_DataBlockType_httpwww_opengis_netgmltupleList', False)

    
    tupleList = property(__tupleList.value, __tupleList.set, None, None)

    
    # Element {http://www.opengis.net/gml}doubleOrNullTupleList uses Python identifier doubleOrNullTupleList
    __doubleOrNullTupleList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'doubleOrNullTupleList'), 'doubleOrNullTupleList', '__httpwww_opengis_netgml_DataBlockType_httpwww_opengis_netgmldoubleOrNullTupleList', False)

    
    doubleOrNullTupleList = property(__doubleOrNullTupleList.value, __doubleOrNullTupleList.set, None, None)

    
    # Element {http://www.opengis.net/gml}rangeParameters uses Python identifier rangeParameters
    __rangeParameters = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'rangeParameters'), 'rangeParameters', '__httpwww_opengis_netgml_DataBlockType_httpwww_opengis_netgmlrangeParameters', False)

    
    rangeParameters = property(__rangeParameters.value, __rangeParameters.set, None, None)


    _ElementMap = {
        __tupleList.name() : __tupleList,
        __doubleOrNullTupleList.name() : __doubleOrNullTupleList,
        __rangeParameters.name() : __rangeParameters
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'DataBlockType', DataBlockType)


# Complex type TinType with content type ELEMENT_ONLY
class TinType (TriangulatedSurfaceType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TinType')
    # Base type is TriangulatedSurfaceType
    
    # Element {http://www.opengis.net/gml}controlPoint uses Python identifier controlPoint
    __controlPoint = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'controlPoint'), 'controlPoint', '__httpwww_opengis_netgml_TinType_httpwww_opengis_netgmlcontrolPoint', False)

    
    controlPoint = property(__controlPoint.value, __controlPoint.set, None, u'The corners of the triangles in the TIN \n  are often referred to as pots. ControlPoint shall contain a \n  set of the GM_Position used as posts for this TIN. Since each  \n  TIN contains triangles, there must be at least 3 posts. The \n       order in which these points are given does not affect the \n       surface that is represented. Application schemas may add \n       information based on ordering of control points to facilitate \n       the reconstruction of the TIN from the control points.')

    
    # Element {http://www.opengis.net/gml}breakLines uses Python identifier breakLines
    __breakLines = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'breakLines'), 'breakLines', '__httpwww_opengis_netgml_TinType_httpwww_opengis_netgmlbreakLines', True)

    
    breakLines = property(__breakLines.value, __breakLines.set, None, u'Breaklines are lines of a critical\n       nature to the shape of the surface, representing local\n       ridges, or depressions (such as drainage lines) in the\n       surface. As such their constituent segments must be\n       included in the tin eve if doing so\n       violates the Delauny criterion. Break lines contains these\n       critical segments as a set of line strings.')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element trianglePatches ({http://www.opengis.net/gml}trianglePatches) inherited from {http://www.opengis.net/gml}TriangulatedSurfaceType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}stopLines uses Python identifier stopLines
    __stopLines = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'stopLines'), 'stopLines', '__httpwww_opengis_netgml_TinType_httpwww_opengis_netgmlstopLines', True)

    
    stopLines = property(__stopLines.value, __stopLines.set, None, u'Stoplines are lines where the local\n       continuity or regularity of the surface is questionable.\n       In the area of these pathologies, triangles intersecting\n       a stopline shall be removed from the tin surface, leaving\n       holes in the surface. If coincidence occurs on surface\n       boundary triangles, the result shall be a change of the \n       surface boundary. Stoplines contains all these\n       pathological segments as a set of line strings.')

    
    # Element {http://www.opengis.net/gml}maxLength uses Python identifier maxLength
    __maxLength = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'maxLength'), 'maxLength', '__httpwww_opengis_netgml_TinType_httpwww_opengis_netgmlmaxLength', False)

    
    maxLength = property(__maxLength.value, __maxLength.set, None, u'Areas of the surface where data is not \n       sufficiently dense to assure reasonable calculation shall be    \n       removed by adding a retention criterion for triangles based \n       on the length of their sides. For many triangle sides  \n       exceeding maximum length, the adjacent triangles to that \n       triangle side shall be removed from the surface.')

    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = TriangulatedSurfaceType._ElementMap.copy()
    _ElementMap.update({
        __controlPoint.name() : __controlPoint,
        __breakLines.name() : __breakLines,
        __stopLines.name() : __stopLines,
        __maxLength.name() : __maxLength
    })
    _AttributeMap = TriangulatedSurfaceType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TinType', TinType)


# Complex type TopologyStylePropertyType with content type ELEMENT_ONLY
class TopologyStylePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopologyStylePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TopologyStyle uses Python identifier TopologyStyle
    __TopologyStyle = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TopologyStyle'), 'TopologyStyle', '__httpwww_opengis_netgml_TopologyStylePropertyType_httpwww_opengis_netgmlTopologyStyle', False)

    
    TopologyStyle = property(__TopologyStyle.value, __TopologyStyle.set, None, u'The style descriptor for topologies of a feature. Describes individual topology elements styles.')

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_TopologyStylePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_TopologyStylePropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_TopologyStylePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_TopologyStylePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_TopologyStylePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_TopologyStylePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_TopologyStylePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_TopologyStylePropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute about uses Python identifier about
    __about = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'about'), 'about', '__httpwww_opengis_netgml_TopologyStylePropertyType_about', pyxb.binding.datatypes.anyURI)
    
    about = property(__about.value, __about.set, None, None)


    _ElementMap = {
        __TopologyStyle.name() : __TopologyStyle
    }
    _AttributeMap = {
        __role.name() : __role,
        __show.name() : __show,
        __type.name() : __type,
        __arcrole.name() : __arcrole,
        __href.name() : __href,
        __title.name() : __title,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __about.name() : __about
    }
Namespace.addCategoryObject('typeBinding', u'TopologyStylePropertyType', TopologyStylePropertyType)


# Complex type CylinderType with content type ELEMENT_ONLY
class CylinderType (AbstractGriddedSurfaceType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CylinderType')
    # Base type is AbstractGriddedSurfaceType
    
    # Element row ({http://www.opengis.net/gml}row) inherited from {http://www.opengis.net/gml}AbstractGriddedSurfaceType
    
    # Element columns ({http://www.opengis.net/gml}columns) inherited from {http://www.opengis.net/gml}AbstractGriddedSurfaceType
    
    # Element rows ({http://www.opengis.net/gml}rows) inherited from {http://www.opengis.net/gml}AbstractGriddedSurfaceType
    
    # Attribute horizontalCurveType uses Python identifier horizontalCurveType
    __horizontalCurveType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'horizontalCurveType'), 'horizontalCurveType', '__httpwww_opengis_netgml_CylinderType_horizontalCurveType', CurveInterpolationType, fixed=True, unicode_default=u'circularArc3Points')
    
    horizontalCurveType = property(__horizontalCurveType.value, __horizontalCurveType.set, None, None)

    
    # Attribute verticalCurveType uses Python identifier verticalCurveType
    __verticalCurveType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'verticalCurveType'), 'verticalCurveType', '__httpwww_opengis_netgml_CylinderType_verticalCurveType', CurveInterpolationType, fixed=True, unicode_default=u'linear')
    
    verticalCurveType = property(__verticalCurveType.value, __verticalCurveType.set, None, None)


    _ElementMap = AbstractGriddedSurfaceType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractGriddedSurfaceType._AttributeMap.copy()
    _AttributeMap.update({
        __horizontalCurveType.name() : __horizontalCurveType,
        __verticalCurveType.name() : __verticalCurveType
    })
Namespace.addCategoryObject('typeBinding', u'CylinderType', CylinderType)


# Complex type LabelStyleType with content type ELEMENT_ONLY
class LabelStyleType (BaseStyleDescriptorType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LabelStyleType')
    # Base type is BaseStyleDescriptorType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element styleVariation ({http://www.opengis.net/gml}styleVariation) inherited from {http://www.opengis.net/gml}BaseStyleDescriptorType
    
    # Element {http://www.opengis.net/gml}style uses Python identifier style
    __style = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'style'), 'style', '__httpwww_opengis_netgml_LabelStyleType_httpwww_opengis_netgmlstyle', False)

    
    style = property(__style.value, __style.set, None, None)

    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element animateMotion ({http://www.w3.org/2001/SMIL20/}animateMotion) inherited from {http://www.opengis.net/gml}BaseStyleDescriptorType
    
    # Element animateColor ({http://www.w3.org/2001/SMIL20/}animateColor) inherited from {http://www.opengis.net/gml}BaseStyleDescriptorType
    
    # Element animate ({http://www.w3.org/2001/SMIL20/}animate) inherited from {http://www.opengis.net/gml}BaseStyleDescriptorType
    
    # Element set ({http://www.w3.org/2001/SMIL20/}set) inherited from {http://www.opengis.net/gml}BaseStyleDescriptorType
    
    # Element {http://www.opengis.net/gml}label uses Python identifier label
    __label = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'label'), 'label', '__httpwww_opengis_netgml_LabelStyleType_httpwww_opengis_netgmllabel', False)

    
    label = property(__label.value, __label.set, None, None)

    
    # Element spatialResolution ({http://www.opengis.net/gml}spatialResolution) inherited from {http://www.opengis.net/gml}BaseStyleDescriptorType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = BaseStyleDescriptorType._ElementMap.copy()
    _ElementMap.update({
        __style.name() : __style,
        __label.name() : __label
    })
    _AttributeMap = BaseStyleDescriptorType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'LabelStyleType', LabelStyleType)


# Complex type ReferenceSystemRefType with content type ELEMENT_ONLY
class ReferenceSystemRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ReferenceSystemRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_ReferenceSystem uses Python identifier ReferenceSystem
    __ReferenceSystem = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_ReferenceSystem'), 'ReferenceSystem', '__httpwww_opengis_netgml_ReferenceSystemRefType_httpwww_opengis_netgml_ReferenceSystem', False)

    
    ReferenceSystem = property(__ReferenceSystem.value, __ReferenceSystem.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_ReferenceSystemRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_ReferenceSystemRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_ReferenceSystemRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_ReferenceSystemRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_ReferenceSystemRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_ReferenceSystemRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_ReferenceSystemRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_ReferenceSystemRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)


    _ElementMap = {
        __ReferenceSystem.name() : __ReferenceSystem
    }
    _AttributeMap = {
        __show.name() : __show,
        __remoteSchema.name() : __remoteSchema,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __href.name() : __href,
        __type.name() : __type,
        __arcrole.name() : __arcrole,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'ReferenceSystemRefType', ReferenceSystemRefType)


# Complex type TemporalDatumBaseType with content type ELEMENT_ONLY
class TemporalDatumBaseType (AbstractDatumType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TemporalDatumBaseType')
    # Base type is AbstractDatumType
    
    # Element scope ({http://www.opengis.net/gml}scope) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element datumName ({http://www.opengis.net/gml}datumName) inherited from {http://www.opengis.net/gml}AbstractDatumBaseType
    
    # Element datumID ({http://www.opengis.net/gml}datumID) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element validArea ({http://www.opengis.net/gml}validArea) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Attribute id is restricted from parent
    
    # Attribute {http://www.opengis.net/gml}id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'id'), 'id', '__httpwww_opengis_netgml_AbstractGMLType_httpwww_opengis_netgmlid', pyxb.binding.datatypes.ID, required=True)
    
    id = property(__id.value, __id.set, None, u'Database handle for the object.  It is of XML type ID, so is constrained to be unique in the XML document within which it occurs.  An external identifier for the object in the form of a URI may be constructed using standard XML and XPointer methods.  This is done by concatenating the URI for the document, a fragment separator, and the value of the id attribute.')


    _ElementMap = AbstractDatumType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractDatumType._AttributeMap.copy()
    _AttributeMap.update({
        __id.name() : __id
    })
Namespace.addCategoryObject('typeBinding', u'TemporalDatumBaseType', TemporalDatumBaseType)


# Complex type TemporalDatumType with content type ELEMENT_ONLY
class TemporalDatumType (TemporalDatumBaseType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TemporalDatumType')
    # Base type is TemporalDatumBaseType
    
    # Element datumName ({http://www.opengis.net/gml}datumName) inherited from {http://www.opengis.net/gml}AbstractDatumBaseType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element scope ({http://www.opengis.net/gml}scope) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element datumID ({http://www.opengis.net/gml}datumID) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element {http://www.opengis.net/gml}origin uses Python identifier origin
    __origin = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'origin'), 'origin', '__httpwww_opengis_netgml_TemporalDatumType_httpwww_opengis_netgmlorigin', False)

    
    origin = property(__origin.value, __origin.set, None, u'The date and time origin of this temporal datum. ')

    
    # Element validArea ({http://www.opengis.net/gml}validArea) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Attribute id_3 inherited from {http://www.opengis.net/gml}TemporalDatumBaseType

    _ElementMap = TemporalDatumBaseType._ElementMap.copy()
    _ElementMap.update({
        __origin.name() : __origin
    })
    _AttributeMap = TemporalDatumBaseType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TemporalDatumType', TemporalDatumType)


# Complex type DMSAngleType with content type ELEMENT_ONLY
class DMSAngleType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DMSAngleType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}seconds uses Python identifier seconds
    __seconds = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'seconds'), 'seconds', '__httpwww_opengis_netgml_DMSAngleType_httpwww_opengis_netgmlseconds', False)

    
    seconds = property(__seconds.value, __seconds.set, None, None)

    
    # Element {http://www.opengis.net/gml}minutes uses Python identifier minutes
    __minutes = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'minutes'), 'minutes', '__httpwww_opengis_netgml_DMSAngleType_httpwww_opengis_netgmlminutes', False)

    
    minutes = property(__minutes.value, __minutes.set, None, None)

    
    # Element {http://www.opengis.net/gml}decimalMinutes uses Python identifier decimalMinutes
    __decimalMinutes = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'decimalMinutes'), 'decimalMinutes', '__httpwww_opengis_netgml_DMSAngleType_httpwww_opengis_netgmldecimalMinutes', False)

    
    decimalMinutes = property(__decimalMinutes.value, __decimalMinutes.set, None, None)

    
    # Element {http://www.opengis.net/gml}degrees uses Python identifier degrees
    __degrees = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'degrees'), 'degrees', '__httpwww_opengis_netgml_DMSAngleType_httpwww_opengis_netgmldegrees', False)

    
    degrees = property(__degrees.value, __degrees.set, None, None)


    _ElementMap = {
        __seconds.name() : __seconds,
        __minutes.name() : __minutes,
        __decimalMinutes.name() : __decimalMinutes,
        __degrees.name() : __degrees
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'DMSAngleType', DMSAngleType)


# Complex type TimeEdgeType with content type ELEMENT_ONLY
class TimeEdgeType (AbstractTimeTopologyPrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeEdgeType')
    # Base type is AbstractTimeTopologyPrimitiveType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element complex ({http://www.opengis.net/gml}complex) inherited from {http://www.opengis.net/gml}AbstractTimeTopologyPrimitiveType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}extent uses Python identifier extent
    __extent = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'extent'), 'extent', '__httpwww_opengis_netgml_TimeEdgeType_httpwww_opengis_netgmlextent', False)

    
    extent = property(__extent.value, __extent.set, None, None)

    
    # Element relatedTime ({http://www.opengis.net/gml}relatedTime) inherited from {http://www.opengis.net/gml}AbstractTimePrimitiveType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}start uses Python identifier start
    __start = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'start'), 'start', '__httpwww_opengis_netgml_TimeEdgeType_httpwww_opengis_netgmlstart', False)

    
    start = property(__start.value, __start.set, None, None)

    
    # Element {http://www.opengis.net/gml}end uses Python identifier end
    __end = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'end'), 'end', '__httpwww_opengis_netgml_TimeEdgeType_httpwww_opengis_netgmlend', False)

    
    end = property(__end.value, __end.set, None, None)

    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTimeTopologyPrimitiveType._ElementMap.copy()
    _ElementMap.update({
        __extent.name() : __extent,
        __start.name() : __start,
        __end.name() : __end
    })
    _AttributeMap = AbstractTimeTopologyPrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TimeEdgeType', TimeEdgeType)


# Complex type TimeCoordinateSystemType with content type ELEMENT_ONLY
class TimeCoordinateSystemType (AbstractTimeReferenceSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeCoordinateSystemType')
    # Base type is AbstractTimeReferenceSystemType
    
    # Element domainOfValidity ({http://www.opengis.net/gml}domainOfValidity) inherited from {http://www.opengis.net/gml}AbstractTimeReferenceSystemType
    
    # Element {http://www.opengis.net/gml}originPosition uses Python identifier originPosition
    __originPosition = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'originPosition'), 'originPosition', '__httpwww_opengis_netgml_TimeCoordinateSystemType_httpwww_opengis_netgmloriginPosition', False)

    
    originPosition = property(__originPosition.value, __originPosition.set, None, None)

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}origin uses Python identifier origin
    __origin = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'origin'), 'origin', '__httpwww_opengis_netgml_TimeCoordinateSystemType_httpwww_opengis_netgmlorigin', False)

    
    origin = property(__origin.value, __origin.set, None, None)

    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}interval uses Python identifier interval
    __interval = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'interval'), 'interval', '__httpwww_opengis_netgml_TimeCoordinateSystemType_httpwww_opengis_netgmlinterval', False)

    
    interval = property(__interval.value, __interval.set, None, None)

    
    # Attribute id_ inherited from {http://www.opengis.net/gml}DefinitionType

    _ElementMap = AbstractTimeReferenceSystemType._ElementMap.copy()
    _ElementMap.update({
        __originPosition.name() : __originPosition,
        __origin.name() : __origin,
        __interval.name() : __interval
    })
    _AttributeMap = AbstractTimeReferenceSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TimeCoordinateSystemType', TimeCoordinateSystemType)


# Complex type KnotType with content type ELEMENT_ONLY
class KnotType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'KnotType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}weight uses Python identifier weight
    __weight = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'weight'), 'weight', '__httpwww_opengis_netgml_KnotType_httpwww_opengis_netgmlweight', False)

    
    weight = property(__weight.value, __weight.set, None, u'The property "weight" is the value of the averaging weight used for this knot of the spline.')

    
    # Element {http://www.opengis.net/gml}multiplicity uses Python identifier multiplicity
    __multiplicity = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'multiplicity'), 'multiplicity', '__httpwww_opengis_netgml_KnotType_httpwww_opengis_netgmlmultiplicity', False)

    
    multiplicity = property(__multiplicity.value, __multiplicity.set, None, u'The property "multiplicity" is the multiplicity of this knot used in the definition of the spline (with the same weight).')

    
    # Element {http://www.opengis.net/gml}value uses Python identifier value_
    __value = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'value'), 'value_', '__httpwww_opengis_netgml_KnotType_httpwww_opengis_netgmlvalue', False)

    
    value_ = property(__value.value, __value.set, None, u'The property "value" is the value of the parameter at the knot of the spline. The sequence of knots shall be a non-decreasing sequence. That is, each knot\'s value in the sequence shall be equal to or greater than the previous knot\'s value. The use of equal consecutive knots is normally handled using the multiplicity.')


    _ElementMap = {
        __weight.name() : __weight,
        __multiplicity.name() : __multiplicity,
        __value.name() : __value
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'KnotType', KnotType)


# Complex type TriangleType with content type ELEMENT_ONLY
class TriangleType (AbstractSurfacePatchType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TriangleType')
    # Base type is AbstractSurfacePatchType
    
    # Element {http://www.opengis.net/gml}exterior uses Python identifier exterior
    __exterior = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'exterior'), 'exterior', '__httpwww_opengis_netgml_TriangleType_httpwww_opengis_netgmlexterior', False)

    
    exterior = property(__exterior.value, __exterior.set, None, u'A boundary of a surface consists of a number of rings. In the normal 2D case, one of these rings is distinguished as being the exterior boundary. In a general manifold this is not always possible, in which case all boundaries shall be listed as interior boundaries, and the exterior will be empty.')

    
    # Attribute interpolation uses Python identifier interpolation
    __interpolation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'interpolation'), 'interpolation', '__httpwww_opengis_netgml_TriangleType_interpolation', SurfaceInterpolationType, fixed=True, unicode_default=u'planar')
    
    interpolation = property(__interpolation.value, __interpolation.set, None, u'The attribute "interpolation" specifies the interpolation mechanism used for this surface patch. Currently only planar surface patches are defined in GML 3, the attribute is fixed to "planar", i.e. the interpolation method shall return points on a single plane. The boundary of the patch shall be contained within that plane.')


    _ElementMap = AbstractSurfacePatchType._ElementMap.copy()
    _ElementMap.update({
        __exterior.name() : __exterior
    })
    _AttributeMap = AbstractSurfacePatchType._AttributeMap.copy()
    _AttributeMap.update({
        __interpolation.name() : __interpolation
    })
Namespace.addCategoryObject('typeBinding', u'TriangleType', TriangleType)


# Complex type ArrayAssociationType with content type ELEMENT_ONLY
class ArrayAssociationType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ArrayAssociationType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_Object uses Python identifier Object
    __Object = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_Object'), 'Object', '__httpwww_opengis_netgml_ArrayAssociationType_httpwww_opengis_netgml_Object', True)

    
    Object = property(__Object.value, __Object.set, None, u'This abstract element is the head of a substitutionGroup hierararchy which may contain either simpleContent or complexContent elements.  It is used to assert the model position of "class" elements declared in other GML schemas.')


    _ElementMap = {
        __Object.name() : __Object
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'ArrayAssociationType', ArrayAssociationType)


# Complex type MultiPointDomainType with content type ELEMENT_ONLY
class MultiPointDomainType (DomainSetType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiPointDomainType')
    # Base type is DomainSetType
    
    # Element {http://www.opengis.net/gml}MultiPoint uses Python identifier MultiPoint
    __MultiPoint = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'MultiPoint'), 'MultiPoint', '__httpwww_opengis_netgml_MultiPointDomainType_httpwww_opengis_netgmlMultiPoint', False)

    
    MultiPoint = property(__MultiPoint.value, __MultiPoint.set, None, None)

    
    # Attribute title is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute show is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute type is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute role is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute actuate is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute remoteSchema is restricted from parent
    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_DomainSetType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute href is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute arcrole is restricted from parent
    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_DomainSetType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)


    _ElementMap = DomainSetType._ElementMap.copy()
    _ElementMap.update({
        __MultiPoint.name() : __MultiPoint
    })
    _AttributeMap = DomainSetType._AttributeMap.copy()
    _AttributeMap.update({
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __href.name() : __href,
        __arcrole.name() : __arcrole
    })
Namespace.addCategoryObject('typeBinding', u'MultiPointDomainType', MultiPointDomainType)


# Complex type OperationRefType with content type ELEMENT_ONLY
class OperationRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'OperationRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_Operation uses Python identifier Operation
    __Operation = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_Operation'), 'Operation', '__httpwww_opengis_netgml_OperationRefType_httpwww_opengis_netgml_Operation', False)

    
    Operation = property(__Operation.value, __Operation.set, None, u'A parameterized mathematical operation on coordinates that transforms or converts coordinates to another coordinate reference system. This coordinate operation uses an operation method, usually with associated parameter values. However, operation methods and parameter values are directly associated with concrete subtypes, not with this abstract type.\n\nThis abstract complexType shall not be directly used, extended, or restricted in a compliant Application Schema. ')

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_OperationRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_OperationRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_OperationRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_OperationRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_OperationRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_OperationRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_OperationRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_OperationRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)


    _ElementMap = {
        __Operation.name() : __Operation
    }
    _AttributeMap = {
        __remoteSchema.name() : __remoteSchema,
        __href.name() : __href,
        __actuate.name() : __actuate,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __show.name() : __show,
        __role.name() : __role,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'OperationRefType', OperationRefType)


# Complex type TimeOrdinalReferenceSystemType with content type ELEMENT_ONLY
class TimeOrdinalReferenceSystemType (AbstractTimeReferenceSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeOrdinalReferenceSystemType')
    # Base type is AbstractTimeReferenceSystemType
    
    # Element {http://www.opengis.net/gml}component uses Python identifier component
    __component = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'component'), 'component', '__httpwww_opengis_netgml_TimeOrdinalReferenceSystemType_httpwww_opengis_netgmlcomponent', True)

    
    component = property(__component.value, __component.set, None, None)

    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element domainOfValidity ({http://www.opengis.net/gml}domainOfValidity) inherited from {http://www.opengis.net/gml}AbstractTimeReferenceSystemType
    
    # Attribute id_ inherited from {http://www.opengis.net/gml}DefinitionType

    _ElementMap = AbstractTimeReferenceSystemType._ElementMap.copy()
    _ElementMap.update({
        __component.name() : __component
    })
    _AttributeMap = AbstractTimeReferenceSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TimeOrdinalReferenceSystemType', TimeOrdinalReferenceSystemType)


# Complex type ImageCRSRefType with content type ELEMENT_ONLY
class ImageCRSRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ImageCRSRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}ImageCRS uses Python identifier ImageCRS
    __ImageCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'ImageCRS'), 'ImageCRS', '__httpwww_opengis_netgml_ImageCRSRefType_httpwww_opengis_netgmlImageCRS', False)

    
    ImageCRS = property(__ImageCRS.value, __ImageCRS.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_ImageCRSRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_ImageCRSRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_ImageCRSRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_ImageCRSRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_ImageCRSRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_ImageCRSRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_ImageCRSRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_ImageCRSRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')


    _ElementMap = {
        __ImageCRS.name() : __ImageCRS
    }
    _AttributeMap = {
        __arcrole.name() : __arcrole,
        __href.name() : __href,
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema
    }
Namespace.addCategoryObject('typeBinding', u'ImageCRSRefType', ImageCRSRefType)


# Complex type EngineeringDatumType with content type ELEMENT_ONLY
class EngineeringDatumType (AbstractDatumType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'EngineeringDatumType')
    # Base type is AbstractDatumType
    
    # Element datumName ({http://www.opengis.net/gml}datumName) inherited from {http://www.opengis.net/gml}AbstractDatumBaseType
    
    # Element realizationEpoch ({http://www.opengis.net/gml}realizationEpoch) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element scope ({http://www.opengis.net/gml}scope) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element datumID ({http://www.opengis.net/gml}datumID) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element validArea ({http://www.opengis.net/gml}validArea) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element anchorPoint ({http://www.opengis.net/gml}anchorPoint) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractDatumBaseType

    _ElementMap = AbstractDatumType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractDatumType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'EngineeringDatumType', EngineeringDatumType)


# Complex type TimeOrdinalEraPropertyType with content type ELEMENT_ONLY
class TimeOrdinalEraPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeOrdinalEraPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TimeOrdinalEra uses Python identifier TimeOrdinalEra
    __TimeOrdinalEra = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TimeOrdinalEra'), 'TimeOrdinalEra', '__httpwww_opengis_netgml_TimeOrdinalEraPropertyType_httpwww_opengis_netgmlTimeOrdinalEra', False)

    
    TimeOrdinalEra = property(__TimeOrdinalEra.value, __TimeOrdinalEra.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_TimeOrdinalEraPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_TimeOrdinalEraPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_TimeOrdinalEraPropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_TimeOrdinalEraPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_TimeOrdinalEraPropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_TimeOrdinalEraPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_TimeOrdinalEraPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_TimeOrdinalEraPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)


    _ElementMap = {
        __TimeOrdinalEra.name() : __TimeOrdinalEra
    }
    _AttributeMap = {
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __show.name() : __show,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __href.name() : __href
    }
Namespace.addCategoryObject('typeBinding', u'TimeOrdinalEraPropertyType', TimeOrdinalEraPropertyType)


# Complex type GridLengthType with content type SIMPLE
class GridLengthType (MeasureType):
    _TypeDefinition = STD_ANON_9
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GridLengthType')
    # Base type is MeasureType
    
    # Attribute uom inherited from {http://www.opengis.net/gml}MeasureType

    _ElementMap = MeasureType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = MeasureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'GridLengthType', GridLengthType)


# Complex type TimeOrdinalEraType with content type ELEMENT_ONLY
class TimeOrdinalEraType (DefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeOrdinalEraType')
    # Base type is DefinitionType
    
    # Element {http://www.opengis.net/gml}group uses Python identifier group
    __group = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'group'), 'group', '__httpwww_opengis_netgml_TimeOrdinalEraType_httpwww_opengis_netgmlgroup', False)

    
    group = property(__group.value, __group.set, None, u'In a particular Time System, an Era may be a member of a group.  The "group" element implements the back-pointer to the Era at the next level up in the hierarchy. \n\nIf the hierarchy is represented by describing the nested components fully in the their nested position inside "member" elements, then the parent can be easily inferred, so the group property is unnecessary.  \n\nHowever, if the hierarchy is represented by links carried on the "member" property elements, pointing to Eras described fully elsewhere, then it may be useful for a child (member) era to carry an explicit pointer back to its parent (group) Era.')

    
    # Element {http://www.opengis.net/gml}end uses Python identifier end
    __end = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'end'), 'end', '__httpwww_opengis_netgml_TimeOrdinalEraType_httpwww_opengis_netgmlend', False)

    
    end = property(__end.value, __end.set, None, None)

    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}extent uses Python identifier extent
    __extent = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'extent'), 'extent', '__httpwww_opengis_netgml_TimeOrdinalEraType_httpwww_opengis_netgmlextent', False)

    
    extent = property(__extent.value, __extent.set, None, None)

    
    # Element {http://www.opengis.net/gml}start uses Python identifier start
    __start = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'start'), 'start', '__httpwww_opengis_netgml_TimeOrdinalEraType_httpwww_opengis_netgmlstart', False)

    
    start = property(__start.value, __start.set, None, None)

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}member uses Python identifier member
    __member = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'member'), 'member', '__httpwww_opengis_netgml_TimeOrdinalEraType_httpwww_opengis_netgmlmember', True)

    
    member = property(__member.value, __member.set, None, u'An Era may be composed of several member Eras. The "member" element implements the association to the Era at the next level down the hierarchy.  "member" follows the standard GML property pattern whereby its (complex) value may be either described fully inline, or may be the target of a link carried on the member element and described fully elsewhere, either in the same document or from another service.')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}relatedTime uses Python identifier relatedTime
    __relatedTime = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'), 'relatedTime', '__httpwww_opengis_netgml_TimeOrdinalEraType_httpwww_opengis_netgmlrelatedTime', True)

    
    relatedTime = property(__relatedTime.value, __relatedTime.set, None, None)

    
    # Attribute id_ inherited from {http://www.opengis.net/gml}DefinitionType

    _ElementMap = DefinitionType._ElementMap.copy()
    _ElementMap.update({
        __group.name() : __group,
        __end.name() : __end,
        __extent.name() : __extent,
        __start.name() : __start,
        __member.name() : __member,
        __relatedTime.name() : __relatedTime
    })
    _AttributeMap = DefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TimeOrdinalEraType', TimeOrdinalEraType)


# Complex type DerivedCRSRefType with content type ELEMENT_ONLY
class DerivedCRSRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DerivedCRSRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}DerivedCRS uses Python identifier DerivedCRS
    __DerivedCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'DerivedCRS'), 'DerivedCRS', '__httpwww_opengis_netgml_DerivedCRSRefType_httpwww_opengis_netgmlDerivedCRS', False)

    
    DerivedCRS = property(__DerivedCRS.value, __DerivedCRS.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_DerivedCRSRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_DerivedCRSRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_DerivedCRSRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_DerivedCRSRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_DerivedCRSRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_DerivedCRSRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_DerivedCRSRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_DerivedCRSRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)


    _ElementMap = {
        __DerivedCRS.name() : __DerivedCRS
    }
    _AttributeMap = {
        __show.name() : __show,
        __actuate.name() : __actuate,
        __href.name() : __href,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __role.name() : __role,
        __title.name() : __title,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'DerivedCRSRefType', DerivedCRSRefType)


# Complex type RingPropertyType with content type ELEMENT_ONLY
class RingPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'RingPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Ring uses Python identifier Ring
    __Ring = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Ring'), 'Ring', '__httpwww_opengis_netgml_RingPropertyType_httpwww_opengis_netgmlRing', False)

    
    Ring = property(__Ring.value, __Ring.set, None, None)


    _ElementMap = {
        __Ring.name() : __Ring
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'RingPropertyType', RingPropertyType)


# Complex type RelatedTimeType with content type ELEMENT_ONLY
class RelatedTimeType (TimePrimitivePropertyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'RelatedTimeType')
    # Base type is TimePrimitivePropertyType
    
    # Element TimePrimitive ({http://www.opengis.net/gml}_TimePrimitive) inherited from {http://www.opengis.net/gml}TimePrimitivePropertyType
    
    # Attribute href inherited from {http://www.opengis.net/gml}TimePrimitivePropertyType
    
    # Attribute actuate inherited from {http://www.opengis.net/gml}TimePrimitivePropertyType
    
    # Attribute remoteSchema inherited from {http://www.opengis.net/gml}TimePrimitivePropertyType
    
    # Attribute arcrole inherited from {http://www.opengis.net/gml}TimePrimitivePropertyType
    
    # Attribute relativePosition uses Python identifier relativePosition
    __relativePosition = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'relativePosition'), 'relativePosition', '__httpwww_opengis_netgml_RelatedTimeType_relativePosition', STD_ANON_17)
    
    relativePosition = property(__relativePosition.value, __relativePosition.set, None, None)

    
    # Attribute title inherited from {http://www.opengis.net/gml}TimePrimitivePropertyType
    
    # Attribute show inherited from {http://www.opengis.net/gml}TimePrimitivePropertyType
    
    # Attribute role inherited from {http://www.opengis.net/gml}TimePrimitivePropertyType
    
    # Attribute type inherited from {http://www.opengis.net/gml}TimePrimitivePropertyType

    _ElementMap = TimePrimitivePropertyType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = TimePrimitivePropertyType._AttributeMap.copy()
    _AttributeMap.update({
        __relativePosition.name() : __relativePosition
    })
Namespace.addCategoryObject('typeBinding', u'RelatedTimeType', RelatedTimeType)


# Complex type CartesianCSType with content type ELEMENT_ONLY
class CartesianCSType (AbstractCoordinateSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CartesianCSType')
    # Base type is AbstractCoordinateSystemType
    
    # Element usesAxis ({http://www.opengis.net/gml}usesAxis) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element csID ({http://www.opengis.net/gml}csID) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element csName ({http://www.opengis.net/gml}csName) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemBaseType
    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemBaseType

    _ElementMap = AbstractCoordinateSystemType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractCoordinateSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CartesianCSType', CartesianCSType)


# Complex type TopoPrimitiveArrayAssociationType with content type ELEMENT_ONLY
class TopoPrimitiveArrayAssociationType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopoPrimitiveArrayAssociationType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_TopoPrimitive uses Python identifier TopoPrimitive
    __TopoPrimitive = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_TopoPrimitive'), 'TopoPrimitive', '__httpwww_opengis_netgml_TopoPrimitiveArrayAssociationType_httpwww_opengis_netgml_TopoPrimitive', True)

    
    TopoPrimitive = property(__TopoPrimitive.value, __TopoPrimitive.set, None, u'Substitution group branch for Topo Primitives, used by TopoPrimitiveArrayAssociationType')


    _ElementMap = {
        __TopoPrimitive.name() : __TopoPrimitive
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'TopoPrimitiveArrayAssociationType', TopoPrimitiveArrayAssociationType)


# Complex type ImageDatumRefType with content type ELEMENT_ONLY
class ImageDatumRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ImageDatumRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}ImageDatum uses Python identifier ImageDatum
    __ImageDatum = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'ImageDatum'), 'ImageDatum', '__httpwww_opengis_netgml_ImageDatumRefType_httpwww_opengis_netgmlImageDatum', False)

    
    ImageDatum = property(__ImageDatum.value, __ImageDatum.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_ImageDatumRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_ImageDatumRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_ImageDatumRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_ImageDatumRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_ImageDatumRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_ImageDatumRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_ImageDatumRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_ImageDatumRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)


    _ElementMap = {
        __ImageDatum.name() : __ImageDatum
    }
    _AttributeMap = {
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __arcrole.name() : __arcrole,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __href.name() : __href
    }
Namespace.addCategoryObject('typeBinding', u'ImageDatumRefType', ImageDatumRefType)


# Complex type PixelInCellType with content type SIMPLE
class PixelInCellType (CodeType):
    _TypeDefinition = STD_ANON_14
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PixelInCellType')
    # Base type is CodeType
    
    # Attribute codeSpace is restricted from parent
    
    # Attribute codeSpace uses Python identifier codeSpace
    __codeSpace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'codeSpace'), 'codeSpace', '__httpwww_opengis_netgml_CodeType_codeSpace', pyxb.binding.datatypes.anyURI, required=True)
    
    codeSpace = property(__codeSpace.value, __codeSpace.set, None, u'Reference to a source of information specifying the values and meanings of all the allowed string values for this PixelInCellType. ')


    _ElementMap = CodeType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = CodeType._AttributeMap.copy()
    _AttributeMap.update({
        __codeSpace.name() : __codeSpace
    })
Namespace.addCategoryObject('typeBinding', u'PixelInCellType', PixelInCellType)


# Complex type TopoPointType with content type ELEMENT_ONLY
class TopoPointType (AbstractTopologyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopoPointType')
    # Base type is AbstractTopologyType
    
    # Element {http://www.opengis.net/gml}directedNode uses Python identifier directedNode
    __directedNode = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'directedNode'), 'directedNode', '__httpwww_opengis_netgml_TopoPointType_httpwww_opengis_netgmldirectedNode', False)

    
    directedNode = property(__directedNode.value, __directedNode.set, None, u'')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTopologyType._ElementMap.copy()
    _ElementMap.update({
        __directedNode.name() : __directedNode
    })
    _AttributeMap = AbstractTopologyType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TopoPointType', TopoPointType)


# Complex type DerivedUnitType with content type ELEMENT_ONLY
class DerivedUnitType (UnitDefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DerivedUnitType')
    # Base type is UnitDefinitionType
    
    # Element quantityType ({http://www.opengis.net/gml}quantityType) inherited from {http://www.opengis.net/gml}UnitDefinitionType
    
    # Element catalogSymbol ({http://www.opengis.net/gml}catalogSymbol) inherited from {http://www.opengis.net/gml}UnitDefinitionType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}derivationUnitTerm uses Python identifier derivationUnitTerm
    __derivationUnitTerm = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'derivationUnitTerm'), 'derivationUnitTerm', '__httpwww_opengis_netgml_DerivedUnitType_httpwww_opengis_netgmlderivationUnitTerm', True)

    
    derivationUnitTerm = property(__derivationUnitTerm.value, __derivationUnitTerm.set, None, None)

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id_ inherited from {http://www.opengis.net/gml}DefinitionType

    _ElementMap = UnitDefinitionType._ElementMap.copy()
    _ElementMap.update({
        __derivationUnitTerm.name() : __derivationUnitTerm
    })
    _AttributeMap = UnitDefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'DerivedUnitType', DerivedUnitType)


# Complex type TimeInstantType with content type ELEMENT_ONLY
class TimeInstantType (AbstractTimeGeometricPrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeInstantType')
    # Base type is AbstractTimeGeometricPrimitiveType
    
    # Element {http://www.opengis.net/gml}timePosition uses Python identifier timePosition
    __timePosition = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'timePosition'), 'timePosition', '__httpwww_opengis_netgml_TimeInstantType_httpwww_opengis_netgmltimePosition', False)

    
    timePosition = property(__timePosition.value, __timePosition.set, None, u'Direct representation of a temporal position')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element relatedTime ({http://www.opengis.net/gml}relatedTime) inherited from {http://www.opengis.net/gml}AbstractTimePrimitiveType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute frame inherited from {http://www.opengis.net/gml}AbstractTimeGeometricPrimitiveType

    _ElementMap = AbstractTimeGeometricPrimitiveType._ElementMap.copy()
    _ElementMap.update({
        __timePosition.name() : __timePosition
    })
    _AttributeMap = AbstractTimeGeometricPrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TimeInstantType', TimeInstantType)


# Complex type GeometryStylePropertyType with content type ELEMENT_ONLY
class GeometryStylePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeometryStylePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}GeometryStyle uses Python identifier GeometryStyle
    __GeometryStyle = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'GeometryStyle'), 'GeometryStyle', '__httpwww_opengis_netgml_GeometryStylePropertyType_httpwww_opengis_netgmlGeometryStyle', False)

    
    GeometryStyle = property(__GeometryStyle.value, __GeometryStyle.set, None, u'The style descriptor for geometries of a feature.')

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_GeometryStylePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_GeometryStylePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_GeometryStylePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute about uses Python identifier about
    __about = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'about'), 'about', '__httpwww_opengis_netgml_GeometryStylePropertyType_about', pyxb.binding.datatypes.anyURI)
    
    about = property(__about.value, __about.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_GeometryStylePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_GeometryStylePropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_GeometryStylePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_GeometryStylePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_GeometryStylePropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")


    _ElementMap = {
        __GeometryStyle.name() : __GeometryStyle
    }
    _AttributeMap = {
        __type.name() : __type,
        __href.name() : __href,
        __role.name() : __role,
        __about.name() : __about,
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __show.name() : __show
    }
Namespace.addCategoryObject('typeBinding', u'GeometryStylePropertyType', GeometryStylePropertyType)


# Complex type TimeCalendarType with content type ELEMENT_ONLY
class TimeCalendarType (AbstractTimeReferenceSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeCalendarType')
    # Base type is AbstractTimeReferenceSystemType
    
    # Element {http://www.opengis.net/gml}referenceFrame uses Python identifier referenceFrame
    __referenceFrame = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'referenceFrame'), 'referenceFrame', '__httpwww_opengis_netgml_TimeCalendarType_httpwww_opengis_netgmlreferenceFrame', True)

    
    referenceFrame = property(__referenceFrame.value, __referenceFrame.set, None, u'Link to the CalendarEras that it uses as a reference for dating.')

    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element domainOfValidity ({http://www.opengis.net/gml}domainOfValidity) inherited from {http://www.opengis.net/gml}AbstractTimeReferenceSystemType
    
    # Attribute id_ inherited from {http://www.opengis.net/gml}DefinitionType

    _ElementMap = AbstractTimeReferenceSystemType._ElementMap.copy()
    _ElementMap.update({
        __referenceFrame.name() : __referenceFrame
    })
    _AttributeMap = AbstractTimeReferenceSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TimeCalendarType', TimeCalendarType)


# Complex type VerticalDatumType with content type ELEMENT_ONLY
class VerticalDatumType (AbstractDatumType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VerticalDatumType')
    # Base type is AbstractDatumType
    
    # Element {http://www.opengis.net/gml}verticalDatumType uses Python identifier verticalDatumType
    __verticalDatumType = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'verticalDatumType'), 'verticalDatumType', '__httpwww_opengis_netgml_VerticalDatumType_httpwww_opengis_netgmlverticalDatumType', False)

    
    verticalDatumType = property(__verticalDatumType.value, __verticalDatumType.set, None, None)

    
    # Element datumName ({http://www.opengis.net/gml}datumName) inherited from {http://www.opengis.net/gml}AbstractDatumBaseType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element scope ({http://www.opengis.net/gml}scope) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element datumID ({http://www.opengis.net/gml}datumID) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element realizationEpoch ({http://www.opengis.net/gml}realizationEpoch) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element validArea ({http://www.opengis.net/gml}validArea) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Element anchorPoint ({http://www.opengis.net/gml}anchorPoint) inherited from {http://www.opengis.net/gml}AbstractDatumType
    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractDatumBaseType

    _ElementMap = AbstractDatumType._ElementMap.copy()
    _ElementMap.update({
        __verticalDatumType.name() : __verticalDatumType
    })
    _AttributeMap = AbstractDatumType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'VerticalDatumType', VerticalDatumType)


# Complex type CoordinateSystemAxisRefType with content type ELEMENT_ONLY
class CoordinateSystemAxisRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CoordinateSystemAxisRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}CoordinateSystemAxis uses Python identifier CoordinateSystemAxis
    __CoordinateSystemAxis = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CoordinateSystemAxis'), 'CoordinateSystemAxis', '__httpwww_opengis_netgml_CoordinateSystemAxisRefType_httpwww_opengis_netgmlCoordinateSystemAxis', False)

    
    CoordinateSystemAxis = property(__CoordinateSystemAxis.value, __CoordinateSystemAxis.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_CoordinateSystemAxisRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_CoordinateSystemAxisRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_CoordinateSystemAxisRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_CoordinateSystemAxisRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_CoordinateSystemAxisRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_CoordinateSystemAxisRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_CoordinateSystemAxisRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_CoordinateSystemAxisRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')


    _ElementMap = {
        __CoordinateSystemAxis.name() : __CoordinateSystemAxis
    }
    _AttributeMap = {
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __href.name() : __href,
        __remoteSchema.name() : __remoteSchema
    }
Namespace.addCategoryObject('typeBinding', u'CoordinateSystemAxisRefType', CoordinateSystemAxisRefType)


# Complex type SolidArrayPropertyType with content type ELEMENT_ONLY
class SolidArrayPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SolidArrayPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_Solid uses Python identifier Solid
    __Solid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_Solid'), 'Solid', '__httpwww_opengis_netgml_SolidArrayPropertyType_httpwww_opengis_netgml_Solid', True)

    
    Solid = property(__Solid.value, __Solid.set, None, u'The "_Solid" element is the abstract head of the substituition group for all (continuous) solid elements.')


    _ElementMap = {
        __Solid.name() : __Solid
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'SolidArrayPropertyType', SolidArrayPropertyType)


# Complex type TimeCalendarEraPropertyType with content type ELEMENT_ONLY
class TimeCalendarEraPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeCalendarEraPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TimeCalendarEra uses Python identifier TimeCalendarEra
    __TimeCalendarEra = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TimeCalendarEra'), 'TimeCalendarEra', '__httpwww_opengis_netgml_TimeCalendarEraPropertyType_httpwww_opengis_netgmlTimeCalendarEra', False)

    
    TimeCalendarEra = property(__TimeCalendarEra.value, __TimeCalendarEra.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_TimeCalendarEraPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_TimeCalendarEraPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_TimeCalendarEraPropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_TimeCalendarEraPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_TimeCalendarEraPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_TimeCalendarEraPropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_TimeCalendarEraPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_TimeCalendarEraPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)


    _ElementMap = {
        __TimeCalendarEra.name() : __TimeCalendarEra
    }
    _AttributeMap = {
        __title.name() : __title,
        __role.name() : __role,
        __show.name() : __show,
        __type.name() : __type,
        __href.name() : __href,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole
    }
Namespace.addCategoryObject('typeBinding', u'TimeCalendarEraPropertyType', TimeCalendarEraPropertyType)


# Complex type OrientableCurveType with content type ELEMENT_ONLY
class OrientableCurveType (AbstractCurveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'OrientableCurveType')
    # Base type is AbstractCurveType
    
    # Element {http://www.opengis.net/gml}baseCurve uses Python identifier baseCurve
    __baseCurve = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'baseCurve'), 'baseCurve', '__httpwww_opengis_netgml_OrientableCurveType_httpwww_opengis_netgmlbaseCurve', False)

    
    baseCurve = property(__baseCurve.value, __baseCurve.set, None, u'This property element either references a curve via the XLink-attributes or contains the curve element. A curve element is any element which is substitutable for "_Curve".')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute orientation uses Python identifier orientation
    __orientation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'orientation'), 'orientation', '__httpwww_opengis_netgml_OrientableCurveType_orientation', SignType, unicode_default=u'+')
    
    orientation = property(__orientation.value, __orientation.set, None, u'If the orientation is "+", then the OrientableCurve is identical to the baseCurve. If the orientation is "-", then the OrientableCurve is related to another _Curve with a parameterization that reverses the sense of the curve traversal. "+" is the default value.')


    _ElementMap = AbstractCurveType._ElementMap.copy()
    _ElementMap.update({
        __baseCurve.name() : __baseCurve
    })
    _AttributeMap = AbstractCurveType._AttributeMap.copy()
    _AttributeMap.update({
        __orientation.name() : __orientation
    })
Namespace.addCategoryObject('typeBinding', u'OrientableCurveType', OrientableCurveType)


# Complex type TopoPrimitiveMemberType with content type ELEMENT_ONLY
class TopoPrimitiveMemberType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopoPrimitiveMemberType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_TopoPrimitive uses Python identifier TopoPrimitive
    __TopoPrimitive = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_TopoPrimitive'), 'TopoPrimitive', '__httpwww_opengis_netgml_TopoPrimitiveMemberType_httpwww_opengis_netgml_TopoPrimitive', False)

    
    TopoPrimitive = property(__TopoPrimitive.value, __TopoPrimitive.set, None, u'Substitution group branch for Topo Primitives, used by TopoPrimitiveArrayAssociationType')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_TopoPrimitiveMemberType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_TopoPrimitiveMemberType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_TopoPrimitiveMemberType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_TopoPrimitiveMemberType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_TopoPrimitiveMemberType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_TopoPrimitiveMemberType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_TopoPrimitiveMemberType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_TopoPrimitiveMemberType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)


    _ElementMap = {
        __TopoPrimitive.name() : __TopoPrimitive
    }
    _AttributeMap = {
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __href.name() : __href
    }
Namespace.addCategoryObject('typeBinding', u'TopoPrimitiveMemberType', TopoPrimitiveMemberType)


# Complex type TemporalCSType with content type ELEMENT_ONLY
class TemporalCSType (AbstractCoordinateSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TemporalCSType')
    # Base type is AbstractCoordinateSystemType
    
    # Element usesAxis ({http://www.opengis.net/gml}usesAxis) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element csID ({http://www.opengis.net/gml}csID) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element csName ({http://www.opengis.net/gml}csName) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemBaseType
    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemBaseType

    _ElementMap = AbstractCoordinateSystemType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractCoordinateSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TemporalCSType', TemporalCSType)


# Complex type CompositeSolidPropertyType with content type ELEMENT_ONLY
class CompositeSolidPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CompositeSolidPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}CompositeSolid uses Python identifier CompositeSolid
    __CompositeSolid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CompositeSolid'), 'CompositeSolid', '__httpwww_opengis_netgml_CompositeSolidPropertyType_httpwww_opengis_netgmlCompositeSolid', False)

    
    CompositeSolid = property(__CompositeSolid.value, __CompositeSolid.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_CompositeSolidPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_CompositeSolidPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_CompositeSolidPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_CompositeSolidPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_CompositeSolidPropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_CompositeSolidPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_CompositeSolidPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_CompositeSolidPropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")


    _ElementMap = {
        __CompositeSolid.name() : __CompositeSolid
    }
    _AttributeMap = {
        __title.name() : __title,
        __href.name() : __href,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __show.name() : __show
    }
Namespace.addCategoryObject('typeBinding', u'CompositeSolidPropertyType', CompositeSolidPropertyType)


# Complex type LengthType with content type SIMPLE
class LengthType (MeasureType):
    _TypeDefinition = STD_ANON_13
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LengthType')
    # Base type is MeasureType
    
    # Attribute uom inherited from {http://www.opengis.net/gml}MeasureType

    _ElementMap = MeasureType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = MeasureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'LengthType', LengthType)


# Complex type AbsoluteExternalPositionalAccuracyType with content type ELEMENT_ONLY
class AbsoluteExternalPositionalAccuracyType (AbstractPositionalAccuracyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AbsoluteExternalPositionalAccuracyType')
    # Base type is AbstractPositionalAccuracyType
    
    # Element {http://www.opengis.net/gml}result uses Python identifier result
    __result = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'result'), 'result', '__httpwww_opengis_netgml_AbsoluteExternalPositionalAccuracyType_httpwww_opengis_netgmlresult', False)

    
    result = property(__result.value, __result.set, None, u'A quantitative result defined by the evaluation procedure used, and identified by the measureDescription. ')

    
    # Element measureDescription ({http://www.opengis.net/gml}measureDescription) inherited from {http://www.opengis.net/gml}AbstractPositionalAccuracyType

    _ElementMap = AbstractPositionalAccuracyType._ElementMap.copy()
    _ElementMap.update({
        __result.name() : __result
    })
    _AttributeMap = AbstractPositionalAccuracyType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AbsoluteExternalPositionalAccuracyType', AbsoluteExternalPositionalAccuracyType)


# Complex type TimeNodeType with content type ELEMENT_ONLY
class TimeNodeType (AbstractTimeTopologyPrimitiveType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeNodeType')
    # Base type is AbstractTimeTopologyPrimitiveType
    
    # Element {http://www.opengis.net/gml}nextEdge uses Python identifier nextEdge
    __nextEdge = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'nextEdge'), 'nextEdge', '__httpwww_opengis_netgml_TimeNodeType_httpwww_opengis_netgmlnextEdge', True)

    
    nextEdge = property(__nextEdge.value, __nextEdge.set, None, None)

    
    # Element complex ({http://www.opengis.net/gml}complex) inherited from {http://www.opengis.net/gml}AbstractTimeTopologyPrimitiveType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element relatedTime ({http://www.opengis.net/gml}relatedTime) inherited from {http://www.opengis.net/gml}AbstractTimePrimitiveType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}position uses Python identifier position
    __position = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'position'), 'position', '__httpwww_opengis_netgml_TimeNodeType_httpwww_opengis_netgmlposition', False)

    
    position = property(__position.value, __position.set, None, None)

    
    # Element {http://www.opengis.net/gml}previousEdge uses Python identifier previousEdge
    __previousEdge = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'previousEdge'), 'previousEdge', '__httpwww_opengis_netgml_TimeNodeType_httpwww_opengis_netgmlpreviousEdge', True)

    
    previousEdge = property(__previousEdge.value, __previousEdge.set, None, None)

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTimeTopologyPrimitiveType._ElementMap.copy()
    _ElementMap.update({
        __nextEdge.name() : __nextEdge,
        __position.name() : __position,
        __previousEdge.name() : __previousEdge
    })
    _AttributeMap = AbstractTimeTopologyPrimitiveType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TimeNodeType', TimeNodeType)


# Complex type MovingObjectStatusType with content type ELEMENT_ONLY
class MovingObjectStatusType (AbstractTimeSliceType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MovingObjectStatusType')
    # Base type is AbstractTimeSliceType
    
    # Element {http://www.opengis.net/gml}elevation uses Python identifier elevation
    __elevation = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'elevation'), 'elevation', '__httpwww_opengis_netgml_MovingObjectStatusType_httpwww_opengis_netgmlelevation', False)

    
    elevation = property(__elevation.value, __elevation.set, None, None)

    
    # Element dataSource ({http://www.opengis.net/gml}dataSource) inherited from {http://www.opengis.net/gml}AbstractTimeSliceType
    
    # Element {http://www.opengis.net/gml}bearing uses Python identifier bearing
    __bearing = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'bearing'), 'bearing', '__httpwww_opengis_netgml_MovingObjectStatusType_httpwww_opengis_netgmlbearing', False)

    
    bearing = property(__bearing.value, __bearing.set, None, None)

    
    # Element {http://www.opengis.net/gml}speed uses Python identifier speed
    __speed = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'speed'), 'speed', '__httpwww_opengis_netgml_MovingObjectStatusType_httpwww_opengis_netgmlspeed', False)

    
    speed = property(__speed.value, __speed.set, None, None)

    
    # Element {http://www.opengis.net/gml}status uses Python identifier status
    __status = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'status'), 'status', '__httpwww_opengis_netgml_MovingObjectStatusType_httpwww_opengis_netgmlstatus', False)

    
    status = property(__status.value, __status.set, None, None)

    
    # Element {http://www.opengis.net/gml}location uses Python identifier location
    __location = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'location'), 'location', '__httpwww_opengis_netgml_MovingObjectStatusType_httpwww_opengis_netgmllocation', False)

    
    location = property(__location.value, __location.set, None, u'Deprecated in GML 3.1.0')

    
    # Element {http://www.opengis.net/gml}acceleration uses Python identifier acceleration
    __acceleration = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'acceleration'), 'acceleration', '__httpwww_opengis_netgml_MovingObjectStatusType_httpwww_opengis_netgmlacceleration', False)

    
    acceleration = property(__acceleration.value, __acceleration.set, None, None)

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element validTime ({http://www.opengis.net/gml}validTime) inherited from {http://www.opengis.net/gml}AbstractTimeSliceType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractTimeSliceType._ElementMap.copy()
    _ElementMap.update({
        __elevation.name() : __elevation,
        __bearing.name() : __bearing,
        __speed.name() : __speed,
        __status.name() : __status,
        __location.name() : __location,
        __acceleration.name() : __acceleration
    })
    _AttributeMap = AbstractTimeSliceType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MovingObjectStatusType', MovingObjectStatusType)


# Complex type CovarianceMatrixType with content type ELEMENT_ONLY
class CovarianceMatrixType (AbstractPositionalAccuracyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CovarianceMatrixType')
    # Base type is AbstractPositionalAccuracyType
    
    # Element {http://www.opengis.net/gml}includesElement uses Python identifier includesElement
    __includesElement = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'includesElement'), 'includesElement', '__httpwww_opengis_netgml_CovarianceMatrixType_httpwww_opengis_netgmlincludesElement', True)

    
    includesElement = property(__includesElement.value, __includesElement.set, None, None)

    
    # Element {http://www.opengis.net/gml}unitOfMeasure uses Python identifier unitOfMeasure
    __unitOfMeasure = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'unitOfMeasure'), 'unitOfMeasure', '__httpwww_opengis_netgml_CovarianceMatrixType_httpwww_opengis_netgmlunitOfMeasure', True)

    
    unitOfMeasure = property(__unitOfMeasure.value, __unitOfMeasure.set, None, None)

    
    # Element measureDescription ({http://www.opengis.net/gml}measureDescription) inherited from {http://www.opengis.net/gml}AbstractPositionalAccuracyType

    _ElementMap = AbstractPositionalAccuracyType._ElementMap.copy()
    _ElementMap.update({
        __includesElement.name() : __includesElement,
        __unitOfMeasure.name() : __unitOfMeasure
    })
    _AttributeMap = AbstractPositionalAccuracyType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CovarianceMatrixType', CovarianceMatrixType)


# Complex type ConventionalUnitType with content type ELEMENT_ONLY
class ConventionalUnitType (UnitDefinitionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ConventionalUnitType')
    # Base type is UnitDefinitionType
    
    # Element quantityType ({http://www.opengis.net/gml}quantityType) inherited from {http://www.opengis.net/gml}UnitDefinitionType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element catalogSymbol ({http://www.opengis.net/gml}catalogSymbol) inherited from {http://www.opengis.net/gml}UnitDefinitionType
    
    # Element {http://www.opengis.net/gml}roughConversionToPreferredUnit uses Python identifier roughConversionToPreferredUnit
    __roughConversionToPreferredUnit = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'roughConversionToPreferredUnit'), 'roughConversionToPreferredUnit', '__httpwww_opengis_netgml_ConventionalUnitType_httpwww_opengis_netgmlroughConversionToPreferredUnit', False)

    
    roughConversionToPreferredUnit = property(__roughConversionToPreferredUnit.value, __roughConversionToPreferredUnit.set, None, u'This element is included when the correct definition of this unit is unknown, but this unit has a rough or inaccurate conversion to the preferred unit for this quantity type.')

    
    # Element {http://www.opengis.net/gml}derivationUnitTerm uses Python identifier derivationUnitTerm
    __derivationUnitTerm = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'derivationUnitTerm'), 'derivationUnitTerm', '__httpwww_opengis_netgml_ConventionalUnitType_httpwww_opengis_netgmlderivationUnitTerm', True)

    
    derivationUnitTerm = property(__derivationUnitTerm.value, __derivationUnitTerm.set, None, None)

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}conversionToPreferredUnit uses Python identifier conversionToPreferredUnit
    __conversionToPreferredUnit = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'conversionToPreferredUnit'), 'conversionToPreferredUnit', '__httpwww_opengis_netgml_ConventionalUnitType_httpwww_opengis_netgmlconversionToPreferredUnit', False)

    
    conversionToPreferredUnit = property(__conversionToPreferredUnit.value, __conversionToPreferredUnit.set, None, u'This element is included when this unit has an accurate conversion to the preferred unit for this quantity type.')

    
    # Attribute id_ inherited from {http://www.opengis.net/gml}DefinitionType

    _ElementMap = UnitDefinitionType._ElementMap.copy()
    _ElementMap.update({
        __roughConversionToPreferredUnit.name() : __roughConversionToPreferredUnit,
        __derivationUnitTerm.name() : __derivationUnitTerm,
        __conversionToPreferredUnit.name() : __conversionToPreferredUnit
    })
    _AttributeMap = UnitDefinitionType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ConventionalUnitType', ConventionalUnitType)


# Complex type CovarianceElementType with content type ELEMENT_ONLY
class CovarianceElementType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CovarianceElementType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}columnIndex uses Python identifier columnIndex
    __columnIndex = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'columnIndex'), 'columnIndex', '__httpwww_opengis_netgml_CovarianceElementType_httpwww_opengis_netgmlcolumnIndex', False)

    
    columnIndex = property(__columnIndex.value, __columnIndex.set, None, u'Column number of this covariance element value. ')

    
    # Element {http://www.opengis.net/gml}covariance uses Python identifier covariance
    __covariance = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'covariance'), 'covariance', '__httpwww_opengis_netgml_CovarianceElementType_httpwww_opengis_netgmlcovariance', False)

    
    covariance = property(__covariance.value, __covariance.set, None, u'Value of covariance matrix element. ')

    
    # Element {http://www.opengis.net/gml}rowIndex uses Python identifier rowIndex
    __rowIndex = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'rowIndex'), 'rowIndex', '__httpwww_opengis_netgml_CovarianceElementType_httpwww_opengis_netgmlrowIndex', False)

    
    rowIndex = property(__rowIndex.value, __rowIndex.set, None, u'Row number of this covariance element value. ')


    _ElementMap = {
        __columnIndex.name() : __columnIndex,
        __covariance.name() : __covariance,
        __rowIndex.name() : __rowIndex
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'CovarianceElementType', CovarianceElementType)


# Complex type CodeListType with content type SIMPLE
class CodeListType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = NameList
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CodeListType')
    # Base type is NameList
    
    # Attribute codeSpace uses Python identifier codeSpace
    __codeSpace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'codeSpace'), 'codeSpace', '__httpwww_opengis_netgml_CodeListType_codeSpace', pyxb.binding.datatypes.anyURI)
    
    codeSpace = property(__codeSpace.value, __codeSpace.set, None, None)


    _ElementMap = {
        
    }
    _AttributeMap = {
        __codeSpace.name() : __codeSpace
    }
Namespace.addCategoryObject('typeBinding', u'CodeListType', CodeListType)


# Complex type PassThroughOperationType with content type ELEMENT_ONLY
class PassThroughOperationType (AbstractCoordinateOperationType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PassThroughOperationType')
    # Base type is AbstractCoordinateOperationType
    
    # Element {http://www.opengis.net/gml}usesOperation uses Python identifier usesOperation
    __usesOperation = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesOperation'), 'usesOperation', '__httpwww_opengis_netgml_PassThroughOperationType_httpwww_opengis_netgmlusesOperation', False)

    
    usesOperation = property(__usesOperation.value, __usesOperation.set, None, u'Association to the operation applied to the specified ordinates. ')

    
    # Element positionalAccuracy ({http://www.opengis.net/gml}_positionalAccuracy) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element coordinateOperationName ({http://www.opengis.net/gml}coordinateOperationName) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationBaseType
    
    # Element validArea ({http://www.opengis.net/gml}validArea) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element sourceCRS ({http://www.opengis.net/gml}sourceCRS) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}modifiedCoordinate uses Python identifier modifiedCoordinate
    __modifiedCoordinate = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'modifiedCoordinate'), 'modifiedCoordinate', '__httpwww_opengis_netgml_PassThroughOperationType_httpwww_opengis_netgmlmodifiedCoordinate', True)

    
    modifiedCoordinate = property(__modifiedCoordinate.value, __modifiedCoordinate.set, None, u'A positive integer defining a position in a coordinate tuple. ')

    
    # Element targetCRS ({http://www.opengis.net/gml}targetCRS) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element operationVersion ({http://www.opengis.net/gml}operationVersion) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element coordinateOperationID ({http://www.opengis.net/gml}coordinateOperationID) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element scope ({http://www.opengis.net/gml}scope) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationBaseType

    _ElementMap = AbstractCoordinateOperationType._ElementMap.copy()
    _ElementMap.update({
        __usesOperation.name() : __usesOperation,
        __modifiedCoordinate.name() : __modifiedCoordinate
    })
    _AttributeMap = AbstractCoordinateOperationType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'PassThroughOperationType', PassThroughOperationType)


# Complex type TimeTopologyPrimitivePropertyType with content type ELEMENT_ONLY
class TimeTopologyPrimitivePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeTopologyPrimitivePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_TimeTopologyPrimitive uses Python identifier TimeTopologyPrimitive
    __TimeTopologyPrimitive = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_TimeTopologyPrimitive'), 'TimeTopologyPrimitive', '__httpwww_opengis_netgml_TimeTopologyPrimitivePropertyType_httpwww_opengis_netgml_TimeTopologyPrimitive', False)

    
    TimeTopologyPrimitive = property(__TimeTopologyPrimitive.value, __TimeTopologyPrimitive.set, None, u'This abstract element acts as the head of the substitution group for temporal topology primitives.')

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_TimeTopologyPrimitivePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_TimeTopologyPrimitivePropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_TimeTopologyPrimitivePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_TimeTopologyPrimitivePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_TimeTopologyPrimitivePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_TimeTopologyPrimitivePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_TimeTopologyPrimitivePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_TimeTopologyPrimitivePropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")


    _ElementMap = {
        __TimeTopologyPrimitive.name() : __TimeTopologyPrimitive
    }
    _AttributeMap = {
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role,
        __href.name() : __href,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __actuate.name() : __actuate
    }
Namespace.addCategoryObject('typeBinding', u'TimeTopologyPrimitivePropertyType', TimeTopologyPrimitivePropertyType)


# Complex type ParameterValueGroupType with content type ELEMENT_ONLY
class ParameterValueGroupType (AbstractGeneralParameterValueType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ParameterValueGroupType')
    # Base type is AbstractGeneralParameterValueType
    
    # Element {http://www.opengis.net/gml}includesValue uses Python identifier includesValue
    __includesValue = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'includesValue'), 'includesValue', '__httpwww_opengis_netgml_ParameterValueGroupType_httpwww_opengis_netgmlincludesValue', True)

    
    includesValue = property(__includesValue.value, __includesValue.set, None, u'A composition association to a parameter value or group of values included in this group. ')

    
    # Element {http://www.opengis.net/gml}valuesOfGroup uses Python identifier valuesOfGroup
    __valuesOfGroup = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'valuesOfGroup'), 'valuesOfGroup', '__httpwww_opengis_netgml_ParameterValueGroupType_httpwww_opengis_netgmlvaluesOfGroup', False)

    
    valuesOfGroup = property(__valuesOfGroup.value, __valuesOfGroup.set, None, u'Association to the operation parameter group for which this element provides parameter values. ')


    _ElementMap = AbstractGeneralParameterValueType._ElementMap.copy()
    _ElementMap.update({
        __includesValue.name() : __includesValue,
        __valuesOfGroup.name() : __valuesOfGroup
    })
    _AttributeMap = AbstractGeneralParameterValueType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ParameterValueGroupType', ParameterValueGroupType)


# Complex type GeometricPrimitivePropertyType with content type ELEMENT_ONLY
class GeometricPrimitivePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeometricPrimitivePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_GeometricPrimitive uses Python identifier GeometricPrimitive
    __GeometricPrimitive = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_GeometricPrimitive'), 'GeometricPrimitive', '__httpwww_opengis_netgml_GeometricPrimitivePropertyType_httpwww_opengis_netgml_GeometricPrimitive', False)

    
    GeometricPrimitive = property(__GeometricPrimitive.value, __GeometricPrimitive.set, None, u'The "_GeometricPrimitive" element is the abstract head of the substituition group for all (pre- and user-defined) \n\t\t\tgeometric primitives.')

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_GeometricPrimitivePropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_GeometricPrimitivePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_GeometricPrimitivePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_GeometricPrimitivePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_GeometricPrimitivePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_GeometricPrimitivePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_GeometricPrimitivePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_GeometricPrimitivePropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")


    _ElementMap = {
        __GeometricPrimitive.name() : __GeometricPrimitive
    }
    _AttributeMap = {
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __href.name() : __href,
        __title.name() : __title,
        __type.name() : __type,
        __role.name() : __role,
        __show.name() : __show
    }
Namespace.addCategoryObject('typeBinding', u'GeometricPrimitivePropertyType', GeometricPrimitivePropertyType)


# Complex type OrientableSurfaceType with content type ELEMENT_ONLY
class OrientableSurfaceType (AbstractSurfaceType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'OrientableSurfaceType')
    # Base type is AbstractSurfaceType
    
    # Element {http://www.opengis.net/gml}baseSurface uses Python identifier baseSurface
    __baseSurface = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'baseSurface'), 'baseSurface', '__httpwww_opengis_netgml_OrientableSurfaceType_httpwww_opengis_netgmlbaseSurface', False)

    
    baseSurface = property(__baseSurface.value, __baseSurface.set, None, u'This property element either references a surface via the XLink-attributes or contains the surface element. A surface element is any element which is substitutable for "_Surface".')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute orientation uses Python identifier orientation
    __orientation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'orientation'), 'orientation', '__httpwww_opengis_netgml_OrientableSurfaceType_orientation', SignType, unicode_default=u'+')
    
    orientation = property(__orientation.value, __orientation.set, None, u'If the orientation is "+", then the OrientableSurface is identical to the baseSurface. If the orientation is "-", then the OrientableSurface is a reference to a Surface with an up-normal that reverses the direction for this OrientableSurface, the sense of "the top of the surface". "+" is the default value.')


    _ElementMap = AbstractSurfaceType._ElementMap.copy()
    _ElementMap.update({
        __baseSurface.name() : __baseSurface
    })
    _AttributeMap = AbstractSurfaceType._AttributeMap.copy()
    _AttributeMap.update({
        __orientation.name() : __orientation
    })
Namespace.addCategoryObject('typeBinding', u'OrientableSurfaceType', OrientableSurfaceType)


# Complex type BagType with content type ELEMENT_ONLY
class BagType (AbstractGMLType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'BagType')
    # Base type is AbstractGMLType
    
    # Element {http://www.opengis.net/gml}members uses Python identifier members
    __members = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'members'), 'members', '__httpwww_opengis_netgml_BagType_httpwww_opengis_netgmlmembers', False)

    
    members = property(__members.value, __members.set, None, None)

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}member uses Python identifier member
    __member = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'member'), 'member', '__httpwww_opengis_netgml_BagType_httpwww_opengis_netgmlmember', True)

    
    member = property(__member.value, __member.set, None, None)

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractGMLType._ElementMap.copy()
    _ElementMap.update({
        __members.name() : __members,
        __member.name() : __member
    })
    _AttributeMap = AbstractGMLType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'BagType', BagType)


# Complex type PolygonPatchArrayPropertyType with content type ELEMENT_ONLY
class PolygonPatchArrayPropertyType (SurfacePatchArrayPropertyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PolygonPatchArrayPropertyType')
    # Base type is SurfacePatchArrayPropertyType
    
    # Element {http://www.opengis.net/gml}PolygonPatch uses Python identifier PolygonPatch
    __PolygonPatch = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'PolygonPatch'), 'PolygonPatch', '__httpwww_opengis_netgml_PolygonPatchArrayPropertyType_httpwww_opengis_netgmlPolygonPatch', True)

    
    PolygonPatch = property(__PolygonPatch.value, __PolygonPatch.set, None, None)


    _ElementMap = SurfacePatchArrayPropertyType._ElementMap.copy()
    _ElementMap.update({
        __PolygonPatch.name() : __PolygonPatch
    })
    _AttributeMap = SurfacePatchArrayPropertyType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'PolygonPatchArrayPropertyType', PolygonPatchArrayPropertyType)


# Complex type DynamicFeatureType with content type ELEMENT_ONLY
class DynamicFeatureType (AbstractFeatureType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DynamicFeatureType')
    # Base type is AbstractFeatureType
    
    # Element {http://www.opengis.net/gml}dataSource uses Python identifier dataSource
    __dataSource = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'dataSource'), 'dataSource', '__httpwww_opengis_netgml_DynamicFeatureType_httpwww_opengis_netgmldataSource', False)

    
    dataSource = property(__dataSource.value, __dataSource.set, None, None)

    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element boundedBy ({http://www.opengis.net/gml}boundedBy) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}history uses Python identifier history
    __history = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'history'), 'history', '__httpwww_opengis_netgml_DynamicFeatureType_httpwww_opengis_netgmlhistory', False)

    
    history = property(__history.value, __history.set, None, None)

    
    # Element {http://www.opengis.net/gml}validTime uses Python identifier validTime
    __validTime = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'validTime'), 'validTime', '__httpwww_opengis_netgml_DynamicFeatureType_httpwww_opengis_netgmlvalidTime', False)

    
    validTime = property(__validTime.value, __validTime.set, None, None)

    
    # Element location ({http://www.opengis.net/gml}location) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractFeatureType._ElementMap.copy()
    _ElementMap.update({
        __dataSource.name() : __dataSource,
        __history.name() : __history,
        __validTime.name() : __validTime
    })
    _AttributeMap = AbstractFeatureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'DynamicFeatureType', DynamicFeatureType)


# Complex type ArrayType with content type ELEMENT_ONLY
class ArrayType (AbstractGMLType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ArrayType')
    # Base type is AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}members uses Python identifier members
    __members = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'members'), 'members', '__httpwww_opengis_netgml_ArrayType_httpwww_opengis_netgmlmembers', False)

    
    members = property(__members.value, __members.set, None, None)

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = AbstractGMLType._ElementMap.copy()
    _ElementMap.update({
        __members.name() : __members
    })
    _AttributeMap = AbstractGMLType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ArrayType', ArrayType)


# Complex type FileType with content type ELEMENT_ONLY
class FileType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'FileType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}compression uses Python identifier compression
    __compression = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'compression'), 'compression', '__httpwww_opengis_netgml_FileType_httpwww_opengis_netgmlcompression', False)

    
    compression = property(__compression.value, __compression.set, None, None)

    
    # Element {http://www.opengis.net/gml}mimeType uses Python identifier mimeType
    __mimeType = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'mimeType'), 'mimeType', '__httpwww_opengis_netgml_FileType_httpwww_opengis_netgmlmimeType', False)

    
    mimeType = property(__mimeType.value, __mimeType.set, None, None)

    
    # Element {http://www.opengis.net/gml}fileName uses Python identifier fileName
    __fileName = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'fileName'), 'fileName', '__httpwww_opengis_netgml_FileType_httpwww_opengis_netgmlfileName', False)

    
    fileName = property(__fileName.value, __fileName.set, None, None)

    
    # Element {http://www.opengis.net/gml}rangeParameters uses Python identifier rangeParameters
    __rangeParameters = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'rangeParameters'), 'rangeParameters', '__httpwww_opengis_netgml_FileType_httpwww_opengis_netgmlrangeParameters', False)

    
    rangeParameters = property(__rangeParameters.value, __rangeParameters.set, None, None)

    
    # Element {http://www.opengis.net/gml}fileStructure uses Python identifier fileStructure
    __fileStructure = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'fileStructure'), 'fileStructure', '__httpwww_opengis_netgml_FileType_httpwww_opengis_netgmlfileStructure', False)

    
    fileStructure = property(__fileStructure.value, __fileStructure.set, None, None)


    _ElementMap = {
        __compression.name() : __compression,
        __mimeType.name() : __mimeType,
        __fileName.name() : __fileName,
        __rangeParameters.name() : __rangeParameters,
        __fileStructure.name() : __fileStructure
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'FileType', FileType)


# Complex type PolarCSRefType with content type ELEMENT_ONLY
class PolarCSRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PolarCSRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}PolarCS uses Python identifier PolarCS
    __PolarCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'PolarCS'), 'PolarCS', '__httpwww_opengis_netgml_PolarCSRefType_httpwww_opengis_netgmlPolarCS', False)

    
    PolarCS = property(__PolarCS.value, __PolarCS.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_PolarCSRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_PolarCSRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_PolarCSRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_PolarCSRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_PolarCSRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_PolarCSRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_PolarCSRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_PolarCSRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)


    _ElementMap = {
        __PolarCS.name() : __PolarCS
    }
    _AttributeMap = {
        __remoteSchema.name() : __remoteSchema,
        __actuate.name() : __actuate,
        __href.name() : __href,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __show.name() : __show,
        __role.name() : __role,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'PolarCSRefType', PolarCSRefType)


# Complex type PassThroughOperationRefType with content type ELEMENT_ONLY
class PassThroughOperationRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PassThroughOperationRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}PassThroughOperation uses Python identifier PassThroughOperation
    __PassThroughOperation = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'PassThroughOperation'), 'PassThroughOperation', '__httpwww_opengis_netgml_PassThroughOperationRefType_httpwww_opengis_netgmlPassThroughOperation', False)

    
    PassThroughOperation = property(__PassThroughOperation.value, __PassThroughOperation.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_PassThroughOperationRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_PassThroughOperationRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_PassThroughOperationRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_PassThroughOperationRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_PassThroughOperationRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_PassThroughOperationRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_PassThroughOperationRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_PassThroughOperationRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")


    _ElementMap = {
        __PassThroughOperation.name() : __PassThroughOperation
    }
    _AttributeMap = {
        __type.name() : __type,
        __role.name() : __role,
        __arcrole.name() : __arcrole,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __href.name() : __href,
        __title.name() : __title,
        __show.name() : __show
    }
Namespace.addCategoryObject('typeBinding', u'PassThroughOperationRefType', PassThroughOperationRefType)


# Complex type TopoVolumePropertyType with content type ELEMENT_ONLY
class TopoVolumePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopoVolumePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TopoVolume uses Python identifier TopoVolume
    __TopoVolume = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TopoVolume'), 'TopoVolume', '__httpwww_opengis_netgml_TopoVolumePropertyType_httpwww_opengis_netgmlTopoVolume', False)

    
    TopoVolume = property(__TopoVolume.value, __TopoVolume.set, None, None)


    _ElementMap = {
        __TopoVolume.name() : __TopoVolume
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'TopoVolumePropertyType', TopoVolumePropertyType)


# Complex type DefaultStylePropertyType with content type ELEMENT_ONLY
class DefaultStylePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DefaultStylePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_Style uses Python identifier Style
    __Style = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_Style'), 'Style', '__httpwww_opengis_netgml_DefaultStylePropertyType_httpwww_opengis_netgml_Style', False)

    
    Style = property(__Style.value, __Style.set, None, u'The value of the top-level property. It is an abstract element. Used as the head element of the substitution group for extensibility purposes.')

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_DefaultStylePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_DefaultStylePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_DefaultStylePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_DefaultStylePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_DefaultStylePropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute about uses Python identifier about
    __about = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'about'), 'about', '__httpwww_opengis_netgml_DefaultStylePropertyType_about', pyxb.binding.datatypes.anyURI)
    
    about = property(__about.value, __about.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_DefaultStylePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_DefaultStylePropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_DefaultStylePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')


    _ElementMap = {
        __Style.name() : __Style
    }
    _AttributeMap = {
        __title.name() : __title,
        __href.name() : __href,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __about.name() : __about,
        __arcrole.name() : __arcrole,
        __show.name() : __show,
        __remoteSchema.name() : __remoteSchema
    }
Namespace.addCategoryObject('typeBinding', u'DefaultStylePropertyType', DefaultStylePropertyType)


# Complex type TopoCurvePropertyType with content type ELEMENT_ONLY
class TopoCurvePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TopoCurvePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}TopoCurve uses Python identifier TopoCurve
    __TopoCurve = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'TopoCurve'), 'TopoCurve', '__httpwww_opengis_netgml_TopoCurvePropertyType_httpwww_opengis_netgmlTopoCurve', False)

    
    TopoCurve = property(__TopoCurve.value, __TopoCurve.set, None, None)


    _ElementMap = {
        __TopoCurve.name() : __TopoCurve
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'TopoCurvePropertyType', TopoCurvePropertyType)


# Complex type ConcatenatedOperationType with content type ELEMENT_ONLY
class ConcatenatedOperationType (AbstractCoordinateOperationType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ConcatenatedOperationType')
    # Base type is AbstractCoordinateOperationType
    
    # Element coordinateOperationID ({http://www.opengis.net/gml}coordinateOperationID) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element {http://www.opengis.net/gml}usesSingleOperation uses Python identifier usesSingleOperation
    __usesSingleOperation = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesSingleOperation'), 'usesSingleOperation', '__httpwww_opengis_netgml_ConcatenatedOperationType_httpwww_opengis_netgmlusesSingleOperation', True)

    
    usesSingleOperation = property(__usesSingleOperation.value, __usesSingleOperation.set, None, u'Association to a single operation. ')

    
    # Element positionalAccuracy ({http://www.opengis.net/gml}_positionalAccuracy) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element coordinateOperationName ({http://www.opengis.net/gml}coordinateOperationName) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationBaseType
    
    # Element validArea ({http://www.opengis.net/gml}validArea) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element sourceCRS ({http://www.opengis.net/gml}sourceCRS) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element scope ({http://www.opengis.net/gml}scope) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element targetCRS ({http://www.opengis.net/gml}targetCRS) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Element operationVersion ({http://www.opengis.net/gml}operationVersion) inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationType
    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractCoordinateOperationBaseType

    _ElementMap = AbstractCoordinateOperationType._ElementMap.copy()
    _ElementMap.update({
        __usesSingleOperation.name() : __usesSingleOperation
    })
    _AttributeMap = AbstractCoordinateOperationType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ConcatenatedOperationType', ConcatenatedOperationType)


# Complex type PolarCSType with content type ELEMENT_ONLY
class PolarCSType (AbstractCoordinateSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PolarCSType')
    # Base type is AbstractCoordinateSystemType
    
    # Element usesAxis ({http://www.opengis.net/gml}usesAxis) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element csID ({http://www.opengis.net/gml}csID) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element csName ({http://www.opengis.net/gml}csName) inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemBaseType
    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractCoordinateSystemBaseType

    _ElementMap = AbstractCoordinateSystemType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractCoordinateSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'PolarCSType', PolarCSType)


# Complex type MultiPolygonPropertyType with content type ELEMENT_ONLY
class MultiPolygonPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiPolygonPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}MultiPolygon uses Python identifier MultiPolygon
    __MultiPolygon = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'MultiPolygon'), 'MultiPolygon', '__httpwww_opengis_netgml_MultiPolygonPropertyType_httpwww_opengis_netgmlMultiPolygon', False)

    
    MultiPolygon = property(__MultiPolygon.value, __MultiPolygon.set, None, u'Deprecated with GML 3.0 and included for backwards compatibility with GML 2. Use the "MultiSurface" element instead.')

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_MultiPolygonPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_MultiPolygonPropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_MultiPolygonPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_MultiPolygonPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_MultiPolygonPropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_MultiPolygonPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_MultiPolygonPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_MultiPolygonPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)


    _ElementMap = {
        __MultiPolygon.name() : __MultiPolygon
    }
    _AttributeMap = {
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __href.name() : __href,
        __arcrole.name() : __arcrole
    }
Namespace.addCategoryObject('typeBinding', u'MultiPolygonPropertyType', MultiPolygonPropertyType)


# Complex type MultiPointCoverageType with content type ELEMENT_ONLY
class MultiPointCoverageType (AbstractDiscreteCoverageType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiPointCoverageType')
    # Base type is AbstractDiscreteCoverageType
    
    # Element rangeSet ({http://www.opengis.net/gml}rangeSet) inherited from {http://www.opengis.net/gml}AbstractCoverageType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element boundedBy ({http://www.opengis.net/gml}boundedBy) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}multiPointDomain uses Python identifier multiPointDomain
    __multiPointDomain = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'multiPointDomain'), 'multiPointDomain', '__httpwww_opengis_netgml_MultiPointCoverageType_httpwww_opengis_netgmlmultiPointDomain', False)

    
    multiPointDomain = property(__multiPointDomain.value, __multiPointDomain.set, None, None)

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element coverageFunction ({http://www.opengis.net/gml}coverageFunction) inherited from {http://www.opengis.net/gml}AbstractDiscreteCoverageType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute dimension inherited from {http://www.opengis.net/gml}AbstractCoverageType

    _ElementMap = AbstractDiscreteCoverageType._ElementMap.copy()
    _ElementMap.update({
        __multiPointDomain.name() : __multiPointDomain
    })
    _AttributeMap = AbstractDiscreteCoverageType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MultiPointCoverageType', MultiPointCoverageType)


# Complex type CircleType with content type ELEMENT_ONLY
class CircleType (ArcType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CircleType')
    # Base type is ArcType
    
    # Element pointProperty ({http://www.opengis.net/gml}pointProperty) inherited from {http://www.opengis.net/gml}ArcStringType
    
    # Element posList ({http://www.opengis.net/gml}posList) inherited from {http://www.opengis.net/gml}ArcStringType
    
    # Element coordinates ({http://www.opengis.net/gml}coordinates) inherited from {http://www.opengis.net/gml}ArcStringType
    
    # Element pointRep ({http://www.opengis.net/gml}pointRep) inherited from {http://www.opengis.net/gml}ArcStringType
    
    # Element pos ({http://www.opengis.net/gml}pos) inherited from {http://www.opengis.net/gml}ArcStringType
    
    # Attribute numArc_ inherited from {http://www.opengis.net/gml}ArcType
    
    # Attribute interpolation inherited from {http://www.opengis.net/gml}ArcStringType
    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType

    _ElementMap = ArcType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = ArcType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CircleType', CircleType)


# Complex type VolumeType with content type SIMPLE
class VolumeType (MeasureType):
    _TypeDefinition = STD_ANON_16
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VolumeType')
    # Base type is MeasureType
    
    # Attribute uom inherited from {http://www.opengis.net/gml}MeasureType

    _ElementMap = MeasureType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = MeasureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'VolumeType', VolumeType)


# Complex type ValueArrayType with content type ELEMENT_ONLY
class ValueArrayType (CompositeValueType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ValueArrayType')
    # Base type is CompositeValueType
    
    # Element valueComponents ({http://www.opengis.net/gml}valueComponents) inherited from {http://www.opengis.net/gml}CompositeValueType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element valueComponent ({http://www.opengis.net/gml}valueComponent) inherited from {http://www.opengis.net/gml}CompositeValueType
    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute codeSpace uses Python identifier codeSpace
    __codeSpace = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'codeSpace'), 'codeSpace', '__httpwww_opengis_netgml_ValueArrayType_codeSpace', pyxb.binding.datatypes.anyURI)
    
    codeSpace = property(__codeSpace.value, __codeSpace.set, None, None)

    
    # Attribute uom uses Python identifier uom
    __uom = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'uom'), 'uom', '__httpwww_opengis_netgml_ValueArrayType_uom', pyxb.binding.datatypes.anyURI)
    
    uom = property(__uom.value, __uom.set, None, None)


    _ElementMap = CompositeValueType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = CompositeValueType._AttributeMap.copy()
    _AttributeMap.update({
        __codeSpace.name() : __codeSpace,
        __uom.name() : __uom
    })
Namespace.addCategoryObject('typeBinding', u'ValueArrayType', ValueArrayType)


# Complex type ArcStringByBulgeType with content type ELEMENT_ONLY
class ArcStringByBulgeType (AbstractCurveSegmentType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ArcStringByBulgeType')
    # Base type is AbstractCurveSegmentType
    
    # Element {http://www.opengis.net/gml}normal uses Python identifier normal
    __normal = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'normal'), 'normal', '__httpwww_opengis_netgml_ArcStringByBulgeType_httpwww_opengis_netgmlnormal', True)

    
    normal = property(__normal.value, __normal.set, None, u'The attribute "normal" is a vector normal (perpendicular) to the chord of the arc, the line joining the first and last\npoint of the arc. In a 2D coordinate system, there are only two possible directions for the normal, and it is often given as a signed real, indicating its length, with a positive sign indicating a left turn angle from the chord line, and a negative sign indicating a right turn from the chord. In 3D, the normal determines the plane of the arc, along with the start and endPoint of the arc.\nThe normal is usually a unit vector, but this is not absolutely necessary. If the normal is a zero vector, the geometric object becomes equivalent to the straight line between the two end points. The length of the normal sequence is exactly the same as for the bulge sequence, 1 less than the control point sequence length.')

    
    # Element {http://www.opengis.net/gml}pointProperty uses Python identifier pointProperty
    __pointProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), 'pointProperty', '__httpwww_opengis_netgml_ArcStringByBulgeType_httpwww_opengis_netgmlpointProperty', True)

    
    pointProperty = property(__pointProperty.value, __pointProperty.set, None, u'This property element either references a point via the XLink-attributes or contains the point element. pointProperty \n\t\t\tis the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that \n\t\t\tis substitutable for Point.')

    
    # Element {http://www.opengis.net/gml}pointRep uses Python identifier pointRep
    __pointRep = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), 'pointRep', '__httpwww_opengis_netgml_ArcStringByBulgeType_httpwww_opengis_netgmlpointRep', True)

    
    pointRep = property(__pointRep.value, __pointRep.set, None, u'Deprecated with GML version 3.1.0. Use "pointProperty" instead. Included for backwards compatibility with GML 3.0.0.')

    
    # Element {http://www.opengis.net/gml}bulge uses Python identifier bulge
    __bulge = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'bulge'), 'bulge', '__httpwww_opengis_netgml_ArcStringByBulgeType_httpwww_opengis_netgmlbulge', True)

    
    bulge = property(__bulge.value, __bulge.set, None, u'The bulge controls the offset of each arc\'s midpoint. The "bulge" is the real number multiplier for the normal that determines the offset direction of the midpoint of each arc. The length of the bulge sequence is exactly 1 less than the length of the control point array, since a bulge is needed for each pair of adjacent points in the control point array. The bulge is not given by a distance, since it is simply a multiplier for the normal.\nThe midpoint of the resulting arc is given by: midPoint = ((startPoint + endPoint)/2.0) + bulge*normal')

    
    # Element {http://www.opengis.net/gml}pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pos'), 'pos', '__httpwww_opengis_netgml_ArcStringByBulgeType_httpwww_opengis_netgmlpos', True)

    
    pos = property(__pos.value, __pos.set, None, u'')

    
    # Element {http://www.opengis.net/gml}posList uses Python identifier posList
    __posList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'posList'), 'posList', '__httpwww_opengis_netgml_ArcStringByBulgeType_httpwww_opengis_netgmlposList', False)

    
    posList = property(__posList.value, __posList.set, None, u'')

    
    # Element {http://www.opengis.net/gml}coordinates uses Python identifier coordinates
    __coordinates = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), 'coordinates', '__httpwww_opengis_netgml_ArcStringByBulgeType_httpwww_opengis_netgmlcoordinates', False)

    
    coordinates = property(__coordinates.value, __coordinates.set, None, u'Deprecated with GML version 3.1.0.')

    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numArc uses Python identifier numArc
    __numArc = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'numArc'), 'numArc', '__httpwww_opengis_netgml_ArcStringByBulgeType_numArc', pyxb.binding.datatypes.integer)
    
    numArc = property(__numArc.value, __numArc.set, None, u'The number of arcs in the arc string can be explicitly stated in this attribute. The number of control points in the arc string must be numArc + 1.')

    
    # Attribute interpolation uses Python identifier interpolation
    __interpolation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'interpolation'), 'interpolation', '__httpwww_opengis_netgml_ArcStringByBulgeType_interpolation', CurveInterpolationType, fixed=True, unicode_default=u'circularArc2PointWithBulge')
    
    interpolation = property(__interpolation.value, __interpolation.set, None, u'The attribute "interpolation" specifies the curve interpolation mechanism used for this segment. This mechanism\nuses the control points and control parameters to determine the position of this curve segment. For an ArcStringByBulge the interpolation is fixed as "circularArc2PointWithBulge".')

    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType

    _ElementMap = AbstractCurveSegmentType._ElementMap.copy()
    _ElementMap.update({
        __normal.name() : __normal,
        __pointProperty.name() : __pointProperty,
        __pointRep.name() : __pointRep,
        __bulge.name() : __bulge,
        __pos.name() : __pos,
        __posList.name() : __posList,
        __coordinates.name() : __coordinates
    })
    _AttributeMap = AbstractCurveSegmentType._AttributeMap.copy()
    _AttributeMap.update({
        __numArc.name() : __numArc,
        __interpolation.name() : __interpolation
    })
Namespace.addCategoryObject('typeBinding', u'ArcStringByBulgeType', ArcStringByBulgeType)


# Complex type CubicSplineType with content type ELEMENT_ONLY
class CubicSplineType (AbstractCurveSegmentType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CubicSplineType')
    # Base type is AbstractCurveSegmentType
    
    # Element {http://www.opengis.net/gml}pointRep uses Python identifier pointRep
    __pointRep = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), 'pointRep', '__httpwww_opengis_netgml_CubicSplineType_httpwww_opengis_netgmlpointRep', True)

    
    pointRep = property(__pointRep.value, __pointRep.set, None, u'Deprecated with GML version 3.1.0. Use "pointProperty" instead. Included for backwards compatibility with GML 3.0.0.')

    
    # Element {http://www.opengis.net/gml}posList uses Python identifier posList
    __posList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'posList'), 'posList', '__httpwww_opengis_netgml_CubicSplineType_httpwww_opengis_netgmlposList', False)

    
    posList = property(__posList.value, __posList.set, None, u'')

    
    # Element {http://www.opengis.net/gml}pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pos'), 'pos', '__httpwww_opengis_netgml_CubicSplineType_httpwww_opengis_netgmlpos', True)

    
    pos = property(__pos.value, __pos.set, None, u'')

    
    # Element {http://www.opengis.net/gml}vectorAtStart uses Python identifier vectorAtStart
    __vectorAtStart = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'vectorAtStart'), 'vectorAtStart', '__httpwww_opengis_netgml_CubicSplineType_httpwww_opengis_netgmlvectorAtStart', False)

    
    vectorAtStart = property(__vectorAtStart.value, __vectorAtStart.set, None, u'"vectorAtStart" is the unit tangent vector at the start point of the spline.')

    
    # Element {http://www.opengis.net/gml}coordinates uses Python identifier coordinates
    __coordinates = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), 'coordinates', '__httpwww_opengis_netgml_CubicSplineType_httpwww_opengis_netgmlcoordinates', False)

    
    coordinates = property(__coordinates.value, __coordinates.set, None, u'Deprecated with GML version 3.1.0.')

    
    # Element {http://www.opengis.net/gml}pointProperty uses Python identifier pointProperty
    __pointProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), 'pointProperty', '__httpwww_opengis_netgml_CubicSplineType_httpwww_opengis_netgmlpointProperty', True)

    
    pointProperty = property(__pointProperty.value, __pointProperty.set, None, u'This property element either references a point via the XLink-attributes or contains the point element. pointProperty \n\t\t\tis the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that \n\t\t\tis substitutable for Point.')

    
    # Element {http://www.opengis.net/gml}vectorAtEnd uses Python identifier vectorAtEnd
    __vectorAtEnd = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'vectorAtEnd'), 'vectorAtEnd', '__httpwww_opengis_netgml_CubicSplineType_httpwww_opengis_netgmlvectorAtEnd', False)

    
    vectorAtEnd = property(__vectorAtEnd.value, __vectorAtEnd.set, None, u'"vectorAtEnd" is the unit tangent vector at the end point of the spline.')

    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute degree uses Python identifier degree
    __degree = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'degree'), 'degree', '__httpwww_opengis_netgml_CubicSplineType_degree', pyxb.binding.datatypes.integer, fixed=True, unicode_default=u'3')
    
    degree = property(__degree.value, __degree.set, None, u'The degree for a cubic spline is "3".')

    
    # Attribute interpolation uses Python identifier interpolation
    __interpolation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'interpolation'), 'interpolation', '__httpwww_opengis_netgml_CubicSplineType_interpolation', CurveInterpolationType, fixed=True, unicode_default=u'cubicSpline')
    
    interpolation = property(__interpolation.value, __interpolation.set, None, u'The attribute "interpolation" specifies the curve interpolation mechanism used for this segment. This mechanism\nuses the control points and control parameters to determine the position of this curve segment. For a CubicSpline the interpolation is fixed as "cubicSpline".')

    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType

    _ElementMap = AbstractCurveSegmentType._ElementMap.copy()
    _ElementMap.update({
        __pointRep.name() : __pointRep,
        __posList.name() : __posList,
        __pos.name() : __pos,
        __vectorAtStart.name() : __vectorAtStart,
        __coordinates.name() : __coordinates,
        __pointProperty.name() : __pointProperty,
        __vectorAtEnd.name() : __vectorAtEnd
    })
    _AttributeMap = AbstractCurveSegmentType._AttributeMap.copy()
    _AttributeMap.update({
        __degree.name() : __degree,
        __interpolation.name() : __interpolation
    })
Namespace.addCategoryObject('typeBinding', u'CubicSplineType', CubicSplineType)


# Complex type RangeParametersType with content type ELEMENT_ONLY
class RangeParametersType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'RangeParametersType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Boolean uses Python identifier Boolean
    __Boolean = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Boolean'), 'Boolean', '__httpwww_opengis_netgml_RangeParametersType_httpwww_opengis_netgmlBoolean', False)

    
    Boolean = property(__Boolean.value, __Boolean.set, None, u'A value from two-valued logic, using the XML Schema boolean type.  An instance may take the values {true, false, 1, 0}.')

    
    # Element {http://www.opengis.net/gml}Count uses Python identifier Count
    __Count = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Count'), 'Count', '__httpwww_opengis_netgml_RangeParametersType_httpwww_opengis_netgmlCount', False)

    
    Count = property(__Count.value, __Count.set, None, u'An integer representing a frequency of occurrence.')

    
    # Element {http://www.opengis.net/gml}CategoryExtent uses Python identifier CategoryExtent
    __CategoryExtent = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CategoryExtent'), 'CategoryExtent', '__httpwww_opengis_netgml_RangeParametersType_httpwww_opengis_netgmlCategoryExtent', False)

    
    CategoryExtent = property(__CategoryExtent.value, __CategoryExtent.set, None, u'Utility element to store a 2-point range of ordinal values. If one member is a null, then this is a single ended interval.')

    
    # Element {http://www.opengis.net/gml}CountExtent uses Python identifier CountExtent
    __CountExtent = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CountExtent'), 'CountExtent', '__httpwww_opengis_netgml_RangeParametersType_httpwww_opengis_netgmlCountExtent', False)

    
    CountExtent = property(__CountExtent.value, __CountExtent.set, None, u'Utility element to store a 2-point range of frequency values. If one member is a null, then this is a single ended interval.')

    
    # Element {http://www.opengis.net/gml}Category uses Python identifier Category
    __Category = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Category'), 'Category', '__httpwww_opengis_netgml_RangeParametersType_httpwww_opengis_netgmlCategory', False)

    
    Category = property(__Category.value, __Category.set, None, u'A term representing a classification.  It has an optional XML attribute codeSpace, whose value is a URI which identifies a dictionary, codelist or authority for the term.')

    
    # Element {http://www.opengis.net/gml}QuantityExtent uses Python identifier QuantityExtent
    __QuantityExtent = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'QuantityExtent'), 'QuantityExtent', '__httpwww_opengis_netgml_RangeParametersType_httpwww_opengis_netgmlQuantityExtent', False)

    
    QuantityExtent = property(__QuantityExtent.value, __QuantityExtent.set, None, u'Utility element to store a 2-point range of numeric values. If one member is a null, then this is a single ended interval.')

    
    # Element {http://www.opengis.net/gml}QuantityList uses Python identifier QuantityList
    __QuantityList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'QuantityList'), 'QuantityList', '__httpwww_opengis_netgml_RangeParametersType_httpwww_opengis_netgmlQuantityList', False)

    
    QuantityList = property(__QuantityList.value, __QuantityList.set, None, u'A space separated list of amounts or nulls.  The amounts use the XML Schema type double.  A single XML attribute uom (unit of measure) is required, whose value is a URI which identifies the definition of the scale or units by which all the amounts in the list must be multiplied.')

    
    # Element {http://www.opengis.net/gml}CompositeValue uses Python identifier CompositeValue
    __CompositeValue = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CompositeValue'), 'CompositeValue', '__httpwww_opengis_netgml_RangeParametersType_httpwww_opengis_netgmlCompositeValue', False)

    
    CompositeValue = property(__CompositeValue.value, __CompositeValue.set, None, u'Aggregate value built using the Composite pattern.')

    
    # Element {http://www.opengis.net/gml}Quantity uses Python identifier Quantity
    __Quantity = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Quantity'), 'Quantity', '__httpwww_opengis_netgml_RangeParametersType_httpwww_opengis_netgmlQuantity', False)

    
    Quantity = property(__Quantity.value, __Quantity.set, None, u'A numeric value with a scale.  The content of the element is an amount using the XML Schema type double which permits decimal or scientific notation.  An XML attribute uom (unit of measure) is required, whose value is a URI which identifies the definition of the scale or units by which the numeric value must be multiplied.')

    
    # Element {http://www.opengis.net/gml}BooleanList uses Python identifier BooleanList
    __BooleanList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'BooleanList'), 'BooleanList', '__httpwww_opengis_netgml_RangeParametersType_httpwww_opengis_netgmlBooleanList', False)

    
    BooleanList = property(__BooleanList.value, __BooleanList.set, None, u'XML List based on XML Schema boolean type.  An element of this type contains a space-separated list of boolean values {0,1,true,false}')

    
    # Element {http://www.opengis.net/gml}CountList uses Python identifier CountList
    __CountList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CountList'), 'CountList', '__httpwww_opengis_netgml_RangeParametersType_httpwww_opengis_netgmlCountList', False)

    
    CountList = property(__CountList.value, __CountList.set, None, u'A space-separated list of integers or nulls.')

    
    # Element {http://www.opengis.net/gml}CategoryList uses Python identifier CategoryList
    __CategoryList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CategoryList'), 'CategoryList', '__httpwww_opengis_netgml_RangeParametersType_httpwww_opengis_netgmlCategoryList', False)

    
    CategoryList = property(__CategoryList.value, __CategoryList.set, None, u'A space-separated list of terms or nulls.  A single XML attribute codeSpace may be provided, which authorises all the terms in the list.')

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_RangeParametersType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_RangeParametersType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_RangeParametersType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_RangeParametersType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_RangeParametersType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_RangeParametersType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_RangeParametersType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_RangeParametersType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)


    _ElementMap = {
        __Boolean.name() : __Boolean,
        __Count.name() : __Count,
        __CategoryExtent.name() : __CategoryExtent,
        __CountExtent.name() : __CountExtent,
        __Category.name() : __Category,
        __QuantityExtent.name() : __QuantityExtent,
        __QuantityList.name() : __QuantityList,
        __CompositeValue.name() : __CompositeValue,
        __Quantity.name() : __Quantity,
        __BooleanList.name() : __BooleanList,
        __CountList.name() : __CountList,
        __CategoryList.name() : __CategoryList
    }
    _AttributeMap = {
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __href.name() : __href,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'RangeParametersType', RangeParametersType)


# Complex type MultiGeometryType with content type ELEMENT_ONLY
class MultiGeometryType (AbstractGeometricAggregateType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiGeometryType')
    # Base type is AbstractGeometricAggregateType
    
    # Element {http://www.opengis.net/gml}geometryMembers uses Python identifier geometryMembers
    __geometryMembers = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'geometryMembers'), 'geometryMembers', '__httpwww_opengis_netgml_MultiGeometryType_httpwww_opengis_netgmlgeometryMembers', False)

    
    geometryMembers = property(__geometryMembers.value, __geometryMembers.set, None, u'This property element contains a list of geometry elements. The order of the elements is significant and shall be preserved when processing the array.')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}geometryMember uses Python identifier geometryMember
    __geometryMember = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'geometryMember'), 'geometryMember', '__httpwww_opengis_netgml_MultiGeometryType_httpwww_opengis_netgmlgeometryMember', True)

    
    geometryMember = property(__geometryMember.value, __geometryMember.set, None, u'This property element either references a geometry element via the XLink-attributes or contains the geometry element.')

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute gid inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsDimension inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute srsName inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute axisLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute uomLabels inherited from {http://www.opengis.net/gml}AbstractGeometryType

    _ElementMap = AbstractGeometricAggregateType._ElementMap.copy()
    _ElementMap.update({
        __geometryMembers.name() : __geometryMembers,
        __geometryMember.name() : __geometryMember
    })
    _AttributeMap = AbstractGeometricAggregateType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MultiGeometryType', MultiGeometryType)


# Complex type AreaType with content type SIMPLE
class AreaType (MeasureType):
    _TypeDefinition = STD_ANON_15
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AreaType')
    # Base type is MeasureType
    
    # Attribute uom inherited from {http://www.opengis.net/gml}MeasureType

    _ElementMap = MeasureType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = MeasureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AreaType', AreaType)


# Complex type GeocentricCRSRefType with content type ELEMENT_ONLY
class GeocentricCRSRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeocentricCRSRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}GeocentricCRS uses Python identifier GeocentricCRS
    __GeocentricCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'GeocentricCRS'), 'GeocentricCRS', '__httpwww_opengis_netgml_GeocentricCRSRefType_httpwww_opengis_netgmlGeocentricCRS', False)

    
    GeocentricCRS = property(__GeocentricCRS.value, __GeocentricCRS.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_GeocentricCRSRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_GeocentricCRSRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_GeocentricCRSRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_GeocentricCRSRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_GeocentricCRSRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_GeocentricCRSRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_GeocentricCRSRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_GeocentricCRSRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)


    _ElementMap = {
        __GeocentricCRS.name() : __GeocentricCRS
    }
    _AttributeMap = {
        __href.name() : __href,
        __show.name() : __show,
        __title.name() : __title,
        __remoteSchema.name() : __remoteSchema,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __arcrole.name() : __arcrole
    }
Namespace.addCategoryObject('typeBinding', u'GeocentricCRSRefType', GeocentricCRSRefType)


# Complex type ArcByBulgeType with content type ELEMENT_ONLY
class ArcByBulgeType (ArcStringByBulgeType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ArcByBulgeType')
    # Base type is ArcStringByBulgeType
    
    # Element normal ({http://www.opengis.net/gml}normal) inherited from {http://www.opengis.net/gml}ArcStringByBulgeType
    
    # Element pointProperty ({http://www.opengis.net/gml}pointProperty) inherited from {http://www.opengis.net/gml}ArcStringByBulgeType
    
    # Element pointRep ({http://www.opengis.net/gml}pointRep) inherited from {http://www.opengis.net/gml}ArcStringByBulgeType
    
    # Element bulge ({http://www.opengis.net/gml}bulge) inherited from {http://www.opengis.net/gml}ArcStringByBulgeType
    
    # Element pos ({http://www.opengis.net/gml}pos) inherited from {http://www.opengis.net/gml}ArcStringByBulgeType
    
    # Element posList ({http://www.opengis.net/gml}posList) inherited from {http://www.opengis.net/gml}ArcStringByBulgeType
    
    # Element coordinates ({http://www.opengis.net/gml}coordinates) inherited from {http://www.opengis.net/gml}ArcStringByBulgeType
    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numArc is restricted from parent
    
    # Attribute numArc uses Python identifier numArc
    __numArc = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'numArc'), 'numArc', '__httpwww_opengis_netgml_ArcStringByBulgeType_numArc', pyxb.binding.datatypes.integer, fixed=True, unicode_default=u'1')
    
    numArc = property(__numArc.value, __numArc.set, None, u'An arc is an arc string consiting of a single arc, the attribute is fixed to "1".')

    
    # Attribute interpolation inherited from {http://www.opengis.net/gml}ArcStringByBulgeType
    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType

    _ElementMap = ArcStringByBulgeType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = ArcStringByBulgeType._AttributeMap.copy()
    _AttributeMap.update({
        __numArc.name() : __numArc
    })
Namespace.addCategoryObject('typeBinding', u'ArcByBulgeType', ArcByBulgeType)


# Complex type TimeGeometricPrimitivePropertyType with content type ELEMENT_ONLY
class TimeGeometricPrimitivePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeGeometricPrimitivePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}_TimeGeometricPrimitive uses Python identifier TimeGeometricPrimitive
    __TimeGeometricPrimitive = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'_TimeGeometricPrimitive'), 'TimeGeometricPrimitive', '__httpwww_opengis_netgml_TimeGeometricPrimitivePropertyType_httpwww_opengis_netgml_TimeGeometricPrimitive', False)

    
    TimeGeometricPrimitive = property(__TimeGeometricPrimitive.value, __TimeGeometricPrimitive.set, None, u'This abstract element acts as the head of the substitution group for temporal geometric primitives.')

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_TimeGeometricPrimitivePropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_TimeGeometricPrimitivePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_TimeGeometricPrimitivePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_TimeGeometricPrimitivePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_TimeGeometricPrimitivePropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_TimeGeometricPrimitivePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_TimeGeometricPrimitivePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_TimeGeometricPrimitivePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)


    _ElementMap = {
        __TimeGeometricPrimitive.name() : __TimeGeometricPrimitive
    }
    _AttributeMap = {
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role,
        __href.name() : __href,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __title.name() : __title
    }
Namespace.addCategoryObject('typeBinding', u'TimeGeometricPrimitivePropertyType', TimeGeometricPrimitivePropertyType)


# Complex type TemporalCRSType with content type ELEMENT_ONLY
class TemporalCRSType (AbstractReferenceSystemType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TemporalCRSType')
    # Base type is AbstractReferenceSystemType
    
    # Element {http://www.opengis.net/gml}usesTemporalDatum uses Python identifier usesTemporalDatum
    __usesTemporalDatum = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesTemporalDatum'), 'usesTemporalDatum', '__httpwww_opengis_netgml_TemporalCRSType_httpwww_opengis_netgmlusesTemporalDatum', False)

    
    usesTemporalDatum = property(__usesTemporalDatum.value, __usesTemporalDatum.set, None, u'Association to the temporal datum used by this CRS. ')

    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element validArea ({http://www.opengis.net/gml}validArea) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element srsID ({http://www.opengis.net/gml}srsID) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element scope ({http://www.opengis.net/gml}scope) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element {http://www.opengis.net/gml}usesTemporalCS uses Python identifier usesTemporalCS
    __usesTemporalCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'usesTemporalCS'), 'usesTemporalCS', '__httpwww_opengis_netgml_TemporalCRSType_httpwww_opengis_netgmlusesTemporalCS', False)

    
    usesTemporalCS = property(__usesTemporalCS.value, __usesTemporalCS.set, None, u'Association to the temporal coordinate system used by this CRS. ')

    
    # Element remarks ({http://www.opengis.net/gml}remarks) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemType
    
    # Element srsName ({http://www.opengis.net/gml}srsName) inherited from {http://www.opengis.net/gml}AbstractReferenceSystemBaseType
    
    # Attribute id_2 inherited from {http://www.opengis.net/gml}AbstractReferenceSystemBaseType

    _ElementMap = AbstractReferenceSystemType._ElementMap.copy()
    _ElementMap.update({
        __usesTemporalDatum.name() : __usesTemporalDatum,
        __usesTemporalCS.name() : __usesTemporalCS
    })
    _AttributeMap = AbstractReferenceSystemType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TemporalCRSType', TemporalCRSType)


# Complex type PriorityLocationPropertyType with content type ELEMENT_ONLY
class PriorityLocationPropertyType (LocationPropertyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'PriorityLocationPropertyType')
    # Base type is LocationPropertyType
    
    # Element Geometry ({http://www.opengis.net/gml}_Geometry) inherited from {http://www.opengis.net/gml}LocationPropertyType
    
    # Element Null ({http://www.opengis.net/gml}Null) inherited from {http://www.opengis.net/gml}LocationPropertyType
    
    # Element LocationKeyWord ({http://www.opengis.net/gml}LocationKeyWord) inherited from {http://www.opengis.net/gml}LocationPropertyType
    
    # Element LocationString ({http://www.opengis.net/gml}LocationString) inherited from {http://www.opengis.net/gml}LocationPropertyType
    
    # Attribute arcrole inherited from {http://www.opengis.net/gml}LocationPropertyType
    
    # Attribute href inherited from {http://www.opengis.net/gml}LocationPropertyType
    
    # Attribute title inherited from {http://www.opengis.net/gml}LocationPropertyType
    
    # Attribute show inherited from {http://www.opengis.net/gml}LocationPropertyType
    
    # Attribute type inherited from {http://www.opengis.net/gml}LocationPropertyType
    
    # Attribute role inherited from {http://www.opengis.net/gml}LocationPropertyType
    
    # Attribute actuate inherited from {http://www.opengis.net/gml}LocationPropertyType
    
    # Attribute remoteSchema inherited from {http://www.opengis.net/gml}LocationPropertyType
    
    # Attribute priority uses Python identifier priority
    __priority = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'priority'), 'priority', '__httpwww_opengis_netgml_PriorityLocationPropertyType_priority', pyxb.binding.datatypes.string)
    
    priority = property(__priority.value, __priority.set, None, None)


    _ElementMap = LocationPropertyType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = LocationPropertyType._AttributeMap.copy()
    _AttributeMap.update({
        __priority.name() : __priority
    })
Namespace.addCategoryObject('typeBinding', u'PriorityLocationPropertyType', PriorityLocationPropertyType)


# Complex type CylindricalCSRefType with content type ELEMENT_ONLY
class CylindricalCSRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CylindricalCSRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}CylindricalCS uses Python identifier CylindricalCS
    __CylindricalCS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CylindricalCS'), 'CylindricalCS', '__httpwww_opengis_netgml_CylindricalCSRefType_httpwww_opengis_netgmlCylindricalCS', False)

    
    CylindricalCS = property(__CylindricalCS.value, __CylindricalCS.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_CylindricalCSRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_CylindricalCSRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_CylindricalCSRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_CylindricalCSRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_CylindricalCSRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_CylindricalCSRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_CylindricalCSRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_CylindricalCSRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)


    _ElementMap = {
        __CylindricalCS.name() : __CylindricalCS
    }
    _AttributeMap = {
        __title.name() : __title,
        __role.name() : __role,
        __show.name() : __show,
        __type.name() : __type,
        __href.name() : __href,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole
    }
Namespace.addCategoryObject('typeBinding', u'CylindricalCSRefType', CylindricalCSRefType)


# Complex type SecondDefiningParameterType with content type ELEMENT_ONLY
class SecondDefiningParameterType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SecondDefiningParameterType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}inverseFlattening uses Python identifier inverseFlattening
    __inverseFlattening = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'inverseFlattening'), 'inverseFlattening', '__httpwww_opengis_netgml_SecondDefiningParameterType_httpwww_opengis_netgmlinverseFlattening', False)

    
    inverseFlattening = property(__inverseFlattening.value, __inverseFlattening.set, None, u'Inverse flattening value of the ellipsoid. Value is a scale factor (or ratio) that has no physical unit. Uses the MeasureType with the restriction that the unit of measure referenced by uom must be suitable for a scale factor, such as percent, permil, or parts-per-million. ')

    
    # Element {http://www.opengis.net/gml}semiMinorAxis uses Python identifier semiMinorAxis
    __semiMinorAxis = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'semiMinorAxis'), 'semiMinorAxis', '__httpwww_opengis_netgml_SecondDefiningParameterType_httpwww_opengis_netgmlsemiMinorAxis', False)

    
    semiMinorAxis = property(__semiMinorAxis.value, __semiMinorAxis.set, None, u'Length of the semi-minor axis of the ellipsoid. Uses the MeasureType with the restriction that the unit of measure referenced by uom must be suitable for a length, such as metres or feet. ')

    
    # Element {http://www.opengis.net/gml}isSphere uses Python identifier isSphere
    __isSphere = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'isSphere'), 'isSphere', '__httpwww_opengis_netgml_SecondDefiningParameterType_httpwww_opengis_netgmlisSphere', False)

    
    isSphere = property(__isSphere.value, __isSphere.set, None, u'The ellipsoid is degenerate and is actually a sphere. The sphere is completely defined by the semi-major axis, which is the radius of the sphere. ')


    _ElementMap = {
        __inverseFlattening.name() : __inverseFlattening,
        __semiMinorAxis.name() : __semiMinorAxis,
        __isSphere.name() : __isSphere
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'SecondDefiningParameterType', SecondDefiningParameterType)


# Complex type ConeType with content type ELEMENT_ONLY
class ConeType (AbstractGriddedSurfaceType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ConeType')
    # Base type is AbstractGriddedSurfaceType
    
    # Element row ({http://www.opengis.net/gml}row) inherited from {http://www.opengis.net/gml}AbstractGriddedSurfaceType
    
    # Element columns ({http://www.opengis.net/gml}columns) inherited from {http://www.opengis.net/gml}AbstractGriddedSurfaceType
    
    # Element rows ({http://www.opengis.net/gml}rows) inherited from {http://www.opengis.net/gml}AbstractGriddedSurfaceType
    
    # Attribute horizontalCurveType uses Python identifier horizontalCurveType
    __horizontalCurveType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'horizontalCurveType'), 'horizontalCurveType', '__httpwww_opengis_netgml_ConeType_horizontalCurveType', CurveInterpolationType, fixed=True, unicode_default=u'circularArc3Points')
    
    horizontalCurveType = property(__horizontalCurveType.value, __horizontalCurveType.set, None, None)

    
    # Attribute verticalCurveType uses Python identifier verticalCurveType
    __verticalCurveType = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'verticalCurveType'), 'verticalCurveType', '__httpwww_opengis_netgml_ConeType_verticalCurveType', CurveInterpolationType, fixed=True, unicode_default=u'linear')
    
    verticalCurveType = property(__verticalCurveType.value, __verticalCurveType.set, None, None)


    _ElementMap = AbstractGriddedSurfaceType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = AbstractGriddedSurfaceType._AttributeMap.copy()
    _AttributeMap.update({
        __horizontalCurveType.name() : __horizontalCurveType,
        __verticalCurveType.name() : __verticalCurveType
    })
Namespace.addCategoryObject('typeBinding', u'ConeType', ConeType)


# Complex type VerticalCRSRefType with content type ELEMENT_ONLY
class VerticalCRSRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VerticalCRSRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}VerticalCRS uses Python identifier VerticalCRS
    __VerticalCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'VerticalCRS'), 'VerticalCRS', '__httpwww_opengis_netgml_VerticalCRSRefType_httpwww_opengis_netgmlVerticalCRS', False)

    
    VerticalCRS = property(__VerticalCRS.value, __VerticalCRS.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_VerticalCRSRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_VerticalCRSRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_VerticalCRSRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_VerticalCRSRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_VerticalCRSRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_VerticalCRSRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_VerticalCRSRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_VerticalCRSRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)


    _ElementMap = {
        __VerticalCRS.name() : __VerticalCRS
    }
    _AttributeMap = {
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __href.name() : __href,
        __show.name() : __show,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'VerticalCRSRefType', VerticalCRSRefType)


# Complex type GeodesicType with content type ELEMENT_ONLY
class GeodesicType (GeodesicStringType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeodesicType')
    # Base type is GeodesicStringType
    
    # Element posList ({http://www.opengis.net/gml}posList) inherited from {http://www.opengis.net/gml}GeodesicStringType
    
    # Element pointProperty ({http://www.opengis.net/gml}pointProperty) inherited from {http://www.opengis.net/gml}GeodesicStringType
    
    # Element pos ({http://www.opengis.net/gml}pos) inherited from {http://www.opengis.net/gml}GeodesicStringType
    
    # Attribute interpolation inherited from {http://www.opengis.net/gml}GeodesicStringType
    
    # Attribute numDerivativesAtEnd inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativeInterior inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType
    
    # Attribute numDerivativesAtStart inherited from {http://www.opengis.net/gml}AbstractCurveSegmentType

    _ElementMap = GeodesicStringType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = GeodesicStringType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'GeodesicType', GeodesicType)


# Complex type ScaleType with content type SIMPLE
class ScaleType (MeasureType):
    _TypeDefinition = STD_ANON_5
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ScaleType')
    # Base type is MeasureType
    
    # Attribute uom inherited from {http://www.opengis.net/gml}MeasureType

    _ElementMap = MeasureType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = MeasureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ScaleType', ScaleType)


# Complex type IsolatedPropertyType with content type ELEMENT_ONLY
class IsolatedPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'IsolatedPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}Node uses Python identifier Node
    __Node = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Node'), 'Node', '__httpwww_opengis_netgml_IsolatedPropertyType_httpwww_opengis_netgmlNode', False)

    
    Node = property(__Node.value, __Node.set, None, None)

    
    # Element {http://www.opengis.net/gml}Edge uses Python identifier Edge
    __Edge = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'Edge'), 'Edge', '__httpwww_opengis_netgml_IsolatedPropertyType_httpwww_opengis_netgmlEdge', False)

    
    Edge = property(__Edge.value, __Edge.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_IsolatedPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_IsolatedPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_IsolatedPropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_IsolatedPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_IsolatedPropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_IsolatedPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_IsolatedPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_IsolatedPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)


    _ElementMap = {
        __Node.name() : __Node,
        __Edge.name() : __Edge
    }
    _AttributeMap = {
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __show.name() : __show,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __href.name() : __href
    }
Namespace.addCategoryObject('typeBinding', u'IsolatedPropertyType', IsolatedPropertyType)


# Complex type SequenceRuleType with content type SIMPLE
class SequenceRuleType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = SequenceRuleNames
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SequenceRuleType')
    # Base type is SequenceRuleNames
    
    # Attribute order uses Python identifier order
    __order = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'order'), 'order', '__httpwww_opengis_netgml_SequenceRuleType_order', IncrementOrder)
    
    order = property(__order.value, __order.set, None, None)


    _ElementMap = {
        
    }
    _AttributeMap = {
        __order.name() : __order
    }
Namespace.addCategoryObject('typeBinding', u'SequenceRuleType', SequenceRuleType)


# Complex type TrackType with content type ELEMENT_ONLY
class TrackType (HistoryPropertyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TrackType')
    # Base type is HistoryPropertyType
    
    # Element {http://www.opengis.net/gml}MovingObjectStatus uses Python identifier MovingObjectStatus
    __MovingObjectStatus = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'MovingObjectStatus'), 'MovingObjectStatus', '__httpwww_opengis_netgml_TrackType_httpwww_opengis_netgmlMovingObjectStatus', True)

    
    MovingObjectStatus = property(__MovingObjectStatus.value, __MovingObjectStatus.set, None, None)


    _ElementMap = HistoryPropertyType._ElementMap.copy()
    _ElementMap.update({
        __MovingObjectStatus.name() : __MovingObjectStatus
    })
    _AttributeMap = HistoryPropertyType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TrackType', TrackType)


# Complex type ScalarValuePropertyType with content type ELEMENT_ONLY
class ScalarValuePropertyType (ValuePropertyType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ScalarValuePropertyType')
    # Base type is ValuePropertyType
    
    # Element Boolean ({http://www.opengis.net/gml}Boolean) inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Element Category ({http://www.opengis.net/gml}Category) inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Element Count ({http://www.opengis.net/gml}Count) inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Element Quantity ({http://www.opengis.net/gml}Quantity) inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute role inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute remoteSchema inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute type inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute arcrole inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute title inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute actuate inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute href inherited from {http://www.opengis.net/gml}ValuePropertyType
    
    # Attribute show inherited from {http://www.opengis.net/gml}ValuePropertyType

    _ElementMap = ValuePropertyType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = ValuePropertyType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ScalarValuePropertyType', ScalarValuePropertyType)


# Complex type CTD_ANON_ with content type ELEMENT_ONLY
class CTD_ANON_ (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pos'), 'pos', '__httpwww_opengis_netgml_CTD_ANON__httpwww_opengis_netgmlpos', True)

    
    pos = property(__pos.value, __pos.set, None, u'')

    
    # Element {http://www.opengis.net/gml}posList uses Python identifier posList
    __posList = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'posList'), 'posList', '__httpwww_opengis_netgml_CTD_ANON__httpwww_opengis_netgmlposList', False)

    
    posList = property(__posList.value, __posList.set, None, u'')

    
    # Element {http://www.opengis.net/gml}pointProperty uses Python identifier pointProperty
    __pointProperty = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), 'pointProperty', '__httpwww_opengis_netgml_CTD_ANON__httpwww_opengis_netgmlpointProperty', True)

    
    pointProperty = property(__pointProperty.value, __pointProperty.set, None, u'This property element either references a point via the XLink-attributes or contains the point element. pointProperty \n\t\t\tis the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that \n\t\t\tis substitutable for Point.')


    _ElementMap = {
        __pos.name() : __pos,
        __posList.name() : __posList,
        __pointProperty.name() : __pointProperty
    }
    _AttributeMap = {
        
    }



# Complex type IndexMapType with content type ELEMENT_ONLY
class IndexMapType (GridFunctionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'IndexMapType')
    # Base type is GridFunctionType
    
    # Element sequenceRule ({http://www.opengis.net/gml}sequenceRule) inherited from {http://www.opengis.net/gml}GridFunctionType
    
    # Element {http://www.opengis.net/gml}lookUpTable uses Python identifier lookUpTable
    __lookUpTable = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'lookUpTable'), 'lookUpTable', '__httpwww_opengis_netgml_IndexMapType_httpwww_opengis_netgmllookUpTable', False)

    
    lookUpTable = property(__lookUpTable.value, __lookUpTable.set, None, None)

    
    # Element startPoint ({http://www.opengis.net/gml}startPoint) inherited from {http://www.opengis.net/gml}GridFunctionType

    _ElementMap = GridFunctionType._ElementMap.copy()
    _ElementMap.update({
        __lookUpTable.name() : __lookUpTable
    })
    _AttributeMap = GridFunctionType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'IndexMapType', IndexMapType)


# Complex type LabelType with content type MIXED
class LabelType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_MIXED
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LabelType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}LabelExpression uses Python identifier LabelExpression
    __LabelExpression = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'LabelExpression'), 'LabelExpression', '__httpwww_opengis_netgml_LabelType_httpwww_opengis_netgmlLabelExpression', True)

    
    LabelExpression = property(__LabelExpression.value, __LabelExpression.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}transform uses Python identifier transform
    __transform = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'transform'), 'transform', '__httpwww_opengis_netgml_LabelType_httpwww_opengis_netgmltransform', pyxb.binding.datatypes.string)
    
    transform = property(__transform.value, __transform.set, None, u'Defines the geometric transformation of entities. There is no particular grammar defined for this value.')


    _ElementMap = {
        __LabelExpression.name() : __LabelExpression
    }
    _AttributeMap = {
        __transform.name() : __transform
    }
Namespace.addCategoryObject('typeBinding', u'LabelType', LabelType)


# Complex type CompositeSurfacePropertyType with content type ELEMENT_ONLY
class CompositeSurfacePropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CompositeSurfacePropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}CompositeSurface uses Python identifier CompositeSurface
    __CompositeSurface = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CompositeSurface'), 'CompositeSurface', '__httpwww_opengis_netgml_CompositeSurfacePropertyType_httpwww_opengis_netgmlCompositeSurface', False)

    
    CompositeSurface = property(__CompositeSurface.value, __CompositeSurface.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_CompositeSurfacePropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_CompositeSurfacePropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_CompositeSurfacePropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_CompositeSurfacePropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_CompositeSurfacePropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_CompositeSurfacePropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_CompositeSurfacePropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_CompositeSurfacePropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")


    _ElementMap = {
        __CompositeSurface.name() : __CompositeSurface
    }
    _AttributeMap = {
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __href.name() : __href,
        __title.name() : __title,
        __show.name() : __show,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate
    }
Namespace.addCategoryObject('typeBinding', u'CompositeSurfacePropertyType', CompositeSurfacePropertyType)


# Complex type CompoundCRSRefType with content type ELEMENT_ONLY
class CompoundCRSRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CompoundCRSRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}CompoundCRS uses Python identifier CompoundCRS
    __CompoundCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'CompoundCRS'), 'CompoundCRS', '__httpwww_opengis_netgml_CompoundCRSRefType_httpwww_opengis_netgmlCompoundCRS', False)

    
    CompoundCRS = property(__CompoundCRS.value, __CompoundCRS.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_CompoundCRSRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_CompoundCRSRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_CompoundCRSRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_CompoundCRSRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_CompoundCRSRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_CompoundCRSRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_CompoundCRSRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_CompoundCRSRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)


    _ElementMap = {
        __CompoundCRS.name() : __CompoundCRS
    }
    _AttributeMap = {
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __show.name() : __show,
        __remoteSchema.name() : __remoteSchema,
        __type.name() : __type,
        __role.name() : __role,
        __actuate.name() : __actuate,
        __href.name() : __href
    }
Namespace.addCategoryObject('typeBinding', u'CompoundCRSRefType', CompoundCRSRefType)


# Complex type CTD_ANON_2 with content type ELEMENT_ONLY
class CTD_ANON_2 (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}AffinePlacement uses Python identifier AffinePlacement
    __AffinePlacement = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'AffinePlacement'), 'AffinePlacement', '__httpwww_opengis_netgml_CTD_ANON_2_httpwww_opengis_netgmlAffinePlacement', False)

    
    AffinePlacement = property(__AffinePlacement.value, __AffinePlacement.set, None, None)


    _ElementMap = {
        __AffinePlacement.name() : __AffinePlacement
    }
    _AttributeMap = {
        
    }



# Complex type DynamicFeatureCollectionType with content type ELEMENT_ONLY
class DynamicFeatureCollectionType (FeatureCollectionType):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DynamicFeatureCollectionType')
    # Base type is FeatureCollectionType
    
    # Element featureMember ({http://www.opengis.net/gml}featureMember) inherited from {http://www.opengis.net/gml}AbstractFeatureCollectionType
    
    # Element metaDataProperty ({http://www.opengis.net/gml}metaDataProperty) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}dataSource uses Python identifier dataSource
    __dataSource = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'dataSource'), 'dataSource', '__httpwww_opengis_netgml_DynamicFeatureCollectionType_httpwww_opengis_netgmldataSource', False)

    
    dataSource = property(__dataSource.value, __dataSource.set, None, None)

    
    # Element boundedBy ({http://www.opengis.net/gml}boundedBy) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element {http://www.opengis.net/gml}validTime uses Python identifier validTime
    __validTime = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'validTime'), 'validTime', '__httpwww_opengis_netgml_DynamicFeatureCollectionType_httpwww_opengis_netgmlvalidTime', False)

    
    validTime = property(__validTime.value, __validTime.set, None, None)

    
    # Element featureMembers ({http://www.opengis.net/gml}featureMembers) inherited from {http://www.opengis.net/gml}AbstractFeatureCollectionType
    
    # Element location ({http://www.opengis.net/gml}location) inherited from {http://www.opengis.net/gml}AbstractFeatureType
    
    # Element name ({http://www.opengis.net/gml}name) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Element {http://www.opengis.net/gml}history uses Python identifier history
    __history = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'history'), 'history', '__httpwww_opengis_netgml_DynamicFeatureCollectionType_httpwww_opengis_netgmlhistory', False)

    
    history = property(__history.value, __history.set, None, None)

    
    # Element description ({http://www.opengis.net/gml}description) inherited from {http://www.opengis.net/gml}AbstractGMLType
    
    # Attribute id inherited from {http://www.opengis.net/gml}AbstractGMLType

    _ElementMap = FeatureCollectionType._ElementMap.copy()
    _ElementMap.update({
        __dataSource.name() : __dataSource,
        __validTime.name() : __validTime,
        __history.name() : __history
    })
    _AttributeMap = FeatureCollectionType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'DynamicFeatureCollectionType', DynamicFeatureCollectionType)


# Complex type GridEnvelopeType with content type ELEMENT_ONLY
class GridEnvelopeType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GridEnvelopeType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}high uses Python identifier high
    __high = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'high'), 'high', '__httpwww_opengis_netgml_GridEnvelopeType_httpwww_opengis_netgmlhigh', False)

    
    high = property(__high.value, __high.set, None, None)

    
    # Element {http://www.opengis.net/gml}low uses Python identifier low
    __low = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'low'), 'low', '__httpwww_opengis_netgml_GridEnvelopeType_httpwww_opengis_netgmllow', False)

    
    low = property(__low.value, __low.set, None, None)


    _ElementMap = {
        __high.name() : __high,
        __low.name() : __low
    }
    _AttributeMap = {
        
    }
Namespace.addCategoryObject('typeBinding', u'GridEnvelopeType', GridEnvelopeType)


# Complex type TimeType with content type SIMPLE
class TimeType (MeasureType):
    _TypeDefinition = STD_ANON_20
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_SIMPLE
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TimeType')
    # Base type is MeasureType
    
    # Attribute uom inherited from {http://www.opengis.net/gml}MeasureType

    _ElementMap = MeasureType._ElementMap.copy()
    _ElementMap.update({
        
    })
    _AttributeMap = MeasureType._AttributeMap.copy()
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'TimeType', TimeType)


# Complex type MultiSolidPropertyType with content type ELEMENT_ONLY
class MultiSolidPropertyType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MultiSolidPropertyType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}MultiSolid uses Python identifier MultiSolid
    __MultiSolid = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'MultiSolid'), 'MultiSolid', '__httpwww_opengis_netgml_MultiSolidPropertyType_httpwww_opengis_netgmlMultiSolid', False)

    
    MultiSolid = property(__MultiSolid.value, __MultiSolid.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_MultiSolidPropertyType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_MultiSolidPropertyType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_MultiSolidPropertyType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_MultiSolidPropertyType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_MultiSolidPropertyType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_MultiSolidPropertyType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_MultiSolidPropertyType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_MultiSolidPropertyType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)


    _ElementMap = {
        __MultiSolid.name() : __MultiSolid
    }
    _AttributeMap = {
        __role.name() : __role,
        __actuate.name() : __actuate,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __title.name() : __title,
        __href.name() : __href,
        __show.name() : __show,
        __type.name() : __type
    }
Namespace.addCategoryObject('typeBinding', u'MultiSolidPropertyType', MultiSolidPropertyType)


# Complex type GeographicCRSRefType with content type ELEMENT_ONLY
class GeographicCRSRefType (pyxb.binding.basis.complexTypeDefinition):
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GeographicCRSRefType')
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://www.opengis.net/gml}GeographicCRS uses Python identifier GeographicCRS
    __GeographicCRS = pyxb.binding.content.ElementUse(pyxb.namespace.ExpandedName(Namespace, u'GeographicCRS'), 'GeographicCRS', '__httpwww_opengis_netgml_GeographicCRSRefType_httpwww_opengis_netgmlGeographicCRS', False)

    
    GeographicCRS = property(__GeographicCRS.value, __GeographicCRS.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'type'), 'type', '__httpwww_opengis_netgml_GeographicCRSRefType_httpwww_w3_org1999xlinktype', pyxb.binding.datatypes.string, fixed=True, unicode_default=u'simple')
    
    type = property(__type.value, __type.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}actuate uses Python identifier actuate
    __actuate = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'actuate'), 'actuate', '__httpwww_opengis_netgml_GeographicCRSRefType_httpwww_w3_org1999xlinkactuate', pyxb.bundles.opengis.misc.xlinks.STD_ANON)
    
    actuate = property(__actuate.value, __actuate.set, None, u"\n        The 'actuate' attribute is used to communicate the desired timing \n        of traversal from the starting resource to the ending resource; \n        it's value should be treated as follows:\n        onLoad - traverse to the ending resource immediately on loading \n                 the starting resource \n        onRequest - traverse from the starting resource to the ending \n                    resource only on a post-loading event triggered for \n                    this purpose \n        other - behavior is unconstrained; examine other markup in link \n                for hints \n        none - behavior is unconstrained\n      ")

    
    # Attribute {http://www.w3.org/1999/xlink}role uses Python identifier role
    __role = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'role'), 'role', '__httpwww_opengis_netgml_GeographicCRSRefType_httpwww_w3_org1999xlinkrole', pyxb.binding.datatypes.anyURI)
    
    role = property(__role.value, __role.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}title uses Python identifier title
    __title = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'title'), 'title', '__httpwww_opengis_netgml_GeographicCRSRefType_httpwww_w3_org1999xlinktitle', pyxb.binding.datatypes.string)
    
    title = property(__title.value, __title.set, None, None)

    
    # Attribute {http://www.opengis.net/gml}remoteSchema uses Python identifier remoteSchema
    __remoteSchema = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(Namespace, u'remoteSchema'), 'remoteSchema', '__httpwww_opengis_netgml_GeographicCRSRefType_httpwww_opengis_netgmlremoteSchema', pyxb.binding.datatypes.anyURI)
    
    remoteSchema = property(__remoteSchema.value, __remoteSchema.set, None, u'Reference to an XML Schema fragment that specifies the content model of the propertys value. This is in conformance with the XML Schema Section 4.14 Referencing Schemas from Elsewhere.')

    
    # Attribute {http://www.w3.org/1999/xlink}arcrole uses Python identifier arcrole
    __arcrole = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'arcrole'), 'arcrole', '__httpwww_opengis_netgml_GeographicCRSRefType_httpwww_w3_org1999xlinkarcrole', pyxb.binding.datatypes.anyURI)
    
    arcrole = property(__arcrole.value, __arcrole.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}href uses Python identifier href
    __href = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'href'), 'href', '__httpwww_opengis_netgml_GeographicCRSRefType_httpwww_w3_org1999xlinkhref', pyxb.binding.datatypes.anyURI)
    
    href = property(__href.value, __href.set, None, None)

    
    # Attribute {http://www.w3.org/1999/xlink}show uses Python identifier show
    __show = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/1999/xlink'), u'show'), 'show', '__httpwww_opengis_netgml_GeographicCRSRefType_httpwww_w3_org1999xlinkshow', pyxb.bundles.opengis.misc.xlinks.STD_ANON_)
    
    show = property(__show.value, __show.set, None, u"\n        The 'show' attribute is used to communicate the desired presentation \n        of the ending resource on traversal from the starting resource; it's \n        value should be treated as follows: \n        new - load ending resource in a new window, frame, pane, or other \n              presentation context\n        replace - load the resource in the same window, frame, pane, or \n                  other presentation context\n        embed - load ending resource in place of the presentation of the \n                starting resource\n        other - behavior is unconstrained; examine other markup in the \n                link for hints \n        none - behavior is unconstrained \n      ")


    _ElementMap = {
        __GeographicCRS.name() : __GeographicCRS
    }
    _AttributeMap = {
        __type.name() : __type,
        __actuate.name() : __actuate,
        __role.name() : __role,
        __title.name() : __title,
        __remoteSchema.name() : __remoteSchema,
        __arcrole.name() : __arcrole,
        __href.name() : __href,
        __show.name() : __show
    }
Namespace.addCategoryObject('typeBinding', u'GeographicCRSRefType', GeographicCRSRefType)


generalConversionRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'generalConversionRef'), GeneralConversionRefType)
Namespace.addCategoryObject('elementBinding', generalConversionRef.name().localName(), generalConversionRef)

Dictionary = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Dictionary'), DictionaryType)
Namespace.addCategoryObject('elementBinding', Dictionary.name().localName(), Dictionary)

usesTemporalDatum = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesTemporalDatum'), TemporalDatumRefType, documentation=u'Association to the temporal datum used by this CRS. ')
Namespace.addCategoryObject('elementBinding', usesTemporalDatum.name().localName(), usesTemporalDatum)

MultiCurveCoverage = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiCurveCoverage'), MultiCurveCoverageType)
Namespace.addCategoryObject('elementBinding', MultiCurveCoverage.name().localName(), MultiCurveCoverage)

CircleByCenterPoint = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CircleByCenterPoint'), CircleByCenterPointType)
Namespace.addCategoryObject('elementBinding', CircleByCenterPoint.name().localName(), CircleByCenterPoint)

methodID = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'methodID'), IdentifierType, documentation=u'An identification of an operation method. ')
Namespace.addCategoryObject('elementBinding', methodID.name().localName(), methodID)

meridianID = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'meridianID'), IdentifierType, documentation=u'An identification of a prime meridian. ')
Namespace.addCategoryObject('elementBinding', meridianID.name().localName(), meridianID)

validTime = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'validTime'), TimePrimitivePropertyType)
Namespace.addCategoryObject('elementBinding', validTime.name().localName(), validTime)

greenwichLongitude = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'greenwichLongitude'), AngleChoiceType, documentation=u'Longitude of the prime meridian measured from the Greenwich meridian, positive eastward. The greenwichLongitude most common value is zero, and that value shall be used when the meridianName value is Greenwich. ')
Namespace.addCategoryObject('elementBinding', greenwichLongitude.name().localName(), greenwichLongitude)

topoPointProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'topoPointProperty'), TopoPointPropertyType)
Namespace.addCategoryObject('elementBinding', topoPointProperty.name().localName(), topoPointProperty)

targetDimensions = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'targetDimensions'), pyxb.binding.datatypes.positiveInteger, documentation=u'Number of dimensions in the target CRS of this operation method. ')
Namespace.addCategoryObject('elementBinding', targetDimensions.name().localName(), targetDimensions)

GeocentricCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GeocentricCRS'), GeocentricCRSType)
Namespace.addCategoryObject('elementBinding', GeocentricCRS.name().localName(), GeocentricCRS)

using = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'using'), FeaturePropertyType, documentation=u'This element contains or points to a description of a sensor, instrument or procedure used for the observation')
Namespace.addCategoryObject('elementBinding', using.name().localName(), using)

GeometricAggregate = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_GeometricAggregate'), AbstractGeometricAggregateType, abstract=pyxb.binding.datatypes.boolean(1), documentation=u'The "_GeometricAggregate" element is the abstract head of the substituition group for all geometric aggremates.')
Namespace.addCategoryObject('elementBinding', GeometricAggregate.name().localName(), GeometricAggregate)

DefinitionCollection = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DefinitionCollection'), DictionaryType)
Namespace.addCategoryObject('elementBinding', DefinitionCollection.name().localName(), DefinitionCollection)

boundingBox = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'boundingBox'), EnvelopeType, documentation=u'A bounding box (or envelope) defining the spatial domain of this object.')
Namespace.addCategoryObject('elementBinding', boundingBox.name().localName(), boundingBox)

boundedBy = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'), BoundingShapeType)
Namespace.addCategoryObject('elementBinding', boundedBy.name().localName(), boundedBy)

derivedCRSType = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'derivedCRSType'), DerivedCRSTypeType)
Namespace.addCategoryObject('elementBinding', derivedCRSType.name().localName(), derivedCRSType)

operationMethodRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'operationMethodRef'), OperationMethodRefType)
Namespace.addCategoryObject('elementBinding', operationMethodRef.name().localName(), operationMethodRef)

multiGeometryProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiGeometryProperty'), MultiGeometryPropertyType, documentation=u'This property element either references a geometric aggregate via the XLink-attributes or contains the "multi geometry" element. multiGeometryProperty is the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that is substitutable for _GeometricAggregate.')
Namespace.addCategoryObject('elementBinding', multiGeometryProperty.name().localName(), multiGeometryProperty)

MultiSurfaceCoverage = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiSurfaceCoverage'), MultiSurfaceCoverageType)
Namespace.addCategoryObject('elementBinding', MultiSurfaceCoverage.name().localName(), MultiSurfaceCoverage)

TimeCalendarEra = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeCalendarEra'), TimeCalendarEraType)
Namespace.addCategoryObject('elementBinding', TimeCalendarEra.name().localName(), TimeCalendarEra)

GeneralOperationParameter = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_GeneralOperationParameter'), AbstractGeneralOperationParameterType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', GeneralOperationParameter.name().localName(), GeneralOperationParameter)

multiPosition = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiPosition'), MultiPointPropertyType)
Namespace.addCategoryObject('elementBinding', multiPosition.name().localName(), multiPosition)

patches = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'patches'), SurfacePatchArrayPropertyType, documentation=u'This property element contains a list of surface patches. The order of the elements is significant and shall be preserved when processing the array.')
Namespace.addCategoryObject('elementBinding', patches.name().localName(), patches)

EnvelopeWithTimePeriod = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'EnvelopeWithTimePeriod'), EnvelopeWithTimePeriodType)
Namespace.addCategoryObject('elementBinding', EnvelopeWithTimePeriod.name().localName(), EnvelopeWithTimePeriod)

multiEdgeOf = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiEdgeOf'), MultiCurvePropertyType)
Namespace.addCategoryObject('elementBinding', multiEdgeOf.name().localName(), multiEdgeOf)

Null = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Null'), NullType)
Namespace.addCategoryObject('elementBinding', Null.name().localName(), Null)

topoSurfaceProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'topoSurfaceProperty'), TopoSurfacePropertyType)
Namespace.addCategoryObject('elementBinding', topoSurfaceProperty.name().localName(), topoSurfaceProperty)

temporalCRSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'temporalCRSRef'), TemporalCRSRefType)
Namespace.addCategoryObject('elementBinding', temporalCRSRef.name().localName(), temporalCRSRef)

usesPrimeMeridian = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesPrimeMeridian'), PrimeMeridianRefType, documentation=u'Association to the prime meridian used by this geodetic datum. ')
Namespace.addCategoryObject('elementBinding', usesPrimeMeridian.name().localName(), usesPrimeMeridian)

LineStringSegment = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'LineStringSegment'), LineStringSegmentType)
Namespace.addCategoryObject('elementBinding', LineStringSegment.name().localName(), LineStringSegment)

trianglePatches = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'trianglePatches'), TrianglePatchArrayPropertyType, documentation=u'This property element contains a list of\n   triangle patches. The order of the patches is significant and \n   shall be preserved when processing the list.')
Namespace.addCategoryObject('elementBinding', trianglePatches.name().localName(), trianglePatches)

abstractGeneralOperationParameterRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'abstractGeneralOperationParameterRef'), AbstractGeneralOperationParameterRefType)
Namespace.addCategoryObject('elementBinding', abstractGeneralOperationParameterRef.name().localName(), abstractGeneralOperationParameterRef)

Surface = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Surface'), SurfaceType)
Namespace.addCategoryObject('elementBinding', Surface.name().localName(), Surface)

definitionRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'definitionRef'), ReferenceType)
Namespace.addCategoryObject('elementBinding', definitionRef.name().localName(), definitionRef)

featureMember = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'featureMember'), FeaturePropertyType)
Namespace.addCategoryObject('elementBinding', featureMember.name().localName(), featureMember)

datumName = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'datumName'), CodeType, documentation=u'The name by which this datum is identified. ')
Namespace.addCategoryObject('elementBinding', datumName.name().localName(), datumName)

target = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'target'), TargetPropertyType, documentation=u'This element contains or points to the specimen, region or station which is the object of the observation')
Namespace.addCategoryObject('elementBinding', target.name().localName(), target)

featureProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'featureProperty'), FeaturePropertyType)
Namespace.addCategoryObject('elementBinding', featureProperty.name().localName(), featureProperty)

TimeReferenceSystem = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_TimeReferenceSystem'), AbstractTimeReferenceSystemType, abstract=pyxb.binding.datatypes.boolean(1), documentation=u'Abstract element serves primarily as the head of a substitution group for temporal reference systems.')
Namespace.addCategoryObject('elementBinding', TimeReferenceSystem.name().localName(), TimeReferenceSystem)

MultiSolidCoverage = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiSolidCoverage'), MultiSolidCoverageType)
Namespace.addCategoryObject('elementBinding', MultiSolidCoverage.name().localName(), MultiSolidCoverage)

OperationParameter = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'OperationParameter'), OperationParameterType)
Namespace.addCategoryObject('elementBinding', OperationParameter.name().localName(), OperationParameter)

UnitDefinition = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'UnitDefinition'), UnitDefinitionType)
Namespace.addCategoryObject('elementBinding', UnitDefinition.name().localName(), UnitDefinition)

relativeInternalPositionalAccuracy = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'relativeInternalPositionalAccuracy'), RelativeInternalPositionalAccuracyType)
Namespace.addCategoryObject('elementBinding', relativeInternalPositionalAccuracy.name().localName(), relativeInternalPositionalAccuracy)

DirectedObservationAtDistance = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DirectedObservationAtDistance'), DirectedObservationAtDistanceType)
Namespace.addCategoryObject('elementBinding', DirectedObservationAtDistance.name().localName(), DirectedObservationAtDistance)

featureMembers = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'featureMembers'), FeatureArrayPropertyType)
Namespace.addCategoryObject('elementBinding', featureMembers.name().localName(), featureMembers)

DefinitionProxy = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DefinitionProxy'), DefinitionProxyType)
Namespace.addCategoryObject('elementBinding', DefinitionProxy.name().localName(), DefinitionProxy)

DirectedObservation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DirectedObservation'), DirectedObservationType)
Namespace.addCategoryObject('elementBinding', DirectedObservation.name().localName(), DirectedObservation)

GeneralTransformation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_GeneralTransformation'), AbstractGeneralTransformationType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', GeneralTransformation.name().localName(), GeneralTransformation)

coverageFunction = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coverageFunction'), CoverageFunctionType)
Namespace.addCategoryObject('elementBinding', coverageFunction.name().localName(), coverageFunction)

BaseUnit = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'BaseUnit'), BaseUnitType)
Namespace.addCategoryObject('elementBinding', BaseUnit.name().localName(), BaseUnit)

usesGeodeticDatum = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesGeodeticDatum'), GeodeticDatumRefType, documentation=u'Association to the geodetic datum used by this CRS. ')
Namespace.addCategoryObject('elementBinding', usesGeodeticDatum.name().localName(), usesGeodeticDatum)

domainSet = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'domainSet'), DomainSetType)
Namespace.addCategoryObject('elementBinding', domainSet.name().localName(), domainSet)

ArcString = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ArcString'), ArcStringType)
Namespace.addCategoryObject('elementBinding', ArcString.name().localName(), ArcString)

vector = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'vector'), VectorType, documentation=u'')
Namespace.addCategoryObject('elementBinding', vector.name().localName(), vector)

CountList = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CountList'), integerOrNullList, documentation=u'A space-separated list of integers or nulls.')
Namespace.addCategoryObject('elementBinding', CountList.name().localName(), CountList)

GridCoverage = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GridCoverage'), GridCoverageType)
Namespace.addCategoryObject('elementBinding', GridCoverage.name().localName(), GridCoverage)

usesCartesianCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesCartesianCS'), CartesianCSRefType, documentation=u'Association to the Cartesian coordinate system used by this CRS. ')
Namespace.addCategoryObject('elementBinding', usesCartesianCS.name().localName(), usesCartesianCS)

FeatureCollection = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'FeatureCollection'), FeatureCollectionType)
Namespace.addCategoryObject('elementBinding', FeatureCollection.name().localName(), FeatureCollection)

parameterID = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'parameterID'), IdentifierType, documentation=u'An identification of an operation parameter. ')
Namespace.addCategoryObject('elementBinding', parameterID.name().localName(), parameterID)

measure = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'measure'), MeasureType)
Namespace.addCategoryObject('elementBinding', measure.name().localName(), measure)

rowIndex = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'rowIndex'), pyxb.binding.datatypes.positiveInteger, documentation=u'Row number of this covariance element value. ')
Namespace.addCategoryObject('elementBinding', rowIndex.name().localName(), rowIndex)

multiCoverage = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiCoverage'), MultiSurfacePropertyType)
Namespace.addCategoryObject('elementBinding', multiCoverage.name().localName(), multiCoverage)

LocationKeyWord = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'LocationKeyWord'), CodeType)
Namespace.addCategoryObject('elementBinding', LocationKeyWord.name().localName(), LocationKeyWord)

LocationString = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'LocationString'), StringOrRefType)
Namespace.addCategoryObject('elementBinding', LocationString.name().localName(), LocationString)

sourceDimensions = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sourceDimensions'), pyxb.binding.datatypes.positiveInteger, documentation=u'Number of dimensions in the source CRS of this operation method. ')
Namespace.addCategoryObject('elementBinding', sourceDimensions.name().localName(), sourceDimensions)

centerOf = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'centerOf'), PointPropertyType)
Namespace.addCategoryObject('elementBinding', centerOf.name().localName(), centerOf)

position = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'position'), PointPropertyType)
Namespace.addCategoryObject('elementBinding', position.name().localName(), position)

PrimeMeridian = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'PrimeMeridian'), PrimeMeridianType)
Namespace.addCategoryObject('elementBinding', PrimeMeridian.name().localName(), PrimeMeridian)

gridDomain = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'gridDomain'), GridDomainType)
Namespace.addCategoryObject('elementBinding', gridDomain.name().localName(), gridDomain)

centerLineOf = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'centerLineOf'), CurvePropertyType)
Namespace.addCategoryObject('elementBinding', centerLineOf.name().localName(), centerLineOf)

PolyhedralSurface = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'PolyhedralSurface'), PolyhedralSurfaceType)
Namespace.addCategoryObject('elementBinding', PolyhedralSurface.name().localName(), PolyhedralSurface)

extentOf = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'extentOf'), SurfacePropertyType)
Namespace.addCategoryObject('elementBinding', extentOf.name().localName(), extentOf)

Clothoid = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Clothoid'), ClothoidType)
Namespace.addCategoryObject('elementBinding', Clothoid.name().localName(), Clothoid)

Arc = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Arc'), ArcType)
Namespace.addCategoryObject('elementBinding', Arc.name().localName(), Arc)

RectifiedGridCoverage = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'RectifiedGridCoverage'), RectifiedGridCoverageType)
Namespace.addCategoryObject('elementBinding', RectifiedGridCoverage.name().localName(), RectifiedGridCoverage)

GeometryStyle = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GeometryStyle'), GeometryStyleType, documentation=u'The style descriptor for geometries of a feature.')
Namespace.addCategoryObject('elementBinding', GeometryStyle.name().localName(), GeometryStyle)

multiSurfaceProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiSurfaceProperty'), MultiSurfacePropertyType, documentation=u'This property element either references a surface aggregate via the XLink-attributes or contains the "multi surface" element. multiSurfaceProperty is the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that is substitutable for MultiSurface.')
Namespace.addCategoryObject('elementBinding', multiSurfaceProperty.name().localName(), multiSurfaceProperty)

positionalAccuracy = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_positionalAccuracy'), AbstractPositionalAccuracyType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', positionalAccuracy.name().localName(), positionalAccuracy)

ellipsoidName = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ellipsoidName'), CodeType, documentation=u'The name by which this ellipsoid is identified. ')
Namespace.addCategoryObject('elementBinding', ellipsoidName.name().localName(), ellipsoidName)

dictionaryEntry = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'dictionaryEntry'), DictionaryEntryType)
Namespace.addCategoryObject('elementBinding', dictionaryEntry.name().localName(), dictionaryEntry)

temporalCSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'temporalCSRef'), TemporalCSRefType)
Namespace.addCategoryObject('elementBinding', temporalCSRef.name().localName(), temporalCSRef)

usesTemporalCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesTemporalCS'), TemporalCSRefType, documentation=u'Association to the temporal coordinate system used by this CRS. ')
Namespace.addCategoryObject('elementBinding', usesTemporalCS.name().localName(), usesTemporalCS)

version = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'version'), pyxb.binding.datatypes.string, documentation=u'Identifier of the version of the associated codeSpace or code, as specified by the codeSpace or code authority. This version is included only when the "code" or "codeSpace" uses versions. When appropriate, the version is identified by the effective date, coded using ISO 8601 date format.')
Namespace.addCategoryObject('elementBinding', version.name().localName(), version)

remarks = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'remarks'), StringOrRefType, documentation=u'Information about this object or code. Contains text or refers to external text.')
Namespace.addCategoryObject('elementBinding', remarks.name().localName(), remarks)

axisID = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'axisID'), IdentifierType, documentation=u'An identification of a coordinate system axis. ')
Namespace.addCategoryObject('elementBinding', axisID.name().localName(), axisID)

ContinuousCoverage = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_ContinuousCoverage'), AbstractContinuousCoverageType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', ContinuousCoverage.name().localName(), ContinuousCoverage)

definitionMember = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'definitionMember'), DictionaryEntryType)
Namespace.addCategoryObject('elementBinding', definitionMember.name().localName(), definitionMember)

TimeTopologyComplex = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeTopologyComplex'), TimeTopologyComplexType, documentation=u'This element represents temporal topology complex. It shall be the connected acyclic directed graph composed of time nodes and time edges.')
Namespace.addCategoryObject('elementBinding', TimeTopologyComplex.name().localName(), TimeTopologyComplex)

Conversion = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Conversion'), ConversionType)
Namespace.addCategoryObject('elementBinding', Conversion.name().localName(), Conversion)

usesObliqueCartesianCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesObliqueCartesianCS'), ObliqueCartesianCSRefType, documentation=u'Association to the oblique Cartesian coordinate system used by this CRS.')
Namespace.addCategoryObject('elementBinding', usesObliqueCartesianCS.name().localName(), usesObliqueCartesianCS)

covariance = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'covariance'), pyxb.binding.datatypes.double, documentation=u'Value of covariance matrix element. ')
Namespace.addCategoryObject('elementBinding', covariance.name().localName(), covariance)

quantityType = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'quantityType'), StringOrRefType, documentation=u'Informal description of the phenomenon or type of quantity that is measured or observed. For example, "length", "angle", "time", "pressure", or "temperature". When the quantity is the result of an observation or measurement, this term is known as Observable Type or Measurand.')
Namespace.addCategoryObject('elementBinding', quantityType.name().localName(), quantityType)

usesParameter = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesParameter'), AbstractGeneralOperationParameterRefType, documentation=u'Association to an operation parameter or parameter group used by this operation method. ')
Namespace.addCategoryObject('elementBinding', usesParameter.name().localName(), usesParameter)

usesMethod = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesMethod'), OperationMethodRefType, documentation=u'Association to the operation method used by this coordinate operation. ')
Namespace.addCategoryObject('elementBinding', usesMethod.name().localName(), usesMethod)

multiCurveDomain = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiCurveDomain'), MultiCurveDomainType)
Namespace.addCategoryObject('elementBinding', multiCurveDomain.name().localName(), multiCurveDomain)

dataSource = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'dataSource'), StringOrRefType)
Namespace.addCategoryObject('elementBinding', dataSource.name().localName(), dataSource)

conversionRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'conversionRef'), ConversionRefType)
Namespace.addCategoryObject('elementBinding', conversionRef.name().localName(), conversionRef)

MultiPoint = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiPoint'), MultiPointType)
Namespace.addCategoryObject('elementBinding', MultiPoint.name().localName(), MultiPoint)

MappingRule = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MappingRule'), StringOrRefType, documentation=u'Description of a rule for associating members from the domainSet with members of the rangeSet.')
Namespace.addCategoryObject('elementBinding', MappingRule.name().localName(), MappingRule)

FeatureCollection_ = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_FeatureCollection'), AbstractFeatureCollectionType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', FeatureCollection_.name().localName(), FeatureCollection_)

GeodesicString = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GeodesicString'), GeodesicStringType)
Namespace.addCategoryObject('elementBinding', GeodesicString.name().localName(), GeodesicString)

DiscreteCoverage = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_DiscreteCoverage'), AbstractDiscreteCoverageType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', DiscreteCoverage.name().localName(), DiscreteCoverage)

AffinePlacement = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AffinePlacement'), AffinePlacementType)
Namespace.addCategoryObject('elementBinding', AffinePlacement.name().localName(), AffinePlacement)

anchorPoint = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'anchorPoint'), CodeType, documentation=u'Description, possibly including coordinates, of the point or points used to anchor the datum to the Earth. Also known as the "origin", especially for engineering and image datums. The codeSpace attribute can be used to reference a source of more detailed on this point or surface, or on a set of such descriptions. \n- For a geodetic datum, this point is also known as the fundamental point, which is traditionally the point where the relationship between geoid and ellipsoid is defined. In some cases, the "fundamental point" may consist of a number of points. In those cases, the parameters defining the geoid/ellipsoid relationship have been averaged for these points, and the averages adopted as the datum definition.\n- For an engineering datum, the anchor point may be a physical point, or it may be a point with defined coordinates in another CRS. When appropriate, the coordinates of this anchor point can be referenced in another document, such as referencing a GML feature that references or includes a point position.\n- For an image datum, the anchor point is usually either the centre of the image or the corner of the image.\n- For a temporal datum, this attribute is not defined. Instead of the anchor point, a temporal datum carries a separate time origin of type DateTime. ')
Namespace.addCategoryObject('elementBinding', anchorPoint.name().localName(), anchorPoint)

Solid = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Solid'), SolidType)
Namespace.addCategoryObject('elementBinding', Solid.name().localName(), Solid)

Envelope = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Envelope'), EnvelopeType)
Namespace.addCategoryObject('elementBinding', Envelope.name().localName(), Envelope)

definedByConversion = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'definedByConversion'), GeneralConversionRefType, documentation=u'Association to the coordinate conversion used to define this derived CRS. ')
Namespace.addCategoryObject('elementBinding', definedByConversion.name().localName(), definedByConversion)

CoordinateSystemAxis = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CoordinateSystemAxis'), CoordinateSystemAxisType)
Namespace.addCategoryObject('elementBinding', CoordinateSystemAxis.name().localName(), CoordinateSystemAxis)

CylindricalCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CylindricalCS'), CylindricalCSType)
Namespace.addCategoryObject('elementBinding', CylindricalCS.name().localName(), CylindricalCS)

temporalExtent = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'temporalExtent'), TimePeriodType, documentation=u'A time period defining the temporal domain of this object.')
Namespace.addCategoryObject('elementBinding', temporalExtent.name().localName(), temporalExtent)

Ellipsoid = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Ellipsoid'), EllipsoidType)
Namespace.addCategoryObject('elementBinding', Ellipsoid.name().localName(), Ellipsoid)

projectedCRSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'projectedCRSRef'), ProjectedCRSRefType)
Namespace.addCategoryObject('elementBinding', projectedCRSRef.name().localName(), projectedCRSRef)

EllipsoidalCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'EllipsoidalCS'), EllipsoidalCSType)
Namespace.addCategoryObject('elementBinding', EllipsoidalCS.name().localName(), EllipsoidalCS)

GeographicCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GeographicCRS'), GeographicCRSType)
Namespace.addCategoryObject('elementBinding', GeographicCRS.name().localName(), GeographicCRS)

meridianName = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'meridianName'), CodeType, documentation=u'The name by which this prime meridian is identified. The meridianName most common value is Greenwich, and that value shall be used when the greenwichLongitude value is zero. ')
Namespace.addCategoryObject('elementBinding', meridianName.name().localName(), meridianName)

Style = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Style'), AbstractStyleType, abstract=pyxb.binding.datatypes.boolean(1), documentation=u'The value of the top-level property. It is an abstract element. Used as the head element of the substitution group for extensibility purposes.')
Namespace.addCategoryObject('elementBinding', Style.name().localName(), Style)

crsRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'crsRef'), CRSRefType)
Namespace.addCategoryObject('elementBinding', crsRef.name().localName(), crsRef)

coord = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coord'), CoordType, documentation=u'Deprecated with GML 3.0 and included for backwards compatibility with GML 2. Use the "pos" element instead.')
Namespace.addCategoryObject('elementBinding', coord.name().localName(), coord)

ArcByCenterPoint = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ArcByCenterPoint'), ArcByCenterPointType)
Namespace.addCategoryObject('elementBinding', ArcByCenterPoint.name().localName(), ArcByCenterPoint)

association = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_association'), AssociationType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', association.name().localName(), association)

indirectEntry = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'indirectEntry'), IndirectEntryType)
Namespace.addCategoryObject('elementBinding', indirectEntry.name().localName(), indirectEntry)

operationParameterRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'operationParameterRef'), OperationParameterRefType)
Namespace.addCategoryObject('elementBinding', operationParameterRef.name().localName(), operationParameterRef)

Category = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Category'), CodeType, documentation=u'A term representing a classification.  It has an optional XML attribute codeSpace, whose value is a URI which identifies a dictionary, codelist or authority for the term.')
Namespace.addCategoryObject('elementBinding', Category.name().localName(), Category)

graphStyle = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'graphStyle'), GraphStylePropertyType, documentation=u'')
Namespace.addCategoryObject('elementBinding', graphStyle.name().localName(), graphStyle)

multiLocation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiLocation'), MultiPointPropertyType, documentation=u'Deprecated with GML 3.0 and included only for backwards compatibility with GML 2.0. Use "curveMember" instead.\nThis property element either references a line string via the XLink-attributes or contains the line string element.')
Namespace.addCategoryObject('elementBinding', multiLocation.name().localName(), multiLocation)

Bezier = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Bezier'), BezierType)
Namespace.addCategoryObject('elementBinding', Bezier.name().localName(), Bezier)

DirectionVector = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DirectionVector'), DirectionVectorType)
Namespace.addCategoryObject('elementBinding', DirectionVector.name().localName(), DirectionVector)

featureStyle = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'featureStyle'), FeatureStylePropertyType, documentation=u'')
Namespace.addCategoryObject('elementBinding', featureStyle.name().localName(), featureStyle)

transformationRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'transformationRef'), TransformationRefType)
Namespace.addCategoryObject('elementBinding', transformationRef.name().localName(), transformationRef)

segments = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'segments'), CurveSegmentArrayPropertyType, documentation=u'This property element contains a list of curve segments. The order of the elements is significant and shall be preserved when processing the array.')
Namespace.addCategoryObject('elementBinding', segments.name().localName(), segments)

CategoryList = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CategoryList'), CodeOrNullListType, documentation=u'A space-separated list of terms or nulls.  A single XML attribute codeSpace may be provided, which authorises all the terms in the list.')
Namespace.addCategoryObject('elementBinding', CategoryList.name().localName(), CategoryList)

measureDescription = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'measureDescription'), CodeType, documentation=u'A description of the position accuracy parameter(s) provided. ')
Namespace.addCategoryObject('elementBinding', measureDescription.name().localName(), measureDescription)

CompositeSolid = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CompositeSolid'), CompositeSolidType)
Namespace.addCategoryObject('elementBinding', CompositeSolid.name().localName(), CompositeSolid)

SurfacePatch = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_SurfacePatch'), AbstractSurfacePatchType, abstract=pyxb.binding.datatypes.boolean(1), documentation=u'The "_SurfacePatch" element is the abstract head of the substituition group for all surface pach elements describing a continuous portion of a surface.')
Namespace.addCategoryObject('elementBinding', SurfacePatch.name().localName(), SurfacePatch)

TimeObject = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_TimeObject'), AbstractTimeObjectType, abstract=pyxb.binding.datatypes.boolean(1), documentation=u'This abstract element acts as the head of the substitution group for temporal primitives and complexes.')
Namespace.addCategoryObject('elementBinding', TimeObject.name().localName(), TimeObject)

groupID = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'groupID'), IdentifierType, documentation=u'An identification of an operation parameter group. ')
Namespace.addCategoryObject('elementBinding', groupID.name().localName(), groupID)

GenericMetaData = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GenericMetaData'), GenericMetaDataType, documentation=u'Concrete element in the _MetaData substitution group, which permits any well-formed XML content.  Intended to act as a container for metadata defined in external schemas, for which it is not possible to add the concrete components to the GML _MetaData substitution group directly. Deprecated with GML version 3.1.0.')
Namespace.addCategoryObject('elementBinding', GenericMetaData.name().localName(), GenericMetaData)

catalogSymbol = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'catalogSymbol'), CodeType, documentation=u'For global understanding of a unit of measure, it is often possible to reference an item in a catalog of units, using a symbol in that catalog. The "codeSpace" attribute in "CodeType" identifies a namespace for the catalog symbol value, and might reference the catalog. The "string" value in "CodeType" contains the value of a symbol that is unique within this catalog namespace. This symbol often appears explicitly in the catalog, but it could be a combination of symbols using a specified algebra of units. For example, the symbol "cm" might indicate that it is the "m" symbol combined with the "c" prefix.')
Namespace.addCategoryObject('elementBinding', catalogSymbol.name().localName(), catalogSymbol)

datumRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'datumRef'), DatumRefType)
Namespace.addCategoryObject('elementBinding', datumRef.name().localName(), datumRef)

srsID = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'srsID'), IdentifierType, documentation=u'An identification of a reference system.')
Namespace.addCategoryObject('elementBinding', srsID.name().localName(), srsID)

Quantity = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Quantity'), MeasureType, documentation=u'A numeric value with a scale.  The content of the element is an amount using the XML Schema type double which permits decimal or scientific notation.  An XML attribute uom (unit of measure) is required, whose value is a URI which identifies the definition of the scale or units by which the numeric value must be multiplied.')
Namespace.addCategoryObject('elementBinding', Quantity.name().localName(), Quantity)

semiMinorAxis = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'semiMinorAxis'), MeasureType, documentation=u'Length of the semi-minor axis of the ellipsoid. Uses the MeasureType with the restriction that the unit of measure referenced by uom must be suitable for a length, such as metres or feet. ')
Namespace.addCategoryObject('elementBinding', semiMinorAxis.name().localName(), semiMinorAxis)

valueProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'valueProperty'), ValuePropertyType, documentation=u'Element which refers to, or contains, a Value')
Namespace.addCategoryObject('elementBinding', valueProperty.name().localName(), valueProperty)

Surface_ = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Surface'), AbstractSurfaceType, abstract=pyxb.binding.datatypes.boolean(1), documentation=u'The "_Surface" element is the abstract head of the substituition group for all (continuous) surface elements.')
Namespace.addCategoryObject('elementBinding', Surface_.name().localName(), Surface_)

temporalDatumRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'temporalDatumRef'), TemporalDatumRefType)
Namespace.addCategoryObject('elementBinding', temporalDatumRef.name().localName(), temporalDatumRef)

generalTransformationRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'generalTransformationRef'), GeneralTransformationRefType)
Namespace.addCategoryObject('elementBinding', generalTransformationRef.name().localName(), generalTransformationRef)

userDefinedCSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'userDefinedCSRef'), UserDefinedCSRefType)
Namespace.addCategoryObject('elementBinding', userDefinedCSRef.name().localName(), userDefinedCSRef)

ObliqueCartesianCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ObliqueCartesianCS'), ObliqueCartesianCSType)
Namespace.addCategoryObject('elementBinding', ObliqueCartesianCS.name().localName(), ObliqueCartesianCS)

ImageDatum = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ImageDatum'), ImageDatumType)
Namespace.addCategoryObject('elementBinding', ImageDatum.name().localName(), ImageDatum)

realizationEpoch = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'realizationEpoch'), pyxb.binding.datatypes.date, documentation=u'The time after which this datum definition is valid. This time may be precise (e.g. 1997.0 for IRTF97) or merely a year (e.g. 1983 for NAD83). In the latter case, the epoch usually refers to the year in which a major recalculation of the geodetic control network, underlying the datum, was executed or initiated. An old datum can remain valid after a new datum is defined. Alternatively, a datum may be superseded by a later datum, in which case the realization epoch for the new datum defines the upper limit for the validity of the superseded datum. ')
Namespace.addCategoryObject('elementBinding', realizationEpoch.name().localName(), realizationEpoch)

ImplicitGeometry = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_ImplicitGeometry'), AbstractGeometryType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', ImplicitGeometry.name().localName(), ImplicitGeometry)

TimeClock = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeClock'), TimeClockType)
Namespace.addCategoryObject('elementBinding', TimeClock.name().localName(), TimeClock)

coordinateOperationRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationRef'), CoordinateOperationRefType)
Namespace.addCategoryObject('elementBinding', coordinateOperationRef.name().localName(), coordinateOperationRef)

origin = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'origin'), pyxb.binding.datatypes.dateTime, documentation=u'The date and time origin of this temporal datum. ')
Namespace.addCategoryObject('elementBinding', origin.name().localName(), origin)

Grid = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Grid'), GridType)
Namespace.addCategoryObject('elementBinding', Grid.name().localName(), Grid)

TimeSlice = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_TimeSlice'), AbstractTimeSliceType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', TimeSlice.name().localName(), TimeSlice)

MultiCurve = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiCurve'), MultiCurveType)
Namespace.addCategoryObject('elementBinding', MultiCurve.name().localName(), MultiCurve)

Coverage = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Coverage'), AbstractCoverageType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', Coverage.name().localName(), Coverage)

TopoCurve = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopoCurve'), TopoCurveType)
Namespace.addCategoryObject('elementBinding', TopoCurve.name().localName(), TopoCurve)

GridFunction = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GridFunction'), GridFunctionType)
Namespace.addCategoryObject('elementBinding', GridFunction.name().localName(), GridFunction)

coordinates = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), CoordinatesType, documentation=u'Deprecated with GML version 3.1.0.')
Namespace.addCategoryObject('elementBinding', coordinates.name().localName(), coordinates)

minimumOccurs = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minimumOccurs'), pyxb.binding.datatypes.nonNegativeInteger, documentation=u'The minimum number of times that values for this parameter group or parameter are required. If this attribute is omitted, the minimum number is one. ')
Namespace.addCategoryObject('elementBinding', minimumOccurs.name().localName(), minimumOccurs)

RectifiedGrid = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'RectifiedGrid'), RectifiedGridType, documentation=u'Should be substitutionGroup="gml:Grid" but changed in order to accomplish Xerces-J schema validation')
Namespace.addCategoryObject('elementBinding', RectifiedGrid.name().localName(), RectifiedGrid)

directedFace = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedFace'), DirectedFacePropertyType, documentation=u'')
Namespace.addCategoryObject('elementBinding', directedFace.name().localName(), directedFace)

container = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'container'), ContainerPropertyType, documentation=u'')
Namespace.addCategoryObject('elementBinding', container.name().localName(), container)

usesEllipsoid = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesEllipsoid'), EllipsoidRefType, documentation=u'Association to the ellipsoid used by this geodetic datum. ')
Namespace.addCategoryObject('elementBinding', usesEllipsoid.name().localName(), usesEllipsoid)

Curve = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Curve'), CurveType)
Namespace.addCategoryObject('elementBinding', Curve.name().localName(), Curve)

multiSurfaceDomain = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiSurfaceDomain'), MultiSurfaceDomainType)
Namespace.addCategoryObject('elementBinding', multiSurfaceDomain.name().localName(), multiSurfaceDomain)

directedEdge = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'), DirectedEdgePropertyType, documentation=u'')
Namespace.addCategoryObject('elementBinding', directedEdge.name().localName(), directedEdge)

Sphere = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Sphere'), SphereType)
Namespace.addCategoryObject('elementBinding', Sphere.name().localName(), Sphere)

Node = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Node'), NodeType)
Namespace.addCategoryObject('elementBinding', Node.name().localName(), Node)

surfaceArrayProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'surfaceArrayProperty'), SurfaceArrayPropertyType)
Namespace.addCategoryObject('elementBinding', surfaceArrayProperty.name().localName(), surfaceArrayProperty)

Geometry = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Geometry'), AbstractGeometryType, abstract=pyxb.binding.datatypes.boolean(1), documentation=u'The "_Geometry" element is the abstract head of the substituition group for all geometry elements of GML 3. This \n\t\t\tincludes pre-defined and user-defined geometry elements. Any geometry element must be a direct or indirect extension/restriction \n\t\t\tof AbstractGeometryType and must be directly or indirectly in the substitution group of "_Geometry".')
Namespace.addCategoryObject('elementBinding', Geometry.name().localName(), Geometry)

axisAbbrev = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'axisAbbrev'), CodeType, documentation=u'The abbreviation used for this coordinate system axis. This abbreviation can be used to identify the ordinates in a coordinate tuple. Examples are X and Y. The codeSpace attribute can reference a source of more information on a set of standardized abbreviations, or on this abbreviation. ')
Namespace.addCategoryObject('elementBinding', axisAbbrev.name().localName(), axisAbbrev)

CoordinateOperation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_CoordinateOperation'), AbstractCoordinateOperationType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', CoordinateOperation.name().localName(), CoordinateOperation)

directedNode = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedNode'), DirectedNodePropertyType, documentation=u'')
Namespace.addCategoryObject('elementBinding', directedNode.name().localName(), directedNode)

SphericalCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'SphericalCS'), SphericalCSType)
Namespace.addCategoryObject('elementBinding', SphericalCS.name().localName(), SphericalCS)

strictAssociation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_strictAssociation'), AssociationType, abstract=pyxb.binding.datatypes.boolean(1), documentation=u'must carry a reference to an object or contain an object but not both')
Namespace.addCategoryObject('elementBinding', strictAssociation.name().localName(), strictAssociation)

FeatureStyle = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'FeatureStyle'), FeatureStyleType, documentation=u'The style descriptor for features.')
Namespace.addCategoryObject('elementBinding', FeatureStyle.name().localName(), FeatureStyle)

Style_ = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Style'), StyleType, documentation=u'Predefined concrete value of the top-level property. Encapsulates all other styling information.')
Namespace.addCategoryObject('elementBinding', Style_.name().localName(), Style_)

axisDirection = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'axisDirection'), CodeType, documentation=u'Direction of this coordinate system axis (or in the case of Cartesian projected coordinates, the direction of this coordinate system axis at the origin). Examples: north or south, east or west, up or down. Within any set of coordinate system axes, only one of each pair of terms can be used. For earth-fixed CRSs, this direction is often approximate and intended to provide a human interpretable meaning to the axis. When a geodetic datum is used, the precise directions of the axes may therefore vary slightly from this approximate direction. Note that an EngineeringCRS can include specific descriptions of the directions of its coordinate system axes. For example, the path of a linear CRS axis can be referenced in another document, such as referencing a GML feature that references or includes a curve geometry. The codeSpace attribute can reference a source of more information on a set of standardized directions, or on this direction. ')
Namespace.addCategoryObject('elementBinding', axisDirection.name().localName(), axisDirection)

engineeringDatumRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'engineeringDatumRef'), EngineeringDatumRefType)
Namespace.addCategoryObject('elementBinding', engineeringDatumRef.name().localName(), engineeringDatumRef)

surfaceProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'surfaceProperty'), SurfacePropertyType, documentation=u'This property element either references a surface via the XLink-attributes or contains the surface element. surfaceProperty is the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that is substitutable for _Surface.')
Namespace.addCategoryObject('elementBinding', surfaceProperty.name().localName(), surfaceProperty)

solidProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'solidProperty'), SolidPropertyType, documentation=u'This property element either references a solid via the XLink-attributes or contains the solid element. solidProperty is the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that is substitutable for _Solid.')
Namespace.addCategoryObject('elementBinding', solidProperty.name().localName(), solidProperty)

maximumOccurs = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximumOccurs'), pyxb.binding.datatypes.positiveInteger, documentation=u'The maximum number of times that values for this parameter group can be included. If this attribute is omitted, the maximum number is one. ')
Namespace.addCategoryObject('elementBinding', maximumOccurs.name().localName(), maximumOccurs)

TopoSurface = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopoSurface'), TopoSurfaceType)
Namespace.addCategoryObject('elementBinding', TopoSurface.name().localName(), TopoSurface)

MultiPolygon = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiPolygon'), MultiPolygonType, documentation=u'Deprecated with GML 3.0 and included for backwards compatibility with GML 2. Use the "MultiSurface" element instead.')
Namespace.addCategoryObject('elementBinding', MultiPolygon.name().localName(), MultiPolygon)

Point = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Point'), PointType)
Namespace.addCategoryObject('elementBinding', Point.name().localName(), Point)

Rectangle = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Rectangle'), RectangleType)
Namespace.addCategoryObject('elementBinding', Rectangle.name().localName(), Rectangle)

isSphere = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'isSphere'), STD_ANON_12, documentation=u'The ellipsoid is degenerate and is actually a sphere. The sphere is completely defined by the semi-major axis, which is the radius of the sphere. ')
Namespace.addCategoryObject('elementBinding', isSphere.name().localName(), isSphere)

lineStringProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'lineStringProperty'), LineStringPropertyType, documentation=u'Deprecated with GML 3.0 and included only for backwards compatibility with GML 2.0. Use "curveProperty" instead. This \n\t\t\tproperty element either references a line string via the XLink-attributes or contains the line string element.')
Namespace.addCategoryObject('elementBinding', lineStringProperty.name().localName(), lineStringProperty)

member = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'member'), AssociationType)
Namespace.addCategoryObject('elementBinding', member.name().localName(), member)

usesSingleOperation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesSingleOperation'), SingleOperationRefType, documentation=u'Association to a single operation. ')
Namespace.addCategoryObject('elementBinding', usesSingleOperation.name().localName(), usesSingleOperation)

generalParameterValue = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_generalParameterValue'), AbstractGeneralParameterValueType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', generalParameterValue.name().localName(), generalParameterValue)

Polygon = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Polygon'), PolygonType)
Namespace.addCategoryObject('elementBinding', Polygon.name().localName(), Polygon)

CompositeCurve = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CompositeCurve'), CompositeCurveType)
Namespace.addCategoryObject('elementBinding', CompositeCurve.name().localName(), CompositeCurve)

MultiLineString = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiLineString'), MultiLineStringType, documentation=u'Deprecated with GML 3.0 and included for backwards compatibility with GML 2. Use the "MultiCurve" element instead.')
Namespace.addCategoryObject('elementBinding', MultiLineString.name().localName(), MultiLineString)

value = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'value'), MeasureType, documentation=u'Numeric value of an operation parameter, with its associated unit of measure. ')
Namespace.addCategoryObject('elementBinding', value.name().localName(), value)

TriangulatedSurface = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TriangulatedSurface'), TriangulatedSurfaceType)
Namespace.addCategoryObject('elementBinding', TriangulatedSurface.name().localName(), TriangulatedSurface)

Ring = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Ring'), RingType)
Namespace.addCategoryObject('elementBinding', Ring.name().localName(), Ring)

Ring_ = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Ring'), AbstractRingType, abstract=pyxb.binding.datatypes.boolean(1), documentation=u'The "_Ring" element is the abstract head of the substituition group for all closed boundaries of a surface patch.')
Namespace.addCategoryObject('elementBinding', Ring_.name().localName(), Ring_)

CurveSegment = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_CurveSegment'), AbstractCurveSegmentType, abstract=pyxb.binding.datatypes.boolean(1), documentation=u'The "_CurveSegment" element is the abstract head of the substituition group for all curve segment elements, i.e. continuous segments of the same interpolation mechanism.')
Namespace.addCategoryObject('elementBinding', CurveSegment.name().localName(), CurveSegment)

curveMembers = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'curveMembers'), CurveArrayPropertyType, documentation=u'This property element contains a list of curves. The order of the elements is significant and shall be preserved when processing the array.')
Namespace.addCategoryObject('elementBinding', curveMembers.name().localName(), curveMembers)

GeometricPrimitive = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_GeometricPrimitive'), AbstractGeometricPrimitiveType, abstract=pyxb.binding.datatypes.boolean(1), documentation=u'The "_GeometricPrimitive" element is the abstract head of the substituition group for all (pre- and user-defined) \n\t\t\tgeometric primitives.')
Namespace.addCategoryObject('elementBinding', GeometricPrimitive.name().localName(), GeometricPrimitive)

integerValue = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'integerValue'), pyxb.binding.datatypes.positiveInteger, documentation=u'Positive integer value of an operation parameter, usually used for a count. An integer value does not have an associated unit of measure. ')
Namespace.addCategoryObject('elementBinding', integerValue.name().localName(), integerValue)

TopoSolid = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopoSolid'), TopoSolidType)
Namespace.addCategoryObject('elementBinding', TopoSolid.name().localName(), TopoSolid)

pointArrayProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointArrayProperty'), PointArrayPropertyType)
Namespace.addCategoryObject('elementBinding', pointArrayProperty.name().localName(), pointArrayProperty)

metaDataProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'), MetaDataPropertyType, documentation=u'Contains or refers to a metadata package that contains metadata properties.')
Namespace.addCategoryObject('elementBinding', metaDataProperty.name().localName(), metaDataProperty)

geometryMember = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'geometryMember'), GeometryPropertyType, documentation=u'This property element either references a geometry element via the XLink-attributes or contains the geometry element.')
Namespace.addCategoryObject('elementBinding', geometryMember.name().localName(), geometryMember)

interior = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'interior'), AbstractRingPropertyType, documentation=u'A boundary of a surface consists of a number of rings. The "interior" rings seperate the surface / surface patch from the area enclosed by the rings.')
Namespace.addCategoryObject('elementBinding', interior.name().localName(), interior)

BSpline = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'BSpline'), BSplineType)
Namespace.addCategoryObject('elementBinding', BSpline.name().localName(), BSpline)

solidMember = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'solidMember'), SolidPropertyType, documentation=u'This property element either references a solid via the XLink-attributes or contains the solid element. A solid element is any element which is substitutable for "_Solid".')
Namespace.addCategoryObject('elementBinding', solidMember.name().localName(), solidMember)

polygonMember = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'polygonMember'), PolygonPropertyType, documentation=u'Deprecated with GML 3.0 and included only for backwards compatibility with GML 2.0. Use "surfaceMember" instead.\nThis property element either references a polygon via the XLink-attributes or contains the polygon element.')
Namespace.addCategoryObject('elementBinding', polygonMember.name().localName(), polygonMember)

outerBoundaryIs = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'outerBoundaryIs'), AbstractRingPropertyType, documentation=u'Deprecated with GML 3.0, included only for backwards compatibility with GML 2. Use "exterior" instead.')
Namespace.addCategoryObject('elementBinding', outerBoundaryIs.name().localName(), outerBoundaryIs)

integerValueList = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'integerValueList'), integerList, documentation=u'Ordered sequence of two or more integer values of an operation parameter list, usually used for counts. These integer values do not have an associated unit of measure. An element of this type contains a space-separated sequence of integer values. ')
Namespace.addCategoryObject('elementBinding', integerValueList.name().localName(), integerValueList)

GeometricComplex = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GeometricComplex'), GeometricComplexType)
Namespace.addCategoryObject('elementBinding', GeometricComplex.name().localName(), GeometricComplex)

Curve_ = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Curve'), AbstractCurveType, abstract=pyxb.binding.datatypes.boolean(1), documentation=u'The "_Curve" element is the abstract head of the substituition group for all (continuous) curve elements.')
Namespace.addCategoryObject('elementBinding', Curve_.name().localName(), Curve_)

multiCenterOf = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiCenterOf'), MultiPointPropertyType)
Namespace.addCategoryObject('elementBinding', multiCenterOf.name().localName(), multiCenterOf)

concatenatedOperationRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'concatenatedOperationRef'), ConcatenatedOperationRefType)
Namespace.addCategoryObject('elementBinding', concatenatedOperationRef.name().localName(), concatenatedOperationRef)

ParametricCurveSurface = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_ParametricCurveSurface'), AbstractParametricCurveSurfaceType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', ParametricCurveSurface.name().localName(), ParametricCurveSurface)

valueOfParameter = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'valueOfParameter'), OperationParameterRefType, documentation=u'Association to the operation parameter that this is a value of. ')
Namespace.addCategoryObject('elementBinding', valueOfParameter.name().localName(), valueOfParameter)

modifiedCoordinate = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'modifiedCoordinate'), pyxb.binding.datatypes.positiveInteger, documentation=u'A positive integer defining a position in a coordinate tuple. ')
Namespace.addCategoryObject('elementBinding', modifiedCoordinate.name().localName(), modifiedCoordinate)

coordinateOperationName = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationName'), CodeType, documentation=u'The name by which this coordinate operation is identified. ')
Namespace.addCategoryObject('elementBinding', coordinateOperationName.name().localName(), coordinateOperationName)

LinearRing = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'LinearRing'), LinearRingType)
Namespace.addCategoryObject('elementBinding', LinearRing.name().localName(), LinearRing)

geometryMembers = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'geometryMembers'), GeometryArrayPropertyType, documentation=u'This property element contains a list of geometry elements. The order of the elements is significant and shall be preserved when processing the array.')
Namespace.addCategoryObject('elementBinding', geometryMembers.name().localName(), geometryMembers)

parameterValue = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'parameterValue'), ParameterValueType)
Namespace.addCategoryObject('elementBinding', parameterValue.name().localName(), parameterValue)

lineStringMember = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'lineStringMember'), LineStringPropertyType, documentation=u'Deprecated with GML 3.0 and included only for backwards compatibility with GML 2.0. Use "curveMember" instead.\nThis property element either references a line string via the XLink-attributes or contains the line string element.')
Namespace.addCategoryObject('elementBinding', lineStringMember.name().localName(), lineStringMember)

engineeringCRSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'engineeringCRSRef'), EngineeringCRSRefType)
Namespace.addCategoryObject('elementBinding', engineeringCRSRef.name().localName(), engineeringCRSRef)

methodFormula = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'methodFormula'), CodeType, documentation=u'Formula(s) used by this operation method. The value may be a reference to a publication. Note that the operation method may not be analytic, in which case this element references or contains the procedure, not an analytic formula.')
Namespace.addCategoryObject('elementBinding', methodFormula.name().localName(), methodFormula)

name = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'name'), CodeType, documentation=u'Label for the object, normally a descriptive name. An object may have several names, typically assigned by different authorities.  The authority for a name is indicated by the value of its (optional) codeSpace attribute.  The name may or may not be unique, as determined by the rules of the organization responsible for the codeSpace.')
Namespace.addCategoryObject('elementBinding', name.name().localName(), name)

GriddedSurface = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_GriddedSurface'), AbstractGriddedSurfaceType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', GriddedSurface.name().localName(), GriddedSurface)

OffsetCurve = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'OffsetCurve'), OffsetCurveType)
Namespace.addCategoryObject('elementBinding', OffsetCurve.name().localName(), OffsetCurve)

reference = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_reference'), ReferenceType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', reference.name().localName(), reference)

Operation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Operation'), AbstractCoordinateOperationType, abstract=pyxb.binding.datatypes.boolean(1), documentation=u'A parameterized mathematical operation on coordinates that transforms or converts coordinates to another coordinate reference system. This coordinate operation uses an operation method, usually with associated parameter values. However, operation methods and parameter values are directly associated with concrete subtypes, not with this abstract type.\n\nThis abstract complexType shall not be directly used, extended, or restricted in a compliant Application Schema. ')
Namespace.addCategoryObject('elementBinding', Operation.name().localName(), Operation)

sourceCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sourceCRS'), CRSRefType, documentation=u'Association to the source CRS (coordinate reference system) of this coordinate operation. ')
Namespace.addCategoryObject('elementBinding', sourceCRS.name().localName(), sourceCRS)

coordinateSystemRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinateSystemRef'), CoordinateSystemRefType)
Namespace.addCategoryObject('elementBinding', coordinateSystemRef.name().localName(), coordinateSystemRef)

usesCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesCS'), CoordinateSystemRefType, documentation=u'Association to the coordinate system used by this CRS. ')
Namespace.addCategoryObject('elementBinding', usesCS.name().localName(), usesCS)

topoComplexProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'topoComplexProperty'), TopoComplexMemberType)
Namespace.addCategoryObject('elementBinding', topoComplexProperty.name().localName(), topoComplexProperty)

Definition = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Definition'), DefinitionType)
Namespace.addCategoryObject('elementBinding', Definition.name().localName(), Definition)

SingleOperation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_SingleOperation'), AbstractCoordinateOperationType, abstract=pyxb.binding.datatypes.boolean(1), documentation=u'A single (not concatenated) coordinate operation. ')
Namespace.addCategoryObject('elementBinding', SingleOperation.name().localName(), SingleOperation)

pointMember = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointMember'), PointPropertyType, documentation=u'This property element either references a Point via the XLink-attributes or contains the Point element.')
Namespace.addCategoryObject('elementBinding', pointMember.name().localName(), pointMember)

valueComponents = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'valueComponents'), ValueArrayPropertyType, documentation=u'Element which refers to, or contains, a set of homogeneously typed Values.')
Namespace.addCategoryObject('elementBinding', valueComponents.name().localName(), valueComponents)

CompositeSurface = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CompositeSurface'), CompositeSurfaceType)
Namespace.addCategoryObject('elementBinding', CompositeSurface.name().localName(), CompositeSurface)

methodName = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'methodName'), CodeType, documentation=u'The name by which this operation method is identified. ')
Namespace.addCategoryObject('elementBinding', methodName.name().localName(), methodName)

includesParameter = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'includesParameter'), AbstractGeneralOperationParameterRefType, documentation=u'Association to an operation parameter that is a member of a group. ')
Namespace.addCategoryObject('elementBinding', includesParameter.name().localName(), includesParameter)

linearCSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'linearCSRef'), LinearCSRefType)
Namespace.addCategoryObject('elementBinding', linearCSRef.name().localName(), linearCSRef)

ReferenceSystem = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_ReferenceSystem'), AbstractReferenceSystemType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', ReferenceSystem.name().localName(), ReferenceSystem)

polygonProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'polygonProperty'), PolygonPropertyType, documentation=u'Deprecated with GML 3.0 and included only for backwards compatibility with GML 2.0. Use "surfaceProperty" instead.\nThis property element either references a polygon via the XLink-attributes or contains the polygon element.')
Namespace.addCategoryObject('elementBinding', polygonProperty.name().localName(), polygonProperty)

DataBlock = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DataBlock'), DataBlockType)
Namespace.addCategoryObject('elementBinding', DataBlock.name().localName(), DataBlock)

minutes = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minutes'), ArcMinutesType)
Namespace.addCategoryObject('elementBinding', minutes.name().localName(), minutes)

Tin = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Tin'), TinType)
Namespace.addCategoryObject('elementBinding', Tin.name().localName(), Tin)

Cylinder = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Cylinder'), CylinderType)
Namespace.addCategoryObject('elementBinding', Cylinder.name().localName(), Cylinder)

pointMembers = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointMembers'), PointArrayPropertyType, documentation=u'This property element contains a list of points. The order of the elements is significant and shall be preserved when processing the array.')
Namespace.addCategoryObject('elementBinding', pointMembers.name().localName(), pointMembers)

referenceSystemRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'referenceSystemRef'), ReferenceSystemRefType)
Namespace.addCategoryObject('elementBinding', referenceSystemRef.name().localName(), referenceSystemRef)

conversionToPreferredUnit = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'conversionToPreferredUnit'), ConversionToPreferredUnitType, documentation=u'This element is included when this unit has an accurate conversion to the preferred unit for this quantity type.')
Namespace.addCategoryObject('elementBinding', conversionToPreferredUnit.name().localName(), conversionToPreferredUnit)

duration = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'duration'), pyxb.binding.datatypes.duration, documentation=u'This element is an instance of the primitive xsd:duration simple type to \n      enable use of the ISO 8601 syntax for temporal length (e.g. P5DT4H30M). \n      It is a valid subtype of TimeDurationType according to section 3.14.6, \n      rule 2.2.4 in XML Schema, Part 1.')
Namespace.addCategoryObject('elementBinding', duration.name().localName(), duration)

MetaData = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_MetaData'), AbstractMetaDataType, abstract=pyxb.binding.datatypes.boolean(1), documentation=u'Abstract element which acts as the head of a substitution group for packages of MetaData properties.')
Namespace.addCategoryObject('elementBinding', MetaData.name().localName(), MetaData)

dmsAngleValue = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'dmsAngleValue'), DMSAngleType, documentation=u'Value of an angle operation parameter, in either degree-minute-second format or single value format. ')
Namespace.addCategoryObject('elementBinding', dmsAngleValue.name().localName(), dmsAngleValue)

multiSolidDomain = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiSolidDomain'), MultiSolidDomainType)
Namespace.addCategoryObject('elementBinding', multiSolidDomain.name().localName(), multiSolidDomain)

stringValue = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'stringValue'), pyxb.binding.datatypes.string, documentation=u'String value of an operation parameter. A string value does not have an associated unit of measure. ')
Namespace.addCategoryObject('elementBinding', stringValue.name().localName(), stringValue)

TimeCoordinateSystem = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeCoordinateSystem'), TimeCoordinateSystemType)
Namespace.addCategoryObject('elementBinding', TimeCoordinateSystem.name().localName(), TimeCoordinateSystem)

location = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'location'), LocationPropertyType, documentation=u'Deprecated in GML 3.1.0')
Namespace.addCategoryObject('elementBinding', location.name().localName(), location)

multiPointProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiPointProperty'), MultiPointPropertyType, documentation=u'This property element either references a point aggregate via the XLink-attributes or contains the "multi point" element. multiPointProperty is the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that is substitutable for MultiPoint.')
Namespace.addCategoryObject('elementBinding', multiPointProperty.name().localName(), multiPointProperty)

datumID = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'datumID'), IdentifierType, documentation=u'An identification of a datum. ')
Namespace.addCategoryObject('elementBinding', datumID.name().localName(), datumID)

singleOperationRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'singleOperationRef'), SingleOperationRefType)
Namespace.addCategoryObject('elementBinding', singleOperationRef.name().localName(), singleOperationRef)

timePosition = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'timePosition'), TimePositionType, documentation=u'Direct representation of a temporal position')
Namespace.addCategoryObject('elementBinding', timePosition.name().localName(), timePosition)

columnIndex = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'columnIndex'), pyxb.binding.datatypes.positiveInteger, documentation=u'Column number of this covariance element value. ')
Namespace.addCategoryObject('elementBinding', columnIndex.name().localName(), columnIndex)

DerivedCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DerivedCRS'), DerivedCRSType)
Namespace.addCategoryObject('elementBinding', DerivedCRS.name().localName(), DerivedCRS)

sphericalCSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sphericalCSRef'), SphericalCSRefType)
Namespace.addCategoryObject('elementBinding', sphericalCSRef.name().localName(), sphericalCSRef)

surfaceMember = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'surfaceMember'), SurfacePropertyType, documentation=u'This property element either references a surface via the XLink-attributes or contains the surface element. A surface element is any element which is substitutable for "_Surface".')
Namespace.addCategoryObject('elementBinding', surfaceMember.name().localName(), surfaceMember)

TimeOrdinalReferenceSystem = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeOrdinalReferenceSystem'), TimeOrdinalReferenceSystemType)
Namespace.addCategoryObject('elementBinding', TimeOrdinalReferenceSystem.name().localName(), TimeOrdinalReferenceSystem)

imageCRSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'imageCRSRef'), ImageCRSRefType)
Namespace.addCategoryObject('elementBinding', imageCRSRef.name().localName(), imageCRSRef)

QuantityExtent = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'QuantityExtent'), QuantityExtentType, documentation=u'Utility element to store a 2-point range of numeric values. If one member is a null, then this is a single ended interval.')
Namespace.addCategoryObject('elementBinding', QuantityExtent.name().localName(), QuantityExtent)

dmsAngle = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'dmsAngle'), DMSAngleType)
Namespace.addCategoryObject('elementBinding', dmsAngle.name().localName(), dmsAngle)

EngineeringDatum = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'EngineeringDatum'), EngineeringDatumType)
Namespace.addCategoryObject('elementBinding', EngineeringDatum.name().localName(), EngineeringDatum)

CompositeValue = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CompositeValue'), CompositeValueType, documentation=u'Aggregate value built using the Composite pattern.')
Namespace.addCategoryObject('elementBinding', CompositeValue.name().localName(), CompositeValue)

Solid_ = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Solid'), AbstractSolidType, abstract=pyxb.binding.datatypes.boolean(1), documentation=u'The "_Solid" element is the abstract head of the substituition group for all (continuous) solid elements.')
Namespace.addCategoryObject('elementBinding', Solid_.name().localName(), Solid_)

TimeOrdinalEra = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeOrdinalEra'), TimeOrdinalEraType)
Namespace.addCategoryObject('elementBinding', TimeOrdinalEra.name().localName(), TimeOrdinalEra)

derivedCRSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'derivedCRSRef'), DerivedCRSRefType)
Namespace.addCategoryObject('elementBinding', derivedCRSRef.name().localName(), derivedCRSRef)

derivationUnitTerm = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'derivationUnitTerm'), DerivationUnitTermType)
Namespace.addCategoryObject('elementBinding', derivationUnitTerm.name().localName(), derivationUnitTerm)

pixelInCell = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pixelInCell'), PixelInCellType)
Namespace.addCategoryObject('elementBinding', pixelInCell.name().localName(), pixelInCell)

DerivedUnit = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DerivedUnit'), DerivedUnitType)
Namespace.addCategoryObject('elementBinding', DerivedUnit.name().localName(), DerivedUnit)

valueList = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'valueList'), MeasureListType, documentation=u'Ordered sequence of two or more numeric values of an operation parameter list, where each value has the same associated unit of measure. An element of this type contains a space-separated sequence of double values. ')
Namespace.addCategoryObject('elementBinding', valueList.name().localName(), valueList)

baseCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'baseCRS'), CoordinateReferenceSystemRefType, documentation=u'Association to the coordinate reference system used by this derived CRS. ')
Namespace.addCategoryObject('elementBinding', baseCRS.name().localName(), baseCRS)

imageDatumRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'imageDatumRef'), ImageDatumRefType)
Namespace.addCategoryObject('elementBinding', imageDatumRef.name().localName(), imageDatumRef)

TimeInstant = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeInstant'), TimeInstantType)
Namespace.addCategoryObject('elementBinding', TimeInstant.name().localName(), TimeInstant)

TemporalDatum = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TemporalDatum'), TemporalDatumType)
Namespace.addCategoryObject('elementBinding', TemporalDatum.name().localName(), TemporalDatum)

verticalCSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'verticalCSRef'), VerticalCSRefType)
Namespace.addCategoryObject('elementBinding', verticalCSRef.name().localName(), verticalCSRef)

TimeCalendar = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeCalendar'), TimeCalendarType)
Namespace.addCategoryObject('elementBinding', TimeCalendar.name().localName(), TimeCalendar)

rectifiedGridDomain = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'rectifiedGridDomain'), RectifiedGridDomainType)
Namespace.addCategoryObject('elementBinding', rectifiedGridDomain.name().localName(), rectifiedGridDomain)

VerticalDatum = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'VerticalDatum'), VerticalDatumType)
Namespace.addCategoryObject('elementBinding', VerticalDatum.name().localName(), VerticalDatum)

coordinateSystemAxisRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinateSystemAxisRef'), CoordinateSystemAxisRefType)
Namespace.addCategoryObject('elementBinding', coordinateSystemAxisRef.name().localName(), coordinateSystemAxisRef)

rangeSet = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'rangeSet'), RangeSetType)
Namespace.addCategoryObject('elementBinding', rangeSet.name().localName(), rangeSet)

baseCurve = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'baseCurve'), CurvePropertyType, documentation=u'This property element either references a curve via the XLink-attributes or contains the curve element. A curve element is any element which is substitutable for "_Curve".')
Namespace.addCategoryObject('elementBinding', baseCurve.name().localName(), baseCurve)

operationParameterGroupRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'operationParameterGroupRef'), OperationParameterRefType)
Namespace.addCategoryObject('elementBinding', operationParameterGroupRef.name().localName(), operationParameterGroupRef)

solidMembers = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'solidMembers'), SolidArrayPropertyType, documentation=u'This property element contains a list of solids. The order of the elements is significant and shall be preserved when processing the array.')
Namespace.addCategoryObject('elementBinding', solidMembers.name().localName(), solidMembers)

usesEllipsoidalCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesEllipsoidalCS'), EllipsoidalCSRefType, documentation=u'Association to the ellipsoidal coordinate system used by this CRS. ')
Namespace.addCategoryObject('elementBinding', usesEllipsoidalCS.name().localName(), usesEllipsoidalCS)

OrientableCurve = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'OrientableCurve'), OrientableCurveType)
Namespace.addCategoryObject('elementBinding', OrientableCurve.name().localName(), OrientableCurve)

verticalDatumType = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'verticalDatumType'), VerticalDatumTypeType)
Namespace.addCategoryObject('elementBinding', verticalDatumType.name().localName(), verticalDatumType)

absoluteExternalPositionalAccuracy = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'absoluteExternalPositionalAccuracy'), AbsoluteExternalPositionalAccuracyType)
Namespace.addCategoryObject('elementBinding', absoluteExternalPositionalAccuracy.name().localName(), absoluteExternalPositionalAccuracy)

decimalMinutes = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'decimalMinutes'), DecimalMinutesType)
Namespace.addCategoryObject('elementBinding', decimalMinutes.name().localName(), decimalMinutes)

VerticalCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'VerticalCRS'), VerticalCRSType)
Namespace.addCategoryObject('elementBinding', VerticalCRS.name().localName(), VerticalCRS)

TopologyStyle = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopologyStyle'), TopologyStyleType, documentation=u'The style descriptor for topologies of a feature. Describes individual topology elements styles.')
Namespace.addCategoryObject('elementBinding', TopologyStyle.name().localName(), TopologyStyle)

TimeNode = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeNode'), TimeNodeType, documentation=u'"TimeNode" is a zero dimensional temporal topology primitive, \n\t\t\texpresses a position in topological time, and is a start and an end of time edge, which represents states of time.\n\t\t\tTime node may be isolated. However, it cannot describe the ordering relationships with other primitives. \n\t\t\tAn isolated node may not be an element of any temporal topology complex.')
Namespace.addCategoryObject('elementBinding', TimeNode.name().localName(), TimeNode)

valueFile = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'valueFile'), pyxb.binding.datatypes.anyURI, documentation=u'Reference to a file or a part of a file containing one or more parameter values, each numeric value with its associated unit of measure. When referencing a part of a file, that file must contain multiple identified parts, such as an XML encoded document. Furthermore, the referenced file or part of a file can reference another part of the same or different files, as allowed in XML documents. ')
Namespace.addCategoryObject('elementBinding', valueFile.name().localName(), valueFile)

GeodeticDatum = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GeodeticDatum'), GeodeticDatumType)
Namespace.addCategoryObject('elementBinding', GeodeticDatum.name().localName(), GeodeticDatum)

Transformation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Transformation'), TransformationType)
Namespace.addCategoryObject('elementBinding', Transformation.name().localName(), Transformation)

UserDefinedCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'UserDefinedCS'), UserDefinedCSType)
Namespace.addCategoryObject('elementBinding', UserDefinedCS.name().localName(), UserDefinedCS)

pointProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), PointPropertyType, documentation=u'This property element either references a point via the XLink-attributes or contains the point element. pointProperty \n\t\t\tis the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that \n\t\t\tis substitutable for Point.')
Namespace.addCategoryObject('elementBinding', pointProperty.name().localName(), pointProperty)

result = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'result'), MeasureType, documentation=u'A quantitative result defined by the evaluation procedure used, and identified by the measureDescription. ')
Namespace.addCategoryObject('elementBinding', result.name().localName(), result)

LineString = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'LineString'), LineStringType)
Namespace.addCategoryObject('elementBinding', LineString.name().localName(), LineString)

covarianceMatrix = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'covarianceMatrix'), CovarianceMatrixType)
Namespace.addCategoryObject('elementBinding', covarianceMatrix.name().localName(), covarianceMatrix)

multiCurveProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiCurveProperty'), MultiCurvePropertyType, documentation=u'This property element either references a curve aggregate via the XLink-attributes or contains the "multi curve" element. multiCurveProperty is the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that is substitutable for MultiCurve.')
Namespace.addCategoryObject('elementBinding', multiCurveProperty.name().localName(), multiCurveProperty)

ConventionalUnit = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ConventionalUnit'), ConventionalUnitType)
Namespace.addCategoryObject('elementBinding', ConventionalUnit.name().localName(), ConventionalUnit)

multiCenterLineOf = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiCenterLineOf'), MultiCurvePropertyType)
Namespace.addCategoryObject('elementBinding', multiCenterLineOf.name().localName(), multiCenterLineOf)

labelStyle = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'labelStyle'), LabelStylePropertyType, documentation=u'')
Namespace.addCategoryObject('elementBinding', labelStyle.name().localName(), labelStyle)

includesElement = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'includesElement'), CovarianceElementType)
Namespace.addCategoryObject('elementBinding', includesElement.name().localName(), includesElement)

TopoPoint = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopoPoint'), TopoPointType)
Namespace.addCategoryObject('elementBinding', TopoPoint.name().localName(), TopoPoint)

MultiSurface = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiSurface'), MultiSurfaceType)
Namespace.addCategoryObject('elementBinding', MultiSurface.name().localName(), MultiSurface)

seconds = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'seconds'), ArcSecondsType)
Namespace.addCategoryObject('elementBinding', seconds.name().localName(), seconds)

curveProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'curveProperty'), CurvePropertyType, documentation=u'This property element either references a curve via the XLink-attributes or contains the curve element. curveProperty is the \n\t\t\tpredefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that is \n\t\t\tsubstitutable for _Curve.')
Namespace.addCategoryObject('elementBinding', curveProperty.name().localName(), curveProperty)

Object = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Object'), pyxb.binding.datatypes.anyType, abstract=pyxb.binding.datatypes.boolean(1), documentation=u'This abstract element is the head of a substitutionGroup hierararchy which may contain either simpleContent or complexContent elements.  It is used to assert the model position of "class" elements declared in other GML schemas.')
Namespace.addCategoryObject('elementBinding', Object.name().localName(), Object)

TopoVolume = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopoVolume'), TopoVolumeType)
Namespace.addCategoryObject('elementBinding', TopoVolume.name().localName(), TopoVolume)

GML = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_GML'), AbstractGMLType, abstract=pyxb.binding.datatypes.boolean(1), documentation=u'Global element which acts as the head of a substitution group that may include any element which is a GML feature, object, geometry or complex value')
Namespace.addCategoryObject('elementBinding', GML.name().localName(), GML)

edgeOf = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'edgeOf'), CurvePropertyType)
Namespace.addCategoryObject('elementBinding', edgeOf.name().localName(), edgeOf)

LabelStyle = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'LabelStyle'), LabelStyleType, documentation=u'The style descriptor for labels of a feature, geometry or topology.')
Namespace.addCategoryObject('elementBinding', LabelStyle.name().localName(), LabelStyle)

usesImageDatum = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesImageDatum'), ImageDatumRefType, documentation=u'Association to the image datum used by this CRS. ')
Namespace.addCategoryObject('elementBinding', usesImageDatum.name().localName(), usesImageDatum)

parameterValueGroup = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'parameterValueGroup'), ParameterValueGroupType)
Namespace.addCategoryObject('elementBinding', parameterValueGroup.name().localName(), parameterValueGroup)

baseSurface = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'baseSurface'), SurfacePropertyType, documentation=u'This property element either references a surface via the XLink-attributes or contains the surface element. A surface element is any element which is substitutable for "_Surface".')
Namespace.addCategoryObject('elementBinding', baseSurface.name().localName(), baseSurface)

CoordinateReferenceSystem = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_CoordinateReferenceSystem'), AbstractReferenceSystemType, abstract=pyxb.binding.datatypes.boolean(1), documentation=u'A coordinate reference system consists of an ordered sequence of coordinate system axes that are related to the earth through a datum. A coordinate reference system is defined by one datum and by one coordinate system. Most coordinate reference system do not move relative to the earth, except for engineering coordinate reference systems defined on moving platforms such as cars, ships, aircraft, and spacecraft. For further information, see OGC Abstract Specification Topic 2.\n\nCoordinate reference systems are commonly divided into sub-types. The common classification criterion for sub-typing of coordinate reference systems is the way in which they deal with earth curvature. This has a direct effect on the portion of the earth\'s surface that can be covered by that type of CRS with an acceptable degree of error. The exception to the rule is the subtype "Temporal" which has been added by analogy. ')
Namespace.addCategoryObject('elementBinding', CoordinateReferenceSystem.name().localName(), CoordinateReferenceSystem)

OrientableSurface = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'OrientableSurface'), OrientableSurfaceType)
Namespace.addCategoryObject('elementBinding', OrientableSurface.name().localName(), OrientableSurface)

multiExtentOf = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiExtentOf'), MultiSurfacePropertyType)
Namespace.addCategoryObject('elementBinding', multiExtentOf.name().localName(), multiExtentOf)

MultiSolid = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiSolid'), MultiSolidType)
Namespace.addCategoryObject('elementBinding', MultiSolid.name().localName(), MultiSolid)

GeneralDerivedCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_GeneralDerivedCRS'), AbstractGeneralDerivedCRSType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', GeneralDerivedCRS.name().localName(), GeneralDerivedCRS)

OperationParameterGroup = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'OperationParameterGroup'), OperationParameterGroupType)
Namespace.addCategoryObject('elementBinding', OperationParameterGroup.name().localName(), OperationParameterGroup)

Bag = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Bag'), BagType, documentation=u'Generic GML element to contain a heterogeneous collection of GML _Objects')
Namespace.addCategoryObject('elementBinding', Bag.name().localName(), Bag)

direction = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'direction'), DirectionPropertyType)
Namespace.addCategoryObject('elementBinding', direction.name().localName(), direction)

usesOperation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesOperation'), OperationRefType, documentation=u'Association to the operation applied to the specified ordinates. ')
Namespace.addCategoryObject('elementBinding', usesOperation.name().localName(), usesOperation)

parameterName = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'parameterName'), CodeType, documentation=u'The name by which this operation parameter is identified. ')
Namespace.addCategoryObject('elementBinding', parameterName.name().localName(), parameterName)

TopoPrimitive = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_TopoPrimitive'), AbstractTopoPrimitiveType, abstract=pyxb.binding.datatypes.boolean(1), documentation=u'Substitution group branch for Topo Primitives, used by TopoPrimitiveArrayAssociationType')
Namespace.addCategoryObject('elementBinding', TopoPrimitive.name().localName(), TopoPrimitive)

EngineeringCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'EngineeringCRS'), EngineeringCRSType)
Namespace.addCategoryObject('elementBinding', EngineeringCRS.name().localName(), EngineeringCRS)

GraphStyle = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GraphStyle'), GraphStyleType, documentation=u'The style descriptor for a graph consisting of a number of features. Describes graph-specific style attributes.')
Namespace.addCategoryObject('elementBinding', GraphStyle.name().localName(), GraphStyle)

Array = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Array'), ArrayType, documentation=u'Generic GML element to contain a homogeneous array of GML _Objects')
Namespace.addCategoryObject('elementBinding', Array.name().localName(), Array)

ProjectedCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ProjectedCRS'), ProjectedCRSType)
Namespace.addCategoryObject('elementBinding', ProjectedCRS.name().localName(), ProjectedCRS)

TimeTopologyPrimitive = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_TimeTopologyPrimitive'), AbstractTimeTopologyPrimitiveType, abstract=pyxb.binding.datatypes.boolean(1), documentation=u'This abstract element acts as the head of the substitution group for temporal topology primitives.')
Namespace.addCategoryObject('elementBinding', TimeTopologyPrimitive.name().localName(), TimeTopologyPrimitive)

usesSphericalCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesSphericalCS'), SphericalCSRefType, documentation=u'Association to the spherical coordinate system used by this CRS.')
Namespace.addCategoryObject('elementBinding', usesSphericalCS.name().localName(), usesSphericalCS)

polarCSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'polarCSRef'), PolarCSRefType)
Namespace.addCategoryObject('elementBinding', polarCSRef.name().localName(), polarCSRef)

ImageCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ImageCRS'), ImageCRSType)
Namespace.addCategoryObject('elementBinding', ImageCRS.name().localName(), ImageCRS)

PolygonPatch = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'PolygonPatch'), PolygonPatchType)
Namespace.addCategoryObject('elementBinding', PolygonPatch.name().localName(), PolygonPatch)

topoPrimitiveMember = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'topoPrimitiveMember'), TopoPrimitiveMemberType, documentation=u'')
Namespace.addCategoryObject('elementBinding', topoPrimitiveMember.name().localName(), topoPrimitiveMember)

passThroughOperationRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'passThroughOperationRef'), PassThroughOperationRefType)
Namespace.addCategoryObject('elementBinding', passThroughOperationRef.name().localName(), passThroughOperationRef)

CategoryExtent = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CategoryExtent'), CategoryExtentType, documentation=u'Utility element to store a 2-point range of ordinal values. If one member is a null, then this is a single ended interval.')
Namespace.addCategoryObject('elementBinding', CategoryExtent.name().localName(), CategoryExtent)

coordinateOperationID = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationID'), IdentifierType, documentation=u'An identification of a coordinate operation. ')
Namespace.addCategoryObject('elementBinding', coordinateOperationID.name().localName(), coordinateOperationID)

topoVolumeProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'topoVolumeProperty'), TopoVolumePropertyType)
Namespace.addCategoryObject('elementBinding', topoVolumeProperty.name().localName(), topoVolumeProperty)

defaultStyle = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'defaultStyle'), DefaultStylePropertyType, documentation=u'Top-level property. Used in application schemas to "attach" the styling information to GML data. The link between the data and the style should be established through this property only.')
Namespace.addCategoryObject('elementBinding', defaultStyle.name().localName(), defaultStyle)

topoCurveProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'topoCurveProperty'), TopoCurvePropertyType)
Namespace.addCategoryObject('elementBinding', topoCurveProperty.name().localName(), topoCurveProperty)

operationVersion = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'operationVersion'), pyxb.binding.datatypes.string, documentation=u'Version of the coordinate transformation (i.e., instantiation due to the stochastic nature of the parameters). Mandatory when describing a transformation, and should not be supplied for a conversion. ')
Namespace.addCategoryObject('elementBinding', operationVersion.name().localName(), operationVersion)

subject = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'subject'), TargetPropertyType, documentation=u'Synonym for target - common word used for photographs')
Namespace.addCategoryObject('elementBinding', subject.name().localName(), subject)

surfaceMembers = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'surfaceMembers'), SurfaceArrayPropertyType, documentation=u'This property element contains a list of surfaces. The order of the elements is significant and shall be preserved when processing the array.')
Namespace.addCategoryObject('elementBinding', surfaceMembers.name().localName(), surfaceMembers)

ellipsoidRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ellipsoidRef'), EllipsoidRefType)
Namespace.addCategoryObject('elementBinding', ellipsoidRef.name().localName(), ellipsoidRef)

topoPrimitiveMembers = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'topoPrimitiveMembers'), TopoPrimitiveArrayAssociationType, documentation=u'')
Namespace.addCategoryObject('elementBinding', topoPrimitiveMembers.name().localName(), topoPrimitiveMembers)

targetCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'targetCRS'), CRSRefType, documentation=u'Association to the target CRS (coordinate reference system) of this coordinate operation. For constraints on multiplicity of "sourceCRS" and "targetCRS", see UML model of Coordinate Operation package in OGC Abstract Specification topic 2. ')
Namespace.addCategoryObject('elementBinding', targetCRS.name().localName(), targetCRS)

cartesianCSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'cartesianCSRef'), CartesianCSRefType)
Namespace.addCategoryObject('elementBinding', cartesianCSRef.name().localName(), cartesianCSRef)

maximalComplex = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximalComplex'), TopoComplexMemberType, documentation=u'Need schamatron test here that isMaximal attribute value is true')
Namespace.addCategoryObject('elementBinding', maximalComplex.name().localName(), maximalComplex)

curveArrayProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'curveArrayProperty'), CurveArrayPropertyType)
Namespace.addCategoryObject('elementBinding', curveArrayProperty.name().localName(), curveArrayProperty)

TimePeriod = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimePeriod'), TimePeriodType)
Namespace.addCategoryObject('elementBinding', TimePeriod.name().localName(), TimePeriod)

roughConversionToPreferredUnit = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'roughConversionToPreferredUnit'), ConversionToPreferredUnitType, documentation=u'This element is included when the correct definition of this unit is unknown, but this unit has a rough or inaccurate conversion to the preferred unit for this quantity type.')
Namespace.addCategoryObject('elementBinding', roughConversionToPreferredUnit.name().localName(), roughConversionToPreferredUnit)

LinearCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'LinearCS'), LinearCSType)
Namespace.addCategoryObject('elementBinding', LinearCS.name().localName(), LinearCS)

Datum = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Datum'), AbstractDatumType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', Datum.name().localName(), Datum)

TopoComplex = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopoComplex'), TopoComplexType)
Namespace.addCategoryObject('elementBinding', TopoComplex.name().localName(), TopoComplex)

directedTopoSolid = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedTopoSolid'), DirectedTopoSolidPropertyType, documentation=u'')
Namespace.addCategoryObject('elementBinding', directedTopoSolid.name().localName(), directedTopoSolid)

includesValue = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'includesValue'), AbstractGeneralParameterValueType, documentation=u'A composition association to a parameter value or group of values included in this group. ')
Namespace.addCategoryObject('elementBinding', includesValue.name().localName(), includesValue)

pos = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, documentation=u'')
Namespace.addCategoryObject('elementBinding', pos.name().localName(), pos)

usesVerticalCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesVerticalCS'), VerticalCSRefType, documentation=u'Association to the vertical coordinate system used by this CRS. ')
Namespace.addCategoryObject('elementBinding', usesVerticalCS.name().localName(), usesVerticalCS)

geometryStyle = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'geometryStyle'), GeometryStylePropertyType, documentation=u'')
Namespace.addCategoryObject('elementBinding', geometryStyle.name().localName(), geometryStyle)

innerBoundaryIs = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'innerBoundaryIs'), AbstractRingPropertyType, documentation=u'Deprecated with GML 3.0, included only for backwards compatibility with GML 2. Use "interior" instead.')
Namespace.addCategoryObject('elementBinding', innerBoundaryIs.name().localName(), innerBoundaryIs)

solidArrayProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'solidArrayProperty'), SolidArrayPropertyType)
Namespace.addCategoryObject('elementBinding', solidArrayProperty.name().localName(), solidArrayProperty)

MultiPointCoverage = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiPointCoverage'), MultiPointCoverageType)
Namespace.addCategoryObject('elementBinding', MultiPointCoverage.name().localName(), MultiPointCoverage)

csID = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'csID'), IdentifierType, documentation=u'An identification of a coordinate system. ')
Namespace.addCategoryObject('elementBinding', csID.name().localName(), csID)

Circle = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Circle'), CircleType)
Namespace.addCategoryObject('elementBinding', Circle.name().localName(), Circle)

description = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'description'), StringOrRefType, documentation=u'Contains a simple text description of the object, or refers to an external description.')
Namespace.addCategoryObject('elementBinding', description.name().localName(), description)

scope = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'scope'), pyxb.binding.datatypes.string, documentation=u'Description of domain of usage, or limitations of usage, for which this CRS object is valid.')
Namespace.addCategoryObject('elementBinding', scope.name().localName(), scope)

ValueArray = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ValueArray'), ValueArrayType, documentation=u'A Value Array is used for homogeneous arrays of primitive and aggregate values.   _ScalarValueList is preferred for arrays of Scalar Values since this is more efficient.  Since "choice" is not available for attribute groups, an external constraint (e.g. Schematron) would be required to enforce the selection of only one of these through schema validation')
Namespace.addCategoryObject('elementBinding', ValueArray.name().localName(), ValueArray)

srsName = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'srsName'), CodeType, documentation=u'The name by which this reference system is identified.')
Namespace.addCategoryObject('elementBinding', srsName.name().localName(), srsName)

ArcStringByBulge = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ArcStringByBulge'), ArcStringByBulgeType)
Namespace.addCategoryObject('elementBinding', ArcStringByBulge.name().localName(), ArcStringByBulge)

CubicSpline = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CubicSpline'), CubicSplineType)
Namespace.addCategoryObject('elementBinding', CubicSpline.name().localName(), CubicSpline)

unitOfMeasure = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'unitOfMeasure'), UnitOfMeasureType)
Namespace.addCategoryObject('elementBinding', unitOfMeasure.name().localName(), unitOfMeasure)

ConcatenatedOperation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ConcatenatedOperation'), ConcatenatedOperationType)
Namespace.addCategoryObject('elementBinding', ConcatenatedOperation.name().localName(), ConcatenatedOperation)

polygonPatches = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'polygonPatches'), PolygonPatchArrayPropertyType, documentation=u'This property element contains a list of\n   polygon patches. The order of the patches is significant and \n   shall be preserved when processing the list.')
Namespace.addCategoryObject('elementBinding', polygonPatches.name().localName(), polygonPatches)

Feature = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Feature'), AbstractFeatureType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', Feature.name().localName(), Feature)

OperationMethod = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'OperationMethod'), OperationMethodType)
Namespace.addCategoryObject('elementBinding', OperationMethod.name().localName(), OperationMethod)

semiMajorAxis = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'semiMajorAxis'), MeasureType, documentation=u'Length of the semi-major axis of the ellipsoid, with its units. Uses the MeasureType with the restriction that the unit of measure referenced by uom must be suitable for a length, such as metres or feet. ')
Namespace.addCategoryObject('elementBinding', semiMajorAxis.name().localName(), semiMajorAxis)

TimePrimitive = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_TimePrimitive'), AbstractTimePrimitiveType, abstract=pyxb.binding.datatypes.boolean(1), documentation=u'This abstract element acts as the head of the substitution group for temporal primitives.')
Namespace.addCategoryObject('elementBinding', TimePrimitive.name().localName(), TimePrimitive)

posList = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'posList'), DirectPositionListType, documentation=u'')
Namespace.addCategoryObject('elementBinding', posList.name().localName(), posList)

operationRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'operationRef'), OperationRefType)
Namespace.addCategoryObject('elementBinding', operationRef.name().localName(), operationRef)

usesEngineeringDatum = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesEngineeringDatum'), EngineeringDatumRefType, documentation=u'Association to the engineering datum used by this CRS. ')
Namespace.addCategoryObject('elementBinding', usesEngineeringDatum.name().localName(), usesEngineeringDatum)

MultiGeometry = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiGeometry'), MultiGeometryType)
Namespace.addCategoryObject('elementBinding', MultiGeometry.name().localName(), MultiGeometry)

valueComponent = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'valueComponent'), ValuePropertyType, documentation=u'Element which refers to, or contains, a Value.  This version is used in CompositeValues.')
Namespace.addCategoryObject('elementBinding', valueComponent.name().localName(), valueComponent)

obliqueCartesianCSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'obliqueCartesianCSRef'), ObliqueCartesianCSRefType)
Namespace.addCategoryObject('elementBinding', obliqueCartesianCSRef.name().localName(), obliqueCartesianCSRef)

geocentricCRSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'geocentricCRSRef'), GeocentricCRSRefType)
Namespace.addCategoryObject('elementBinding', geocentricCRSRef.name().localName(), geocentricCRSRef)

TimeEdge = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeEdge'), TimeEdgeType, documentation=u'TimeEdge is one dimensional temporal topology primitive,\n\t\t\t expresses a state in topological time. It has an orientation from its start toward the end, \n\t\t\t and its boundaries shall associate with two different time nodes.')
Namespace.addCategoryObject('elementBinding', TimeEdge.name().localName(), TimeEdge)

rangeParameters = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'rangeParameters'), RangeParametersType)
Namespace.addCategoryObject('elementBinding', rangeParameters.name().localName(), rangeParameters)

TimeComplex = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_TimeComplex'), AbstractTimeComplexType, abstract=pyxb.binding.datatypes.boolean(1), documentation=u'This abstract element acts as the head of the substitution group for temporal complexes. \n\t\t\tTemporal complex is an aggregation of temporal primitives as its components, \n\t\t\trepresents a temporal geometric complex and a temporal topology complex. \n\t\t\tN.B. Temporal geometric complex is not defined in this schema.')
Namespace.addCategoryObject('elementBinding', TimeComplex.name().localName(), TimeComplex)

PolarCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'PolarCS'), PolarCSType)
Namespace.addCategoryObject('elementBinding', PolarCS.name().localName(), PolarCS)

tupleList = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'tupleList'), CoordinatesType)
Namespace.addCategoryObject('elementBinding', tupleList.name().localName(), tupleList)

ArcByBulge = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ArcByBulge'), ArcByBulgeType)
Namespace.addCategoryObject('elementBinding', ArcByBulge.name().localName(), ArcByBulge)

boundingPolygon = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'boundingPolygon'), PolygonType, documentation=u'A bounding polygon defining the horizontal spatial domain of this object.')
Namespace.addCategoryObject('elementBinding', boundingPolygon.name().localName(), boundingPolygon)

pointRep = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), PointPropertyType, documentation=u'Deprecated with GML version 3.1.0. Use "pointProperty" instead. Included for backwards compatibility with GML 3.0.0.')
Namespace.addCategoryObject('elementBinding', pointRep.name().localName(), pointRep)

Boolean = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Boolean'), pyxb.binding.datatypes.boolean, documentation=u'A value from two-valued logic, using the XML Schema boolean type.  An instance may take the values {true, false, 1, 0}.')
Namespace.addCategoryObject('elementBinding', Boolean.name().localName(), Boolean)

CRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_CRS'), AbstractReferenceSystemType, abstract=pyxb.binding.datatypes.boolean(1), documentation=u'Abstract coordinate reference system, usually defined by a coordinate system and a datum. This abstract complexType shall not be used, extended, or restricted, in an Application Schema, to define a concrete subtype with a meaning equivalent to a concrete subtype specified in this document.')
Namespace.addCategoryObject('elementBinding', CRS.name().localName(), CRS)

QuantityList = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'QuantityList'), MeasureOrNullListType, documentation=u'A space separated list of amounts or nulls.  The amounts use the XML Schema type double.  A single XML attribute uom (unit of measure) is required, whose value is a URI which identifies the definition of the scale or units by which all the amounts in the list must be multiplied.')
Namespace.addCategoryObject('elementBinding', QuantityList.name().localName(), QuantityList)

symbol = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'symbol'), SymbolType, documentation=u'The symbol property. Extends the gml:AssociationType to allow for remote referencing of symbols.')
Namespace.addCategoryObject('elementBinding', symbol.name().localName(), symbol)

TimeGeometricPrimitive = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_TimeGeometricPrimitive'), AbstractTimeGeometricPrimitiveType, abstract=pyxb.binding.datatypes.boolean(1), documentation=u'This abstract element acts as the head of the substitution group for temporal geometric primitives.')
Namespace.addCategoryObject('elementBinding', TimeGeometricPrimitive.name().localName(), TimeGeometricPrimitive)

angle = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'angle'), MeasureType)
Namespace.addCategoryObject('elementBinding', angle.name().localName(), angle)

BooleanList = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'BooleanList'), booleanOrNullList, documentation=u'XML List based on XML Schema boolean type.  An element of this type contains a space-separated list of boolean values {0,1,true,false}')
Namespace.addCategoryObject('elementBinding', BooleanList.name().localName(), BooleanList)

geodeticDatumRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'geodeticDatumRef'), GeodeticDatumRefType)
Namespace.addCategoryObject('elementBinding', geodeticDatumRef.name().localName(), geodeticDatumRef)

superComplex = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'superComplex'), TopoComplexMemberType, documentation=u'')
Namespace.addCategoryObject('elementBinding', superComplex.name().localName(), superComplex)

Triangle = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Triangle'), TriangleType)
Namespace.addCategoryObject('elementBinding', Triangle.name().localName(), Triangle)

booleanValue = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'booleanValue'), pyxb.binding.datatypes.boolean, documentation=u'Boolean value of an operation parameter. A Boolean value does not have an associated unit of measure. ')
Namespace.addCategoryObject('elementBinding', booleanValue.name().localName(), booleanValue)

CoordinateSystem = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_CoordinateSystem'), AbstractCoordinateSystemType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', CoordinateSystem.name().localName(), CoordinateSystem)

timeInterval = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'timeInterval'), TimeIntervalLengthType, documentation=u'This element is a valid subtype of TimeDurationType \n\t\t\taccording to section 3.14.6, rule 2.2.4 in XML Schema, Part 1.')
Namespace.addCategoryObject('elementBinding', timeInterval.name().localName(), timeInterval)

CompassPoint = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CompassPoint'), CompassPointEnumeration)
Namespace.addCategoryObject('elementBinding', CompassPoint.name().localName(), CompassPoint)

verticalDatumRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'verticalDatumRef'), VerticalDatumRefType)
Namespace.addCategoryObject('elementBinding', verticalDatumRef.name().localName(), verticalDatumRef)

doubleOrNullTupleList = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'doubleOrNullTupleList'), doubleOrNullList)
Namespace.addCategoryObject('elementBinding', doubleOrNullTupleList.name().localName(), doubleOrNullTupleList)

usesValue = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesValue'), ParameterValueType, documentation=u'Composition association to a parameter value used by this coordinate operation. ')
Namespace.addCategoryObject('elementBinding', usesValue.name().localName(), usesValue)

degrees = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'degrees'), DegreesType)
Namespace.addCategoryObject('elementBinding', degrees.name().localName(), degrees)

status = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'status'), StringOrRefType)
Namespace.addCategoryObject('elementBinding', status.name().localName(), status)

ellipsoidID = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ellipsoidID'), IdentifierType, documentation=u'An identification of an ellipsoid. ')
Namespace.addCategoryObject('elementBinding', ellipsoidID.name().localName(), ellipsoidID)

groupName = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'groupName'), CodeType, documentation=u'The name by which this operation parameter group is identified. ')
Namespace.addCategoryObject('elementBinding', groupName.name().localName(), groupName)

priorityLocation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'priorityLocation'), PriorityLocationPropertyType, documentation=u'Deprecated in GML 3.1.0')
Namespace.addCategoryObject('elementBinding', priorityLocation.name().localName(), priorityLocation)

cylindricalCSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'cylindricalCSRef'), CylindricalCSRefType)
Namespace.addCategoryObject('elementBinding', cylindricalCSRef.name().localName(), cylindricalCSRef)

csName = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'csName'), CodeType, documentation=u'The name by which this coordinate system is identified. ')
Namespace.addCategoryObject('elementBinding', csName.name().localName(), csName)

usesVerticalDatum = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesVerticalDatum'), VerticalDatumRefType, documentation=u'Association to the vertical datum used by this CRS. ')
Namespace.addCategoryObject('elementBinding', usesVerticalDatum.name().localName(), usesVerticalDatum)

GeneralConversion = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_GeneralConversion'), AbstractGeneralConversionType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', GeneralConversion.name().localName(), GeneralConversion)

MovingObjectStatus = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MovingObjectStatus'), MovingObjectStatusType)
Namespace.addCategoryObject('elementBinding', MovingObjectStatus.name().localName(), MovingObjectStatus)

secondDefiningParameter = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'secondDefiningParameter'), SecondDefiningParameterType)
Namespace.addCategoryObject('elementBinding', secondDefiningParameter.name().localName(), secondDefiningParameter)

CartesianCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CartesianCS'), CartesianCSType)
Namespace.addCategoryObject('elementBinding', CartesianCS.name().localName(), CartesianCS)

TemporalCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TemporalCRS'), TemporalCRSType)
Namespace.addCategoryObject('elementBinding', TemporalCRS.name().localName(), TemporalCRS)

usesAxis = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesAxis'), CoordinateSystemAxisRefType, documentation=u'Association to a coordinate system axis. ')
Namespace.addCategoryObject('elementBinding', usesAxis.name().localName(), usesAxis)

Face = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Face'), FaceType)
Namespace.addCategoryObject('elementBinding', Face.name().localName(), Face)

Cone = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Cone'), ConeType)
Namespace.addCategoryObject('elementBinding', Cone.name().localName(), Cone)

members = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'members'), ArrayAssociationType)
Namespace.addCategoryObject('elementBinding', members.name().localName(), members)

verticalCRSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'verticalCRSRef'), VerticalCRSRefType)
Namespace.addCategoryObject('elementBinding', verticalCRSRef.name().localName(), verticalCRSRef)

Geodesic = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Geodesic'), GeodesicType)
Namespace.addCategoryObject('elementBinding', Geodesic.name().localName(), Geodesic)

validArea = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'validArea'), ExtentType, documentation=u'Area or region in which this CRS object is valid.')
Namespace.addCategoryObject('elementBinding', validArea.name().localName(), validArea)

curveMember = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'curveMember'), CurvePropertyType, documentation=u'This property element either references a curve via the XLink-attributes or contains the curve element. A curve element is any element which is substitutable for "_Curve".')
Namespace.addCategoryObject('elementBinding', curveMember.name().localName(), curveMember)

isolated = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'isolated'), IsolatedPropertyType, documentation=u'')
Namespace.addCategoryObject('elementBinding', isolated.name().localName(), isolated)

history = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'history'), HistoryPropertyType)
Namespace.addCategoryObject('elementBinding', history.name().localName(), history)

primeMeridianRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'primeMeridianRef'), PrimeMeridianRefType)
Namespace.addCategoryObject('elementBinding', primeMeridianRef.name().localName(), primeMeridianRef)

coordinateReferenceSystemRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinateReferenceSystemRef'), CoordinateReferenceSystemRefType)
Namespace.addCategoryObject('elementBinding', coordinateReferenceSystemRef.name().localName(), coordinateReferenceSystemRef)

topologyStyle = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'topologyStyle'), TopologyStylePropertyType, documentation=u'')
Namespace.addCategoryObject('elementBinding', topologyStyle.name().localName(), topologyStyle)

ellipsoidalCSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ellipsoidalCSRef'), EllipsoidalCSRefType)
Namespace.addCategoryObject('elementBinding', ellipsoidalCSRef.name().localName(), ellipsoidalCSRef)

subComplex = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'subComplex'), TopoComplexMemberType, documentation=u'')
Namespace.addCategoryObject('elementBinding', subComplex.name().localName(), subComplex)

track = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'track'), TrackType)
Namespace.addCategoryObject('elementBinding', track.name().localName(), track)

CompoundCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CompoundCRS'), CompoundCRSType)
Namespace.addCategoryObject('elementBinding', CompoundCRS.name().localName(), CompoundCRS)

PassThroughOperation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'PassThroughOperation'), PassThroughOperationType)
Namespace.addCategoryObject('elementBinding', PassThroughOperation.name().localName(), PassThroughOperation)

exterior = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'exterior'), AbstractRingPropertyType, documentation=u'A boundary of a surface consists of a number of rings. In the normal 2D case, one of these rings is distinguished as being the exterior boundary. In a general manifold this is not always possible, in which case all boundaries shall be listed as interior boundaries, and the exterior will be empty.')
Namespace.addCategoryObject('elementBinding', exterior.name().localName(), exterior)

resultOf = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'resultOf'), AssociationType, documentation=u'The result of the observation: an image, external object, etc')
Namespace.addCategoryObject('elementBinding', resultOf.name().localName(), resultOf)

IndexMap = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'IndexMap'), IndexMapType)
Namespace.addCategoryObject('elementBinding', IndexMap.name().localName(), IndexMap)

Observation = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Observation'), ObservationType)
Namespace.addCategoryObject('elementBinding', Observation.name().localName(), Observation)

includesCRS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'includesCRS'), CoordinateReferenceSystemRefType, documentation=u'An association to a component coordinate reference system included in this compound coordinate reference system. ')
Namespace.addCategoryObject('elementBinding', includesCRS.name().localName(), includesCRS)

compoundCRSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'compoundCRSRef'), CompoundCRSRefType)
Namespace.addCategoryObject('elementBinding', compoundCRSRef.name().localName(), compoundCRSRef)

VerticalCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'VerticalCS'), VerticalCSType)
Namespace.addCategoryObject('elementBinding', VerticalCS.name().localName(), VerticalCS)

inverseFlattening = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'inverseFlattening'), MeasureType, documentation=u'Inverse flattening value of the ellipsoid. Value is a scale factor (or ratio) that has no physical unit. Uses the MeasureType with the restriction that the unit of measure referenced by uom must be suitable for a scale factor, such as percent, permil, or parts-per-million. ')
Namespace.addCategoryObject('elementBinding', inverseFlattening.name().localName(), inverseFlattening)

File = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'File'), FileType)
Namespace.addCategoryObject('elementBinding', File.name().localName(), File)

verticalExtent = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'verticalExtent'), EnvelopeType, documentation=u'An interval defining the vertical spatial domain of this object.')
Namespace.addCategoryObject('elementBinding', verticalExtent.name().localName(), verticalExtent)

CountExtent = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CountExtent'), CountExtentType, documentation=u'Utility element to store a 2-point range of frequency values. If one member is a null, then this is a single ended interval.')
Namespace.addCategoryObject('elementBinding', CountExtent.name().localName(), CountExtent)

Edge = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Edge'), EdgeType)
Namespace.addCategoryObject('elementBinding', Edge.name().localName(), Edge)

Count = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Count'), pyxb.binding.datatypes.integer, documentation=u'An integer representing a frequency of occurrence.')
Namespace.addCategoryObject('elementBinding', Count.name().localName(), Count)

valuesOfGroup = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'valuesOfGroup'), OperationParameterGroupRefType, documentation=u'Association to the operation parameter group for which this element provides parameter values. ')
Namespace.addCategoryObject('elementBinding', valuesOfGroup.name().localName(), valuesOfGroup)

TemporalCS = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TemporalCS'), TemporalCSType)
Namespace.addCategoryObject('elementBinding', TemporalCS.name().localName(), TemporalCS)

multiSolidProperty = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiSolidProperty'), MultiSolidPropertyType, documentation=u'This property element either references a solid aggregate via the XLink-attributes or contains the "multi solid" element. multiSolidProperty is the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that is substitutable for MultiSolid.')
Namespace.addCategoryObject('elementBinding', multiSolidProperty.name().localName(), multiSolidProperty)

Topology = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Topology'), AbstractTopologyType, abstract=pyxb.binding.datatypes.boolean(1))
Namespace.addCategoryObject('elementBinding', Topology.name().localName(), Topology)

geographicCRSRef = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'geographicCRSRef'), GeographicCRSRefType)
Namespace.addCategoryObject('elementBinding', geographicCRSRef.name().localName(), geographicCRSRef)

multiPointDomain = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiPointDomain'), MultiPointDomainType)
Namespace.addCategoryObject('elementBinding', multiPointDomain.name().localName(), multiPointDomain)



GeneralConversionRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_GeneralConversion'), AbstractGeneralConversionType, abstract=pyxb.binding.datatypes.boolean(1), scope=GeneralConversionRefType))
GeneralConversionRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeneralConversionRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_GeneralConversion')), min_occurs=1, max_occurs=1)
    )
GeneralConversionRefType._ContentModel = pyxb.binding.content.ParticleModel(GeneralConversionRefType._GroupModel, min_occurs=0L, max_occurs=1)



AbstractGMLType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'name'), CodeType, scope=AbstractGMLType, documentation=u'Label for the object, normally a descriptive name. An object may have several names, typically assigned by different authorities.  The authority for a name is indicated by the value of its (optional) codeSpace attribute.  The name may or may not be unique, as determined by the rules of the organization responsible for the codeSpace.'))

AbstractGMLType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'description'), StringOrRefType, scope=AbstractGMLType, documentation=u'Contains a simple text description of the object, or refers to an external description.'))

AbstractGMLType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty'), MetaDataPropertyType, scope=AbstractGMLType, documentation=u'Contains or refers to a metadata package that contains metadata properties.'))
AbstractGMLType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractGMLType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractGMLType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractGMLType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
AbstractGMLType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractGMLType._GroupModel_, min_occurs=1, max_occurs=1)
    )
AbstractGMLType._ContentModel = pyxb.binding.content.ParticleModel(AbstractGMLType._GroupModel, min_occurs=1, max_occurs=1)


DefinitionType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(DefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(DefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=1, max_occurs=None)
    )
DefinitionType._ContentModel = pyxb.binding.content.ParticleModel(DefinitionType._GroupModel, min_occurs=1, max_occurs=1)



DictionaryType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'indirectEntry'), IndirectEntryType, scope=DictionaryType))

DictionaryType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'dictionaryEntry'), DictionaryEntryType, scope=DictionaryType))
DictionaryType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DictionaryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(DictionaryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(DictionaryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=1, max_occurs=None)
    )
DictionaryType._GroupModel_3 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(DictionaryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dictionaryEntry')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DictionaryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'indirectEntry')), min_occurs=1, max_occurs=1)
    )
DictionaryType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DictionaryType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
DictionaryType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DictionaryType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DictionaryType._GroupModel_2, min_occurs=0L, max_occurs=None)
    )
DictionaryType._ContentModel = pyxb.binding.content.ParticleModel(DictionaryType._GroupModel, min_occurs=1, max_occurs=1)



TemporalDatumRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TemporalDatum'), TemporalDatumType, scope=TemporalDatumRefType))
TemporalDatumRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TemporalDatumRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TemporalDatum')), min_occurs=1, max_occurs=1)
    )
TemporalDatumRefType._ContentModel = pyxb.binding.content.ParticleModel(TemporalDatumRefType._GroupModel, min_occurs=0L, max_occurs=1)



LocationPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Geometry'), AbstractGeometryType, abstract=pyxb.binding.datatypes.boolean(1), scope=LocationPropertyType, documentation=u'The "_Geometry" element is the abstract head of the substituition group for all geometry elements of GML 3. This \n\t\t\tincludes pre-defined and user-defined geometry elements. Any geometry element must be a direct or indirect extension/restriction \n\t\t\tof AbstractGeometryType and must be directly or indirectly in the substitution group of "_Geometry".'))

LocationPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Null'), NullType, scope=LocationPropertyType))

LocationPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'LocationKeyWord'), CodeType, scope=LocationPropertyType))

LocationPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'LocationString'), StringOrRefType, scope=LocationPropertyType))
LocationPropertyType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(LocationPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_Geometry')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(LocationPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'LocationKeyWord')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(LocationPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'LocationString')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(LocationPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Null')), min_occurs=1, max_occurs=1)
    )
LocationPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(LocationPropertyType._GroupModel_, min_occurs=1, max_occurs=1)
    )
LocationPropertyType._ContentModel = pyxb.binding.content.ParticleModel(LocationPropertyType._GroupModel, min_occurs=0L, max_occurs=1)


AbstractTopologyType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTopologyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractTopologyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractTopologyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
AbstractTopologyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTopologyType._GroupModel_, min_occurs=1, max_occurs=1)
    )
AbstractTopologyType._ContentModel = pyxb.binding.content.ParticleModel(AbstractTopologyType._GroupModel, min_occurs=1, max_occurs=1)



AbstractTopoPrimitiveType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'isolated'), IsolatedPropertyType, scope=AbstractTopoPrimitiveType, documentation=u''))

AbstractTopoPrimitiveType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'container'), ContainerPropertyType, scope=AbstractTopoPrimitiveType, documentation=u''))
AbstractTopoPrimitiveType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTopoPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractTopoPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractTopoPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
AbstractTopoPrimitiveType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTopoPrimitiveType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
AbstractTopoPrimitiveType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTopoPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractTopoPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container')), min_occurs=0L, max_occurs=1)
    )
AbstractTopoPrimitiveType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTopoPrimitiveType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractTopoPrimitiveType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
AbstractTopoPrimitiveType._ContentModel = pyxb.binding.content.ParticleModel(AbstractTopoPrimitiveType._GroupModel, min_occurs=1, max_occurs=1)



FaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'surfaceProperty'), SurfacePropertyType, scope=FaceType, documentation=u'This property element either references a surface via the XLink-attributes or contains the surface element. surfaceProperty is the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that is substitutable for _Surface.'))

FaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'), DirectedEdgePropertyType, scope=FaceType, documentation=u''))

FaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedTopoSolid'), DirectedTopoSolidPropertyType, scope=FaceType, documentation=u''))
FaceType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
FaceType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(FaceType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
FaceType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container')), min_occurs=0L, max_occurs=1)
    )
FaceType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(FaceType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(FaceType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
FaceType._GroupModel_5 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedEdge')), min_occurs=1, max_occurs=None),
    pyxb.binding.content.ParticleModel(FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedTopoSolid')), min_occurs=0L, max_occurs=2L),
    pyxb.binding.content.ParticleModel(FaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'surfaceProperty')), min_occurs=0L, max_occurs=1)
    )
FaceType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(FaceType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(FaceType._GroupModel_5, min_occurs=1, max_occurs=1)
    )
FaceType._ContentModel = pyxb.binding.content.ParticleModel(FaceType._GroupModel, min_occurs=1, max_occurs=1)



AbstractFeatureType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'location'), LocationPropertyType, scope=AbstractFeatureType, documentation=u'Deprecated in GML 3.1.0'))

AbstractFeatureType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'boundedBy'), BoundingShapeType, scope=AbstractFeatureType))
AbstractFeatureType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
AbstractFeatureType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractFeatureType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
AbstractFeatureType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location')), min_occurs=0L, max_occurs=1)
    )
AbstractFeatureType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractFeatureType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractFeatureType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
AbstractFeatureType._ContentModel = pyxb.binding.content.ParticleModel(AbstractFeatureType._GroupModel, min_occurs=1, max_occurs=1)



AbstractCoverageType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'rangeSet'), RangeSetType, scope=AbstractCoverageType))

AbstractCoverageType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'domainSet'), DomainSetType, scope=AbstractCoverageType))
AbstractCoverageType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
AbstractCoverageType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractCoverageType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
AbstractCoverageType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location')), min_occurs=0L, max_occurs=1)
    )
AbstractCoverageType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractCoverageType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractCoverageType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
AbstractCoverageType._GroupModel_5 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainSet')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rangeSet')), min_occurs=1, max_occurs=1)
    )
AbstractCoverageType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractCoverageType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractCoverageType._GroupModel_5, min_occurs=1, max_occurs=1)
    )
AbstractCoverageType._ContentModel = pyxb.binding.content.ParticleModel(AbstractCoverageType._GroupModel, min_occurs=1, max_occurs=1)



AbstractDiscreteCoverageType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coverageFunction'), CoverageFunctionType, scope=AbstractDiscreteCoverageType))
AbstractDiscreteCoverageType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
AbstractDiscreteCoverageType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractDiscreteCoverageType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
AbstractDiscreteCoverageType._GroupModel_5 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location')), min_occurs=0L, max_occurs=1)
    )
AbstractDiscreteCoverageType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractDiscreteCoverageType._GroupModel_3, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractDiscreteCoverageType._GroupModel_5, min_occurs=1, max_occurs=1)
    )
AbstractDiscreteCoverageType._GroupModel_6 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainSet')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rangeSet')), min_occurs=1, max_occurs=1)
    )
AbstractDiscreteCoverageType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractDiscreteCoverageType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractDiscreteCoverageType._GroupModel_6, min_occurs=1, max_occurs=1)
    )
AbstractDiscreteCoverageType._GroupModel_7 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractDiscreteCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coverageFunction')), min_occurs=0L, max_occurs=1)
    )
AbstractDiscreteCoverageType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractDiscreteCoverageType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractDiscreteCoverageType._GroupModel_7, min_occurs=1, max_occurs=1)
    )
AbstractDiscreteCoverageType._ContentModel = pyxb.binding.content.ParticleModel(AbstractDiscreteCoverageType._GroupModel, min_occurs=1, max_occurs=1)



MultiCurveCoverageType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiCurveDomain'), MultiCurveDomainType, scope=MultiCurveCoverageType))
MultiCurveCoverageType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
MultiCurveCoverageType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiCurveCoverageType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiCurveDomain')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rangeSet')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiCurveCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coverageFunction')), min_occurs=0L, max_occurs=1)
    )
MultiCurveCoverageType._ContentModel = pyxb.binding.content.ParticleModel(MultiCurveCoverageType._GroupModel, min_occurs=1, max_occurs=1)



ArcByCenterPointType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), PointPropertyType, scope=ArcByCenterPointType, documentation=u'This property element either references a point via the XLink-attributes or contains the point element. pointProperty \n\t\t\tis the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that \n\t\t\tis substitutable for Point.'))

ArcByCenterPointType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'radius'), LengthType, scope=ArcByCenterPointType, documentation=u'The radius of the arc.'))

ArcByCenterPointType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), CoordinatesType, scope=ArcByCenterPointType, documentation=u'Deprecated with GML version 3.1.0.'))

ArcByCenterPointType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), PointPropertyType, scope=ArcByCenterPointType, documentation=u'Deprecated with GML version 3.1.0. Use "pointProperty" instead. Included for backwards compatibility with GML 3.0.0.'))

ArcByCenterPointType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'startAngle'), AngleType, scope=ArcByCenterPointType, documentation=u'The bearing of the arc at the start.'))

ArcByCenterPointType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, scope=ArcByCenterPointType, documentation=u''))

ArcByCenterPointType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'endAngle'), AngleType, scope=ArcByCenterPointType, documentation=u'The bearing of the arc at the end.'))

ArcByCenterPointType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'posList'), DirectPositionListType, scope=ArcByCenterPointType, documentation=u''))
ArcByCenterPointType._GroupModel_2 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(ArcByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ArcByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ArcByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep')), min_occurs=1, max_occurs=1)
    )
ArcByCenterPointType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(ArcByCenterPointType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ArcByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ArcByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates')), min_occurs=1, max_occurs=1)
    )
ArcByCenterPointType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ArcByCenterPointType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ArcByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'radius')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ArcByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'startAngle')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(ArcByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'endAngle')), min_occurs=0L, max_occurs=1)
    )
ArcByCenterPointType._ContentModel = pyxb.binding.content.ParticleModel(ArcByCenterPointType._GroupModel, min_occurs=1, max_occurs=1)


CircleByCenterPointType._GroupModel_2 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(CircleByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CircleByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CircleByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep')), min_occurs=1, max_occurs=1)
    )
CircleByCenterPointType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(CircleByCenterPointType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CircleByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CircleByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates')), min_occurs=1, max_occurs=1)
    )
CircleByCenterPointType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CircleByCenterPointType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CircleByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'radius')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CircleByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'startAngle')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(CircleByCenterPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'endAngle')), min_occurs=0L, max_occurs=1)
    )
CircleByCenterPointType._ContentModel = pyxb.binding.content.ParticleModel(CircleByCenterPointType._GroupModel, min_occurs=1, max_occurs=1)



IdentifierType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'remarks'), StringOrRefType, scope=IdentifierType, documentation=u'Information about this object or code. Contains text or refers to external text.'))

IdentifierType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'version'), pyxb.binding.datatypes.string, scope=IdentifierType, documentation=u'Identifier of the version of the associated codeSpace or code, as specified by the codeSpace or code authority. This version is included only when the "code" or "codeSpace" uses versions. When appropriate, the version is identified by the effective date, coded using ISO 8601 date format.'))

IdentifierType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'name'), CodeType, scope=IdentifierType, documentation=u'Label for the object, normally a descriptive name. An object may have several names, typically assigned by different authorities.  The authority for a name is indicated by the value of its (optional) codeSpace attribute.  The name may or may not be unique, as determined by the rules of the organization responsible for the codeSpace.'))
IdentifierType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(IdentifierType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(IdentifierType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'version')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(IdentifierType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1)
    )
IdentifierType._ContentModel = pyxb.binding.content.ParticleModel(IdentifierType._GroupModel, min_occurs=1, max_occurs=1)



AbstractDatumBaseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'datumName'), CodeType, scope=AbstractDatumBaseType, documentation=u'The name by which this datum is identified. '))
AbstractDatumBaseType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractDatumBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractDatumBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'datumName')), min_occurs=1, max_occurs=1)
    )
AbstractDatumBaseType._ContentModel = pyxb.binding.content.ParticleModel(AbstractDatumBaseType._GroupModel, min_occurs=1, max_occurs=1)



AbstractDatumType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'realizationEpoch'), pyxb.binding.datatypes.date, scope=AbstractDatumType, documentation=u'The time after which this datum definition is valid. This time may be precise (e.g. 1997.0 for IRTF97) or merely a year (e.g. 1983 for NAD83). In the latter case, the epoch usually refers to the year in which a major recalculation of the geodetic control network, underlying the datum, was executed or initiated. An old datum can remain valid after a new datum is defined. Alternatively, a datum may be superseded by a later datum, in which case the realization epoch for the new datum defines the upper limit for the validity of the superseded datum. '))

AbstractDatumType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'scope'), pyxb.binding.datatypes.string, scope=AbstractDatumType, documentation=u'Description of domain of usage, or limitations of usage, for which this CRS object is valid.'))

AbstractDatumType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'datumID'), IdentifierType, scope=AbstractDatumType, documentation=u'An identification of a datum. '))

AbstractDatumType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'remarks'), StringOrRefType, scope=AbstractDatumType, documentation=u'Information about this object or code. Contains text or refers to external text.'))

AbstractDatumType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'validArea'), ExtentType, scope=AbstractDatumType, documentation=u'Area or region in which this CRS object is valid.'))

AbstractDatumType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'anchorPoint'), CodeType, scope=AbstractDatumType, documentation=u'Description, possibly including coordinates, of the point or points used to anchor the datum to the Earth. Also known as the "origin", especially for engineering and image datums. The codeSpace attribute can be used to reference a source of more detailed on this point or surface, or on a set of such descriptions. \n- For a geodetic datum, this point is also known as the fundamental point, which is traditionally the point where the relationship between geoid and ellipsoid is defined. In some cases, the "fundamental point" may consist of a number of points. In those cases, the parameters defining the geoid/ellipsoid relationship have been averaged for these points, and the averages adopted as the datum definition.\n- For an engineering datum, the anchor point may be a physical point, or it may be a point with defined coordinates in another CRS. When appropriate, the coordinates of this anchor point can be referenced in another document, such as referencing a GML feature that references or includes a point position.\n- For an image datum, the anchor point is usually either the centre of the image or the corner of the image.\n- For a temporal datum, this attribute is not defined. Instead of the anchor point, a temporal datum carries a separate time origin of type DateTime. '))
AbstractDatumType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'datumName')), min_occurs=1, max_occurs=1)
    )
AbstractDatumType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'datumID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'anchorPoint')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'realizationEpoch')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validArea')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope')), min_occurs=0L, max_occurs=1)
    )
AbstractDatumType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractDatumType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractDatumType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
AbstractDatumType._ContentModel = pyxb.binding.content.ParticleModel(AbstractDatumType._GroupModel, min_occurs=1, max_occurs=1)



TimePrimitivePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_TimePrimitive'), AbstractTimePrimitiveType, abstract=pyxb.binding.datatypes.boolean(1), scope=TimePrimitivePropertyType, documentation=u'This abstract element acts as the head of the substitution group for temporal primitives.'))
TimePrimitivePropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimePrimitivePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_TimePrimitive')), min_occurs=1, max_occurs=1)
    )
TimePrimitivePropertyType._ContentModel = pyxb.binding.content.ParticleModel(TimePrimitivePropertyType._GroupModel, min_occurs=0L, max_occurs=1)



OperationMethodRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'OperationMethod'), OperationMethodType, scope=OperationMethodRefType))
OperationMethodRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(OperationMethodRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'OperationMethod')), min_occurs=1, max_occurs=1)
    )
OperationMethodRefType._ContentModel = pyxb.binding.content.ParticleModel(OperationMethodRefType._GroupModel, min_occurs=0L, max_occurs=1)



AngleChoiceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'dmsAngle'), DMSAngleType, scope=AngleChoiceType))

AngleChoiceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'angle'), MeasureType, scope=AngleChoiceType))
AngleChoiceType._GroupModel = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(AngleChoiceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'angle')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AngleChoiceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dmsAngle')), min_occurs=1, max_occurs=1)
    )
AngleChoiceType._ContentModel = pyxb.binding.content.ParticleModel(AngleChoiceType._GroupModel, min_occurs=1, max_occurs=1)


AbstractGeometryType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
AbstractGeometryType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractGeometryType._GroupModel_, min_occurs=1, max_occurs=1)
    )
AbstractGeometryType._ContentModel = pyxb.binding.content.ParticleModel(AbstractGeometryType._GroupModel, min_occurs=1, max_occurs=1)


AbstractRingType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
AbstractRingType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractRingType._GroupModel_, min_occurs=1, max_occurs=1)
    )
AbstractRingType._ContentModel = pyxb.binding.content.ParticleModel(AbstractRingType._GroupModel, min_occurs=1, max_occurs=1)



FeatureArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Feature'), AbstractFeatureType, abstract=pyxb.binding.datatypes.boolean(1), scope=FeatureArrayPropertyType))
FeatureArrayPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(FeatureArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_Feature')), min_occurs=0L, max_occurs=None)
    )
FeatureArrayPropertyType._ContentModel = pyxb.binding.content.ParticleModel(FeatureArrayPropertyType._GroupModel, min_occurs=1, max_occurs=1)


AbstractGeometricPrimitiveType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
AbstractGeometricPrimitiveType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractGeometricPrimitiveType._GroupModel_, min_occurs=1, max_occurs=1)
    )
AbstractGeometricPrimitiveType._ContentModel = pyxb.binding.content.ParticleModel(AbstractGeometricPrimitiveType._GroupModel, min_occurs=1, max_occurs=1)


AbstractSurfaceType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
AbstractSurfaceType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractSurfaceType._GroupModel_, min_occurs=1, max_occurs=1)
    )
AbstractSurfaceType._ContentModel = pyxb.binding.content.ParticleModel(AbstractSurfaceType._GroupModel, min_occurs=1, max_occurs=1)



TopoPointPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopoPoint'), TopoPointType, scope=TopoPointPropertyType))
TopoPointPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoPointPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TopoPoint')), min_occurs=1, max_occurs=1)
    )
TopoPointPropertyType._ContentModel = pyxb.binding.content.ParticleModel(TopoPointPropertyType._GroupModel, min_occurs=1, max_occurs=1)



AbstractReferenceSystemBaseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'srsName'), CodeType, scope=AbstractReferenceSystemBaseType, documentation=u'The name by which this reference system is identified.'))
AbstractReferenceSystemBaseType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractReferenceSystemBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractReferenceSystemBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'srsName')), min_occurs=1, max_occurs=1)
    )
AbstractReferenceSystemBaseType._ContentModel = pyxb.binding.content.ParticleModel(AbstractReferenceSystemBaseType._GroupModel, min_occurs=1, max_occurs=1)



AbstractReferenceSystemType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'validArea'), ExtentType, scope=AbstractReferenceSystemType, documentation=u'Area or region in which this CRS object is valid.'))

AbstractReferenceSystemType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'srsID'), IdentifierType, scope=AbstractReferenceSystemType, documentation=u'An identification of a reference system.'))

AbstractReferenceSystemType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'scope'), pyxb.binding.datatypes.string, scope=AbstractReferenceSystemType, documentation=u'Description of domain of usage, or limitations of usage, for which this CRS object is valid.'))

AbstractReferenceSystemType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'remarks'), StringOrRefType, scope=AbstractReferenceSystemType, documentation=u'Information about this object or code. Contains text or refers to external text.'))
AbstractReferenceSystemType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'srsName')), min_occurs=1, max_occurs=1)
    )
AbstractReferenceSystemType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'srsID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validArea')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope')), min_occurs=0L, max_occurs=1)
    )
AbstractReferenceSystemType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractReferenceSystemType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractReferenceSystemType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
AbstractReferenceSystemType._ContentModel = pyxb.binding.content.ParticleModel(AbstractReferenceSystemType._GroupModel, min_occurs=1, max_occurs=1)



GeocentricCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesGeodeticDatum'), GeodeticDatumRefType, scope=GeocentricCRSType, documentation=u'Association to the geodetic datum used by this CRS. '))

GeocentricCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesCartesianCS'), CartesianCSRefType, scope=GeocentricCRSType, documentation=u'Association to the Cartesian coordinate system used by this CRS. '))

GeocentricCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesSphericalCS'), SphericalCSRefType, scope=GeocentricCRSType, documentation=u'Association to the spherical coordinate system used by this CRS.'))
GeocentricCRSType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeocentricCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(GeocentricCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'srsName')), min_occurs=1, max_occurs=1)
    )
GeocentricCRSType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeocentricCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'srsID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(GeocentricCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeocentricCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validArea')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeocentricCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope')), min_occurs=0L, max_occurs=1)
    )
GeocentricCRSType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeocentricCRSType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeocentricCRSType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
GeocentricCRSType._GroupModel_5 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(GeocentricCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesCartesianCS')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeocentricCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesSphericalCS')), min_occurs=1, max_occurs=1)
    )
GeocentricCRSType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeocentricCRSType._GroupModel_5, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeocentricCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesGeodeticDatum')), min_occurs=1, max_occurs=1)
    )
GeocentricCRSType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeocentricCRSType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeocentricCRSType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
GeocentricCRSType._ContentModel = pyxb.binding.content.ParticleModel(GeocentricCRSType._GroupModel, min_occurs=1, max_occurs=1)



FeaturePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Feature'), AbstractFeatureType, abstract=pyxb.binding.datatypes.boolean(1), scope=FeaturePropertyType))
FeaturePropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(FeaturePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_Feature')), min_occurs=1, max_occurs=1)
    )
FeaturePropertyType._ContentModel = pyxb.binding.content.ParticleModel(FeaturePropertyType._GroupModel, min_occurs=0L, max_occurs=1)


AbstractGeometricAggregateType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractGeometricAggregateType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractGeometricAggregateType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractGeometricAggregateType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
AbstractGeometricAggregateType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractGeometricAggregateType._GroupModel_, min_occurs=1, max_occurs=1)
    )
AbstractGeometricAggregateType._ContentModel = pyxb.binding.content.ParticleModel(AbstractGeometricAggregateType._GroupModel, min_occurs=1, max_occurs=1)



EnvelopeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'upperCorner'), DirectPositionType, scope=EnvelopeType))

EnvelopeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, scope=EnvelopeType, documentation=u''))

EnvelopeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coord'), CoordType, scope=EnvelopeType, documentation=u'Deprecated with GML 3.0 and included for backwards compatibility with GML 2. Use the "pos" element instead.'))

EnvelopeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), CoordinatesType, scope=EnvelopeType, documentation=u'Deprecated with GML version 3.1.0.'))

EnvelopeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'lowerCorner'), DirectPositionType, scope=EnvelopeType))
EnvelopeType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EnvelopeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'lowerCorner')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(EnvelopeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'upperCorner')), min_occurs=1, max_occurs=1)
    )
EnvelopeType._GroupModel = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(EnvelopeType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(EnvelopeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coord')), min_occurs=2L, max_occurs=2L),
    pyxb.binding.content.ParticleModel(EnvelopeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos')), min_occurs=2L, max_occurs=2L),
    pyxb.binding.content.ParticleModel(EnvelopeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates')), min_occurs=1, max_occurs=1)
    )
EnvelopeType._ContentModel = pyxb.binding.content.ParticleModel(EnvelopeType._GroupModel, min_occurs=1, max_occurs=1)



BoundingShapeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Envelope'), EnvelopeType, scope=BoundingShapeType))

BoundingShapeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Null'), NullType, scope=BoundingShapeType))
BoundingShapeType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(BoundingShapeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Envelope')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(BoundingShapeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Null')), min_occurs=1, max_occurs=1)
    )
BoundingShapeType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(BoundingShapeType._GroupModel_, min_occurs=1, max_occurs=1)
    )
BoundingShapeType._ContentModel = pyxb.binding.content.ParticleModel(BoundingShapeType._GroupModel, min_occurs=1, max_occurs=1)



TimeNodePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeNode'), TimeNodeType, scope=TimeNodePropertyType, documentation=u'"TimeNode" is a zero dimensional temporal topology primitive, \n\t\t\texpresses a position in topological time, and is a start and an end of time edge, which represents states of time.\n\t\t\tTime node may be isolated. However, it cannot describe the ordering relationships with other primitives. \n\t\t\tAn isolated node may not be an element of any temporal topology complex.'))
TimeNodePropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeNodePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TimeNode')), min_occurs=1, max_occurs=1)
    )
TimeNodePropertyType._ContentModel = pyxb.binding.content.ParticleModel(TimeNodePropertyType._GroupModel, min_occurs=0L, max_occurs=1)



LabelStylePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'LabelStyle'), LabelStyleType, scope=LabelStylePropertyType, documentation=u'The style descriptor for labels of a feature, geometry or topology.'))
LabelStylePropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(LabelStylePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'LabelStyle')), min_occurs=0L, max_occurs=1)
    )
LabelStylePropertyType._ContentModel = pyxb.binding.content.ParticleModel(LabelStylePropertyType._GroupModel, min_occurs=1, max_occurs=1)



AbstractCoordinateOperationBaseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationName'), CodeType, scope=AbstractCoordinateOperationBaseType, documentation=u'The name by which this coordinate operation is identified. '))
AbstractCoordinateOperationBaseType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractCoordinateOperationBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractCoordinateOperationBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationName')), min_occurs=1, max_occurs=1)
    )
AbstractCoordinateOperationBaseType._ContentModel = pyxb.binding.content.ParticleModel(AbstractCoordinateOperationBaseType._GroupModel, min_occurs=1, max_occurs=1)



AbstractCoordinateOperationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationID'), IdentifierType, scope=AbstractCoordinateOperationType, documentation=u'An identification of a coordinate operation. '))

AbstractCoordinateOperationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_positionalAccuracy'), AbstractPositionalAccuracyType, abstract=pyxb.binding.datatypes.boolean(1), scope=AbstractCoordinateOperationType))

AbstractCoordinateOperationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'validArea'), ExtentType, scope=AbstractCoordinateOperationType, documentation=u'Area or region in which this CRS object is valid.'))

AbstractCoordinateOperationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'remarks'), StringOrRefType, scope=AbstractCoordinateOperationType, documentation=u'Information about this object or code. Contains text or refers to external text.'))

AbstractCoordinateOperationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sourceCRS'), CRSRefType, scope=AbstractCoordinateOperationType, documentation=u'Association to the source CRS (coordinate reference system) of this coordinate operation. '))

AbstractCoordinateOperationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'scope'), pyxb.binding.datatypes.string, scope=AbstractCoordinateOperationType, documentation=u'Description of domain of usage, or limitations of usage, for which this CRS object is valid.'))

AbstractCoordinateOperationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'targetCRS'), CRSRefType, scope=AbstractCoordinateOperationType, documentation=u'Association to the target CRS (coordinate reference system) of this coordinate operation. For constraints on multiplicity of "sourceCRS" and "targetCRS", see UML model of Coordinate Operation package in OGC Abstract Specification topic 2. '))

AbstractCoordinateOperationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'operationVersion'), pyxb.binding.datatypes.string, scope=AbstractCoordinateOperationType, documentation=u'Version of the coordinate transformation (i.e., instantiation due to the stochastic nature of the parameters). Mandatory when describing a transformation, and should not be supplied for a conversion. '))
AbstractCoordinateOperationType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationName')), min_occurs=1, max_occurs=1)
    )
AbstractCoordinateOperationType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'operationVersion')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validArea')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_positionalAccuracy')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sourceCRS')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractCoordinateOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'targetCRS')), min_occurs=0L, max_occurs=1)
    )
AbstractCoordinateOperationType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractCoordinateOperationType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractCoordinateOperationType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
AbstractCoordinateOperationType._ContentModel = pyxb.binding.content.ParticleModel(AbstractCoordinateOperationType._GroupModel, min_occurs=1, max_occurs=1)


AbstractGeneralConversionType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractGeneralConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractGeneralConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationName')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractGeneralConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractGeneralConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractGeneralConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validArea')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractGeneralConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractGeneralConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_positionalAccuracy')), min_occurs=0L, max_occurs=None)
    )
AbstractGeneralConversionType._ContentModel = pyxb.binding.content.ParticleModel(AbstractGeneralConversionType._GroupModel, min_occurs=1, max_occurs=1)



DirectedTopoSolidPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopoSolid'), TopoSolidType, scope=DirectedTopoSolidPropertyType))
DirectedTopoSolidPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DirectedTopoSolidPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TopoSolid')), min_occurs=1, max_occurs=1)
    )
DirectedTopoSolidPropertyType._ContentModel = pyxb.binding.content.ParticleModel(DirectedTopoSolidPropertyType._GroupModel, min_occurs=0L, max_occurs=1)



MultiGeometryPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_GeometricAggregate'), AbstractGeometricAggregateType, abstract=pyxb.binding.datatypes.boolean(1), scope=MultiGeometryPropertyType, documentation=u'The "_GeometricAggregate" element is the abstract head of the substituition group for all geometric aggremates.'))
MultiGeometryPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiGeometryPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_GeometricAggregate')), min_occurs=1, max_occurs=1)
    )
MultiGeometryPropertyType._ContentModel = pyxb.binding.content.ParticleModel(MultiGeometryPropertyType._GroupModel, min_occurs=0L, max_occurs=1)



MultiSurfaceCoverageType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiSurfaceDomain'), MultiSurfaceDomainType, scope=MultiSurfaceCoverageType))
MultiSurfaceCoverageType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
MultiSurfaceCoverageType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiSurfaceCoverageType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiSurfaceDomain')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rangeSet')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiSurfaceCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coverageFunction')), min_occurs=0L, max_occurs=1)
    )
MultiSurfaceCoverageType._ContentModel = pyxb.binding.content.ParticleModel(MultiSurfaceCoverageType._GroupModel, min_occurs=1, max_occurs=1)



MultiCurveType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'curveMember'), CurvePropertyType, scope=MultiCurveType, documentation=u'This property element either references a curve via the XLink-attributes or contains the curve element. A curve element is any element which is substitutable for "_Curve".'))

MultiCurveType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'curveMembers'), CurveArrayPropertyType, scope=MultiCurveType, documentation=u'This property element contains a list of curves. The order of the elements is significant and shall be preserved when processing the array.'))
MultiCurveType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(MultiCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
MultiCurveType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiCurveType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
MultiCurveType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'curveMember')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(MultiCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'curveMembers')), min_occurs=0L, max_occurs=1)
    )
MultiCurveType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiCurveType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiCurveType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
MultiCurveType._ContentModel = pyxb.binding.content.ParticleModel(MultiCurveType._GroupModel, min_occurs=1, max_occurs=1)



TimeCalendarEraType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'referenceEvent'), StringOrRefType, scope=TimeCalendarEraType, documentation=u'Name or description of a mythical or historic event which fixes the position of the base scale of the calendar era.'))

TimeCalendarEraType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'epochOfUse'), TimePeriodPropertyType, scope=TimeCalendarEraType, documentation=u'Period for which the calendar era was used as a basis for dating.'))

TimeCalendarEraType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'julianReference'), pyxb.binding.datatypes.decimal, scope=TimeCalendarEraType, documentation=u'Julian date that corresponds to the reference date.  \n              The Julian day numbering system is a temporal coordinate system that has an \n              origin earlier than any known calendar, \n              at noon on 1 January 4713 BC in the Julian proleptic calendar.  \n              The Julian day number is an integer value; \n              the Julian date is a decimal value that allows greater resolution. \n              Transforming calendar dates to and from Julian dates provides a \n              relatively simple basis for transforming dates from one calendar to another.'))

TimeCalendarEraType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'referenceDate'), pyxb.binding.datatypes.date, scope=TimeCalendarEraType, documentation=u'Date of the referenceEvent expressed as a date in the given calendar. \n              In most calendars, this date is the origin (i.e., the first day) of the scale, but this is not always true.'))
TimeCalendarEraType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeCalendarEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TimeCalendarEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeCalendarEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=1, max_occurs=None)
    )
TimeCalendarEraType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeCalendarEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'referenceEvent')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeCalendarEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'referenceDate')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeCalendarEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'julianReference')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeCalendarEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'epochOfUse')), min_occurs=1, max_occurs=1)
    )
TimeCalendarEraType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeCalendarEraType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeCalendarEraType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
TimeCalendarEraType._ContentModel = pyxb.binding.content.ParticleModel(TimeCalendarEraType._GroupModel, min_occurs=1, max_occurs=1)



AbstractGeneralOperationParameterType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minimumOccurs'), pyxb.binding.datatypes.nonNegativeInteger, scope=AbstractGeneralOperationParameterType, documentation=u'The minimum number of times that values for this parameter group or parameter are required. If this attribute is omitted, the minimum number is one. '))
AbstractGeneralOperationParameterType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractGeneralOperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractGeneralOperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractGeneralOperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=1, max_occurs=None)
    )
AbstractGeneralOperationParameterType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractGeneralOperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimumOccurs')), min_occurs=0L, max_occurs=1)
    )
AbstractGeneralOperationParameterType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractGeneralOperationParameterType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractGeneralOperationParameterType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
AbstractGeneralOperationParameterType._ContentModel = pyxb.binding.content.ParticleModel(AbstractGeneralOperationParameterType._GroupModel, min_occurs=1, max_occurs=1)



TopoSolidType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedFace'), DirectedFacePropertyType, scope=TopoSolidType, documentation=u''))
TopoSolidType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
TopoSolidType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoSolidType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
TopoSolidType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container')), min_occurs=0L, max_occurs=1)
    )
TopoSolidType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoSolidType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TopoSolidType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
TopoSolidType._GroupModel_5 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedFace')), min_occurs=1, max_occurs=None)
    )
TopoSolidType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoSolidType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TopoSolidType._GroupModel_5, min_occurs=1, max_occurs=1)
    )
TopoSolidType._ContentModel = pyxb.binding.content.ParticleModel(TopoSolidType._GroupModel, min_occurs=1, max_occurs=1)



MultiPointPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiPoint'), MultiPointType, scope=MultiPointPropertyType))
MultiPointPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiPointPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'MultiPoint')), min_occurs=1, max_occurs=1)
    )
MultiPointPropertyType._ContentModel = pyxb.binding.content.ParticleModel(MultiPointPropertyType._GroupModel, min_occurs=0L, max_occurs=1)



SurfacePatchArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_SurfacePatch'), AbstractSurfacePatchType, abstract=pyxb.binding.datatypes.boolean(1), scope=SurfacePatchArrayPropertyType, documentation=u'The "_SurfacePatch" element is the abstract head of the substituition group for all surface pach elements describing a continuous portion of a surface.'))
SurfacePatchArrayPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(SurfacePatchArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_SurfacePatch')), min_occurs=1, max_occurs=1)
    )
SurfacePatchArrayPropertyType._ContentModel = pyxb.binding.content.ParticleModel(SurfacePatchArrayPropertyType._GroupModel, min_occurs=0L, max_occurs=None)



EnvelopeWithTimePeriodType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'timePosition'), TimePositionType, scope=EnvelopeWithTimePeriodType, documentation=u'Direct representation of a temporal position'))
EnvelopeWithTimePeriodType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EnvelopeWithTimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'lowerCorner')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(EnvelopeWithTimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'upperCorner')), min_occurs=1, max_occurs=1)
    )
EnvelopeWithTimePeriodType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(EnvelopeWithTimePeriodType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(EnvelopeWithTimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coord')), min_occurs=2L, max_occurs=2L),
    pyxb.binding.content.ParticleModel(EnvelopeWithTimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos')), min_occurs=2L, max_occurs=2L),
    pyxb.binding.content.ParticleModel(EnvelopeWithTimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates')), min_occurs=1, max_occurs=1)
    )
EnvelopeWithTimePeriodType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EnvelopeWithTimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'timePosition')), min_occurs=2L, max_occurs=2L)
    )
EnvelopeWithTimePeriodType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EnvelopeWithTimePeriodType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(EnvelopeWithTimePeriodType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
EnvelopeWithTimePeriodType._ContentModel = pyxb.binding.content.ParticleModel(EnvelopeWithTimePeriodType._GroupModel, min_occurs=1, max_occurs=1)



MultiCurvePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiCurve'), MultiCurveType, scope=MultiCurvePropertyType))
MultiCurvePropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiCurvePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'MultiCurve')), min_occurs=1, max_occurs=1)
    )
MultiCurvePropertyType._ContentModel = pyxb.binding.content.ParticleModel(MultiCurvePropertyType._GroupModel, min_occurs=0L, max_occurs=1)



KnotPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Knot'), KnotType, scope=KnotPropertyType))
KnotPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(KnotPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Knot')), min_occurs=1, max_occurs=1)
    )
KnotPropertyType._ContentModel = pyxb.binding.content.ParticleModel(KnotPropertyType._GroupModel, min_occurs=1, max_occurs=1)



TopoSurfacePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopoSurface'), TopoSurfaceType, scope=TopoSurfacePropertyType))
TopoSurfacePropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoSurfacePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TopoSurface')), min_occurs=1, max_occurs=1)
    )
TopoSurfacePropertyType._ContentModel = pyxb.binding.content.ParticleModel(TopoSurfacePropertyType._GroupModel, min_occurs=1, max_occurs=1)



TemporalCRSRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TemporalCRS'), TemporalCRSType, scope=TemporalCRSRefType))
TemporalCRSRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TemporalCRSRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TemporalCRS')), min_occurs=1, max_occurs=1)
    )
TemporalCRSRefType._ContentModel = pyxb.binding.content.ParticleModel(TemporalCRSRefType._GroupModel, min_occurs=0L, max_occurs=1)



PrimeMeridianRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'PrimeMeridian'), PrimeMeridianType, scope=PrimeMeridianRefType))
PrimeMeridianRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PrimeMeridianRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'PrimeMeridian')), min_occurs=1, max_occurs=1)
    )
PrimeMeridianRefType._ContentModel = pyxb.binding.content.ParticleModel(PrimeMeridianRefType._GroupModel, min_occurs=0L, max_occurs=1)



CurveArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Curve'), AbstractCurveType, abstract=pyxb.binding.datatypes.boolean(1), scope=CurveArrayPropertyType, documentation=u'The "_Curve" element is the abstract head of the substituition group for all (continuous) curve elements.'))
CurveArrayPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CurveArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_Curve')), min_occurs=0L, max_occurs=None)
    )
CurveArrayPropertyType._ContentModel = pyxb.binding.content.ParticleModel(CurveArrayPropertyType._GroupModel, min_occurs=1, max_occurs=1)



LineStringSegmentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'posList'), DirectPositionListType, scope=LineStringSegmentType, documentation=u''))

LineStringSegmentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), PointPropertyType, scope=LineStringSegmentType, documentation=u'This property element either references a point via the XLink-attributes or contains the point element. pointProperty \n\t\t\tis the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that \n\t\t\tis substitutable for Point.'))

LineStringSegmentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), CoordinatesType, scope=LineStringSegmentType, documentation=u'Deprecated with GML version 3.1.0.'))

LineStringSegmentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), PointPropertyType, scope=LineStringSegmentType, documentation=u'Deprecated with GML version 3.1.0. Use "pointProperty" instead. Included for backwards compatibility with GML 3.0.0.'))

LineStringSegmentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, scope=LineStringSegmentType, documentation=u''))
LineStringSegmentType._GroupModel_2 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(LineStringSegmentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(LineStringSegmentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(LineStringSegmentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep')), min_occurs=1, max_occurs=1)
    )
LineStringSegmentType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(LineStringSegmentType._GroupModel_2, min_occurs=2L, max_occurs=None),
    pyxb.binding.content.ParticleModel(LineStringSegmentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(LineStringSegmentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates')), min_occurs=1, max_occurs=1)
    )
LineStringSegmentType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(LineStringSegmentType._GroupModel_, min_occurs=1, max_occurs=1)
    )
LineStringSegmentType._ContentModel = pyxb.binding.content.ParticleModel(LineStringSegmentType._GroupModel, min_occurs=1, max_occurs=1)



TrianglePatchArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Triangle'), TriangleType, scope=TrianglePatchArrayPropertyType))
TrianglePatchArrayPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TrianglePatchArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Triangle')), min_occurs=1, max_occurs=1)
    )
TrianglePatchArrayPropertyType._ContentModel = pyxb.binding.content.ParticleModel(TrianglePatchArrayPropertyType._GroupModel, min_occurs=0L, max_occurs=None)



EngineeringDatumRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'EngineeringDatum'), EngineeringDatumType, scope=EngineeringDatumRefType))
EngineeringDatumRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EngineeringDatumRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'EngineeringDatum')), min_occurs=1, max_occurs=1)
    )
EngineeringDatumRefType._ContentModel = pyxb.binding.content.ParticleModel(EngineeringDatumRefType._GroupModel, min_occurs=0L, max_occurs=1)



AbstractGeneralOperationParameterRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_GeneralOperationParameter'), AbstractGeneralOperationParameterType, abstract=pyxb.binding.datatypes.boolean(1), scope=AbstractGeneralOperationParameterRefType))
AbstractGeneralOperationParameterRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractGeneralOperationParameterRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_GeneralOperationParameter')), min_occurs=1, max_occurs=1)
    )
AbstractGeneralOperationParameterRefType._ContentModel = pyxb.binding.content.ParticleModel(AbstractGeneralOperationParameterRefType._GroupModel, min_occurs=0L, max_occurs=1)



SurfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'patches'), SurfacePatchArrayPropertyType, scope=SurfaceType, documentation=u'This property element contains a list of surface patches. The order of the elements is significant and shall be preserved when processing the array.'))
SurfaceType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(SurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(SurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(SurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
SurfaceType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(SurfaceType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
SurfaceType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(SurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'patches')), min_occurs=1, max_occurs=1)
    )
SurfaceType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(SurfaceType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(SurfaceType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
SurfaceType._ContentModel = pyxb.binding.content.ParticleModel(SurfaceType._GroupModel, min_occurs=1, max_occurs=1)



CRSRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_CRS'), AbstractReferenceSystemType, abstract=pyxb.binding.datatypes.boolean(1), scope=CRSRefType, documentation=u'Abstract coordinate reference system, usually defined by a coordinate system and a datum. This abstract complexType shall not be used, extended, or restricted, in an Application Schema, to define a concrete subtype with a meaning equivalent to a concrete subtype specified in this document.'))
CRSRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CRSRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_CRS')), min_occurs=1, max_occurs=1)
    )
CRSRefType._ContentModel = pyxb.binding.content.ParticleModel(CRSRefType._GroupModel, min_occurs=0L, max_occurs=1)



TargetPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Geometry'), AbstractGeometryType, abstract=pyxb.binding.datatypes.boolean(1), scope=TargetPropertyType, documentation=u'The "_Geometry" element is the abstract head of the substituition group for all geometry elements of GML 3. This \n\t\t\tincludes pre-defined and user-defined geometry elements. Any geometry element must be a direct or indirect extension/restriction \n\t\t\tof AbstractGeometryType and must be directly or indirectly in the substitution group of "_Geometry".'))

TargetPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Feature'), AbstractFeatureType, abstract=pyxb.binding.datatypes.boolean(1), scope=TargetPropertyType))
TargetPropertyType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(TargetPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_Feature')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TargetPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_Geometry')), min_occurs=1, max_occurs=1)
    )
TargetPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TargetPropertyType._GroupModel_, min_occurs=1, max_occurs=1)
    )
TargetPropertyType._ContentModel = pyxb.binding.content.ParticleModel(TargetPropertyType._GroupModel, min_occurs=0L, max_occurs=1)



AbstractTimeReferenceSystemType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity'), pyxb.binding.datatypes.string, scope=AbstractTimeReferenceSystemType))
AbstractTimeReferenceSystemType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTimeReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractTimeReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractTimeReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=1, max_occurs=None)
    )
AbstractTimeReferenceSystemType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTimeReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity')), min_occurs=0L, max_occurs=1)
    )
AbstractTimeReferenceSystemType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTimeReferenceSystemType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractTimeReferenceSystemType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
AbstractTimeReferenceSystemType._ContentModel = pyxb.binding.content.ParticleModel(AbstractTimeReferenceSystemType._GroupModel, min_occurs=1, max_occurs=1)



MultiSolidCoverageType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiSolidDomain'), MultiSolidDomainType, scope=MultiSolidCoverageType))
MultiSolidCoverageType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
MultiSolidCoverageType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiSolidCoverageType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiSolidDomain')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rangeSet')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiSolidCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coverageFunction')), min_occurs=0L, max_occurs=1)
    )
MultiSolidCoverageType._ContentModel = pyxb.binding.content.ParticleModel(MultiSolidCoverageType._GroupModel, min_occurs=1, max_occurs=1)



CoverageFunctionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MappingRule'), StringOrRefType, scope=CoverageFunctionType, documentation=u'Description of a rule for associating members from the domainSet with members of the rangeSet.'))

CoverageFunctionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GridFunction'), GridFunctionType, scope=CoverageFunctionType))
CoverageFunctionType._GroupModel = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(CoverageFunctionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'MappingRule')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CoverageFunctionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'GridFunction')), min_occurs=1, max_occurs=1)
    )
CoverageFunctionType._ContentModel = pyxb.binding.content.ParticleModel(CoverageFunctionType._GroupModel, min_occurs=1, max_occurs=1)



OperationParameterBaseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'parameterName'), CodeType, scope=OperationParameterBaseType, documentation=u'The name by which this operation parameter is identified. '))
OperationParameterBaseType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(OperationParameterBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(OperationParameterBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'parameterName')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(OperationParameterBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimumOccurs')), min_occurs=0L, max_occurs=1)
    )
OperationParameterBaseType._ContentModel = pyxb.binding.content.ParticleModel(OperationParameterBaseType._GroupModel, min_occurs=1, max_occurs=1)



OperationParameterType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'parameterID'), IdentifierType, scope=OperationParameterType, documentation=u'An identification of an operation parameter. '))

OperationParameterType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'remarks'), StringOrRefType, scope=OperationParameterType, documentation=u'Information about this object or code. Contains text or refers to external text.'))
OperationParameterType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(OperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(OperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'parameterName')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(OperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimumOccurs')), min_occurs=0L, max_occurs=1)
    )
OperationParameterType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(OperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'parameterID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(OperationParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1)
    )
OperationParameterType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(OperationParameterType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(OperationParameterType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
OperationParameterType._ContentModel = pyxb.binding.content.ParticleModel(OperationParameterType._GroupModel, min_occurs=1, max_occurs=1)



PolygonType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'interior'), AbstractRingPropertyType, scope=PolygonType, documentation=u'A boundary of a surface consists of a number of rings. The "interior" rings seperate the surface / surface patch from the area enclosed by the rings.'))

PolygonType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'exterior'), AbstractRingPropertyType, scope=PolygonType, documentation=u'A boundary of a surface consists of a number of rings. In the normal 2D case, one of these rings is distinguished as being the exterior boundary. In a general manifold this is not always possible, in which case all boundaries shall be listed as interior boundaries, and the exterior will be empty.'))
PolygonType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(PolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(PolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
PolygonType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PolygonType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
PolygonType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'exterior')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(PolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'interior')), min_occurs=0L, max_occurs=None)
    )
PolygonType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PolygonType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(PolygonType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
PolygonType._ContentModel = pyxb.binding.content.ParticleModel(PolygonType._GroupModel, min_occurs=1, max_occurs=1)



EllipsoidBaseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ellipsoidName'), CodeType, scope=EllipsoidBaseType, documentation=u'The name by which this ellipsoid is identified. '))
EllipsoidBaseType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EllipsoidBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(EllipsoidBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'ellipsoidName')), min_occurs=1, max_occurs=1)
    )
EllipsoidBaseType._ContentModel = pyxb.binding.content.ParticleModel(EllipsoidBaseType._GroupModel, min_occurs=1, max_occurs=1)



EllipsoidType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ellipsoidID'), IdentifierType, scope=EllipsoidType, documentation=u'An identification of an ellipsoid. '))

EllipsoidType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'secondDefiningParameter'), SecondDefiningParameterType, scope=EllipsoidType))

EllipsoidType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'remarks'), StringOrRefType, scope=EllipsoidType, documentation=u'Information about this object or code. Contains text or refers to external text.'))

EllipsoidType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'semiMajorAxis'), MeasureType, scope=EllipsoidType, documentation=u'Length of the semi-major axis of the ellipsoid, with its units. Uses the MeasureType with the restriction that the unit of measure referenced by uom must be suitable for a length, such as metres or feet. '))
EllipsoidType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EllipsoidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(EllipsoidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'ellipsoidName')), min_occurs=1, max_occurs=1)
    )
EllipsoidType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EllipsoidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'ellipsoidID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(EllipsoidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(EllipsoidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'semiMajorAxis')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(EllipsoidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'secondDefiningParameter')), min_occurs=1, max_occurs=1)
    )
EllipsoidType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EllipsoidType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(EllipsoidType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
EllipsoidType._ContentModel = pyxb.binding.content.ParticleModel(EllipsoidType._GroupModel, min_occurs=1, max_occurs=1)



UnitDefinitionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'catalogSymbol'), CodeType, scope=UnitDefinitionType, documentation=u'For global understanding of a unit of measure, it is often possible to reference an item in a catalog of units, using a symbol in that catalog. The "codeSpace" attribute in "CodeType" identifies a namespace for the catalog symbol value, and might reference the catalog. The "string" value in "CodeType" contains the value of a symbol that is unique within this catalog namespace. This symbol often appears explicitly in the catalog, but it could be a combination of symbols using a specified algebra of units. For example, the symbol "cm" might indicate that it is the "m" symbol combined with the "c" prefix.'))

UnitDefinitionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'quantityType'), StringOrRefType, scope=UnitDefinitionType, documentation=u'Informal description of the phenomenon or type of quantity that is measured or observed. For example, "length", "angle", "time", "pressure", or "temperature". When the quantity is the result of an observation or measurement, this term is known as Observable Type or Measurand.'))
UnitDefinitionType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(UnitDefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(UnitDefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(UnitDefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=1, max_occurs=None)
    )
UnitDefinitionType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(UnitDefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'quantityType')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(UnitDefinitionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'catalogSymbol')), min_occurs=0L, max_occurs=1)
    )
UnitDefinitionType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(UnitDefinitionType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(UnitDefinitionType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
UnitDefinitionType._ContentModel = pyxb.binding.content.ParticleModel(UnitDefinitionType._GroupModel, min_occurs=1, max_occurs=1)



AbstractCoordinateSystemBaseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'csName'), CodeType, scope=AbstractCoordinateSystemBaseType, documentation=u'The name by which this coordinate system is identified. '))
AbstractCoordinateSystemBaseType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractCoordinateSystemBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractCoordinateSystemBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'csName')), min_occurs=1, max_occurs=1)
    )
AbstractCoordinateSystemBaseType._ContentModel = pyxb.binding.content.ParticleModel(AbstractCoordinateSystemBaseType._GroupModel, min_occurs=1, max_occurs=1)



AbstractCoordinateSystemType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesAxis'), CoordinateSystemAxisRefType, scope=AbstractCoordinateSystemType, documentation=u'Association to a coordinate system axis. '))

AbstractCoordinateSystemType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'remarks'), StringOrRefType, scope=AbstractCoordinateSystemType, documentation=u'Information about this object or code. Contains text or refers to external text.'))

AbstractCoordinateSystemType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'csID'), IdentifierType, scope=AbstractCoordinateSystemType, documentation=u'An identification of a coordinate system. '))
AbstractCoordinateSystemType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'csName')), min_occurs=1, max_occurs=1)
    )
AbstractCoordinateSystemType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'csID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesAxis')), min_occurs=1, max_occurs=None)
    )
AbstractCoordinateSystemType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractCoordinateSystemType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractCoordinateSystemType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
AbstractCoordinateSystemType._ContentModel = pyxb.binding.content.ParticleModel(AbstractCoordinateSystemType._GroupModel, min_occurs=1, max_occurs=1)


ObliqueCartesianCSType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ObliqueCartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(ObliqueCartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'csName')), min_occurs=1, max_occurs=1)
    )
ObliqueCartesianCSType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ObliqueCartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'csID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(ObliqueCartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(ObliqueCartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesAxis')), min_occurs=1, max_occurs=None)
    )
ObliqueCartesianCSType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ObliqueCartesianCSType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ObliqueCartesianCSType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
ObliqueCartesianCSType._ContentModel = pyxb.binding.content.ParticleModel(ObliqueCartesianCSType._GroupModel, min_occurs=1, max_occurs=1)



AbstractPositionalAccuracyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'measureDescription'), CodeType, scope=AbstractPositionalAccuracyType, documentation=u'A description of the position accuracy parameter(s) provided. '))
AbstractPositionalAccuracyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractPositionalAccuracyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'measureDescription')), min_occurs=0L, max_occurs=1)
    )
AbstractPositionalAccuracyType._ContentModel = pyxb.binding.content.ParticleModel(AbstractPositionalAccuracyType._GroupModel, min_occurs=1, max_occurs=1)



RelativeInternalPositionalAccuracyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'result'), MeasureType, scope=RelativeInternalPositionalAccuracyType, documentation=u'A quantitative result defined by the evaluation procedure used, and identified by the measureDescription. '))
RelativeInternalPositionalAccuracyType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(RelativeInternalPositionalAccuracyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'measureDescription')), min_occurs=0L, max_occurs=1)
    )
RelativeInternalPositionalAccuracyType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(RelativeInternalPositionalAccuracyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'result')), min_occurs=1, max_occurs=1)
    )
RelativeInternalPositionalAccuracyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(RelativeInternalPositionalAccuracyType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(RelativeInternalPositionalAccuracyType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
RelativeInternalPositionalAccuracyType._ContentModel = pyxb.binding.content.ParticleModel(RelativeInternalPositionalAccuracyType._GroupModel, min_occurs=1, max_occurs=1)



TopoComplexMemberType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopoComplex'), TopoComplexType, scope=TopoComplexMemberType))
TopoComplexMemberType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoComplexMemberType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TopoComplex')), min_occurs=0L, max_occurs=1)
    )
TopoComplexMemberType._ContentModel = pyxb.binding.content.ParticleModel(TopoComplexMemberType._GroupModel, min_occurs=1, max_occurs=1)



ObservationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'using'), FeaturePropertyType, scope=ObservationType, documentation=u'This element contains or points to a description of a sensor, instrument or procedure used for the observation'))

ObservationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'target'), TargetPropertyType, scope=ObservationType, documentation=u'This element contains or points to the specimen, region or station which is the object of the observation'))

ObservationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'validTime'), TimePrimitivePropertyType, scope=ObservationType))

ObservationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'resultOf'), AssociationType, scope=ObservationType, documentation=u'The result of the observation: an image, external object, etc'))
ObservationType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
ObservationType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ObservationType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
ObservationType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location')), min_occurs=0L, max_occurs=1)
    )
ObservationType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ObservationType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ObservationType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
ObservationType._GroupModel_5 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'using')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'target')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(ObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'resultOf')), min_occurs=1, max_occurs=1)
    )
ObservationType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ObservationType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ObservationType._GroupModel_5, min_occurs=1, max_occurs=1)
    )
ObservationType._ContentModel = pyxb.binding.content.ParticleModel(ObservationType._GroupModel, min_occurs=1, max_occurs=1)



DirectedObservationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'direction'), DirectionPropertyType, scope=DirectedObservationType))
DirectedObservationType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
DirectedObservationType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DirectedObservationType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
DirectedObservationType._GroupModel_5 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location')), min_occurs=0L, max_occurs=1)
    )
DirectedObservationType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DirectedObservationType._GroupModel_3, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DirectedObservationType._GroupModel_5, min_occurs=1, max_occurs=1)
    )
DirectedObservationType._GroupModel_6 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'using')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'target')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'resultOf')), min_occurs=1, max_occurs=1)
    )
DirectedObservationType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DirectedObservationType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DirectedObservationType._GroupModel_6, min_occurs=1, max_occurs=1)
    )
DirectedObservationType._GroupModel_7 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DirectedObservationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'direction')), min_occurs=1, max_occurs=1)
    )
DirectedObservationType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DirectedObservationType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DirectedObservationType._GroupModel_7, min_occurs=1, max_occurs=1)
    )
DirectedObservationType._ContentModel = pyxb.binding.content.ParticleModel(DirectedObservationType._GroupModel, min_occurs=1, max_occurs=1)



DirectedObservationAtDistanceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'distance'), MeasureType, scope=DirectedObservationAtDistanceType))
DirectedObservationAtDistanceType._GroupModel_5 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
DirectedObservationAtDistanceType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DirectedObservationAtDistanceType._GroupModel_5, min_occurs=1, max_occurs=1)
    )
DirectedObservationAtDistanceType._GroupModel_6 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location')), min_occurs=0L, max_occurs=1)
    )
DirectedObservationAtDistanceType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DirectedObservationAtDistanceType._GroupModel_4, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DirectedObservationAtDistanceType._GroupModel_6, min_occurs=1, max_occurs=1)
    )
DirectedObservationAtDistanceType._GroupModel_7 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'using')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'target')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'resultOf')), min_occurs=1, max_occurs=1)
    )
DirectedObservationAtDistanceType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DirectedObservationAtDistanceType._GroupModel_3, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DirectedObservationAtDistanceType._GroupModel_7, min_occurs=1, max_occurs=1)
    )
DirectedObservationAtDistanceType._GroupModel_8 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'direction')), min_occurs=1, max_occurs=1)
    )
DirectedObservationAtDistanceType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DirectedObservationAtDistanceType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DirectedObservationAtDistanceType._GroupModel_8, min_occurs=1, max_occurs=1)
    )
DirectedObservationAtDistanceType._GroupModel_9 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DirectedObservationAtDistanceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'distance')), min_occurs=1, max_occurs=1)
    )
DirectedObservationAtDistanceType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DirectedObservationAtDistanceType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DirectedObservationAtDistanceType._GroupModel_9, min_occurs=1, max_occurs=1)
    )
DirectedObservationAtDistanceType._ContentModel = pyxb.binding.content.ParticleModel(DirectedObservationAtDistanceType._GroupModel, min_occurs=1, max_occurs=1)



BaseStyleDescriptorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'styleVariation'), StyleVariationType, scope=BaseStyleDescriptorType))

BaseStyleDescriptorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'animate'), pyxb.bundles.opengis.raw._nsgroup_.animateType, scope=BaseStyleDescriptorType))

BaseStyleDescriptorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'animateMotion'), pyxb.bundles.opengis.raw._nsgroup_.animateMotionType, scope=BaseStyleDescriptorType))

BaseStyleDescriptorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'spatialResolution'), ScaleType, scope=BaseStyleDescriptorType))

BaseStyleDescriptorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'animateColor'), pyxb.bundles.opengis.raw._nsgroup_.animateColorType, scope=BaseStyleDescriptorType))

BaseStyleDescriptorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'set'), pyxb.bundles.opengis.raw._nsgroup_.setType, scope=BaseStyleDescriptorType))
BaseStyleDescriptorType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(BaseStyleDescriptorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(BaseStyleDescriptorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(BaseStyleDescriptorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
BaseStyleDescriptorType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(BaseStyleDescriptorType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
BaseStyleDescriptorType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(BaseStyleDescriptorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'spatialResolution')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(BaseStyleDescriptorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'styleVariation')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(BaseStyleDescriptorType._UseForTag(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'animate')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(BaseStyleDescriptorType._UseForTag(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'animateMotion')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(BaseStyleDescriptorType._UseForTag(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'animateColor')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(BaseStyleDescriptorType._UseForTag(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'set')), min_occurs=0L, max_occurs=None)
    )
BaseStyleDescriptorType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(BaseStyleDescriptorType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(BaseStyleDescriptorType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
BaseStyleDescriptorType._ContentModel = pyxb.binding.content.ParticleModel(BaseStyleDescriptorType._GroupModel, min_occurs=1, max_occurs=1)



GraphStyleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'aestheticCriteria'), AesheticCriteriaType, scope=GraphStyleType))

GraphStyleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directed'), pyxb.binding.datatypes.boolean, scope=GraphStyleType))

GraphStyleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'graphType'), GraphTypeType, scope=GraphStyleType))

GraphStyleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minDistance'), pyxb.binding.datatypes.double, scope=GraphStyleType))

GraphStyleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'grid'), pyxb.binding.datatypes.boolean, scope=GraphStyleType))

GraphStyleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minAngle'), pyxb.binding.datatypes.double, scope=GraphStyleType))

GraphStyleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'lineType'), LineTypeType, scope=GraphStyleType))

GraphStyleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'planar'), pyxb.binding.datatypes.boolean, scope=GraphStyleType))

GraphStyleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'drawingType'), DrawingTypeType, scope=GraphStyleType))
GraphStyleType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GraphStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(GraphStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(GraphStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
GraphStyleType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GraphStyleType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
GraphStyleType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GraphStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'spatialResolution')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(GraphStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'styleVariation')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(GraphStyleType._UseForTag(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'animate')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(GraphStyleType._UseForTag(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'animateMotion')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(GraphStyleType._UseForTag(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'animateColor')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(GraphStyleType._UseForTag(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'set')), min_occurs=0L, max_occurs=None)
    )
GraphStyleType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GraphStyleType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GraphStyleType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
GraphStyleType._GroupModel_5 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GraphStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'planar')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(GraphStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directed')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(GraphStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'grid')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(GraphStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minDistance')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(GraphStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minAngle')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(GraphStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'graphType')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(GraphStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'drawingType')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(GraphStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'lineType')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(GraphStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'aestheticCriteria')), min_occurs=0L, max_occurs=None)
    )
GraphStyleType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GraphStyleType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GraphStyleType._GroupModel_5, min_occurs=1, max_occurs=1)
    )
GraphStyleType._ContentModel = pyxb.binding.content.ParticleModel(GraphStyleType._GroupModel, min_occurs=1, max_occurs=1)



RangeSetType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'QuantityList'), MeasureOrNullListType, scope=RangeSetType, documentation=u'A space separated list of amounts or nulls.  The amounts use the XML Schema type double.  A single XML attribute uom (unit of measure) is required, whose value is a URI which identifies the definition of the scale or units by which all the amounts in the list must be multiplied.'))

RangeSetType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CountList'), integerOrNullList, scope=RangeSetType, documentation=u'A space-separated list of integers or nulls.'))

RangeSetType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'BooleanList'), booleanOrNullList, scope=RangeSetType, documentation=u'XML List based on XML Schema boolean type.  An element of this type contains a space-separated list of boolean values {0,1,true,false}'))

RangeSetType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ValueArray'), ValueArrayType, scope=RangeSetType, documentation=u'A Value Array is used for homogeneous arrays of primitive and aggregate values.   _ScalarValueList is preferred for arrays of Scalar Values since this is more efficient.  Since "choice" is not available for attribute groups, an external constraint (e.g. Schematron) would be required to enforce the selection of only one of these through schema validation'))

RangeSetType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CategoryList'), CodeOrNullListType, scope=RangeSetType, documentation=u'A space-separated list of terms or nulls.  A single XML attribute codeSpace may be provided, which authorises all the terms in the list.'))

RangeSetType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DataBlock'), DataBlockType, scope=RangeSetType))

RangeSetType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'File'), FileType, scope=RangeSetType))
RangeSetType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(RangeSetType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'BooleanList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(RangeSetType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CategoryList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(RangeSetType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'QuantityList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(RangeSetType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CountList')), min_occurs=1, max_occurs=1)
    )
RangeSetType._GroupModel = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(RangeSetType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'ValueArray')), min_occurs=1, max_occurs=None),
    pyxb.binding.content.ParticleModel(RangeSetType._GroupModel_, min_occurs=1, max_occurs=None),
    pyxb.binding.content.ParticleModel(RangeSetType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'DataBlock')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(RangeSetType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'File')), min_occurs=1, max_occurs=1)
    )
RangeSetType._ContentModel = pyxb.binding.content.ParticleModel(RangeSetType._GroupModel, min_occurs=1, max_occurs=1)



DefinitionProxyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'definitionRef'), ReferenceType, scope=DefinitionProxyType))
DefinitionProxyType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DefinitionProxyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(DefinitionProxyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(DefinitionProxyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=1, max_occurs=None)
    )
DefinitionProxyType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DefinitionProxyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'definitionRef')), min_occurs=1, max_occurs=1)
    )
DefinitionProxyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DefinitionProxyType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DefinitionProxyType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
DefinitionProxyType._ContentModel = pyxb.binding.content.ParticleModel(DefinitionProxyType._GroupModel, min_occurs=1, max_occurs=1)



OperationParameterGroupRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'OperationParameterGroup'), OperationParameterGroupType, scope=OperationParameterGroupRefType))
OperationParameterGroupRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(OperationParameterGroupRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'OperationParameterGroup')), min_occurs=1, max_occurs=1)
    )
OperationParameterGroupRefType._ContentModel = pyxb.binding.content.ParticleModel(OperationParameterGroupRefType._GroupModel, min_occurs=0L, max_occurs=1)



PointPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Point'), PointType, scope=PointPropertyType))
PointPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PointPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Point')), min_occurs=1, max_occurs=1)
    )
PointPropertyType._ContentModel = pyxb.binding.content.ParticleModel(PointPropertyType._GroupModel, min_occurs=0L, max_occurs=1)


AbstractGeneralTransformationType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationName')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'operationVersion')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validArea')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_positionalAccuracy')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sourceCRS')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractGeneralTransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'targetCRS')), min_occurs=1, max_occurs=1)
    )
AbstractGeneralTransformationType._ContentModel = pyxb.binding.content.ParticleModel(AbstractGeneralTransformationType._GroupModel, min_occurs=1, max_occurs=1)



GeometryStyleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'labelStyle'), LabelStylePropertyType, scope=GeometryStyleType, documentation=u''))

GeometryStyleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'style'), pyxb.binding.datatypes.string, scope=GeometryStyleType, documentation=u'Deprecated in GML version 3.1.0. Use symbol with inline content instead.'))

GeometryStyleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'symbol'), SymbolType, scope=GeometryStyleType, documentation=u'The symbol property. Extends the gml:AssociationType to allow for remote referencing of symbols.'))
GeometryStyleType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeometryStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(GeometryStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeometryStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
GeometryStyleType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeometryStyleType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
GeometryStyleType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeometryStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'spatialResolution')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeometryStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'styleVariation')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(GeometryStyleType._UseForTag(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'animate')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(GeometryStyleType._UseForTag(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'animateMotion')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(GeometryStyleType._UseForTag(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'animateColor')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(GeometryStyleType._UseForTag(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'set')), min_occurs=0L, max_occurs=None)
    )
GeometryStyleType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeometryStyleType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeometryStyleType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
GeometryStyleType._GroupModel_6 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(GeometryStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'symbol')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeometryStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'style')), min_occurs=1, max_occurs=1)
    )
GeometryStyleType._GroupModel_5 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeometryStyleType._GroupModel_6, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeometryStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'labelStyle')), min_occurs=0L, max_occurs=1)
    )
GeometryStyleType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeometryStyleType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeometryStyleType._GroupModel_5, min_occurs=1, max_occurs=1)
    )
GeometryStyleType._ContentModel = pyxb.binding.content.ParticleModel(GeometryStyleType._GroupModel, min_occurs=1, max_occurs=1)



BaseUnitType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'unitsSystem'), ReferenceType, scope=BaseUnitType))
BaseUnitType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=1, max_occurs=None)
    )
BaseUnitType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'quantityType')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'catalogSymbol')), min_occurs=0L, max_occurs=1)
    )
BaseUnitType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(BaseUnitType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(BaseUnitType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
BaseUnitType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(BaseUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'unitsSystem')), min_occurs=1, max_occurs=1)
    )
BaseUnitType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(BaseUnitType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(BaseUnitType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
BaseUnitType._ContentModel = pyxb.binding.content.ParticleModel(BaseUnitType._GroupModel, min_occurs=1, max_occurs=1)



GeodeticDatumRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GeodeticDatum'), GeodeticDatumType, scope=GeodeticDatumRefType))
GeodeticDatumRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeodeticDatumRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'GeodeticDatum')), min_occurs=1, max_occurs=1)
    )
GeodeticDatumRefType._ContentModel = pyxb.binding.content.ParticleModel(GeodeticDatumRefType._GroupModel, min_occurs=0L, max_occurs=1)



TopologyStyleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'labelStyle'), LabelStylePropertyType, scope=TopologyStyleType, documentation=u''))

TopologyStyleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'symbol'), SymbolType, scope=TopologyStyleType, documentation=u'The symbol property. Extends the gml:AssociationType to allow for remote referencing of symbols.'))

TopologyStyleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'style'), pyxb.binding.datatypes.string, scope=TopologyStyleType, documentation=u'Deprecated in GML version 3.1.0. Use symbol with inline content instead.'))
TopologyStyleType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopologyStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TopologyStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TopologyStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
TopologyStyleType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopologyStyleType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
TopologyStyleType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopologyStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'spatialResolution')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TopologyStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'styleVariation')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TopologyStyleType._UseForTag(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'animate')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TopologyStyleType._UseForTag(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'animateMotion')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TopologyStyleType._UseForTag(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'animateColor')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TopologyStyleType._UseForTag(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'set')), min_occurs=0L, max_occurs=None)
    )
TopologyStyleType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopologyStyleType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TopologyStyleType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
TopologyStyleType._GroupModel_6 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(TopologyStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'symbol')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TopologyStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'style')), min_occurs=1, max_occurs=1)
    )
TopologyStyleType._GroupModel_5 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopologyStyleType._GroupModel_6, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TopologyStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'labelStyle')), min_occurs=0L, max_occurs=1)
    )
TopologyStyleType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopologyStyleType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TopologyStyleType._GroupModel_5, min_occurs=1, max_occurs=1)
    )
TopologyStyleType._ContentModel = pyxb.binding.content.ParticleModel(TopologyStyleType._GroupModel, min_occurs=1, max_occurs=1)



DomainSetType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Geometry'), AbstractGeometryType, abstract=pyxb.binding.datatypes.boolean(1), scope=DomainSetType, documentation=u'The "_Geometry" element is the abstract head of the substituition group for all geometry elements of GML 3. This \n\t\t\tincludes pre-defined and user-defined geometry elements. Any geometry element must be a direct or indirect extension/restriction \n\t\t\tof AbstractGeometryType and must be directly or indirectly in the substitution group of "_Geometry".'))

DomainSetType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_TimeObject'), AbstractTimeObjectType, abstract=pyxb.binding.datatypes.boolean(1), scope=DomainSetType, documentation=u'This abstract element acts as the head of the substitution group for temporal primitives and complexes.'))
DomainSetType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(DomainSetType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_Geometry')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DomainSetType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_TimeObject')), min_occurs=1, max_occurs=1)
    )
DomainSetType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DomainSetType._GroupModel_, min_occurs=1, max_occurs=1)
    )
DomainSetType._ContentModel = pyxb.binding.content.ParticleModel(DomainSetType._GroupModel, min_occurs=0L, max_occurs=1)



ConversionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesValue'), ParameterValueType, scope=ConversionType, documentation=u'Composition association to a parameter value used by this coordinate operation. '))

ConversionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesMethod'), OperationMethodRefType, scope=ConversionType, documentation=u'Association to the operation method used by this coordinate operation. '))
ConversionType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationName')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validArea')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_positionalAccuracy')), min_occurs=0L, max_occurs=None)
    )
ConversionType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesMethod')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ConversionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesValue')), min_occurs=0L, max_occurs=None)
    )
ConversionType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ConversionType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ConversionType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
ConversionType._ContentModel = pyxb.binding.content.ParticleModel(ConversionType._GroupModel, min_occurs=1, max_occurs=1)



ArcStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), PointPropertyType, scope=ArcStringType, documentation=u'This property element either references a point via the XLink-attributes or contains the point element. pointProperty \n\t\t\tis the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that \n\t\t\tis substitutable for Point.'))

ArcStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'posList'), DirectPositionListType, scope=ArcStringType, documentation=u''))

ArcStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), CoordinatesType, scope=ArcStringType, documentation=u'Deprecated with GML version 3.1.0.'))

ArcStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), PointPropertyType, scope=ArcStringType, documentation=u'Deprecated with GML version 3.1.0. Use "pointProperty" instead. Included for backwards compatibility with GML 3.0.0.'))

ArcStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, scope=ArcStringType, documentation=u''))
ArcStringType._GroupModel_2 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(ArcStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ArcStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ArcStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep')), min_occurs=1, max_occurs=1)
    )
ArcStringType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(ArcStringType._GroupModel_2, min_occurs=3L, max_occurs=None),
    pyxb.binding.content.ParticleModel(ArcStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ArcStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates')), min_occurs=1, max_occurs=1)
    )
ArcStringType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ArcStringType._GroupModel_, min_occurs=1, max_occurs=1)
    )
ArcStringType._ContentModel = pyxb.binding.content.ParticleModel(ArcStringType._GroupModel, min_occurs=1, max_occurs=1)



AbstractRingPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Ring'), AbstractRingType, abstract=pyxb.binding.datatypes.boolean(1), scope=AbstractRingPropertyType, documentation=u'The "_Ring" element is the abstract head of the substituition group for all closed boundaries of a surface patch.'))
AbstractRingPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractRingPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_Ring')), min_occurs=1, max_occurs=1)
    )
AbstractRingPropertyType._ContentModel = pyxb.binding.content.ParticleModel(AbstractRingPropertyType._GroupModel, min_occurs=1, max_occurs=1)



GridCoverageType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'gridDomain'), GridDomainType, scope=GridCoverageType))
GridCoverageType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
GridCoverageType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GridCoverageType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'gridDomain')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rangeSet')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coverageFunction')), min_occurs=0L, max_occurs=1)
    )
GridCoverageType._ContentModel = pyxb.binding.content.ParticleModel(GridCoverageType._GroupModel, min_occurs=1, max_occurs=1)



LineStringSegmentArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'LineStringSegment'), LineStringSegmentType, scope=LineStringSegmentArrayPropertyType))
LineStringSegmentArrayPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(LineStringSegmentArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'LineStringSegment')), min_occurs=0L, max_occurs=None)
    )
LineStringSegmentArrayPropertyType._ContentModel = pyxb.binding.content.ParticleModel(LineStringSegmentArrayPropertyType._GroupModel, min_occurs=1, max_occurs=1)



CartesianCSRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CartesianCS'), CartesianCSType, scope=CartesianCSRefType))
CartesianCSRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CartesianCSRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CartesianCS')), min_occurs=1, max_occurs=1)
    )
CartesianCSRefType._ContentModel = pyxb.binding.content.ParticleModel(CartesianCSRefType._GroupModel, min_occurs=0L, max_occurs=1)



AbstractFeatureCollectionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'featureMember'), FeaturePropertyType, scope=AbstractFeatureCollectionType))

AbstractFeatureCollectionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'featureMembers'), FeatureArrayPropertyType, scope=AbstractFeatureCollectionType))
AbstractFeatureCollectionType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
AbstractFeatureCollectionType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractFeatureCollectionType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
AbstractFeatureCollectionType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location')), min_occurs=0L, max_occurs=1)
    )
AbstractFeatureCollectionType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractFeatureCollectionType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractFeatureCollectionType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
AbstractFeatureCollectionType._GroupModel_5 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMember')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMembers')), min_occurs=0L, max_occurs=1)
    )
AbstractFeatureCollectionType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractFeatureCollectionType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractFeatureCollectionType._GroupModel_5, min_occurs=1, max_occurs=1)
    )
AbstractFeatureCollectionType._ContentModel = pyxb.binding.content.ParticleModel(AbstractFeatureCollectionType._GroupModel, min_occurs=1, max_occurs=1)


FeatureCollectionType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
FeatureCollectionType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(FeatureCollectionType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
FeatureCollectionType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location')), min_occurs=0L, max_occurs=1)
    )
FeatureCollectionType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(FeatureCollectionType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(FeatureCollectionType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
FeatureCollectionType._GroupModel_5 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMember')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(FeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMembers')), min_occurs=0L, max_occurs=1)
    )
FeatureCollectionType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(FeatureCollectionType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(FeatureCollectionType._GroupModel_5, min_occurs=1, max_occurs=1)
    )
FeatureCollectionType._ContentModel = pyxb.binding.content.ParticleModel(FeatureCollectionType._GroupModel, min_occurs=1, max_occurs=1)



MultiSurfacePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiSurface'), MultiSurfaceType, scope=MultiSurfacePropertyType))
MultiSurfacePropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiSurfacePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'MultiSurface')), min_occurs=1, max_occurs=1)
    )
MultiSurfacePropertyType._ContentModel = pyxb.binding.content.ParticleModel(MultiSurfacePropertyType._GroupModel, min_occurs=0L, max_occurs=1)



PrimeMeridianBaseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'meridianName'), CodeType, scope=PrimeMeridianBaseType, documentation=u'The name by which this prime meridian is identified. The meridianName most common value is Greenwich, and that value shall be used when the greenwichLongitude value is zero. '))
PrimeMeridianBaseType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PrimeMeridianBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(PrimeMeridianBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'meridianName')), min_occurs=1, max_occurs=1)
    )
PrimeMeridianBaseType._ContentModel = pyxb.binding.content.ParticleModel(PrimeMeridianBaseType._GroupModel, min_occurs=1, max_occurs=1)



PrimeMeridianType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'greenwichLongitude'), AngleChoiceType, scope=PrimeMeridianType, documentation=u'Longitude of the prime meridian measured from the Greenwich meridian, positive eastward. The greenwichLongitude most common value is zero, and that value shall be used when the meridianName value is Greenwich. '))

PrimeMeridianType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'remarks'), StringOrRefType, scope=PrimeMeridianType, documentation=u'Information about this object or code. Contains text or refers to external text.'))

PrimeMeridianType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'meridianID'), IdentifierType, scope=PrimeMeridianType, documentation=u'An identification of a prime meridian. '))
PrimeMeridianType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PrimeMeridianType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(PrimeMeridianType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'meridianName')), min_occurs=1, max_occurs=1)
    )
PrimeMeridianType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PrimeMeridianType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'meridianID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(PrimeMeridianType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(PrimeMeridianType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'greenwichLongitude')), min_occurs=1, max_occurs=1)
    )
PrimeMeridianType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PrimeMeridianType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(PrimeMeridianType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
PrimeMeridianType._ContentModel = pyxb.binding.content.ParticleModel(PrimeMeridianType._GroupModel, min_occurs=1, max_occurs=1)



GridDomainType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Grid'), GridType, scope=GridDomainType))
GridDomainType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GridDomainType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Grid')), min_occurs=1, max_occurs=1)
    )
GridDomainType._ContentModel = pyxb.binding.content.ParticleModel(GridDomainType._GroupModel, min_occurs=0L, max_occurs=1)



CurvePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Curve'), AbstractCurveType, abstract=pyxb.binding.datatypes.boolean(1), scope=CurvePropertyType, documentation=u'The "_Curve" element is the abstract head of the substituition group for all (continuous) curve elements.'))
CurvePropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CurvePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_Curve')), min_occurs=1, max_occurs=1)
    )
CurvePropertyType._ContentModel = pyxb.binding.content.ParticleModel(CurvePropertyType._GroupModel, min_occurs=0L, max_occurs=1)



PolyhedralSurfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'polygonPatches'), PolygonPatchArrayPropertyType, scope=PolyhedralSurfaceType, documentation=u'This property element contains a list of\n   polygon patches. The order of the patches is significant and \n   shall be preserved when processing the list.'))
PolyhedralSurfaceType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PolyhedralSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(PolyhedralSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(PolyhedralSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
PolyhedralSurfaceType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PolyhedralSurfaceType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(PolyhedralSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'polygonPatches')), min_occurs=1, max_occurs=1)
    )
PolyhedralSurfaceType._ContentModel = pyxb.binding.content.ParticleModel(PolyhedralSurfaceType._GroupModel, min_occurs=1, max_occurs=1)



SurfacePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Surface'), AbstractSurfaceType, abstract=pyxb.binding.datatypes.boolean(1), scope=SurfacePropertyType, documentation=u'The "_Surface" element is the abstract head of the substituition group for all (continuous) surface elements.'))
SurfacePropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(SurfacePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_Surface')), min_occurs=1, max_occurs=1)
    )
SurfacePropertyType._ContentModel = pyxb.binding.content.ParticleModel(SurfacePropertyType._GroupModel, min_occurs=0L, max_occurs=1)


BoundedFeatureType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(BoundedFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(BoundedFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(BoundedFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
BoundedFeatureType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(BoundedFeatureType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(BoundedFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(BoundedFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location')), min_occurs=0L, max_occurs=1)
    )
BoundedFeatureType._ContentModel = pyxb.binding.content.ParticleModel(BoundedFeatureType._GroupModel, min_occurs=1, max_occurs=1)



ClothoidType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'endParameter'), pyxb.binding.datatypes.double, scope=ClothoidType, documentation=u'The endParameter is the arc length\n       distance from the inflection point that will be the end\n       point for this curve segment. This shall be upper limit\n       used in the Fresnel integral and is the value of the\n       constructive parameter of this curve segment at its\n       start point. The startParameter can either be positive\n       or negative.'))

ClothoidType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'startParameter'), pyxb.binding.datatypes.double, scope=ClothoidType, documentation=u"The startParameter is the arc length\n       distance from the inflection point that will be the start\n       point for this curve segment. This shall be lower limit\n       used in the Fresnel integral and is the value of the\n       constructive parameter of this curve segment at its start\n       point. The startParameter can either be positive or\n       negative. \n       NOTE! If 0.0 (zero), lies between the startParameter and\n       the endParameter of the clothoid, then the curve goes\n       through the clothoid's inflection point, and the direction\n       of its radius of curvature, given by the second\n       derivative vector, changes sides with respect to the\n       tangent vector. The term length distance for the"))

ClothoidType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'refLocation'), CTD_ANON_2, scope=ClothoidType))

ClothoidType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'scaleFactor'), pyxb.binding.datatypes.decimal, scope=ClothoidType, documentation=u"The element gives the value for the\n       constant in the Fresnel's integrals."))
ClothoidType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ClothoidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'refLocation')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ClothoidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scaleFactor')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ClothoidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'startParameter')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ClothoidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'endParameter')), min_occurs=1, max_occurs=1)
    )
ClothoidType._ContentModel = pyxb.binding.content.ParticleModel(ClothoidType._GroupModel, min_occurs=1, max_occurs=1)


ArcType._GroupModel_2 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(ArcType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ArcType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ArcType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep')), min_occurs=1, max_occurs=1)
    )
ArcType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(ArcType._GroupModel_2, min_occurs=3L, max_occurs=3L),
    pyxb.binding.content.ParticleModel(ArcType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ArcType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates')), min_occurs=1, max_occurs=1)
    )
ArcType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ArcType._GroupModel_, min_occurs=1, max_occurs=1)
    )
ArcType._ContentModel = pyxb.binding.content.ParticleModel(ArcType._GroupModel, min_occurs=1, max_occurs=1)



RectifiedGridCoverageType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'rectifiedGridDomain'), RectifiedGridDomainType, scope=RectifiedGridCoverageType))
RectifiedGridCoverageType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
RectifiedGridCoverageType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(RectifiedGridCoverageType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rectifiedGridDomain')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rangeSet')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(RectifiedGridCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coverageFunction')), min_occurs=0L, max_occurs=1)
    )
RectifiedGridCoverageType._ContentModel = pyxb.binding.content.ParticleModel(RectifiedGridCoverageType._GroupModel, min_occurs=1, max_occurs=1)



VerticalCSRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'VerticalCS'), VerticalCSType, scope=VerticalCSRefType))
VerticalCSRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(VerticalCSRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'VerticalCS')), min_occurs=1, max_occurs=1)
    )
VerticalCSRefType._ContentModel = pyxb.binding.content.ParticleModel(VerticalCSRefType._GroupModel, min_occurs=0L, max_occurs=1)



DictionaryEntryType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Definition'), DefinitionType, scope=DictionaryEntryType))
DictionaryEntryType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DictionaryEntryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Definition')), min_occurs=1, max_occurs=1)
    )
DictionaryEntryType._ContentModel = pyxb.binding.content.ParticleModel(DictionaryEntryType._GroupModel, min_occurs=0L, max_occurs=1)



TemporalCSRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TemporalCS'), TemporalCSType, scope=TemporalCSRefType))
TemporalCSRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TemporalCSRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TemporalCS')), min_occurs=1, max_occurs=1)
    )
TemporalCSRefType._ContentModel = pyxb.binding.content.ParticleModel(TemporalCSRefType._GroupModel, min_occurs=0L, max_occurs=1)



VerticalDatumRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'VerticalDatum'), VerticalDatumType, scope=VerticalDatumRefType))
VerticalDatumRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(VerticalDatumRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'VerticalDatum')), min_occurs=1, max_occurs=1)
    )
VerticalDatumRefType._ContentModel = pyxb.binding.content.ParticleModel(VerticalDatumRefType._GroupModel, min_occurs=0L, max_occurs=1)



TopoComplexType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'superComplex'), TopoComplexMemberType, scope=TopoComplexType, documentation=u''))

TopoComplexType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'topoPrimitiveMembers'), TopoPrimitiveArrayAssociationType, scope=TopoComplexType, documentation=u''))

TopoComplexType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'subComplex'), TopoComplexMemberType, scope=TopoComplexType, documentation=u''))

TopoComplexType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximalComplex'), TopoComplexMemberType, scope=TopoComplexType, documentation=u'Need schamatron test here that isMaximal attribute value is true'))

TopoComplexType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'topoPrimitiveMember'), TopoPrimitiveMemberType, scope=TopoComplexType, documentation=u''))
TopoComplexType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TopoComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TopoComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
TopoComplexType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoComplexType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
TopoComplexType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximalComplex')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TopoComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'superComplex')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TopoComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'subComplex')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TopoComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'topoPrimitiveMember')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TopoComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'topoPrimitiveMembers')), min_occurs=0L, max_occurs=1)
    )
TopoComplexType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoComplexType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TopoComplexType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
TopoComplexType._ContentModel = pyxb.binding.content.ParticleModel(TopoComplexType._GroupModel, min_occurs=1, max_occurs=1)



AbstractContinuousCoverageType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coverageFunction'), CoverageFunctionType, scope=AbstractContinuousCoverageType))
AbstractContinuousCoverageType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
AbstractContinuousCoverageType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractContinuousCoverageType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
AbstractContinuousCoverageType._GroupModel_5 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location')), min_occurs=0L, max_occurs=1)
    )
AbstractContinuousCoverageType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractContinuousCoverageType._GroupModel_3, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractContinuousCoverageType._GroupModel_5, min_occurs=1, max_occurs=1)
    )
AbstractContinuousCoverageType._GroupModel_6 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainSet')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rangeSet')), min_occurs=1, max_occurs=1)
    )
AbstractContinuousCoverageType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractContinuousCoverageType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractContinuousCoverageType._GroupModel_6, min_occurs=1, max_occurs=1)
    )
AbstractContinuousCoverageType._GroupModel_7 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractContinuousCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coverageFunction')), min_occurs=0L, max_occurs=1)
    )
AbstractContinuousCoverageType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractContinuousCoverageType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractContinuousCoverageType._GroupModel_7, min_occurs=1, max_occurs=1)
    )
AbstractContinuousCoverageType._ContentModel = pyxb.binding.content.ParticleModel(AbstractContinuousCoverageType._GroupModel, min_occurs=1, max_occurs=1)



AbstractGeneralDerivedCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'baseCRS'), CoordinateReferenceSystemRefType, scope=AbstractGeneralDerivedCRSType, documentation=u'Association to the coordinate reference system used by this derived CRS. '))

AbstractGeneralDerivedCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'definedByConversion'), GeneralConversionRefType, scope=AbstractGeneralDerivedCRSType, documentation=u'Association to the coordinate conversion used to define this derived CRS. '))
AbstractGeneralDerivedCRSType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractGeneralDerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractGeneralDerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'srsName')), min_occurs=1, max_occurs=1)
    )
AbstractGeneralDerivedCRSType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractGeneralDerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'srsID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractGeneralDerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractGeneralDerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validArea')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractGeneralDerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope')), min_occurs=0L, max_occurs=1)
    )
AbstractGeneralDerivedCRSType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractGeneralDerivedCRSType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractGeneralDerivedCRSType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
AbstractGeneralDerivedCRSType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractGeneralDerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'baseCRS')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractGeneralDerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'definedByConversion')), min_occurs=1, max_occurs=1)
    )
AbstractGeneralDerivedCRSType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractGeneralDerivedCRSType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractGeneralDerivedCRSType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
AbstractGeneralDerivedCRSType._ContentModel = pyxb.binding.content.ParticleModel(AbstractGeneralDerivedCRSType._GroupModel, min_occurs=1, max_occurs=1)



ProjectedCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesCartesianCS'), CartesianCSRefType, scope=ProjectedCRSType, documentation=u'Association to the Cartesian coordinate system used by this CRS. '))
ProjectedCRSType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'srsName')), min_occurs=1, max_occurs=1)
    )
ProjectedCRSType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'srsID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validArea')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope')), min_occurs=0L, max_occurs=1)
    )
ProjectedCRSType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ProjectedCRSType._GroupModel_3, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ProjectedCRSType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
ProjectedCRSType._GroupModel_5 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'baseCRS')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'definedByConversion')), min_occurs=1, max_occurs=1)
    )
ProjectedCRSType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ProjectedCRSType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ProjectedCRSType._GroupModel_5, min_occurs=1, max_occurs=1)
    )
ProjectedCRSType._GroupModel_6 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ProjectedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesCartesianCS')), min_occurs=1, max_occurs=1)
    )
ProjectedCRSType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ProjectedCRSType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ProjectedCRSType._GroupModel_6, min_occurs=1, max_occurs=1)
    )
ProjectedCRSType._ContentModel = pyxb.binding.content.ParticleModel(ProjectedCRSType._GroupModel, min_occurs=1, max_occurs=1)


AbstractTimeObjectType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTimeObjectType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractTimeObjectType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractTimeObjectType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
AbstractTimeObjectType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTimeObjectType._GroupModel_, min_occurs=1, max_occurs=1)
    )
AbstractTimeObjectType._ContentModel = pyxb.binding.content.ParticleModel(AbstractTimeObjectType._GroupModel, min_occurs=1, max_occurs=1)


AbstractTimeComplexType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTimeComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractTimeComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractTimeComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
AbstractTimeComplexType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTimeComplexType._GroupModel_, min_occurs=1, max_occurs=1)
    )
AbstractTimeComplexType._ContentModel = pyxb.binding.content.ParticleModel(AbstractTimeComplexType._GroupModel, min_occurs=1, max_occurs=1)



TimeTopologyComplexType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'primitive'), TimeTopologyPrimitivePropertyType, scope=TimeTopologyComplexType))
TimeTopologyComplexType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeTopologyComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TimeTopologyComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeTopologyComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
TimeTopologyComplexType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeTopologyComplexType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
TimeTopologyComplexType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeTopologyComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'primitive')), min_occurs=1, max_occurs=None)
    )
TimeTopologyComplexType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeTopologyComplexType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeTopologyComplexType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
TimeTopologyComplexType._ContentModel = pyxb.binding.content.ParticleModel(TimeTopologyComplexType._GroupModel, min_occurs=1, max_occurs=1)



DerivedCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesCS'), CoordinateSystemRefType, scope=DerivedCRSType, documentation=u'Association to the coordinate system used by this CRS. '))

DerivedCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'derivedCRSType'), DerivedCRSTypeType, scope=DerivedCRSType))
DerivedCRSType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'srsName')), min_occurs=1, max_occurs=1)
    )
DerivedCRSType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'srsID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validArea')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope')), min_occurs=0L, max_occurs=1)
    )
DerivedCRSType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DerivedCRSType._GroupModel_3, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DerivedCRSType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
DerivedCRSType._GroupModel_5 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'baseCRS')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'definedByConversion')), min_occurs=1, max_occurs=1)
    )
DerivedCRSType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DerivedCRSType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DerivedCRSType._GroupModel_5, min_occurs=1, max_occurs=1)
    )
DerivedCRSType._GroupModel_6 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'derivedCRSType')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DerivedCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesCS')), min_occurs=1, max_occurs=1)
    )
DerivedCRSType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DerivedCRSType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DerivedCRSType._GroupModel_6, min_occurs=1, max_occurs=1)
    )
DerivedCRSType._ContentModel = pyxb.binding.content.ParticleModel(DerivedCRSType._GroupModel, min_occurs=1, max_occurs=1)



EdgeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'curveProperty'), CurvePropertyType, scope=EdgeType, documentation=u'This property element either references a curve via the XLink-attributes or contains the curve element. curveProperty is the \n\t\t\tpredefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that is \n\t\t\tsubstitutable for _Curve.'))

EdgeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedFace'), DirectedFacePropertyType, scope=EdgeType, documentation=u''))

EdgeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedNode'), DirectedNodePropertyType, scope=EdgeType, documentation=u''))
EdgeType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
EdgeType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EdgeType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
EdgeType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container')), min_occurs=0L, max_occurs=1)
    )
EdgeType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EdgeType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(EdgeType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
EdgeType._GroupModel_5 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedNode')), min_occurs=2L, max_occurs=2L),
    pyxb.binding.content.ParticleModel(EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedFace')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(EdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'curveProperty')), min_occurs=0L, max_occurs=1)
    )
EdgeType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EdgeType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(EdgeType._GroupModel_5, min_occurs=1, max_occurs=1)
    )
EdgeType._ContentModel = pyxb.binding.content.ParticleModel(EdgeType._GroupModel, min_occurs=1, max_occurs=1)



ObliqueCartesianCSRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ObliqueCartesianCS'), ObliqueCartesianCSType, scope=ObliqueCartesianCSRefType))
ObliqueCartesianCSRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ObliqueCartesianCSRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'ObliqueCartesianCS')), min_occurs=1, max_occurs=1)
    )
ObliqueCartesianCSRefType._ContentModel = pyxb.binding.content.ParticleModel(ObliqueCartesianCSRefType._GroupModel, min_occurs=0L, max_occurs=1)


VerticalCSType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(VerticalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(VerticalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'csName')), min_occurs=1, max_occurs=1)
    )
VerticalCSType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(VerticalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'csID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(VerticalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(VerticalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesAxis')), min_occurs=1, max_occurs=None)
    )
VerticalCSType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(VerticalCSType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(VerticalCSType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
VerticalCSType._ContentModel = pyxb.binding.content.ParticleModel(VerticalCSType._GroupModel, min_occurs=1, max_occurs=1)



TimeInstantPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeInstant'), TimeInstantType, scope=TimeInstantPropertyType))
TimeInstantPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeInstantPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TimeInstant')), min_occurs=1, max_occurs=1)
    )
TimeInstantPropertyType._ContentModel = pyxb.binding.content.ParticleModel(TimeInstantPropertyType._GroupModel, min_occurs=0L, max_occurs=1)


CylindricalCSType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CylindricalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(CylindricalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'csName')), min_occurs=1, max_occurs=1)
    )
CylindricalCSType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CylindricalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'csID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(CylindricalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(CylindricalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesAxis')), min_occurs=1, max_occurs=None)
    )
CylindricalCSType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CylindricalCSType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CylindricalCSType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
CylindricalCSType._ContentModel = pyxb.binding.content.ParticleModel(CylindricalCSType._GroupModel, min_occurs=1, max_occurs=1)



MultiSurfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'surfaceMember'), SurfacePropertyType, scope=MultiSurfaceType, documentation=u'This property element either references a surface via the XLink-attributes or contains the surface element. A surface element is any element which is substitutable for "_Surface".'))

MultiSurfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'surfaceMembers'), SurfaceArrayPropertyType, scope=MultiSurfaceType, documentation=u'This property element contains a list of surfaces. The order of the elements is significant and shall be preserved when processing the array.'))
MultiSurfaceType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(MultiSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
MultiSurfaceType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiSurfaceType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
MultiSurfaceType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'surfaceMember')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(MultiSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'surfaceMembers')), min_occurs=0L, max_occurs=1)
    )
MultiSurfaceType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiSurfaceType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiSurfaceType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
MultiSurfaceType._ContentModel = pyxb.binding.content.ParticleModel(MultiSurfaceType._GroupModel, min_occurs=1, max_occurs=1)



DirectedEdgePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Edge'), EdgeType, scope=DirectedEdgePropertyType))
DirectedEdgePropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DirectedEdgePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Edge')), min_occurs=1, max_occurs=1)
    )
DirectedEdgePropertyType._ContentModel = pyxb.binding.content.ParticleModel(DirectedEdgePropertyType._GroupModel, min_occurs=0L, max_occurs=1)



HistoryPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_TimeSlice'), AbstractTimeSliceType, abstract=pyxb.binding.datatypes.boolean(1), scope=HistoryPropertyType))
HistoryPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(HistoryPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_TimeSlice')), min_occurs=1, max_occurs=1)
    )
HistoryPropertyType._ContentModel = pyxb.binding.content.ParticleModel(HistoryPropertyType._GroupModel, min_occurs=1, max_occurs=None)



MultiCurveDomainType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiCurve'), MultiCurveType, scope=MultiCurveDomainType))
MultiCurveDomainType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiCurveDomainType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'MultiCurve')), min_occurs=1, max_occurs=1)
    )
MultiCurveDomainType._ContentModel = pyxb.binding.content.ParticleModel(MultiCurveDomainType._GroupModel, min_occurs=0L, max_occurs=1)



ConversionRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Conversion'), ConversionType, scope=ConversionRefType))
ConversionRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ConversionRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Conversion')), min_occurs=1, max_occurs=1)
    )
ConversionRefType._ContentModel = pyxb.binding.content.ParticleModel(ConversionRefType._GroupModel, min_occurs=0L, max_occurs=1)



MultiPointType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointMembers'), PointArrayPropertyType, scope=MultiPointType, documentation=u'This property element contains a list of points. The order of the elements is significant and shall be preserved when processing the array.'))

MultiPointType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointMember'), PointPropertyType, scope=MultiPointType, documentation=u'This property element either references a Point via the XLink-attributes or contains the Point element.'))
MultiPointType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(MultiPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
MultiPointType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiPointType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
MultiPointType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointMember')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(MultiPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointMembers')), min_occurs=0L, max_occurs=1)
    )
MultiPointType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiPointType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiPointType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
MultiPointType._ContentModel = pyxb.binding.content.ParticleModel(MultiPointType._GroupModel, min_occurs=1, max_occurs=1)


MetaDataPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=pyxb.binding.content.Wildcard.NC_any), min_occurs=1, max_occurs=1)
    )
MetaDataPropertyType._ContentModel = pyxb.binding.content.ParticleModel(MetaDataPropertyType._GroupModel, min_occurs=0L, max_occurs=1)



PointType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), CoordinatesType, scope=PointType, documentation=u'Deprecated with GML version 3.1.0.'))

PointType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coord'), CoordType, scope=PointType, documentation=u'Deprecated with GML 3.0 and included for backwards compatibility with GML 2. Use the "pos" element instead.'))

PointType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, scope=PointType, documentation=u''))
PointType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(PointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(PointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
PointType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PointType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
PointType._GroupModel_4 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(PointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(PointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(PointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coord')), min_occurs=1, max_occurs=1)
    )
PointType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PointType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
PointType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PointType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(PointType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
PointType._ContentModel = pyxb.binding.content.ParticleModel(PointType._GroupModel, min_occurs=1, max_occurs=1)



GeodesicStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'posList'), DirectPositionListType, scope=GeodesicStringType, documentation=u''))

GeodesicStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), PointPropertyType, scope=GeodesicStringType, documentation=u'This property element either references a point via the XLink-attributes or contains the point element. pointProperty \n\t\t\tis the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that \n\t\t\tis substitutable for Point.'))

GeodesicStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, scope=GeodesicStringType, documentation=u''))
GeodesicStringType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(GeodesicStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeodesicStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty')), min_occurs=1, max_occurs=1)
    )
GeodesicStringType._GroupModel = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(GeodesicStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeodesicStringType._GroupModel_, min_occurs=2L, max_occurs=None)
    )
GeodesicStringType._ContentModel = pyxb.binding.content.ParticleModel(GeodesicStringType._GroupModel, min_occurs=1, max_occurs=1)



AffinePlacementType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'outDimension'), pyxb.binding.datatypes.positiveInteger, scope=AffinePlacementType, documentation=u'Dimension of the co-ordinate space.'))

AffinePlacementType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'location'), DirectPositionType, scope=AffinePlacementType, documentation=u'The location property gives \n     the target of the parameter space origin. This is the vector  \n    (x0, y0, z0) in the formulae above.'))

AffinePlacementType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'inDimension'), pyxb.binding.datatypes.positiveInteger, scope=AffinePlacementType, documentation=u'Dimension of the constructive parameter \n     space.'))

AffinePlacementType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'refDirection'), VectorType, scope=AffinePlacementType, documentation=u'The attribute refDirection gives the    \ntarget directions for the co-ordinate basis vectors of the  \nparameter space. These are the columns of the matrix in the \nformulae given above. The number of directions given shall be \ninDimension. The dimension of the directions shall be \noutDimension.'))
AffinePlacementType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AffinePlacementType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AffinePlacementType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'refDirection')), min_occurs=1, max_occurs=None),
    pyxb.binding.content.ParticleModel(AffinePlacementType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'inDimension')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AffinePlacementType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'outDimension')), min_occurs=1, max_occurs=1)
    )
AffinePlacementType._ContentModel = pyxb.binding.content.ParticleModel(AffinePlacementType._GroupModel, min_occurs=1, max_occurs=1)


AbstractSolidType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
AbstractSolidType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractSolidType._GroupModel_, min_occurs=1, max_occurs=1)
    )
AbstractSolidType._ContentModel = pyxb.binding.content.ParticleModel(AbstractSolidType._GroupModel, min_occurs=1, max_occurs=1)



SolidType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'interior'), SurfacePropertyType, scope=SolidType, documentation=u'Boundaries of solids are similar to surface boundaries.'))

SolidType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'exterior'), SurfacePropertyType, scope=SolidType, documentation=u'Boundaries of solids are similar to surface boundaries. In normal 3-dimensional Euclidean space, one (composite) surface is distinguished as the exterior. In the more general case, this is not always possible.'))
SolidType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(SolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(SolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(SolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
SolidType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(SolidType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
SolidType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(SolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'exterior')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(SolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'interior')), min_occurs=0L, max_occurs=None)
    )
SolidType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(SolidType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(SolidType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
SolidType._ContentModel = pyxb.binding.content.ParticleModel(SolidType._GroupModel, min_occurs=1, max_occurs=1)



CoordType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Z'), pyxb.binding.datatypes.decimal, scope=CoordType))

CoordType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'X'), pyxb.binding.datatypes.decimal, scope=CoordType))

CoordType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Y'), pyxb.binding.datatypes.decimal, scope=CoordType))
CoordType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CoordType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'X')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CoordType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Y')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(CoordType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Z')), min_occurs=0L, max_occurs=1)
    )
CoordType._ContentModel = pyxb.binding.content.ParticleModel(CoordType._GroupModel, min_occurs=1, max_occurs=1)


CoordinateSystemAxisBaseType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CoordinateSystemAxisBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(CoordinateSystemAxisBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=1, max_occurs=1)
    )
CoordinateSystemAxisBaseType._ContentModel = pyxb.binding.content.ParticleModel(CoordinateSystemAxisBaseType._GroupModel, min_occurs=1, max_occurs=1)



CoordinateSystemAxisType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'axisID'), IdentifierType, scope=CoordinateSystemAxisType, documentation=u'An identification of a coordinate system axis. '))

CoordinateSystemAxisType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'axisDirection'), CodeType, scope=CoordinateSystemAxisType, documentation=u'Direction of this coordinate system axis (or in the case of Cartesian projected coordinates, the direction of this coordinate system axis at the origin). Examples: north or south, east or west, up or down. Within any set of coordinate system axes, only one of each pair of terms can be used. For earth-fixed CRSs, this direction is often approximate and intended to provide a human interpretable meaning to the axis. When a geodetic datum is used, the precise directions of the axes may therefore vary slightly from this approximate direction. Note that an EngineeringCRS can include specific descriptions of the directions of its coordinate system axes. For example, the path of a linear CRS axis can be referenced in another document, such as referencing a GML feature that references or includes a curve geometry. The codeSpace attribute can reference a source of more information on a set of standardized directions, or on this direction. '))

CoordinateSystemAxisType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'axisAbbrev'), CodeType, scope=CoordinateSystemAxisType, documentation=u'The abbreviation used for this coordinate system axis. This abbreviation can be used to identify the ordinates in a coordinate tuple. Examples are X and Y. The codeSpace attribute can reference a source of more information on a set of standardized abbreviations, or on this abbreviation. '))

CoordinateSystemAxisType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'remarks'), StringOrRefType, scope=CoordinateSystemAxisType, documentation=u'Information about this object or code. Contains text or refers to external text.'))
CoordinateSystemAxisType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CoordinateSystemAxisType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(CoordinateSystemAxisType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=1, max_occurs=1)
    )
CoordinateSystemAxisType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CoordinateSystemAxisType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axisID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(CoordinateSystemAxisType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(CoordinateSystemAxisType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axisAbbrev')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CoordinateSystemAxisType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axisDirection')), min_occurs=1, max_occurs=1)
    )
CoordinateSystemAxisType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CoordinateSystemAxisType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CoordinateSystemAxisType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
CoordinateSystemAxisType._ContentModel = pyxb.binding.content.ParticleModel(CoordinateSystemAxisType._GroupModel, min_occurs=1, max_occurs=1)



AbstractTimePrimitiveType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'), RelatedTimeType, scope=AbstractTimePrimitiveType))
AbstractTimePrimitiveType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTimePrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractTimePrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractTimePrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
AbstractTimePrimitiveType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTimePrimitiveType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
AbstractTimePrimitiveType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTimePrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime')), min_occurs=0L, max_occurs=None)
    )
AbstractTimePrimitiveType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTimePrimitiveType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractTimePrimitiveType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
AbstractTimePrimitiveType._ContentModel = pyxb.binding.content.ParticleModel(AbstractTimePrimitiveType._GroupModel, min_occurs=1, max_occurs=1)


AbstractTimeGeometricPrimitiveType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTimeGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractTimeGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractTimeGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
AbstractTimeGeometricPrimitiveType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTimeGeometricPrimitiveType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
AbstractTimeGeometricPrimitiveType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTimeGeometricPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime')), min_occurs=0L, max_occurs=None)
    )
AbstractTimeGeometricPrimitiveType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTimeGeometricPrimitiveType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractTimeGeometricPrimitiveType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
AbstractTimeGeometricPrimitiveType._ContentModel = pyxb.binding.content.ParticleModel(AbstractTimeGeometricPrimitiveType._GroupModel, min_occurs=1, max_occurs=1)



TimePeriodType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'timeInterval'), TimeIntervalLengthType, scope=TimePeriodType, documentation=u'This element is a valid subtype of TimeDurationType \n\t\t\taccording to section 3.14.6, rule 2.2.4 in XML Schema, Part 1.'))

TimePeriodType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'end'), TimeInstantPropertyType, scope=TimePeriodType))

TimePeriodType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'endPosition'), TimePositionType, scope=TimePeriodType))

TimePeriodType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'beginPosition'), TimePositionType, scope=TimePeriodType))

TimePeriodType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'begin'), TimeInstantPropertyType, scope=TimePeriodType))

TimePeriodType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'duration'), pyxb.binding.datatypes.duration, scope=TimePeriodType, documentation=u'This element is an instance of the primitive xsd:duration simple type to \n      enable use of the ISO 8601 syntax for temporal length (e.g. P5DT4H30M). \n      It is a valid subtype of TimeDurationType according to section 3.14.6, \n      rule 2.2.4 in XML Schema, Part 1.'))
TimePeriodType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
TimePeriodType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimePeriodType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
TimePeriodType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime')), min_occurs=0L, max_occurs=None)
    )
TimePeriodType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimePeriodType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimePeriodType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
TimePeriodType._GroupModel_6 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'beginPosition')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'begin')), min_occurs=1, max_occurs=1)
    )
TimePeriodType._GroupModel_7 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'endPosition')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'end')), min_occurs=1, max_occurs=1)
    )
TimePeriodType._GroupModel_8 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'duration')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimePeriodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'timeInterval')), min_occurs=1, max_occurs=1)
    )
TimePeriodType._GroupModel_5 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimePeriodType._GroupModel_6, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimePeriodType._GroupModel_7, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimePeriodType._GroupModel_8, min_occurs=0L, max_occurs=1)
    )
TimePeriodType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimePeriodType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimePeriodType._GroupModel_5, min_occurs=1, max_occurs=1)
    )
TimePeriodType._ContentModel = pyxb.binding.content.ParticleModel(TimePeriodType._GroupModel, min_occurs=1, max_occurs=1)



TimePeriodPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimePeriod'), TimePeriodType, scope=TimePeriodPropertyType))
TimePeriodPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimePeriodPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TimePeriod')), min_occurs=1, max_occurs=1)
    )
TimePeriodPropertyType._ContentModel = pyxb.binding.content.ParticleModel(TimePeriodPropertyType._GroupModel, min_occurs=0L, max_occurs=1)



ProjectedCRSRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ProjectedCRS'), ProjectedCRSType, scope=ProjectedCRSRefType))
ProjectedCRSRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ProjectedCRSRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'ProjectedCRS')), min_occurs=1, max_occurs=1)
    )
ProjectedCRSRefType._ContentModel = pyxb.binding.content.ParticleModel(ProjectedCRSRefType._GroupModel, min_occurs=0L, max_occurs=1)



OperationParameterGroupBaseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'groupName'), CodeType, scope=OperationParameterGroupBaseType, documentation=u'The name by which this operation parameter group is identified. '))
OperationParameterGroupBaseType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(OperationParameterGroupBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(OperationParameterGroupBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'groupName')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(OperationParameterGroupBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimumOccurs')), min_occurs=0L, max_occurs=1)
    )
OperationParameterGroupBaseType._ContentModel = pyxb.binding.content.ParticleModel(OperationParameterGroupBaseType._GroupModel, min_occurs=1, max_occurs=1)



OperationParameterGroupType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximumOccurs'), pyxb.binding.datatypes.positiveInteger, scope=OperationParameterGroupType, documentation=u'The maximum number of times that values for this parameter group can be included. If this attribute is omitted, the maximum number is one. '))

OperationParameterGroupType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'groupID'), IdentifierType, scope=OperationParameterGroupType, documentation=u'An identification of an operation parameter group. '))

OperationParameterGroupType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'includesParameter'), AbstractGeneralOperationParameterRefType, scope=OperationParameterGroupType, documentation=u'Association to an operation parameter that is a member of a group. '))

OperationParameterGroupType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'remarks'), StringOrRefType, scope=OperationParameterGroupType, documentation=u'Information about this object or code. Contains text or refers to external text.'))
OperationParameterGroupType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(OperationParameterGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(OperationParameterGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'groupName')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(OperationParameterGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimumOccurs')), min_occurs=0L, max_occurs=1)
    )
OperationParameterGroupType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(OperationParameterGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'groupID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(OperationParameterGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(OperationParameterGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximumOccurs')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(OperationParameterGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'includesParameter')), min_occurs=2L, max_occurs=None)
    )
OperationParameterGroupType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(OperationParameterGroupType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(OperationParameterGroupType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
OperationParameterGroupType._ContentModel = pyxb.binding.content.ParticleModel(OperationParameterGroupType._GroupModel, min_occurs=1, max_occurs=1)



PointArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Point'), PointType, scope=PointArrayPropertyType))
PointArrayPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PointArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Point')), min_occurs=0L, max_occurs=None)
    )
PointArrayPropertyType._ContentModel = pyxb.binding.content.ParticleModel(PointArrayPropertyType._GroupModel, min_occurs=1, max_occurs=1)


EllipsoidalCSType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EllipsoidalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(EllipsoidalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'csName')), min_occurs=1, max_occurs=1)
    )
EllipsoidalCSType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EllipsoidalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'csID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(EllipsoidalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(EllipsoidalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesAxis')), min_occurs=1, max_occurs=None)
    )
EllipsoidalCSType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EllipsoidalCSType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(EllipsoidalCSType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
EllipsoidalCSType._ContentModel = pyxb.binding.content.ParticleModel(EllipsoidalCSType._GroupModel, min_occurs=1, max_occurs=1)



SphericalCSRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'SphericalCS'), SphericalCSType, scope=SphericalCSRefType))
SphericalCSRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(SphericalCSRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'SphericalCS')), min_occurs=1, max_occurs=1)
    )
SphericalCSRefType._ContentModel = pyxb.binding.content.ParticleModel(SphericalCSRefType._GroupModel, min_occurs=0L, max_occurs=1)



GeographicCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesEllipsoidalCS'), EllipsoidalCSRefType, scope=GeographicCRSType, documentation=u'Association to the ellipsoidal coordinate system used by this CRS. '))

GeographicCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesGeodeticDatum'), GeodeticDatumRefType, scope=GeographicCRSType, documentation=u'Association to the geodetic datum used by this CRS. '))
GeographicCRSType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeographicCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(GeographicCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'srsName')), min_occurs=1, max_occurs=1)
    )
GeographicCRSType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeographicCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'srsID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(GeographicCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeographicCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validArea')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeographicCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope')), min_occurs=0L, max_occurs=1)
    )
GeographicCRSType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeographicCRSType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeographicCRSType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
GeographicCRSType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeographicCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesEllipsoidalCS')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeographicCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesGeodeticDatum')), min_occurs=1, max_occurs=1)
    )
GeographicCRSType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeographicCRSType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeographicCRSType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
GeographicCRSType._ContentModel = pyxb.binding.content.ParticleModel(GeographicCRSType._GroupModel, min_occurs=1, max_occurs=1)



TimeTopologyComplexPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeTopologyComplex'), TimeTopologyComplexType, scope=TimeTopologyComplexPropertyType, documentation=u'This element represents temporal topology complex. It shall be the connected acyclic directed graph composed of time nodes and time edges.'))
TimeTopologyComplexPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeTopologyComplexPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TimeTopologyComplex')), min_occurs=1, max_occurs=1)
    )
TimeTopologyComplexPropertyType._ContentModel = pyxb.binding.content.ParticleModel(TimeTopologyComplexPropertyType._GroupModel, min_occurs=0L, max_occurs=1)


AbstractStyleType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
AbstractStyleType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractStyleType._GroupModel_, min_occurs=1, max_occurs=1)
    )
AbstractStyleType._ContentModel = pyxb.binding.content.ParticleModel(AbstractStyleType._GroupModel, min_occurs=1, max_occurs=1)



TimeClockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'referenceTime'), pyxb.binding.datatypes.time, scope=TimeClockType, documentation=u'time of day associated with the reference event expressed as \n              a time of day in the given clock. The reference time is usually the origin of the clock scale.'))

TimeClockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'utcReference'), pyxb.binding.datatypes.time, scope=TimeClockType, documentation=u'24 hour local or UTC time that corresponds to the reference time.'))

TimeClockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'referenceEvent'), StringOrRefType, scope=TimeClockType, documentation=u'Name or description of an event, such as solar noon or sunrise, \n              which fixes the position of the base scale of the clock.'))

TimeClockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'dateBasis'), TimeCalendarPropertyType, scope=TimeClockType))
TimeClockType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeClockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TimeClockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeClockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=1, max_occurs=None)
    )
TimeClockType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeClockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity')), min_occurs=0L, max_occurs=1)
    )
TimeClockType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeClockType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeClockType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
TimeClockType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeClockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'referenceEvent')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeClockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'referenceTime')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeClockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'utcReference')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeClockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dateBasis')), min_occurs=0L, max_occurs=None)
    )
TimeClockType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeClockType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeClockType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
TimeClockType._ContentModel = pyxb.binding.content.ParticleModel(TimeClockType._GroupModel, min_occurs=1, max_occurs=1)



AssociationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Object'), pyxb.binding.datatypes.anyType, abstract=pyxb.binding.datatypes.boolean(1), scope=AssociationType, documentation=u'This abstract element is the head of a substitutionGroup hierararchy which may contain either simpleContent or complexContent elements.  It is used to assert the model position of "class" elements declared in other GML schemas.'))
AssociationType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AssociationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_Object')), min_occurs=1, max_occurs=1)
    )
AssociationType._ContentModel = pyxb.binding.content.ParticleModel(AssociationType._GroupModel, min_occurs=0L, max_occurs=1)



IndirectEntryType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DefinitionProxy'), DefinitionProxyType, scope=IndirectEntryType))
IndirectEntryType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(IndirectEntryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'DefinitionProxy')), min_occurs=1, max_occurs=1)
    )
IndirectEntryType._ContentModel = pyxb.binding.content.ParticleModel(IndirectEntryType._GroupModel, min_occurs=1, max_occurs=1)



CompositeValueType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'valueComponents'), ValueArrayPropertyType, scope=CompositeValueType, documentation=u'Element which refers to, or contains, a set of homogeneously typed Values.'))

CompositeValueType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'valueComponent'), ValuePropertyType, scope=CompositeValueType, documentation=u'Element which refers to, or contains, a Value.  This version is used in CompositeValues.'))
CompositeValueType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CompositeValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(CompositeValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(CompositeValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
CompositeValueType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CompositeValueType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
CompositeValueType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CompositeValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueComponent')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(CompositeValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueComponents')), min_occurs=0L, max_occurs=1)
    )
CompositeValueType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CompositeValueType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CompositeValueType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
CompositeValueType._ContentModel = pyxb.binding.content.ParticleModel(CompositeValueType._GroupModel, min_occurs=1, max_occurs=1)



OperationParameterRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'OperationParameter'), OperationParameterType, scope=OperationParameterRefType))
OperationParameterRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(OperationParameterRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'OperationParameter')), min_occurs=1, max_occurs=1)
    )
OperationParameterRefType._ContentModel = pyxb.binding.content.ParticleModel(OperationParameterRefType._GroupModel, min_occurs=0L, max_occurs=1)



GraphStylePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GraphStyle'), GraphStyleType, scope=GraphStylePropertyType, documentation=u'The style descriptor for a graph consisting of a number of features. Describes graph-specific style attributes.'))
GraphStylePropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GraphStylePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'GraphStyle')), min_occurs=0L, max_occurs=1)
    )
GraphStylePropertyType._ContentModel = pyxb.binding.content.ParticleModel(GraphStylePropertyType._GroupModel, min_occurs=1, max_occurs=1)



BSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), PointPropertyType, scope=BSplineType, documentation=u'Deprecated with GML version 3.1.0. Use "pointProperty" instead. Included for backwards compatibility with GML 3.0.0.'))

BSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'knot'), KnotPropertyType, scope=BSplineType, documentation=u'The property "knot" shall be the sequence of distinct knots used to define the spline basis functions.'))

BSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'posList'), DirectPositionListType, scope=BSplineType, documentation=u''))

BSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'degree'), pyxb.binding.datatypes.nonNegativeInteger, scope=BSplineType, documentation=u'The attribute "degree" shall be the degree of the polynomial used for interpolation in this spline.'))

BSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, scope=BSplineType, documentation=u''))

BSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), CoordinatesType, scope=BSplineType, documentation=u'Deprecated with GML version 3.1.0.'))

BSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), PointPropertyType, scope=BSplineType, documentation=u'This property element either references a point via the XLink-attributes or contains the point element. pointProperty \n\t\t\tis the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that \n\t\t\tis substitutable for Point.'))
BSplineType._GroupModel_2 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(BSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(BSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(BSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep')), min_occurs=1, max_occurs=1)
    )
BSplineType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(BSplineType._GroupModel_2, min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(BSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(BSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates')), min_occurs=1, max_occurs=1)
    )
BSplineType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(BSplineType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(BSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'degree')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(BSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'knot')), min_occurs=2L, max_occurs=None)
    )
BSplineType._ContentModel = pyxb.binding.content.ParticleModel(BSplineType._GroupModel, min_occurs=1, max_occurs=1)


BezierType._GroupModel_2 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(BezierType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(BezierType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(BezierType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep')), min_occurs=1, max_occurs=1)
    )
BezierType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(BezierType._GroupModel_2, min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(BezierType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(BezierType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates')), min_occurs=1, max_occurs=1)
    )
BezierType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(BezierType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(BezierType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'degree')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(BezierType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'knot')), min_occurs=2L, max_occurs=2L)
    )
BezierType._ContentModel = pyxb.binding.content.ParticleModel(BezierType._GroupModel, min_occurs=1, max_occurs=1)



DirectionVectorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'horizontalAngle'), AngleType, scope=DirectionVectorType))

DirectionVectorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'vector'), VectorType, scope=DirectionVectorType, documentation=u''))

DirectionVectorType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'verticalAngle'), AngleType, scope=DirectionVectorType))
DirectionVectorType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DirectionVectorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'horizontalAngle')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DirectionVectorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'verticalAngle')), min_occurs=1, max_occurs=1)
    )
DirectionVectorType._GroupModel = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(DirectionVectorType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'vector')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DirectionVectorType._GroupModel_, min_occurs=1, max_occurs=1)
    )
DirectionVectorType._ContentModel = pyxb.binding.content.ParticleModel(DirectionVectorType._GroupModel, min_occurs=1, max_occurs=1)



FeatureStylePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'FeatureStyle'), FeatureStyleType, scope=FeatureStylePropertyType, documentation=u'The style descriptor for features.'))
FeatureStylePropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(FeatureStylePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'FeatureStyle')), min_occurs=0L, max_occurs=1)
    )
FeatureStylePropertyType._ContentModel = pyxb.binding.content.ParticleModel(FeatureStylePropertyType._GroupModel, min_occurs=1, max_occurs=1)



TransformationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesMethod'), OperationMethodRefType, scope=TransformationType, documentation=u'Association to the operation method used by this coordinate operation. '))

TransformationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesValue'), ParameterValueType, scope=TransformationType, documentation=u'Composition association to a parameter value used by this coordinate operation. '))
TransformationType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationName')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'operationVersion')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validArea')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_positionalAccuracy')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sourceCRS')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'targetCRS')), min_occurs=1, max_occurs=1)
    )
TransformationType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesMethod')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TransformationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesValue')), min_occurs=0L, max_occurs=None)
    )
TransformationType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TransformationType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TransformationType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
TransformationType._ContentModel = pyxb.binding.content.ParticleModel(TransformationType._GroupModel, min_occurs=1, max_occurs=1)


AbstractCurveType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
AbstractCurveType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractCurveType._GroupModel_, min_occurs=1, max_occurs=1)
    )
AbstractCurveType._ContentModel = pyxb.binding.content.ParticleModel(AbstractCurveType._GroupModel, min_occurs=1, max_occurs=1)



ExtentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'boundingPolygon'), PolygonType, scope=ExtentType, documentation=u'A bounding polygon defining the horizontal spatial domain of this object.'))

ExtentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'verticalExtent'), EnvelopeType, scope=ExtentType, documentation=u'An interval defining the vertical spatial domain of this object.'))

ExtentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'boundingBox'), EnvelopeType, scope=ExtentType, documentation=u'A bounding box (or envelope) defining the spatial domain of this object.'))

ExtentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'description'), StringOrRefType, scope=ExtentType, documentation=u'Contains a simple text description of the object, or refers to an external description.'))

ExtentType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'temporalExtent'), TimePeriodType, scope=ExtentType, documentation=u'A time period defining the temporal domain of this object.'))
ExtentType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(ExtentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundingBox')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(ExtentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundingPolygon')), min_occurs=0L, max_occurs=None)
    )
ExtentType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ExtentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(ExtentType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ExtentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'verticalExtent')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(ExtentType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'temporalExtent')), min_occurs=0L, max_occurs=None)
    )
ExtentType._ContentModel = pyxb.binding.content.ParticleModel(ExtentType._GroupModel, min_occurs=1, max_occurs=1)



TransformationRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Transformation'), TransformationType, scope=TransformationRefType))
TransformationRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TransformationRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Transformation')), min_occurs=1, max_occurs=1)
    )
TransformationRefType._ContentModel = pyxb.binding.content.ParticleModel(TransformationRefType._GroupModel, min_occurs=0L, max_occurs=1)



CurveSegmentArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_CurveSegment'), AbstractCurveSegmentType, abstract=pyxb.binding.datatypes.boolean(1), scope=CurveSegmentArrayPropertyType, documentation=u'The "_CurveSegment" element is the abstract head of the substituition group for all curve segment elements, i.e. continuous segments of the same interpolation mechanism.'))
CurveSegmentArrayPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CurveSegmentArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_CurveSegment')), min_occurs=0L, max_occurs=None)
    )
CurveSegmentArrayPropertyType._ContentModel = pyxb.binding.content.ParticleModel(CurveSegmentArrayPropertyType._GroupModel, min_occurs=1, max_occurs=1)



DirectedNodePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Node'), NodeType, scope=DirectedNodePropertyType))
DirectedNodePropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DirectedNodePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Node')), min_occurs=1, max_occurs=1)
    )
DirectedNodePropertyType._ContentModel = pyxb.binding.content.ParticleModel(DirectedNodePropertyType._GroupModel, min_occurs=0L, max_occurs=1)



CompositeSolidType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'solidMember'), SolidPropertyType, scope=CompositeSolidType, documentation=u'This property element either references a solid via the XLink-attributes or contains the solid element. A solid element is any element which is substitutable for "_Solid".'))
CompositeSolidType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CompositeSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(CompositeSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(CompositeSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
CompositeSolidType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CompositeSolidType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
CompositeSolidType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CompositeSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'solidMember')), min_occurs=1, max_occurs=None)
    )
CompositeSolidType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CompositeSolidType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CompositeSolidType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
CompositeSolidType._ContentModel = pyxb.binding.content.ParticleModel(CompositeSolidType._GroupModel, min_occurs=1, max_occurs=1)



ValuePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CompositeValue'), CompositeValueType, scope=ValuePropertyType, documentation=u'Aggregate value built using the Composite pattern.'))

ValuePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'BooleanList'), booleanOrNullList, scope=ValuePropertyType, documentation=u'XML List based on XML Schema boolean type.  An element of this type contains a space-separated list of boolean values {0,1,true,false}'))

ValuePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CountList'), integerOrNullList, scope=ValuePropertyType, documentation=u'A space-separated list of integers or nulls.'))

ValuePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Quantity'), MeasureType, scope=ValuePropertyType, documentation=u'A numeric value with a scale.  The content of the element is an amount using the XML Schema type double which permits decimal or scientific notation.  An XML attribute uom (unit of measure) is required, whose value is a URI which identifies the definition of the scale or units by which the numeric value must be multiplied.'))

ValuePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Boolean'), pyxb.binding.datatypes.boolean, scope=ValuePropertyType, documentation=u'A value from two-valued logic, using the XML Schema boolean type.  An instance may take the values {true, false, 1, 0}.'))

ValuePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CategoryList'), CodeOrNullListType, scope=ValuePropertyType, documentation=u'A space-separated list of terms or nulls.  A single XML attribute codeSpace may be provided, which authorises all the terms in the list.'))

ValuePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Count'), pyxb.binding.datatypes.integer, scope=ValuePropertyType, documentation=u'An integer representing a frequency of occurrence.'))

ValuePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CountExtent'), CountExtentType, scope=ValuePropertyType, documentation=u'Utility element to store a 2-point range of frequency values. If one member is a null, then this is a single ended interval.'))

ValuePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Object'), pyxb.binding.datatypes.anyType, abstract=pyxb.binding.datatypes.boolean(1), scope=ValuePropertyType, documentation=u'This abstract element is the head of a substitutionGroup hierararchy which may contain either simpleContent or complexContent elements.  It is used to assert the model position of "class" elements declared in other GML schemas.'))

ValuePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Category'), CodeType, scope=ValuePropertyType, documentation=u'A term representing a classification.  It has an optional XML attribute codeSpace, whose value is a URI which identifies a dictionary, codelist or authority for the term.'))

ValuePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CategoryExtent'), CategoryExtentType, scope=ValuePropertyType, documentation=u'Utility element to store a 2-point range of ordinal values. If one member is a null, then this is a single ended interval.'))

ValuePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'QuantityList'), MeasureOrNullListType, scope=ValuePropertyType, documentation=u'A space separated list of amounts or nulls.  The amounts use the XML Schema type double.  A single XML attribute uom (unit of measure) is required, whose value is a URI which identifies the definition of the scale or units by which all the amounts in the list must be multiplied.'))

ValuePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Null'), NullType, scope=ValuePropertyType))

ValuePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'QuantityExtent'), QuantityExtentType, scope=ValuePropertyType, documentation=u'Utility element to store a 2-point range of numeric values. If one member is a null, then this is a single ended interval.'))
ValuePropertyType._GroupModel_3 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(ValuePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Boolean')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValuePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Category')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValuePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Quantity')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValuePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Count')), min_occurs=1, max_occurs=1)
    )
ValuePropertyType._GroupModel_4 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(ValuePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'BooleanList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValuePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CategoryList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValuePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'QuantityList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValuePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CountList')), min_occurs=1, max_occurs=1)
    )
ValuePropertyType._GroupModel_5 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(ValuePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CategoryExtent')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValuePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'QuantityExtent')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValuePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CountExtent')), min_occurs=1, max_occurs=1)
    )
ValuePropertyType._GroupModel_2 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(ValuePropertyType._GroupModel_3, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValuePropertyType._GroupModel_4, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValuePropertyType._GroupModel_5, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValuePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CompositeValue')), min_occurs=1, max_occurs=1)
    )
ValuePropertyType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(ValuePropertyType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValuePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_Object')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValuePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Null')), min_occurs=1, max_occurs=1)
    )
ValuePropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ValuePropertyType._GroupModel_, min_occurs=1, max_occurs=1)
    )
ValuePropertyType._ContentModel = pyxb.binding.content.ParticleModel(ValuePropertyType._GroupModel, min_occurs=0L, max_occurs=1)


BooleanPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(BooleanPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Boolean')), min_occurs=1, max_occurs=1)
    )
BooleanPropertyType._ContentModel = pyxb.binding.content.ParticleModel(BooleanPropertyType._GroupModel, min_occurs=0L, max_occurs=1)



TimeEdgePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeEdge'), TimeEdgeType, scope=TimeEdgePropertyType, documentation=u'TimeEdge is one dimensional temporal topology primitive,\n\t\t\t expresses a state in topological time. It has an orientation from its start toward the end, \n\t\t\t and its boundaries shall associate with two different time nodes.'))
TimeEdgePropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeEdgePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TimeEdge')), min_occurs=1, max_occurs=1)
    )
TimeEdgePropertyType._ContentModel = pyxb.binding.content.ParticleModel(TimeEdgePropertyType._GroupModel, min_occurs=0L, max_occurs=1)



ContainerPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopoSolid'), TopoSolidType, scope=ContainerPropertyType))

ContainerPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Face'), FaceType, scope=ContainerPropertyType))
ContainerPropertyType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(ContainerPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Face')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ContainerPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TopoSolid')), min_occurs=1, max_occurs=1)
    )
ContainerPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ContainerPropertyType._GroupModel_, min_occurs=1, max_occurs=1)
    )
ContainerPropertyType._ContentModel = pyxb.binding.content.ParticleModel(ContainerPropertyType._GroupModel, min_occurs=0L, max_occurs=1)


CategoryPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CategoryPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Category')), min_occurs=1, max_occurs=1)
    )
CategoryPropertyType._ContentModel = pyxb.binding.content.ParticleModel(CategoryPropertyType._GroupModel, min_occurs=0L, max_occurs=1)


AbstractMetaDataType._GroupModel = pyxb.binding.content.GroupSequence(
    
    )
AbstractMetaDataType._ContentModel = pyxb.binding.content.ParticleModel(AbstractMetaDataType._GroupModel, min_occurs=1, max_occurs=1)


GenericMetaDataType._GroupModel_ = pyxb.binding.content.GroupSequence(
    
    )
GenericMetaDataType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=pyxb.binding.content.Wildcard.NC_any), min_occurs=0L, max_occurs=None)
    )
GenericMetaDataType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GenericMetaDataType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GenericMetaDataType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
GenericMetaDataType._ContentModel = pyxb.binding.content.ParticleModel(GenericMetaDataType._GroupModel, min_occurs=1, max_occurs=1)



NodeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'), DirectedEdgePropertyType, scope=NodeType, documentation=u''))

NodeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), PointPropertyType, scope=NodeType, documentation=u'This property element either references a point via the XLink-attributes or contains the point element. pointProperty \n\t\t\tis the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that \n\t\t\tis substitutable for Point.'))
NodeType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
NodeType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(NodeType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
NodeType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isolated')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'container')), min_occurs=0L, max_occurs=1)
    )
NodeType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(NodeType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(NodeType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
NodeType._GroupModel_5 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedEdge')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(NodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty')), min_occurs=0L, max_occurs=1)
    )
NodeType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(NodeType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(NodeType._GroupModel_5, min_occurs=1, max_occurs=1)
    )
NodeType._ContentModel = pyxb.binding.content.ParticleModel(NodeType._GroupModel, min_occurs=1, max_occurs=1)



DatumRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Datum'), AbstractDatumType, abstract=pyxb.binding.datatypes.boolean(1), scope=DatumRefType))
DatumRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DatumRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_Datum')), min_occurs=1, max_occurs=1)
    )
DatumRefType._ContentModel = pyxb.binding.content.ParticleModel(DatumRefType._GroupModel, min_occurs=0L, max_occurs=1)


QuantityPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(QuantityPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Quantity')), min_occurs=1, max_occurs=1)
    )
QuantityPropertyType._ContentModel = pyxb.binding.content.ParticleModel(QuantityPropertyType._GroupModel, min_occurs=0L, max_occurs=1)



MultiPolygonType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'polygonMember'), PolygonPropertyType, scope=MultiPolygonType, documentation=u'Deprecated with GML 3.0 and included only for backwards compatibility with GML 2.0. Use "surfaceMember" instead.\nThis property element either references a polygon via the XLink-attributes or contains the polygon element.'))
MultiPolygonType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiPolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(MultiPolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiPolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
MultiPolygonType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiPolygonType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
MultiPolygonType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiPolygonType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'polygonMember')), min_occurs=0L, max_occurs=None)
    )
MultiPolygonType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiPolygonType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiPolygonType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
MultiPolygonType._ContentModel = pyxb.binding.content.ParticleModel(MultiPolygonType._GroupModel, min_occurs=1, max_occurs=1)


CountPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CountPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Count')), min_occurs=1, max_occurs=1)
    )
CountPropertyType._ContentModel = pyxb.binding.content.ParticleModel(CountPropertyType._GroupModel, min_occurs=0L, max_occurs=1)



PolygonPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Polygon'), PolygonType, scope=PolygonPropertyType))
PolygonPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PolygonPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Polygon')), min_occurs=1, max_occurs=1)
    )
PolygonPropertyType._ContentModel = pyxb.binding.content.ParticleModel(PolygonPropertyType._GroupModel, min_occurs=0L, max_occurs=1)



GeneralTransformationRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_GeneralTransformation'), AbstractGeneralTransformationType, abstract=pyxb.binding.datatypes.boolean(1), scope=GeneralTransformationRefType))
GeneralTransformationRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeneralTransformationRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_GeneralTransformation')), min_occurs=1, max_occurs=1)
    )
GeneralTransformationRefType._ContentModel = pyxb.binding.content.ParticleModel(GeneralTransformationRefType._GroupModel, min_occurs=0L, max_occurs=1)



UserDefinedCSRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'UserDefinedCS'), UserDefinedCSType, scope=UserDefinedCSRefType))
UserDefinedCSRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(UserDefinedCSRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'UserDefinedCS')), min_occurs=1, max_occurs=1)
    )
UserDefinedCSRefType._ContentModel = pyxb.binding.content.ParticleModel(UserDefinedCSRefType._GroupModel, min_occurs=0L, max_occurs=1)



ImageDatumType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pixelInCell'), PixelInCellType, scope=ImageDatumType))
ImageDatumType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'datumName')), min_occurs=1, max_occurs=1)
    )
ImageDatumType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'datumID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'anchorPoint')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'realizationEpoch')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validArea')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope')), min_occurs=0L, max_occurs=1)
    )
ImageDatumType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ImageDatumType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ImageDatumType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
ImageDatumType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ImageDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pixelInCell')), min_occurs=1, max_occurs=1)
    )
ImageDatumType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ImageDatumType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ImageDatumType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
ImageDatumType._ContentModel = pyxb.binding.content.ParticleModel(ImageDatumType._GroupModel, min_occurs=1, max_occurs=1)



OperationMethodBaseType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'methodName'), CodeType, scope=OperationMethodBaseType, documentation=u'The name by which this operation method is identified. '))
OperationMethodBaseType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(OperationMethodBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(OperationMethodBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'methodName')), min_occurs=1, max_occurs=1)
    )
OperationMethodBaseType._ContentModel = pyxb.binding.content.ParticleModel(OperationMethodBaseType._GroupModel, min_occurs=1, max_occurs=1)



OperationMethodType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'remarks'), StringOrRefType, scope=OperationMethodType, documentation=u'Information about this object or code. Contains text or refers to external text.'))

OperationMethodType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'targetDimensions'), pyxb.binding.datatypes.positiveInteger, scope=OperationMethodType, documentation=u'Number of dimensions in the target CRS of this operation method. '))

OperationMethodType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'methodFormula'), CodeType, scope=OperationMethodType, documentation=u'Formula(s) used by this operation method. The value may be a reference to a publication. Note that the operation method may not be analytic, in which case this element references or contains the procedure, not an analytic formula.'))

OperationMethodType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesParameter'), AbstractGeneralOperationParameterRefType, scope=OperationMethodType, documentation=u'Association to an operation parameter or parameter group used by this operation method. '))

OperationMethodType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'methodID'), IdentifierType, scope=OperationMethodType, documentation=u'An identification of an operation method. '))

OperationMethodType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sourceDimensions'), pyxb.binding.datatypes.positiveInteger, scope=OperationMethodType, documentation=u'Number of dimensions in the source CRS of this operation method. '))
OperationMethodType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(OperationMethodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(OperationMethodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'methodName')), min_occurs=1, max_occurs=1)
    )
OperationMethodType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(OperationMethodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'methodID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(OperationMethodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(OperationMethodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'methodFormula')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(OperationMethodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sourceDimensions')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(OperationMethodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'targetDimensions')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(OperationMethodType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesParameter')), min_occurs=0L, max_occurs=None)
    )
OperationMethodType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(OperationMethodType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(OperationMethodType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
OperationMethodType._ContentModel = pyxb.binding.content.ParticleModel(OperationMethodType._GroupModel, min_occurs=1, max_occurs=1)



CoordinateOperationRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_CoordinateOperation'), AbstractCoordinateOperationType, abstract=pyxb.binding.datatypes.boolean(1), scope=CoordinateOperationRefType))
CoordinateOperationRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CoordinateOperationRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_CoordinateOperation')), min_occurs=1, max_occurs=1)
    )
CoordinateOperationRefType._ContentModel = pyxb.binding.content.ParticleModel(CoordinateOperationRefType._GroupModel, min_occurs=0L, max_occurs=1)



GridType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'axisName'), pyxb.binding.datatypes.string, scope=GridType))

GridType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'limits'), GridLimitsType, scope=GridType))
GridType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(GridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(GridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
GridType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GridType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
GridType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'limits')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axisName')), min_occurs=1, max_occurs=None)
    )
GridType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GridType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GridType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
GridType._ContentModel = pyxb.binding.content.ParticleModel(GridType._GroupModel, min_occurs=1, max_occurs=1)



CoordinateReferenceSystemRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_CoordinateReferenceSystem'), AbstractReferenceSystemType, abstract=pyxb.binding.datatypes.boolean(1), scope=CoordinateReferenceSystemRefType, documentation=u'A coordinate reference system consists of an ordered sequence of coordinate system axes that are related to the earth through a datum. A coordinate reference system is defined by one datum and by one coordinate system. Most coordinate reference system do not move relative to the earth, except for engineering coordinate reference systems defined on moving platforms such as cars, ships, aircraft, and spacecraft. For further information, see OGC Abstract Specification Topic 2.\n\nCoordinate reference systems are commonly divided into sub-types. The common classification criterion for sub-typing of coordinate reference systems is the way in which they deal with earth curvature. This has a direct effect on the portion of the earth\'s surface that can be covered by that type of CRS with an acceptable degree of error. The exception to the rule is the subtype "Temporal" which has been added by analogy. '))
CoordinateReferenceSystemRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CoordinateReferenceSystemRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_CoordinateReferenceSystem')), min_occurs=1, max_occurs=1)
    )
CoordinateReferenceSystemRefType._ContentModel = pyxb.binding.content.ParticleModel(CoordinateReferenceSystemRefType._GroupModel, min_occurs=0L, max_occurs=1)



EngineeringCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesCS'), CoordinateSystemRefType, scope=EngineeringCRSType, documentation=u'Association to the coordinate system used by this CRS. '))

EngineeringCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesEngineeringDatum'), EngineeringDatumRefType, scope=EngineeringCRSType, documentation=u'Association to the engineering datum used by this CRS. '))
EngineeringCRSType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EngineeringCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(EngineeringCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'srsName')), min_occurs=1, max_occurs=1)
    )
EngineeringCRSType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EngineeringCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'srsID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(EngineeringCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(EngineeringCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validArea')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(EngineeringCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope')), min_occurs=0L, max_occurs=1)
    )
EngineeringCRSType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EngineeringCRSType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(EngineeringCRSType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
EngineeringCRSType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EngineeringCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesCS')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(EngineeringCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesEngineeringDatum')), min_occurs=1, max_occurs=1)
    )
EngineeringCRSType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EngineeringCRSType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(EngineeringCRSType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
EngineeringCRSType._ContentModel = pyxb.binding.content.ParticleModel(EngineeringCRSType._GroupModel, min_occurs=1, max_occurs=1)



VerticalCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesVerticalDatum'), VerticalDatumRefType, scope=VerticalCRSType, documentation=u'Association to the vertical datum used by this CRS. '))

VerticalCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesVerticalCS'), VerticalCSRefType, scope=VerticalCRSType, documentation=u'Association to the vertical coordinate system used by this CRS. '))
VerticalCRSType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(VerticalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(VerticalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'srsName')), min_occurs=1, max_occurs=1)
    )
VerticalCRSType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(VerticalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'srsID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(VerticalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(VerticalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validArea')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(VerticalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope')), min_occurs=0L, max_occurs=1)
    )
VerticalCRSType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(VerticalCRSType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(VerticalCRSType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
VerticalCRSType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(VerticalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesVerticalCS')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(VerticalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesVerticalDatum')), min_occurs=1, max_occurs=1)
    )
VerticalCRSType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(VerticalCRSType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(VerticalCRSType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
VerticalCRSType._ContentModel = pyxb.binding.content.ParticleModel(VerticalCRSType._GroupModel, min_occurs=1, max_occurs=1)



AbstractTimeSliceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'validTime'), TimePrimitivePropertyType, scope=AbstractTimeSliceType))

AbstractTimeSliceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'dataSource'), StringOrRefType, scope=AbstractTimeSliceType))
AbstractTimeSliceType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTimeSliceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractTimeSliceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractTimeSliceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
AbstractTimeSliceType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTimeSliceType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
AbstractTimeSliceType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTimeSliceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractTimeSliceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSource')), min_occurs=0L, max_occurs=1)
    )
AbstractTimeSliceType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTimeSliceType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractTimeSliceType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
AbstractTimeSliceType._ContentModel = pyxb.binding.content.ParticleModel(AbstractTimeSliceType._GroupModel, min_occurs=1, max_occurs=1)



TopoCurveType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedEdge'), DirectedEdgePropertyType, scope=TopoCurveType, documentation=u''))
TopoCurveType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TopoCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TopoCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
TopoCurveType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoCurveType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
TopoCurveType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedEdge')), min_occurs=1, max_occurs=None)
    )
TopoCurveType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoCurveType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TopoCurveType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
TopoCurveType._ContentModel = pyxb.binding.content.ParticleModel(TopoCurveType._GroupModel, min_occurs=1, max_occurs=1)



GridFunctionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sequenceRule'), SequenceRuleType, scope=GridFunctionType, documentation=u'If absent, the implied value is "Linear".'))

GridFunctionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'startPoint'), integerList, scope=GridFunctionType, documentation=u'Index position of the first grid post, which must lie somwhere in the GridEnvelope.  If absent, the startPoint is equal to the value of gridEnvelope::low from the grid definition.'))
GridFunctionType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GridFunctionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sequenceRule')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(GridFunctionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'startPoint')), min_occurs=0L, max_occurs=1)
    )
GridFunctionType._ContentModel = pyxb.binding.content.ParticleModel(GridFunctionType._GroupModel, min_occurs=1, max_occurs=1)



ValueArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'QuantityExtent'), QuantityExtentType, scope=ValueArrayPropertyType, documentation=u'Utility element to store a 2-point range of numeric values. If one member is a null, then this is a single ended interval.'))

ValueArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Boolean'), pyxb.binding.datatypes.boolean, scope=ValueArrayPropertyType, documentation=u'A value from two-valued logic, using the XML Schema boolean type.  An instance may take the values {true, false, 1, 0}.'))

ValueArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CountList'), integerOrNullList, scope=ValueArrayPropertyType, documentation=u'A space-separated list of integers or nulls.'))

ValueArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CategoryList'), CodeOrNullListType, scope=ValueArrayPropertyType, documentation=u'A space-separated list of terms or nulls.  A single XML attribute codeSpace may be provided, which authorises all the terms in the list.'))

ValueArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Object'), pyxb.binding.datatypes.anyType, abstract=pyxb.binding.datatypes.boolean(1), scope=ValueArrayPropertyType, documentation=u'This abstract element is the head of a substitutionGroup hierararchy which may contain either simpleContent or complexContent elements.  It is used to assert the model position of "class" elements declared in other GML schemas.'))

ValueArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CountExtent'), CountExtentType, scope=ValueArrayPropertyType, documentation=u'Utility element to store a 2-point range of frequency values. If one member is a null, then this is a single ended interval.'))

ValueArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Null'), NullType, scope=ValueArrayPropertyType))

ValueArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Category'), CodeType, scope=ValueArrayPropertyType, documentation=u'A term representing a classification.  It has an optional XML attribute codeSpace, whose value is a URI which identifies a dictionary, codelist or authority for the term.'))

ValueArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CompositeValue'), CompositeValueType, scope=ValueArrayPropertyType, documentation=u'Aggregate value built using the Composite pattern.'))

ValueArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Count'), pyxb.binding.datatypes.integer, scope=ValueArrayPropertyType, documentation=u'An integer representing a frequency of occurrence.'))

ValueArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'QuantityList'), MeasureOrNullListType, scope=ValueArrayPropertyType, documentation=u'A space separated list of amounts or nulls.  The amounts use the XML Schema type double.  A single XML attribute uom (unit of measure) is required, whose value is a URI which identifies the definition of the scale or units by which all the amounts in the list must be multiplied.'))

ValueArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CategoryExtent'), CategoryExtentType, scope=ValueArrayPropertyType, documentation=u'Utility element to store a 2-point range of ordinal values. If one member is a null, then this is a single ended interval.'))

ValueArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'BooleanList'), booleanOrNullList, scope=ValueArrayPropertyType, documentation=u'XML List based on XML Schema boolean type.  An element of this type contains a space-separated list of boolean values {0,1,true,false}'))

ValueArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Quantity'), MeasureType, scope=ValueArrayPropertyType, documentation=u'A numeric value with a scale.  The content of the element is an amount using the XML Schema type double which permits decimal or scientific notation.  An XML attribute uom (unit of measure) is required, whose value is a URI which identifies the definition of the scale or units by which the numeric value must be multiplied.'))
ValueArrayPropertyType._GroupModel_3 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(ValueArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Boolean')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValueArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Category')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValueArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Quantity')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValueArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Count')), min_occurs=1, max_occurs=1)
    )
ValueArrayPropertyType._GroupModel_4 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(ValueArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'BooleanList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValueArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CategoryList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValueArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'QuantityList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValueArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CountList')), min_occurs=1, max_occurs=1)
    )
ValueArrayPropertyType._GroupModel_5 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(ValueArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CategoryExtent')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValueArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'QuantityExtent')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValueArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CountExtent')), min_occurs=1, max_occurs=1)
    )
ValueArrayPropertyType._GroupModel_2 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(ValueArrayPropertyType._GroupModel_3, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValueArrayPropertyType._GroupModel_4, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValueArrayPropertyType._GroupModel_5, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValueArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CompositeValue')), min_occurs=1, max_occurs=1)
    )
ValueArrayPropertyType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(ValueArrayPropertyType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValueArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_Object')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValueArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Null')), min_occurs=1, max_occurs=1)
    )
ValueArrayPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ValueArrayPropertyType._GroupModel_, min_occurs=1, max_occurs=None)
    )
ValueArrayPropertyType._ContentModel = pyxb.binding.content.ParticleModel(ValueArrayPropertyType._GroupModel, min_occurs=1, max_occurs=1)



MultiSolidDomainType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiSolid'), MultiSolidType, scope=MultiSolidDomainType))
MultiSolidDomainType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiSolidDomainType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'MultiSolid')), min_occurs=1, max_occurs=1)
    )
MultiSolidDomainType._ContentModel = pyxb.binding.content.ParticleModel(MultiSolidDomainType._GroupModel, min_occurs=0L, max_occurs=1)



RectifiedGridDomainType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'RectifiedGrid'), RectifiedGridType, scope=RectifiedGridDomainType, documentation=u'Should be substitutionGroup="gml:Grid" but changed in order to accomplish Xerces-J schema validation'))
RectifiedGridDomainType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(RectifiedGridDomainType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'RectifiedGrid')), min_occurs=1, max_occurs=1)
    )
RectifiedGridDomainType._ContentModel = pyxb.binding.content.ParticleModel(RectifiedGridDomainType._GroupModel, min_occurs=0L, max_occurs=1)



ImageCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesImageDatum'), ImageDatumRefType, scope=ImageCRSType, documentation=u'Association to the image datum used by this CRS. '))

ImageCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesCartesianCS'), CartesianCSRefType, scope=ImageCRSType, documentation=u'Association to the Cartesian coordinate system used by this CRS. '))

ImageCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesObliqueCartesianCS'), ObliqueCartesianCSRefType, scope=ImageCRSType, documentation=u'Association to the oblique Cartesian coordinate system used by this CRS.'))
ImageCRSType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'srsName')), min_occurs=1, max_occurs=1)
    )
ImageCRSType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'srsID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validArea')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope')), min_occurs=0L, max_occurs=1)
    )
ImageCRSType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ImageCRSType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ImageCRSType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
ImageCRSType._GroupModel_5 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesCartesianCS')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesObliqueCartesianCS')), min_occurs=1, max_occurs=1)
    )
ImageCRSType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ImageCRSType._GroupModel_5, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ImageCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesImageDatum')), min_occurs=1, max_occurs=1)
    )
ImageCRSType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ImageCRSType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ImageCRSType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
ImageCRSType._ContentModel = pyxb.binding.content.ParticleModel(ImageCRSType._GroupModel, min_occurs=1, max_occurs=1)



RectifiedGridType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'origin'), PointPropertyType, scope=RectifiedGridType))

RectifiedGridType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'offsetVector'), VectorType, scope=RectifiedGridType))
RectifiedGridType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
RectifiedGridType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(RectifiedGridType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
RectifiedGridType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'limits')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'axisName')), min_occurs=1, max_occurs=None)
    )
RectifiedGridType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(RectifiedGridType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(RectifiedGridType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
RectifiedGridType._GroupModel_5 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'origin')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(RectifiedGridType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'offsetVector')), min_occurs=1, max_occurs=None)
    )
RectifiedGridType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(RectifiedGridType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(RectifiedGridType._GroupModel_5, min_occurs=1, max_occurs=1)
    )
RectifiedGridType._ContentModel = pyxb.binding.content.ParticleModel(RectifiedGridType._GroupModel, min_occurs=1, max_occurs=1)



TimeCalendarPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeCalendar'), TimeCalendarType, scope=TimeCalendarPropertyType))
TimeCalendarPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeCalendarPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TimeCalendar')), min_occurs=1, max_occurs=1)
    )
TimeCalendarPropertyType._ContentModel = pyxb.binding.content.ParticleModel(TimeCalendarPropertyType._GroupModel, min_occurs=0L, max_occurs=1)



TimeClockPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeClock'), TimeClockType, scope=TimeClockPropertyType))
TimeClockPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeClockPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TimeClock')), min_occurs=1, max_occurs=1)
    )
TimeClockPropertyType._ContentModel = pyxb.binding.content.ParticleModel(TimeClockPropertyType._GroupModel, min_occurs=0L, max_occurs=1)



DirectedFacePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Face'), FaceType, scope=DirectedFacePropertyType))
DirectedFacePropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DirectedFacePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Face')), min_occurs=1, max_occurs=1)
    )
DirectedFacePropertyType._ContentModel = pyxb.binding.content.ParticleModel(DirectedFacePropertyType._GroupModel, min_occurs=0L, max_occurs=1)


UserDefinedCSType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(UserDefinedCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(UserDefinedCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'csName')), min_occurs=1, max_occurs=1)
    )
UserDefinedCSType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(UserDefinedCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'csID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(UserDefinedCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(UserDefinedCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesAxis')), min_occurs=1, max_occurs=None)
    )
UserDefinedCSType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(UserDefinedCSType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(UserDefinedCSType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
UserDefinedCSType._ContentModel = pyxb.binding.content.ParticleModel(UserDefinedCSType._GroupModel, min_occurs=1, max_occurs=1)



EllipsoidRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Ellipsoid'), EllipsoidType, scope=EllipsoidRefType))
EllipsoidRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EllipsoidRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Ellipsoid')), min_occurs=1, max_occurs=1)
    )
EllipsoidRefType._ContentModel = pyxb.binding.content.ParticleModel(EllipsoidRefType._GroupModel, min_occurs=0L, max_occurs=1)



CurveType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'segments'), CurveSegmentArrayPropertyType, scope=CurveType, documentation=u'This property element contains a list of curve segments. The order of the elements is significant and shall be preserved when processing the array.'))
CurveType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(CurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(CurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
CurveType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CurveType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
CurveType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'segments')), min_occurs=1, max_occurs=1)
    )
CurveType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CurveType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CurveType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
CurveType._ContentModel = pyxb.binding.content.ParticleModel(CurveType._GroupModel, min_occurs=1, max_occurs=1)


LinearCSType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(LinearCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(LinearCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'csName')), min_occurs=1, max_occurs=1)
    )
LinearCSType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(LinearCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'csID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(LinearCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(LinearCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesAxis')), min_occurs=1, max_occurs=None)
    )
LinearCSType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(LinearCSType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(LinearCSType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
LinearCSType._ContentModel = pyxb.binding.content.ParticleModel(LinearCSType._GroupModel, min_occurs=1, max_occurs=1)


SymbolType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_skip, namespace_constraint=pyxb.binding.content.Wildcard.NC_any), min_occurs=0L, max_occurs=None)
    )
SymbolType._ContentModel = pyxb.binding.content.ParticleModel(SymbolType._GroupModel, min_occurs=1, max_occurs=1)



MultiSurfaceDomainType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiSurface'), MultiSurfaceType, scope=MultiSurfaceDomainType))
MultiSurfaceDomainType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiSurfaceDomainType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'MultiSurface')), min_occurs=1, max_occurs=1)
    )
MultiSurfaceDomainType._ContentModel = pyxb.binding.content.ParticleModel(MultiSurfaceDomainType._GroupModel, min_occurs=0L, max_occurs=1)



AbstractGriddedSurfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'row'), CTD_ANON_, scope=AbstractGriddedSurfaceType))

AbstractGriddedSurfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'columns'), pyxb.binding.datatypes.integer, scope=AbstractGriddedSurfaceType, documentation=u'The attribute columns gives the number\n        of columns in the parameter grid.'))

AbstractGriddedSurfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'rows'), pyxb.binding.datatypes.integer, scope=AbstractGriddedSurfaceType, documentation=u'The attribute rows gives the number\n         of rows in the parameter grid.'))
AbstractGriddedSurfaceType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractGriddedSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'row')), min_occurs=1, max_occurs=None)
    )
AbstractGriddedSurfaceType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractGriddedSurfaceType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractGriddedSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rows')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractGriddedSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'columns')), min_occurs=0L, max_occurs=1)
    )
AbstractGriddedSurfaceType._ContentModel = pyxb.binding.content.ParticleModel(AbstractGriddedSurfaceType._GroupModel, min_occurs=1, max_occurs=1)


SphereType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(SphereType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'row')), min_occurs=1, max_occurs=None)
    )
SphereType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(SphereType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(SphereType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rows')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(SphereType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'columns')), min_occurs=0L, max_occurs=1)
    )
SphereType._ContentModel = pyxb.binding.content.ParticleModel(SphereType._GroupModel, min_occurs=1, max_occurs=1)



SurfaceArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Surface'), AbstractSurfaceType, abstract=pyxb.binding.datatypes.boolean(1), scope=SurfaceArrayPropertyType, documentation=u'The "_Surface" element is the abstract head of the substituition group for all (continuous) surface elements.'))
SurfaceArrayPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(SurfaceArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_Surface')), min_occurs=0L, max_occurs=None)
    )
SurfaceArrayPropertyType._ContentModel = pyxb.binding.content.ParticleModel(SurfaceArrayPropertyType._GroupModel, min_occurs=1, max_occurs=1)


SphericalCSType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(SphericalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(SphericalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'csName')), min_occurs=1, max_occurs=1)
    )
SphericalCSType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(SphericalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'csID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(SphericalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(SphericalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesAxis')), min_occurs=1, max_occurs=None)
    )
SphericalCSType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(SphericalCSType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(SphericalCSType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
SphericalCSType._ContentModel = pyxb.binding.content.ParticleModel(SphericalCSType._GroupModel, min_occurs=1, max_occurs=1)



FeatureStyleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'topologyStyle'), TopologyStylePropertyType, scope=FeatureStyleType, documentation=u''))

FeatureStyleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'featureConstraint'), pyxb.binding.datatypes.string, scope=FeatureStyleType))

FeatureStyleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'labelStyle'), LabelStylePropertyType, scope=FeatureStyleType, documentation=u''))

FeatureStyleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'geometryStyle'), GeometryStylePropertyType, scope=FeatureStyleType, documentation=u''))
FeatureStyleType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(FeatureStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(FeatureStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(FeatureStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
FeatureStyleType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(FeatureStyleType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
FeatureStyleType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(FeatureStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureConstraint')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(FeatureStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'geometryStyle')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(FeatureStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'topologyStyle')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(FeatureStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'labelStyle')), min_occurs=0L, max_occurs=1)
    )
FeatureStyleType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(FeatureStyleType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(FeatureStyleType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
FeatureStyleType._ContentModel = pyxb.binding.content.ParticleModel(FeatureStyleType._GroupModel, min_occurs=1, max_occurs=1)



StyleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'featureStyle'), FeatureStylePropertyType, scope=StyleType, documentation=u''))

StyleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'graphStyle'), GraphStylePropertyType, scope=StyleType, documentation=u''))
StyleType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(StyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(StyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(StyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
StyleType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(StyleType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
StyleType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(StyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureStyle')), min_occurs=1, max_occurs=None),
    pyxb.binding.content.ParticleModel(StyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'graphStyle')), min_occurs=0L, max_occurs=1)
    )
StyleType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(StyleType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(StyleType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
StyleType._ContentModel = pyxb.binding.content.ParticleModel(StyleType._GroupModel, min_occurs=1, max_occurs=1)



SolidPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Solid'), AbstractSolidType, abstract=pyxb.binding.datatypes.boolean(1), scope=SolidPropertyType, documentation=u'The "_Solid" element is the abstract head of the substituition group for all (continuous) solid elements.'))
SolidPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(SolidPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_Solid')), min_occurs=1, max_occurs=1)
    )
SolidPropertyType._ContentModel = pyxb.binding.content.ParticleModel(SolidPropertyType._GroupModel, min_occurs=0L, max_occurs=1)



TopoSurfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedFace'), DirectedFacePropertyType, scope=TopoSurfaceType, documentation=u''))
TopoSurfaceType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TopoSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TopoSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
TopoSurfaceType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoSurfaceType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
TopoSurfaceType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedFace')), min_occurs=1, max_occurs=None)
    )
TopoSurfaceType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoSurfaceType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TopoSurfaceType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
TopoSurfaceType._ContentModel = pyxb.binding.content.ParticleModel(TopoSurfaceType._GroupModel, min_occurs=1, max_occurs=1)



LineStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coord'), CoordType, scope=LineStringType, documentation=u'Deprecated with GML 3.0 and included for backwards compatibility with GML 2. Use the "pos" element instead.'))

LineStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), PointPropertyType, scope=LineStringType, documentation=u'This property element either references a point via the XLink-attributes or contains the point element. pointProperty \n\t\t\tis the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that \n\t\t\tis substitutable for Point.'))

LineStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'posList'), DirectPositionListType, scope=LineStringType, documentation=u''))

LineStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), PointPropertyType, scope=LineStringType, documentation=u'Deprecated with GML version 3.1.0. Use "pointProperty" instead. Included for backwards compatibility with GML 3.0.0.'))

LineStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, scope=LineStringType, documentation=u''))

LineStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), CoordinatesType, scope=LineStringType, documentation=u'Deprecated with GML version 3.1.0.'))
LineStringType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
LineStringType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(LineStringType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
LineStringType._GroupModel_5 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coord')), min_occurs=1, max_occurs=1)
    )
LineStringType._GroupModel_4 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(LineStringType._GroupModel_5, min_occurs=2L, max_occurs=None),
    pyxb.binding.content.ParticleModel(LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(LineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates')), min_occurs=1, max_occurs=1)
    )
LineStringType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(LineStringType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
LineStringType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(LineStringType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(LineStringType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
LineStringType._ContentModel = pyxb.binding.content.ParticleModel(LineStringType._GroupModel, min_occurs=1, max_occurs=1)



CompoundCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'includesCRS'), CoordinateReferenceSystemRefType, scope=CompoundCRSType, documentation=u'An association to a component coordinate reference system included in this compound coordinate reference system. '))
CompoundCRSType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CompoundCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(CompoundCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'srsName')), min_occurs=1, max_occurs=1)
    )
CompoundCRSType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CompoundCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'srsID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(CompoundCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(CompoundCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validArea')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(CompoundCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope')), min_occurs=0L, max_occurs=1)
    )
CompoundCRSType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CompoundCRSType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CompoundCRSType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
CompoundCRSType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CompoundCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'includesCRS')), min_occurs=2L, max_occurs=None)
    )
CompoundCRSType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CompoundCRSType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CompoundCRSType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
CompoundCRSType._ContentModel = pyxb.binding.content.ParticleModel(CompoundCRSType._GroupModel, min_occurs=1, max_occurs=1)



CompositeCurveType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'curveMember'), CurvePropertyType, scope=CompositeCurveType, documentation=u'This property element either references a curve via the XLink-attributes or contains the curve element. A curve element is any element which is substitutable for "_Curve".'))
CompositeCurveType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CompositeCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(CompositeCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(CompositeCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
CompositeCurveType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CompositeCurveType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
CompositeCurveType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CompositeCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'curveMember')), min_occurs=1, max_occurs=None)
    )
CompositeCurveType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CompositeCurveType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CompositeCurveType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
CompositeCurveType._ContentModel = pyxb.binding.content.ParticleModel(CompositeCurveType._GroupModel, min_occurs=1, max_occurs=1)



RectangleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'exterior'), AbstractRingPropertyType, scope=RectangleType, documentation=u'A boundary of a surface consists of a number of rings. In the normal 2D case, one of these rings is distinguished as being the exterior boundary. In a general manifold this is not always possible, in which case all boundaries shall be listed as interior boundaries, and the exterior will be empty.'))
RectangleType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(RectangleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'exterior')), min_occurs=1, max_occurs=1)
    )
RectangleType._ContentModel = pyxb.binding.content.ParticleModel(RectangleType._GroupModel, min_occurs=1, max_occurs=1)



LineStringPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'LineString'), LineStringType, scope=LineStringPropertyType))
LineStringPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(LineStringPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'LineString')), min_occurs=1, max_occurs=1)
    )
LineStringPropertyType._ContentModel = pyxb.binding.content.ParticleModel(LineStringPropertyType._GroupModel, min_occurs=0L, max_occurs=1)



FormulaType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'd'), pyxb.binding.datatypes.double, scope=FormulaType))

FormulaType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'b'), pyxb.binding.datatypes.double, scope=FormulaType))

FormulaType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'a'), pyxb.binding.datatypes.double, scope=FormulaType))

FormulaType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'c'), pyxb.binding.datatypes.double, scope=FormulaType))
FormulaType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(FormulaType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'a')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(FormulaType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'b')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(FormulaType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'c')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(FormulaType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'd')), min_occurs=0L, max_occurs=1)
    )
FormulaType._ContentModel = pyxb.binding.content.ParticleModel(FormulaType._GroupModel, min_occurs=1, max_occurs=1)



GeodeticDatumType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesPrimeMeridian'), PrimeMeridianRefType, scope=GeodeticDatumType, documentation=u'Association to the prime meridian used by this geodetic datum. '))

GeodeticDatumType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesEllipsoid'), EllipsoidRefType, scope=GeodeticDatumType, documentation=u'Association to the ellipsoid used by this geodetic datum. '))
GeodeticDatumType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'datumName')), min_occurs=1, max_occurs=1)
    )
GeodeticDatumType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'datumID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'anchorPoint')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'realizationEpoch')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validArea')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope')), min_occurs=0L, max_occurs=1)
    )
GeodeticDatumType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeodeticDatumType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeodeticDatumType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
GeodeticDatumType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesPrimeMeridian')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeodeticDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesEllipsoid')), min_occurs=1, max_occurs=1)
    )
GeodeticDatumType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeodeticDatumType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeodeticDatumType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
GeodeticDatumType._ContentModel = pyxb.binding.content.ParticleModel(GeodeticDatumType._GroupModel, min_occurs=1, max_occurs=1)



SingleOperationRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_SingleOperation'), AbstractCoordinateOperationType, abstract=pyxb.binding.datatypes.boolean(1), scope=SingleOperationRefType, documentation=u'A single (not concatenated) coordinate operation. '))
SingleOperationRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(SingleOperationRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_SingleOperation')), min_occurs=1, max_occurs=1)
    )
SingleOperationRefType._ContentModel = pyxb.binding.content.ParticleModel(SingleOperationRefType._GroupModel, min_occurs=0L, max_occurs=1)



MultiLineStringType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'lineStringMember'), LineStringPropertyType, scope=MultiLineStringType, documentation=u'Deprecated with GML 3.0 and included only for backwards compatibility with GML 2.0. Use "curveMember" instead.\nThis property element either references a line string via the XLink-attributes or contains the line string element.'))
MultiLineStringType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiLineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(MultiLineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiLineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
MultiLineStringType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiLineStringType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
MultiLineStringType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiLineStringType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'lineStringMember')), min_occurs=0L, max_occurs=None)
    )
MultiLineStringType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiLineStringType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiLineStringType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
MultiLineStringType._ContentModel = pyxb.binding.content.ParticleModel(MultiLineStringType._GroupModel, min_occurs=1, max_occurs=1)



TriangulatedSurfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'trianglePatches'), TrianglePatchArrayPropertyType, scope=TriangulatedSurfaceType, documentation=u'This property element contains a list of\n   triangle patches. The order of the patches is significant and \n   shall be preserved when processing the list.'))
TriangulatedSurfaceType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TriangulatedSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TriangulatedSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TriangulatedSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
TriangulatedSurfaceType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TriangulatedSurfaceType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TriangulatedSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'trianglePatches')), min_occurs=1, max_occurs=1)
    )
TriangulatedSurfaceType._ContentModel = pyxb.binding.content.ParticleModel(TriangulatedSurfaceType._GroupModel, min_occurs=1, max_occurs=1)



RingType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'curveMember'), CurvePropertyType, scope=RingType, documentation=u'This property element either references a curve via the XLink-attributes or contains the curve element. A curve element is any element which is substitutable for "_Curve".'))
RingType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(RingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(RingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(RingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
RingType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(RingType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
RingType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(RingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'curveMember')), min_occurs=1, max_occurs=None)
    )
RingType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(RingType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(RingType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
RingType._ContentModel = pyxb.binding.content.ParticleModel(RingType._GroupModel, min_occurs=1, max_occurs=1)



EllipsoidalCSRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'EllipsoidalCS'), EllipsoidalCSType, scope=EllipsoidalCSRefType))
EllipsoidalCSRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EllipsoidalCSRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'EllipsoidalCS')), min_occurs=1, max_occurs=1)
    )
EllipsoidalCSRefType._ContentModel = pyxb.binding.content.ParticleModel(EllipsoidalCSRefType._GroupModel, min_occurs=0L, max_occurs=1)



GeometryPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Geometry'), AbstractGeometryType, abstract=pyxb.binding.datatypes.boolean(1), scope=GeometryPropertyType, documentation=u'The "_Geometry" element is the abstract head of the substituition group for all geometry elements of GML 3. This \n\t\t\tincludes pre-defined and user-defined geometry elements. Any geometry element must be a direct or indirect extension/restriction \n\t\t\tof AbstractGeometryType and must be directly or indirectly in the substitution group of "_Geometry".'))
GeometryPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeometryPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_Geometry')), min_occurs=1, max_occurs=1)
    )
GeometryPropertyType._ContentModel = pyxb.binding.content.ParticleModel(GeometryPropertyType._GroupModel, min_occurs=0L, max_occurs=1)



TopoVolumeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedTopoSolid'), DirectedTopoSolidPropertyType, scope=TopoVolumeType, documentation=u''))
TopoVolumeType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoVolumeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TopoVolumeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TopoVolumeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
TopoVolumeType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoVolumeType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
TopoVolumeType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoVolumeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedTopoSolid')), min_occurs=1, max_occurs=None)
    )
TopoVolumeType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoVolumeType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TopoVolumeType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
TopoVolumeType._ContentModel = pyxb.binding.content.ParticleModel(TopoVolumeType._GroupModel, min_occurs=1, max_occurs=1)



CTD_ANON._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'posList'), DirectPositionListType, scope=CTD_ANON, documentation=u''))

CTD_ANON._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), PointPropertyType, scope=CTD_ANON, documentation=u'This property element either references a point via the XLink-attributes or contains the point element. pointProperty \n\t\t\tis the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that \n\t\t\tis substitutable for Point.'))

CTD_ANON._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, scope=CTD_ANON, documentation=u''))
CTD_ANON._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(CTD_ANON._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CTD_ANON._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty')), min_occurs=1, max_occurs=1)
    )
CTD_ANON._GroupModel = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(CTD_ANON._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CTD_ANON._GroupModel_, min_occurs=3L, max_occurs=None)
    )
CTD_ANON._ContentModel = pyxb.binding.content.ParticleModel(CTD_ANON._GroupModel, min_occurs=1, max_occurs=1)



GeometricComplexType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'element'), GeometricPrimitivePropertyType, scope=GeometricComplexType))
GeometricComplexType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeometricComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(GeometricComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeometricComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
GeometricComplexType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeometricComplexType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
GeometricComplexType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeometricComplexType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'element')), min_occurs=1, max_occurs=None)
    )
GeometricComplexType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeometricComplexType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeometricComplexType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
GeometricComplexType._ContentModel = pyxb.binding.content.ParticleModel(GeometricComplexType._GroupModel, min_occurs=1, max_occurs=1)



ConcatenatedOperationRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ConcatenatedOperation'), ConcatenatedOperationType, scope=ConcatenatedOperationRefType))
ConcatenatedOperationRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ConcatenatedOperationRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'ConcatenatedOperation')), min_occurs=1, max_occurs=1)
    )
ConcatenatedOperationRefType._ContentModel = pyxb.binding.content.ParticleModel(ConcatenatedOperationRefType._GroupModel, min_occurs=0L, max_occurs=1)



AbstractTimeTopologyPrimitiveType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'complex'), ReferenceType, scope=AbstractTimeTopologyPrimitiveType))
AbstractTimeTopologyPrimitiveType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTimeTopologyPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(AbstractTimeTopologyPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractTimeTopologyPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
AbstractTimeTopologyPrimitiveType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTimeTopologyPrimitiveType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
AbstractTimeTopologyPrimitiveType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTimeTopologyPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime')), min_occurs=0L, max_occurs=None)
    )
AbstractTimeTopologyPrimitiveType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTimeTopologyPrimitiveType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractTimeTopologyPrimitiveType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
AbstractTimeTopologyPrimitiveType._GroupModel_5 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTimeTopologyPrimitiveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'complex')), min_occurs=0L, max_occurs=1)
    )
AbstractTimeTopologyPrimitiveType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbstractTimeTopologyPrimitiveType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbstractTimeTopologyPrimitiveType._GroupModel_5, min_occurs=1, max_occurs=1)
    )
AbstractTimeTopologyPrimitiveType._ContentModel = pyxb.binding.content.ParticleModel(AbstractTimeTopologyPrimitiveType._GroupModel, min_occurs=1, max_occurs=1)



LinearRingType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), PointPropertyType, scope=LinearRingType, documentation=u'This property element either references a point via the XLink-attributes or contains the point element. pointProperty \n\t\t\tis the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that \n\t\t\tis substitutable for Point.'))

LinearRingType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coord'), CoordType, scope=LinearRingType, documentation=u'Deprecated with GML 3.0 and included for backwards compatibility with GML 2. Use the "pos" element instead.'))

LinearRingType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), PointPropertyType, scope=LinearRingType, documentation=u'Deprecated with GML version 3.1.0. Use "pointProperty" instead. Included for backwards compatibility with GML 3.0.0.'))

LinearRingType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'posList'), DirectPositionListType, scope=LinearRingType, documentation=u''))

LinearRingType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, scope=LinearRingType, documentation=u''))

LinearRingType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), CoordinatesType, scope=LinearRingType, documentation=u'Deprecated with GML version 3.1.0.'))
LinearRingType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(LinearRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(LinearRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(LinearRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
LinearRingType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(LinearRingType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
LinearRingType._GroupModel_5 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(LinearRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(LinearRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(LinearRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep')), min_occurs=1, max_occurs=1)
    )
LinearRingType._GroupModel_4 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(LinearRingType._GroupModel_5, min_occurs=4L, max_occurs=None),
    pyxb.binding.content.ParticleModel(LinearRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(LinearRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(LinearRingType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coord')), min_occurs=4L, max_occurs=None)
    )
LinearRingType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(LinearRingType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
LinearRingType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(LinearRingType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(LinearRingType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
LinearRingType._ContentModel = pyxb.binding.content.ParticleModel(LinearRingType._GroupModel, min_occurs=1, max_occurs=1)



GeometryArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Geometry'), AbstractGeometryType, abstract=pyxb.binding.datatypes.boolean(1), scope=GeometryArrayPropertyType, documentation=u'The "_Geometry" element is the abstract head of the substituition group for all geometry elements of GML 3. This \n\t\t\tincludes pre-defined and user-defined geometry elements. Any geometry element must be a direct or indirect extension/restriction \n\t\t\tof AbstractGeometryType and must be directly or indirectly in the substitution group of "_Geometry".'))
GeometryArrayPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeometryArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_Geometry')), min_occurs=0L, max_occurs=None)
    )
GeometryArrayPropertyType._ContentModel = pyxb.binding.content.ParticleModel(GeometryArrayPropertyType._GroupModel, min_occurs=1, max_occurs=1)



ParameterValueType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'stringValue'), pyxb.binding.datatypes.string, scope=ParameterValueType, documentation=u'String value of an operation parameter. A string value does not have an associated unit of measure. '))

ParameterValueType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'valueOfParameter'), OperationParameterRefType, scope=ParameterValueType, documentation=u'Association to the operation parameter that this is a value of. '))

ParameterValueType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'value'), MeasureType, scope=ParameterValueType, documentation=u'Numeric value of an operation parameter, with its associated unit of measure. '))

ParameterValueType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'integerValue'), pyxb.binding.datatypes.positiveInteger, scope=ParameterValueType, documentation=u'Positive integer value of an operation parameter, usually used for a count. An integer value does not have an associated unit of measure. '))

ParameterValueType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'integerValueList'), integerList, scope=ParameterValueType, documentation=u'Ordered sequence of two or more integer values of an operation parameter list, usually used for counts. These integer values do not have an associated unit of measure. An element of this type contains a space-separated sequence of integer values. '))

ParameterValueType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'dmsAngleValue'), DMSAngleType, scope=ParameterValueType, documentation=u'Value of an angle operation parameter, in either degree-minute-second format or single value format. '))

ParameterValueType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'booleanValue'), pyxb.binding.datatypes.boolean, scope=ParameterValueType, documentation=u'Boolean value of an operation parameter. A Boolean value does not have an associated unit of measure. '))

ParameterValueType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'valueFile'), pyxb.binding.datatypes.anyURI, scope=ParameterValueType, documentation=u'Reference to a file or a part of a file containing one or more parameter values, each numeric value with its associated unit of measure. When referencing a part of a file, that file must contain multiple identified parts, such as an XML encoded document. Furthermore, the referenced file or part of a file can reference another part of the same or different files, as allowed in XML documents. '))

ParameterValueType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'valueList'), MeasureListType, scope=ParameterValueType, documentation=u'Ordered sequence of two or more numeric values of an operation parameter list, where each value has the same associated unit of measure. An element of this type contains a space-separated sequence of double values. '))
ParameterValueType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(ParameterValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'value')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ParameterValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dmsAngleValue')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ParameterValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'stringValue')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ParameterValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'integerValue')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ParameterValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'booleanValue')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ParameterValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ParameterValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'integerValueList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ParameterValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueFile')), min_occurs=1, max_occurs=1)
    )
ParameterValueType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ParameterValueType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ParameterValueType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueOfParameter')), min_occurs=1, max_occurs=1)
    )
ParameterValueType._ContentModel = pyxb.binding.content.ParticleModel(ParameterValueType._GroupModel, min_occurs=1, max_occurs=1)



PolygonPatchType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'interior'), AbstractRingPropertyType, scope=PolygonPatchType, documentation=u'A boundary of a surface consists of a number of rings. The "interior" rings seperate the surface / surface patch from the area enclosed by the rings.'))

PolygonPatchType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'exterior'), AbstractRingPropertyType, scope=PolygonPatchType, documentation=u'A boundary of a surface consists of a number of rings. In the normal 2D case, one of these rings is distinguished as being the exterior boundary. In a general manifold this is not always possible, in which case all boundaries shall be listed as interior boundaries, and the exterior will be empty.'))
PolygonPatchType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PolygonPatchType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'exterior')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(PolygonPatchType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'interior')), min_occurs=0L, max_occurs=None)
    )
PolygonPatchType._ContentModel = pyxb.binding.content.ParticleModel(PolygonPatchType._GroupModel, min_occurs=1, max_occurs=1)



EngineeringCRSRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'EngineeringCRS'), EngineeringCRSType, scope=EngineeringCRSRefType))
EngineeringCRSRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EngineeringCRSRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'EngineeringCRS')), min_occurs=1, max_occurs=1)
    )
EngineeringCRSRefType._ContentModel = pyxb.binding.content.ParticleModel(EngineeringCRSRefType._GroupModel, min_occurs=0L, max_occurs=1)



OffsetCurveType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'refDirection'), VectorType, scope=OffsetCurveType, documentation=u'refDistance is used to define the vector\n       direction of the offset curve from the basis curve. It can\n       be omitted in the 2D case, where the distance can be \n       positive or negative. In that case, distance defines left\n       side (positive distance) or right side (negative distance)\n       with respect to the tangent to the basis curve.\n\n       In 3D the basis curve shall have a well defined tangent \n       direction for every point. The offset curve at any point \n       in 3D, the basis curve shall have a well-defined tangent\n       direction for every point. The offset curve at any point\n       (parameter) on the basis curve c is in the direction\n       -   -   -         -               \n       s = v x t  where  v = c.refDirection()  \n       and\n       -\n       t = c.tangent()\n                                                    -\n       For the offset direction to be well-defined, v shall not\n       on any point of the curve be in the same, or opposite, \n       direction as\n       - \n       t.\n\n       The default value of the refDirection shall be the local\n       co-ordinate axis vector for elevation, which indicates up for\n       the curve in a geographic sense.\n\n       NOTE! If the refDirection is the positive tangent to the\n       local elevation axis ("points upward"), then the offset\n       vector points to the left of the curve when viewed from\n       above.'))

OffsetCurveType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'distance'), LengthType, scope=OffsetCurveType, documentation=u'distance is the distance at which the\n\t\t\t\t\t\t\t offset curve is generated from the basis curve. In 2D systems, positive distances\n\t\t\t\t\t\t\t are to be to the left of the basis curve, and the negative distances are to be to the \n\t\t\t\t\t\t\t right of the basis curve.'))

OffsetCurveType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'offsetBase'), CurvePropertyType, scope=OffsetCurveType, documentation=u'offsetBase is a reference to thecurve from which this\n\t\t\t\t\t\t\t curve is define\tas an offset.'))
OffsetCurveType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(OffsetCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'offsetBase')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(OffsetCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'distance')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(OffsetCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'refDirection')), min_occurs=0L, max_occurs=1)
    )
OffsetCurveType._ContentModel = pyxb.binding.content.ParticleModel(OffsetCurveType._GroupModel, min_occurs=1, max_occurs=1)



ConversionToPreferredUnitType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'factor'), pyxb.binding.datatypes.double, scope=ConversionToPreferredUnitType, documentation=u'Specification of the scale factor by which a value using this unit of measure can be multiplied to obtain the corresponding value using the preferred unit of measure.'))

ConversionToPreferredUnitType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'formula'), FormulaType, scope=ConversionToPreferredUnitType, documentation=u'Specification of the formula by which a value using this unit of measure can be converted to obtain the corresponding value using the preferred unit of measure.'))
ConversionToPreferredUnitType._GroupModel = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(ConversionToPreferredUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'factor')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ConversionToPreferredUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'formula')), min_occurs=1, max_occurs=1)
    )
ConversionToPreferredUnitType._ContentModel = pyxb.binding.content.ParticleModel(ConversionToPreferredUnitType._GroupModel, min_occurs=1, max_occurs=1)



GridLimitsType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GridEnvelope'), GridEnvelopeType, scope=GridLimitsType))
GridLimitsType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GridLimitsType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'GridEnvelope')), min_occurs=1, max_occurs=1)
    )
GridLimitsType._ContentModel = pyxb.binding.content.ParticleModel(GridLimitsType._GroupModel, min_occurs=1, max_occurs=1)



CoordinateSystemRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_CoordinateSystem'), AbstractCoordinateSystemType, abstract=pyxb.binding.datatypes.boolean(1), scope=CoordinateSystemRefType))
CoordinateSystemRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CoordinateSystemRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_CoordinateSystem')), min_occurs=1, max_occurs=1)
    )
CoordinateSystemRefType._ContentModel = pyxb.binding.content.ParticleModel(CoordinateSystemRefType._GroupModel, min_occurs=0L, max_occurs=1)



CompositeCurvePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CompositeCurve'), CompositeCurveType, scope=CompositeCurvePropertyType))
CompositeCurvePropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CompositeCurvePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CompositeCurve')), min_occurs=1, max_occurs=1)
    )
CompositeCurvePropertyType._ContentModel = pyxb.binding.content.ParticleModel(CompositeCurvePropertyType._GroupModel, min_occurs=0L, max_occurs=1)



DirectionPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DirectionVector'), DirectionVectorType, scope=DirectionPropertyType))

DirectionPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DirectionString'), StringOrRefType, scope=DirectionPropertyType))

DirectionPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CompassPoint'), CompassPointEnumeration, scope=DirectionPropertyType))

DirectionPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DirectionKeyword'), CodeType, scope=DirectionPropertyType))
DirectionPropertyType._GroupModel = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(DirectionPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'DirectionVector')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DirectionPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CompassPoint')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DirectionPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'DirectionKeyword')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DirectionPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'DirectionString')), min_occurs=1, max_occurs=1)
    )
DirectionPropertyType._ContentModel = pyxb.binding.content.ParticleModel(DirectionPropertyType._GroupModel, min_occurs=1, max_occurs=1)



CompositeSurfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'surfaceMember'), SurfacePropertyType, scope=CompositeSurfaceType, documentation=u'This property element either references a surface via the XLink-attributes or contains the surface element. A surface element is any element which is substitutable for "_Surface".'))
CompositeSurfaceType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CompositeSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(CompositeSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(CompositeSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
CompositeSurfaceType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CompositeSurfaceType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
CompositeSurfaceType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CompositeSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'surfaceMember')), min_occurs=1, max_occurs=None)
    )
CompositeSurfaceType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CompositeSurfaceType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CompositeSurfaceType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
CompositeSurfaceType._ContentModel = pyxb.binding.content.ParticleModel(CompositeSurfaceType._GroupModel, min_occurs=1, max_occurs=1)



LinearRingPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'LinearRing'), LinearRingType, scope=LinearRingPropertyType))
LinearRingPropertyType._GroupModel = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(LinearRingPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'LinearRing')), min_occurs=1, max_occurs=1)
    )
LinearRingPropertyType._ContentModel = pyxb.binding.content.ParticleModel(LinearRingPropertyType._GroupModel, min_occurs=1, max_occurs=1)



GeometricComplexPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GeometricComplex'), GeometricComplexType, scope=GeometricComplexPropertyType))

GeometricComplexPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CompositeCurve'), CompositeCurveType, scope=GeometricComplexPropertyType))

GeometricComplexPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CompositeSolid'), CompositeSolidType, scope=GeometricComplexPropertyType))

GeometricComplexPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CompositeSurface'), CompositeSurfaceType, scope=GeometricComplexPropertyType))
GeometricComplexPropertyType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(GeometricComplexPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'GeometricComplex')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeometricComplexPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CompositeCurve')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeometricComplexPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CompositeSurface')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeometricComplexPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CompositeSolid')), min_occurs=1, max_occurs=1)
    )
GeometricComplexPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeometricComplexPropertyType._GroupModel_, min_occurs=1, max_occurs=1)
    )
GeometricComplexPropertyType._ContentModel = pyxb.binding.content.ParticleModel(GeometricComplexPropertyType._GroupModel, min_occurs=0L, max_occurs=1)



LinearCSRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'LinearCS'), LinearCSType, scope=LinearCSRefType))
LinearCSRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(LinearCSRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'LinearCS')), min_occurs=1, max_occurs=1)
    )
LinearCSRefType._ContentModel = pyxb.binding.content.ParticleModel(LinearCSRefType._GroupModel, min_occurs=0L, max_occurs=1)



MultiSolidType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'solidMember'), SolidPropertyType, scope=MultiSolidType, documentation=u'This property element either references a solid via the XLink-attributes or contains the solid element. A solid element is any element which is substitutable for "_Solid".'))

MultiSolidType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'solidMembers'), SolidArrayPropertyType, scope=MultiSolidType, documentation=u'This property element contains a list of solids. The order of the elements is significant and shall be preserved when processing the array.'))
MultiSolidType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(MultiSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
MultiSolidType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiSolidType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
MultiSolidType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'solidMember')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(MultiSolidType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'solidMembers')), min_occurs=0L, max_occurs=1)
    )
MultiSolidType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiSolidType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiSolidType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
MultiSolidType._ContentModel = pyxb.binding.content.ParticleModel(MultiSolidType._GroupModel, min_occurs=1, max_occurs=1)



MultiLineStringPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiLineString'), MultiLineStringType, scope=MultiLineStringPropertyType, documentation=u'Deprecated with GML 3.0 and included for backwards compatibility with GML 2. Use the "MultiCurve" element instead.'))
MultiLineStringPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiLineStringPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'MultiLineString')), min_occurs=1, max_occurs=1)
    )
MultiLineStringPropertyType._ContentModel = pyxb.binding.content.ParticleModel(MultiLineStringPropertyType._GroupModel, min_occurs=0L, max_occurs=1)



DataBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'tupleList'), CoordinatesType, scope=DataBlockType))

DataBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'doubleOrNullTupleList'), doubleOrNullList, scope=DataBlockType))

DataBlockType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'rangeParameters'), RangeParametersType, scope=DataBlockType))
DataBlockType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(DataBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'tupleList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DataBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'doubleOrNullTupleList')), min_occurs=1, max_occurs=1)
    )
DataBlockType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DataBlockType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rangeParameters')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DataBlockType._GroupModel_, min_occurs=1, max_occurs=1)
    )
DataBlockType._ContentModel = pyxb.binding.content.ParticleModel(DataBlockType._GroupModel, min_occurs=1, max_occurs=1)



TinType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'controlPoint'), CTD_ANON, scope=TinType, documentation=u'The corners of the triangles in the TIN \n  are often referred to as pots. ControlPoint shall contain a \n  set of the GM_Position used as posts for this TIN. Since each  \n  TIN contains triangles, there must be at least 3 posts. The \n       order in which these points are given does not affect the \n       surface that is represented. Application schemas may add \n       information based on ordering of control points to facilitate \n       the reconstruction of the TIN from the control points.'))

TinType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'breakLines'), LineStringSegmentArrayPropertyType, scope=TinType, documentation=u'Breaklines are lines of a critical\n       nature to the shape of the surface, representing local\n       ridges, or depressions (such as drainage lines) in the\n       surface. As such their constituent segments must be\n       included in the tin eve if doing so\n       violates the Delauny criterion. Break lines contains these\n       critical segments as a set of line strings.'))

TinType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'stopLines'), LineStringSegmentArrayPropertyType, scope=TinType, documentation=u'Stoplines are lines where the local\n       continuity or regularity of the surface is questionable.\n       In the area of these pathologies, triangles intersecting\n       a stopline shall be removed from the tin surface, leaving\n       holes in the surface. If coincidence occurs on surface\n       boundary triangles, the result shall be a change of the \n       surface boundary. Stoplines contains all these\n       pathological segments as a set of line strings.'))

TinType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maxLength'), LengthType, scope=TinType, documentation=u'Areas of the surface where data is not \n       sufficiently dense to assure reasonable calculation shall be    \n       removed by adding a retention criterion for triangles based \n       on the length of their sides. For many triangle sides  \n       exceeding maximum length, the adjacent triangles to that \n       triangle side shall be removed from the surface.'))
TinType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TinType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TinType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TinType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
TinType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TinType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TinType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'trianglePatches')), min_occurs=1, max_occurs=1)
    )
TinType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TinType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'stopLines')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TinType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'breakLines')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TinType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maxLength')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TinType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'controlPoint')), min_occurs=1, max_occurs=1)
    )
TinType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TinType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TinType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
TinType._ContentModel = pyxb.binding.content.ParticleModel(TinType._GroupModel, min_occurs=1, max_occurs=1)



TopologyStylePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopologyStyle'), TopologyStyleType, scope=TopologyStylePropertyType, documentation=u'The style descriptor for topologies of a feature. Describes individual topology elements styles.'))
TopologyStylePropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopologyStylePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TopologyStyle')), min_occurs=0L, max_occurs=1)
    )
TopologyStylePropertyType._ContentModel = pyxb.binding.content.ParticleModel(TopologyStylePropertyType._GroupModel, min_occurs=1, max_occurs=1)


CylinderType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CylinderType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'row')), min_occurs=1, max_occurs=None)
    )
CylinderType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CylinderType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CylinderType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rows')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(CylinderType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'columns')), min_occurs=0L, max_occurs=1)
    )
CylinderType._ContentModel = pyxb.binding.content.ParticleModel(CylinderType._GroupModel, min_occurs=1, max_occurs=1)



LabelStyleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'style'), pyxb.binding.datatypes.string, scope=LabelStyleType))

LabelStyleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'label'), LabelType, scope=LabelStyleType))
LabelStyleType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(LabelStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(LabelStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(LabelStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
LabelStyleType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(LabelStyleType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
LabelStyleType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(LabelStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'spatialResolution')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(LabelStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'styleVariation')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(LabelStyleType._UseForTag(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'animate')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(LabelStyleType._UseForTag(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'animateMotion')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(LabelStyleType._UseForTag(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'animateColor')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(LabelStyleType._UseForTag(pyxb.namespace.ExpandedName(pyxb.namespace.NamespaceForURI(u'http://www.w3.org/2001/SMIL20/'), u'set')), min_occurs=0L, max_occurs=None)
    )
LabelStyleType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(LabelStyleType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(LabelStyleType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
LabelStyleType._GroupModel_5 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(LabelStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'style')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(LabelStyleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'label')), min_occurs=1, max_occurs=1)
    )
LabelStyleType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(LabelStyleType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(LabelStyleType._GroupModel_5, min_occurs=1, max_occurs=1)
    )
LabelStyleType._ContentModel = pyxb.binding.content.ParticleModel(LabelStyleType._GroupModel, min_occurs=1, max_occurs=1)



ReferenceSystemRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_ReferenceSystem'), AbstractReferenceSystemType, abstract=pyxb.binding.datatypes.boolean(1), scope=ReferenceSystemRefType))
ReferenceSystemRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ReferenceSystemRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_ReferenceSystem')), min_occurs=1, max_occurs=1)
    )
ReferenceSystemRefType._ContentModel = pyxb.binding.content.ParticleModel(ReferenceSystemRefType._GroupModel, min_occurs=0L, max_occurs=1)


TemporalDatumBaseType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TemporalDatumBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TemporalDatumBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'datumName')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TemporalDatumBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'datumID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TemporalDatumBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validArea')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TemporalDatumBaseType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope')), min_occurs=0L, max_occurs=1)
    )
TemporalDatumBaseType._ContentModel = pyxb.binding.content.ParticleModel(TemporalDatumBaseType._GroupModel, min_occurs=1, max_occurs=1)



TemporalDatumType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'origin'), pyxb.binding.datatypes.dateTime, scope=TemporalDatumType, documentation=u'The date and time origin of this temporal datum. '))
TemporalDatumType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TemporalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TemporalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'datumName')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TemporalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'datumID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TemporalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validArea')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TemporalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope')), min_occurs=0L, max_occurs=1)
    )
TemporalDatumType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TemporalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'origin')), min_occurs=1, max_occurs=1)
    )
TemporalDatumType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TemporalDatumType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TemporalDatumType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
TemporalDatumType._ContentModel = pyxb.binding.content.ParticleModel(TemporalDatumType._GroupModel, min_occurs=1, max_occurs=1)



DMSAngleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'seconds'), ArcSecondsType, scope=DMSAngleType))

DMSAngleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minutes'), ArcMinutesType, scope=DMSAngleType))

DMSAngleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'decimalMinutes'), DecimalMinutesType, scope=DMSAngleType))

DMSAngleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'degrees'), DegreesType, scope=DMSAngleType))
DMSAngleType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DMSAngleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minutes')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DMSAngleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'seconds')), min_occurs=0L, max_occurs=1)
    )
DMSAngleType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(DMSAngleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'decimalMinutes')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DMSAngleType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
DMSAngleType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DMSAngleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'degrees')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DMSAngleType._GroupModel_, min_occurs=0L, max_occurs=1)
    )
DMSAngleType._ContentModel = pyxb.binding.content.ParticleModel(DMSAngleType._GroupModel, min_occurs=1, max_occurs=1)



TimeEdgeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'extent'), TimePeriodPropertyType, scope=TimeEdgeType))

TimeEdgeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'start'), TimeNodePropertyType, scope=TimeEdgeType))

TimeEdgeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'end'), TimeNodePropertyType, scope=TimeEdgeType))
TimeEdgeType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
TimeEdgeType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeEdgeType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
TimeEdgeType._GroupModel_5 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime')), min_occurs=0L, max_occurs=None)
    )
TimeEdgeType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeEdgeType._GroupModel_3, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeEdgeType._GroupModel_5, min_occurs=1, max_occurs=1)
    )
TimeEdgeType._GroupModel_6 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'complex')), min_occurs=0L, max_occurs=1)
    )
TimeEdgeType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeEdgeType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeEdgeType._GroupModel_6, min_occurs=1, max_occurs=1)
    )
TimeEdgeType._GroupModel_7 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'start')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'end')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeEdgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'extent')), min_occurs=0L, max_occurs=1)
    )
TimeEdgeType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeEdgeType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeEdgeType._GroupModel_7, min_occurs=1, max_occurs=1)
    )
TimeEdgeType._ContentModel = pyxb.binding.content.ParticleModel(TimeEdgeType._GroupModel, min_occurs=1, max_occurs=1)



TimeCoordinateSystemType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'originPosition'), TimePositionType, scope=TimeCoordinateSystemType))

TimeCoordinateSystemType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'origin'), TimeInstantPropertyType, scope=TimeCoordinateSystemType))

TimeCoordinateSystemType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'interval'), TimeIntervalLengthType, scope=TimeCoordinateSystemType))
TimeCoordinateSystemType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TimeCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=1, max_occurs=None)
    )
TimeCoordinateSystemType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity')), min_occurs=0L, max_occurs=1)
    )
TimeCoordinateSystemType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeCoordinateSystemType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeCoordinateSystemType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
TimeCoordinateSystemType._GroupModel_5 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(TimeCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'originPosition')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'origin')), min_occurs=1, max_occurs=1)
    )
TimeCoordinateSystemType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeCoordinateSystemType._GroupModel_5, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeCoordinateSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'interval')), min_occurs=1, max_occurs=1)
    )
TimeCoordinateSystemType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeCoordinateSystemType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeCoordinateSystemType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
TimeCoordinateSystemType._ContentModel = pyxb.binding.content.ParticleModel(TimeCoordinateSystemType._GroupModel, min_occurs=1, max_occurs=1)



KnotType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'weight'), pyxb.binding.datatypes.double, scope=KnotType, documentation=u'The property "weight" is the value of the averaging weight used for this knot of the spline.'))

KnotType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiplicity'), pyxb.binding.datatypes.nonNegativeInteger, scope=KnotType, documentation=u'The property "multiplicity" is the multiplicity of this knot used in the definition of the spline (with the same weight).'))

KnotType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'value'), pyxb.binding.datatypes.double, scope=KnotType, documentation=u'The property "value" is the value of the parameter at the knot of the spline. The sequence of knots shall be a non-decreasing sequence. That is, each knot\'s value in the sequence shall be equal to or greater than the previous knot\'s value. The use of equal consecutive knots is normally handled using the multiplicity.'))
KnotType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(KnotType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'value')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(KnotType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiplicity')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(KnotType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'weight')), min_occurs=1, max_occurs=1)
    )
KnotType._ContentModel = pyxb.binding.content.ParticleModel(KnotType._GroupModel, min_occurs=1, max_occurs=1)



TriangleType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'exterior'), AbstractRingPropertyType, scope=TriangleType, documentation=u'A boundary of a surface consists of a number of rings. In the normal 2D case, one of these rings is distinguished as being the exterior boundary. In a general manifold this is not always possible, in which case all boundaries shall be listed as interior boundaries, and the exterior will be empty.'))
TriangleType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TriangleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'exterior')), min_occurs=1, max_occurs=1)
    )
TriangleType._ContentModel = pyxb.binding.content.ParticleModel(TriangleType._GroupModel, min_occurs=1, max_occurs=1)



ArrayAssociationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Object'), pyxb.binding.datatypes.anyType, abstract=pyxb.binding.datatypes.boolean(1), scope=ArrayAssociationType, documentation=u'This abstract element is the head of a substitutionGroup hierararchy which may contain either simpleContent or complexContent elements.  It is used to assert the model position of "class" elements declared in other GML schemas.'))
ArrayAssociationType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ArrayAssociationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_Object')), min_occurs=0L, max_occurs=None)
    )
ArrayAssociationType._ContentModel = pyxb.binding.content.ParticleModel(ArrayAssociationType._GroupModel, min_occurs=1, max_occurs=1)



MultiPointDomainType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiPoint'), MultiPointType, scope=MultiPointDomainType))
MultiPointDomainType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiPointDomainType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'MultiPoint')), min_occurs=1, max_occurs=1)
    )
MultiPointDomainType._ContentModel = pyxb.binding.content.ParticleModel(MultiPointDomainType._GroupModel, min_occurs=0L, max_occurs=1)



OperationRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Operation'), AbstractCoordinateOperationType, abstract=pyxb.binding.datatypes.boolean(1), scope=OperationRefType, documentation=u'A parameterized mathematical operation on coordinates that transforms or converts coordinates to another coordinate reference system. This coordinate operation uses an operation method, usually with associated parameter values. However, operation methods and parameter values are directly associated with concrete subtypes, not with this abstract type.\n\nThis abstract complexType shall not be directly used, extended, or restricted in a compliant Application Schema. '))
OperationRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(OperationRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_Operation')), min_occurs=1, max_occurs=1)
    )
OperationRefType._ContentModel = pyxb.binding.content.ParticleModel(OperationRefType._GroupModel, min_occurs=0L, max_occurs=1)



TimeOrdinalReferenceSystemType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'component'), TimeOrdinalEraPropertyType, scope=TimeOrdinalReferenceSystemType))
TimeOrdinalReferenceSystemType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeOrdinalReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TimeOrdinalReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeOrdinalReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=1, max_occurs=None)
    )
TimeOrdinalReferenceSystemType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeOrdinalReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity')), min_occurs=0L, max_occurs=1)
    )
TimeOrdinalReferenceSystemType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeOrdinalReferenceSystemType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeOrdinalReferenceSystemType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
TimeOrdinalReferenceSystemType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeOrdinalReferenceSystemType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'component')), min_occurs=1, max_occurs=None)
    )
TimeOrdinalReferenceSystemType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeOrdinalReferenceSystemType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeOrdinalReferenceSystemType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
TimeOrdinalReferenceSystemType._ContentModel = pyxb.binding.content.ParticleModel(TimeOrdinalReferenceSystemType._GroupModel, min_occurs=1, max_occurs=1)



ImageCRSRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ImageCRS'), ImageCRSType, scope=ImageCRSRefType))
ImageCRSRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ImageCRSRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'ImageCRS')), min_occurs=1, max_occurs=1)
    )
ImageCRSRefType._ContentModel = pyxb.binding.content.ParticleModel(ImageCRSRefType._GroupModel, min_occurs=0L, max_occurs=1)


EngineeringDatumType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EngineeringDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(EngineeringDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'datumName')), min_occurs=1, max_occurs=1)
    )
EngineeringDatumType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EngineeringDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'datumID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(EngineeringDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(EngineeringDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'anchorPoint')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(EngineeringDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'realizationEpoch')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(EngineeringDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validArea')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(EngineeringDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope')), min_occurs=0L, max_occurs=1)
    )
EngineeringDatumType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(EngineeringDatumType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(EngineeringDatumType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
EngineeringDatumType._ContentModel = pyxb.binding.content.ParticleModel(EngineeringDatumType._GroupModel, min_occurs=1, max_occurs=1)



TimeOrdinalEraPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeOrdinalEra'), TimeOrdinalEraType, scope=TimeOrdinalEraPropertyType))
TimeOrdinalEraPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeOrdinalEraPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TimeOrdinalEra')), min_occurs=1, max_occurs=1)
    )
TimeOrdinalEraPropertyType._ContentModel = pyxb.binding.content.ParticleModel(TimeOrdinalEraPropertyType._GroupModel, min_occurs=0L, max_occurs=1)



TimeOrdinalEraType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'group'), ReferenceType, scope=TimeOrdinalEraType, documentation=u'In a particular Time System, an Era may be a member of a group.  The "group" element implements the back-pointer to the Era at the next level up in the hierarchy. \n\nIf the hierarchy is represented by describing the nested components fully in the their nested position inside "member" elements, then the parent can be easily inferred, so the group property is unnecessary.  \n\nHowever, if the hierarchy is represented by links carried on the "member" property elements, pointing to Eras described fully elsewhere, then it may be useful for a child (member) era to carry an explicit pointer back to its parent (group) Era.'))

TimeOrdinalEraType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'end'), TimeNodePropertyType, scope=TimeOrdinalEraType))

TimeOrdinalEraType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'extent'), TimePeriodPropertyType, scope=TimeOrdinalEraType))

TimeOrdinalEraType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'start'), TimeNodePropertyType, scope=TimeOrdinalEraType))

TimeOrdinalEraType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'member'), TimeOrdinalEraPropertyType, scope=TimeOrdinalEraType, documentation=u'An Era may be composed of several member Eras. The "member" element implements the association to the Era at the next level down the hierarchy.  "member" follows the standard GML property pattern whereby its (complex) value may be either described fully inline, or may be the target of a link carried on the member element and described fully elsewhere, either in the same document or from another service.'))

TimeOrdinalEraType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'relatedTime'), RelatedTimeType, scope=TimeOrdinalEraType))
TimeOrdinalEraType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=1, max_occurs=None)
    )
TimeOrdinalEraType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'start')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'end')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'extent')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'member')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TimeOrdinalEraType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'group')), min_occurs=0L, max_occurs=1)
    )
TimeOrdinalEraType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeOrdinalEraType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeOrdinalEraType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
TimeOrdinalEraType._ContentModel = pyxb.binding.content.ParticleModel(TimeOrdinalEraType._GroupModel, min_occurs=1, max_occurs=1)



DerivedCRSRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'DerivedCRS'), DerivedCRSType, scope=DerivedCRSRefType))
DerivedCRSRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DerivedCRSRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'DerivedCRS')), min_occurs=1, max_occurs=1)
    )
DerivedCRSRefType._ContentModel = pyxb.binding.content.ParticleModel(DerivedCRSRefType._GroupModel, min_occurs=0L, max_occurs=1)



RingPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Ring'), RingType, scope=RingPropertyType))
RingPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(RingPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Ring')), min_occurs=1, max_occurs=1)
    )
RingPropertyType._ContentModel = pyxb.binding.content.ParticleModel(RingPropertyType._GroupModel, min_occurs=1, max_occurs=1)


RelatedTimeType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(RelatedTimeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_TimePrimitive')), min_occurs=1, max_occurs=1)
    )
RelatedTimeType._ContentModel = pyxb.binding.content.ParticleModel(RelatedTimeType._GroupModel, min_occurs=0L, max_occurs=1)


CartesianCSType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(CartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'csName')), min_occurs=1, max_occurs=1)
    )
CartesianCSType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'csID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(CartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(CartesianCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesAxis')), min_occurs=1, max_occurs=None)
    )
CartesianCSType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CartesianCSType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CartesianCSType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
CartesianCSType._ContentModel = pyxb.binding.content.ParticleModel(CartesianCSType._GroupModel, min_occurs=1, max_occurs=1)



TopoPrimitiveArrayAssociationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_TopoPrimitive'), AbstractTopoPrimitiveType, abstract=pyxb.binding.datatypes.boolean(1), scope=TopoPrimitiveArrayAssociationType, documentation=u'Substitution group branch for Topo Primitives, used by TopoPrimitiveArrayAssociationType'))
TopoPrimitiveArrayAssociationType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(TopoPrimitiveArrayAssociationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_TopoPrimitive')), min_occurs=1, max_occurs=1)
    )
TopoPrimitiveArrayAssociationType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoPrimitiveArrayAssociationType._GroupModel_, min_occurs=0L, max_occurs=None)
    )
TopoPrimitiveArrayAssociationType._ContentModel = pyxb.binding.content.ParticleModel(TopoPrimitiveArrayAssociationType._GroupModel, min_occurs=1, max_occurs=1)



ImageDatumRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'ImageDatum'), ImageDatumType, scope=ImageDatumRefType))
ImageDatumRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ImageDatumRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'ImageDatum')), min_occurs=1, max_occurs=1)
    )
ImageDatumRefType._ContentModel = pyxb.binding.content.ParticleModel(ImageDatumRefType._GroupModel, min_occurs=0L, max_occurs=1)



TopoPointType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'directedNode'), DirectedNodePropertyType, scope=TopoPointType, documentation=u''))
TopoPointType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TopoPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TopoPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
TopoPointType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoPointType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
TopoPointType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoPointType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'directedNode')), min_occurs=1, max_occurs=1)
    )
TopoPointType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoPointType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TopoPointType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
TopoPointType._ContentModel = pyxb.binding.content.ParticleModel(TopoPointType._GroupModel, min_occurs=1, max_occurs=1)



DerivedUnitType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'derivationUnitTerm'), DerivationUnitTermType, scope=DerivedUnitType))
DerivedUnitType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=1, max_occurs=None)
    )
DerivedUnitType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'quantityType')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'catalogSymbol')), min_occurs=0L, max_occurs=1)
    )
DerivedUnitType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DerivedUnitType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DerivedUnitType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
DerivedUnitType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DerivedUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'derivationUnitTerm')), min_occurs=1, max_occurs=None)
    )
DerivedUnitType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DerivedUnitType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DerivedUnitType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
DerivedUnitType._ContentModel = pyxb.binding.content.ParticleModel(DerivedUnitType._GroupModel, min_occurs=1, max_occurs=1)



TimeInstantType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'timePosition'), TimePositionType, scope=TimeInstantType, documentation=u'Direct representation of a temporal position'))
TimeInstantType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeInstantType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TimeInstantType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeInstantType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
TimeInstantType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeInstantType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
TimeInstantType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeInstantType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime')), min_occurs=0L, max_occurs=None)
    )
TimeInstantType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeInstantType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeInstantType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
TimeInstantType._GroupModel_5 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeInstantType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'timePosition')), min_occurs=1, max_occurs=1)
    )
TimeInstantType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeInstantType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeInstantType._GroupModel_5, min_occurs=1, max_occurs=1)
    )
TimeInstantType._ContentModel = pyxb.binding.content.ParticleModel(TimeInstantType._GroupModel, min_occurs=1, max_occurs=1)



GeometryStylePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GeometryStyle'), GeometryStyleType, scope=GeometryStylePropertyType, documentation=u'The style descriptor for geometries of a feature.'))
GeometryStylePropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeometryStylePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'GeometryStyle')), min_occurs=0L, max_occurs=1)
    )
GeometryStylePropertyType._ContentModel = pyxb.binding.content.ParticleModel(GeometryStylePropertyType._GroupModel, min_occurs=1, max_occurs=1)



TimeCalendarType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'referenceFrame'), TimeCalendarEraPropertyType, scope=TimeCalendarType, documentation=u'Link to the CalendarEras that it uses as a reference for dating.'))
TimeCalendarType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeCalendarType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TimeCalendarType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeCalendarType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=1, max_occurs=None)
    )
TimeCalendarType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeCalendarType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domainOfValidity')), min_occurs=0L, max_occurs=1)
    )
TimeCalendarType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeCalendarType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeCalendarType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
TimeCalendarType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeCalendarType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'referenceFrame')), min_occurs=1, max_occurs=None)
    )
TimeCalendarType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeCalendarType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeCalendarType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
TimeCalendarType._ContentModel = pyxb.binding.content.ParticleModel(TimeCalendarType._GroupModel, min_occurs=1, max_occurs=1)



VerticalDatumType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'verticalDatumType'), VerticalDatumTypeType, scope=VerticalDatumType))
VerticalDatumType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(VerticalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(VerticalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'datumName')), min_occurs=1, max_occurs=1)
    )
VerticalDatumType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(VerticalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'datumID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(VerticalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(VerticalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'anchorPoint')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(VerticalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'realizationEpoch')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(VerticalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validArea')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(VerticalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope')), min_occurs=0L, max_occurs=1)
    )
VerticalDatumType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(VerticalDatumType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(VerticalDatumType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
VerticalDatumType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(VerticalDatumType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'verticalDatumType')), min_occurs=0L, max_occurs=1)
    )
VerticalDatumType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(VerticalDatumType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(VerticalDatumType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
VerticalDatumType._ContentModel = pyxb.binding.content.ParticleModel(VerticalDatumType._GroupModel, min_occurs=1, max_occurs=1)



CoordinateSystemAxisRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CoordinateSystemAxis'), CoordinateSystemAxisType, scope=CoordinateSystemAxisRefType))
CoordinateSystemAxisRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CoordinateSystemAxisRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CoordinateSystemAxis')), min_occurs=1, max_occurs=1)
    )
CoordinateSystemAxisRefType._ContentModel = pyxb.binding.content.ParticleModel(CoordinateSystemAxisRefType._GroupModel, min_occurs=0L, max_occurs=1)



SolidArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Solid'), AbstractSolidType, abstract=pyxb.binding.datatypes.boolean(1), scope=SolidArrayPropertyType, documentation=u'The "_Solid" element is the abstract head of the substituition group for all (continuous) solid elements.'))
SolidArrayPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(SolidArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_Solid')), min_occurs=1, max_occurs=1)
    )
SolidArrayPropertyType._ContentModel = pyxb.binding.content.ParticleModel(SolidArrayPropertyType._GroupModel, min_occurs=0L, max_occurs=None)



TimeCalendarEraPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TimeCalendarEra'), TimeCalendarEraType, scope=TimeCalendarEraPropertyType))
TimeCalendarEraPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeCalendarEraPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TimeCalendarEra')), min_occurs=1, max_occurs=1)
    )
TimeCalendarEraPropertyType._ContentModel = pyxb.binding.content.ParticleModel(TimeCalendarEraPropertyType._GroupModel, min_occurs=0L, max_occurs=1)



OrientableCurveType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'baseCurve'), CurvePropertyType, scope=OrientableCurveType, documentation=u'This property element either references a curve via the XLink-attributes or contains the curve element. A curve element is any element which is substitutable for "_Curve".'))
OrientableCurveType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(OrientableCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(OrientableCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(OrientableCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
OrientableCurveType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(OrientableCurveType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
OrientableCurveType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(OrientableCurveType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'baseCurve')), min_occurs=1, max_occurs=1)
    )
OrientableCurveType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(OrientableCurveType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(OrientableCurveType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
OrientableCurveType._ContentModel = pyxb.binding.content.ParticleModel(OrientableCurveType._GroupModel, min_occurs=1, max_occurs=1)



TopoPrimitiveMemberType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_TopoPrimitive'), AbstractTopoPrimitiveType, abstract=pyxb.binding.datatypes.boolean(1), scope=TopoPrimitiveMemberType, documentation=u'Substitution group branch for Topo Primitives, used by TopoPrimitiveArrayAssociationType'))
TopoPrimitiveMemberType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoPrimitiveMemberType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_TopoPrimitive')), min_occurs=0L, max_occurs=1)
    )
TopoPrimitiveMemberType._ContentModel = pyxb.binding.content.ParticleModel(TopoPrimitiveMemberType._GroupModel, min_occurs=1, max_occurs=1)


TemporalCSType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TemporalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TemporalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'csName')), min_occurs=1, max_occurs=1)
    )
TemporalCSType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TemporalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'csID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TemporalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TemporalCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesAxis')), min_occurs=1, max_occurs=None)
    )
TemporalCSType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TemporalCSType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TemporalCSType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
TemporalCSType._ContentModel = pyxb.binding.content.ParticleModel(TemporalCSType._GroupModel, min_occurs=1, max_occurs=1)



CompositeSolidPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CompositeSolid'), CompositeSolidType, scope=CompositeSolidPropertyType))
CompositeSolidPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CompositeSolidPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CompositeSolid')), min_occurs=1, max_occurs=1)
    )
CompositeSolidPropertyType._ContentModel = pyxb.binding.content.ParticleModel(CompositeSolidPropertyType._GroupModel, min_occurs=0L, max_occurs=1)



AbsoluteExternalPositionalAccuracyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'result'), MeasureType, scope=AbsoluteExternalPositionalAccuracyType, documentation=u'A quantitative result defined by the evaluation procedure used, and identified by the measureDescription. '))
AbsoluteExternalPositionalAccuracyType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbsoluteExternalPositionalAccuracyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'measureDescription')), min_occurs=0L, max_occurs=1)
    )
AbsoluteExternalPositionalAccuracyType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbsoluteExternalPositionalAccuracyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'result')), min_occurs=1, max_occurs=1)
    )
AbsoluteExternalPositionalAccuracyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(AbsoluteExternalPositionalAccuracyType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(AbsoluteExternalPositionalAccuracyType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
AbsoluteExternalPositionalAccuracyType._ContentModel = pyxb.binding.content.ParticleModel(AbsoluteExternalPositionalAccuracyType._GroupModel, min_occurs=1, max_occurs=1)



TimeNodeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'nextEdge'), TimeEdgePropertyType, scope=TimeNodeType))

TimeNodeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'position'), TimeInstantPropertyType, scope=TimeNodeType))

TimeNodeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'previousEdge'), TimeEdgePropertyType, scope=TimeNodeType))
TimeNodeType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
TimeNodeType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeNodeType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
TimeNodeType._GroupModel_5 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'relatedTime')), min_occurs=0L, max_occurs=None)
    )
TimeNodeType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeNodeType._GroupModel_3, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeNodeType._GroupModel_5, min_occurs=1, max_occurs=1)
    )
TimeNodeType._GroupModel_6 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'complex')), min_occurs=0L, max_occurs=1)
    )
TimeNodeType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeNodeType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeNodeType._GroupModel_6, min_occurs=1, max_occurs=1)
    )
TimeNodeType._GroupModel_7 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'previousEdge')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'nextEdge')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TimeNodeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'position')), min_occurs=0L, max_occurs=1)
    )
TimeNodeType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeNodeType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TimeNodeType._GroupModel_7, min_occurs=1, max_occurs=1)
    )
TimeNodeType._ContentModel = pyxb.binding.content.ParticleModel(TimeNodeType._GroupModel, min_occurs=1, max_occurs=1)



MovingObjectStatusType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'elevation'), MeasureType, scope=MovingObjectStatusType))

MovingObjectStatusType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'bearing'), DirectionPropertyType, scope=MovingObjectStatusType))

MovingObjectStatusType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'speed'), MeasureType, scope=MovingObjectStatusType))

MovingObjectStatusType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'status'), StringOrRefType, scope=MovingObjectStatusType))

MovingObjectStatusType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'location'), LocationPropertyType, scope=MovingObjectStatusType, documentation=u'Deprecated in GML 3.1.0'))

MovingObjectStatusType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'acceleration'), MeasureType, scope=MovingObjectStatusType))
MovingObjectStatusType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
MovingObjectStatusType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MovingObjectStatusType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
MovingObjectStatusType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSource')), min_occurs=0L, max_occurs=1)
    )
MovingObjectStatusType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MovingObjectStatusType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(MovingObjectStatusType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
MovingObjectStatusType._GroupModel_5 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'speed')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'bearing')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'acceleration')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'elevation')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(MovingObjectStatusType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'status')), min_occurs=0L, max_occurs=1)
    )
MovingObjectStatusType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MovingObjectStatusType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(MovingObjectStatusType._GroupModel_5, min_occurs=1, max_occurs=1)
    )
MovingObjectStatusType._ContentModel = pyxb.binding.content.ParticleModel(MovingObjectStatusType._GroupModel, min_occurs=1, max_occurs=1)



CovarianceMatrixType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'includesElement'), CovarianceElementType, scope=CovarianceMatrixType))

CovarianceMatrixType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'unitOfMeasure'), UnitOfMeasureType, scope=CovarianceMatrixType))
CovarianceMatrixType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CovarianceMatrixType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'measureDescription')), min_occurs=0L, max_occurs=1)
    )
CovarianceMatrixType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CovarianceMatrixType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'unitOfMeasure')), min_occurs=1, max_occurs=None),
    pyxb.binding.content.ParticleModel(CovarianceMatrixType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'includesElement')), min_occurs=1, max_occurs=None)
    )
CovarianceMatrixType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CovarianceMatrixType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CovarianceMatrixType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
CovarianceMatrixType._ContentModel = pyxb.binding.content.ParticleModel(CovarianceMatrixType._GroupModel, min_occurs=1, max_occurs=1)



ConventionalUnitType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'roughConversionToPreferredUnit'), ConversionToPreferredUnitType, scope=ConventionalUnitType, documentation=u'This element is included when the correct definition of this unit is unknown, but this unit has a rough or inaccurate conversion to the preferred unit for this quantity type.'))

ConventionalUnitType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'derivationUnitTerm'), DerivationUnitTermType, scope=ConventionalUnitType))

ConventionalUnitType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'conversionToPreferredUnit'), ConversionToPreferredUnitType, scope=ConventionalUnitType, documentation=u'This element is included when this unit has an accurate conversion to the preferred unit for this quantity type.'))
ConventionalUnitType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=1, max_occurs=None)
    )
ConventionalUnitType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'quantityType')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'catalogSymbol')), min_occurs=0L, max_occurs=1)
    )
ConventionalUnitType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ConventionalUnitType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ConventionalUnitType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
ConventionalUnitType._GroupModel_5 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'conversionToPreferredUnit')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'roughConversionToPreferredUnit')), min_occurs=1, max_occurs=1)
    )
ConventionalUnitType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ConventionalUnitType._GroupModel_5, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ConventionalUnitType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'derivationUnitTerm')), min_occurs=0L, max_occurs=None)
    )
ConventionalUnitType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ConventionalUnitType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ConventionalUnitType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
ConventionalUnitType._ContentModel = pyxb.binding.content.ParticleModel(ConventionalUnitType._GroupModel, min_occurs=1, max_occurs=1)



CovarianceElementType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'columnIndex'), pyxb.binding.datatypes.positiveInteger, scope=CovarianceElementType, documentation=u'Column number of this covariance element value. '))

CovarianceElementType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'covariance'), pyxb.binding.datatypes.double, scope=CovarianceElementType, documentation=u'Value of covariance matrix element. '))

CovarianceElementType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'rowIndex'), pyxb.binding.datatypes.positiveInteger, scope=CovarianceElementType, documentation=u'Row number of this covariance element value. '))
CovarianceElementType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CovarianceElementType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rowIndex')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CovarianceElementType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'columnIndex')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CovarianceElementType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'covariance')), min_occurs=1, max_occurs=1)
    )
CovarianceElementType._ContentModel = pyxb.binding.content.ParticleModel(CovarianceElementType._GroupModel, min_occurs=1, max_occurs=1)



PassThroughOperationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesOperation'), OperationRefType, scope=PassThroughOperationType, documentation=u'Association to the operation applied to the specified ordinates. '))

PassThroughOperationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'modifiedCoordinate'), pyxb.binding.datatypes.positiveInteger, scope=PassThroughOperationType, documentation=u'A positive integer defining a position in a coordinate tuple. '))
PassThroughOperationType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationName')), min_occurs=1, max_occurs=1)
    )
PassThroughOperationType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'operationVersion')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validArea')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_positionalAccuracy')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sourceCRS')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'targetCRS')), min_occurs=0L, max_occurs=1)
    )
PassThroughOperationType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PassThroughOperationType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(PassThroughOperationType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
PassThroughOperationType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'modifiedCoordinate')), min_occurs=1, max_occurs=None),
    pyxb.binding.content.ParticleModel(PassThroughOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesOperation')), min_occurs=1, max_occurs=1)
    )
PassThroughOperationType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PassThroughOperationType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(PassThroughOperationType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
PassThroughOperationType._ContentModel = pyxb.binding.content.ParticleModel(PassThroughOperationType._GroupModel, min_occurs=1, max_occurs=1)



TimeTopologyPrimitivePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_TimeTopologyPrimitive'), AbstractTimeTopologyPrimitiveType, abstract=pyxb.binding.datatypes.boolean(1), scope=TimeTopologyPrimitivePropertyType, documentation=u'This abstract element acts as the head of the substitution group for temporal topology primitives.'))
TimeTopologyPrimitivePropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeTopologyPrimitivePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_TimeTopologyPrimitive')), min_occurs=1, max_occurs=1)
    )
TimeTopologyPrimitivePropertyType._ContentModel = pyxb.binding.content.ParticleModel(TimeTopologyPrimitivePropertyType._GroupModel, min_occurs=0L, max_occurs=1)



ParameterValueGroupType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'includesValue'), AbstractGeneralParameterValueType, scope=ParameterValueGroupType, documentation=u'A composition association to a parameter value or group of values included in this group. '))

ParameterValueGroupType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'valuesOfGroup'), OperationParameterGroupRefType, scope=ParameterValueGroupType, documentation=u'Association to the operation parameter group for which this element provides parameter values. '))
ParameterValueGroupType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ParameterValueGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'includesValue')), min_occurs=2L, max_occurs=None),
    pyxb.binding.content.ParticleModel(ParameterValueGroupType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valuesOfGroup')), min_occurs=1, max_occurs=1)
    )
ParameterValueGroupType._ContentModel = pyxb.binding.content.ParticleModel(ParameterValueGroupType._GroupModel, min_occurs=1, max_occurs=1)



GeometricPrimitivePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_GeometricPrimitive'), AbstractGeometricPrimitiveType, abstract=pyxb.binding.datatypes.boolean(1), scope=GeometricPrimitivePropertyType, documentation=u'The "_GeometricPrimitive" element is the abstract head of the substituition group for all (pre- and user-defined) \n\t\t\tgeometric primitives.'))
GeometricPrimitivePropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeometricPrimitivePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_GeometricPrimitive')), min_occurs=1, max_occurs=1)
    )
GeometricPrimitivePropertyType._ContentModel = pyxb.binding.content.ParticleModel(GeometricPrimitivePropertyType._GroupModel, min_occurs=0L, max_occurs=1)



OrientableSurfaceType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'baseSurface'), SurfacePropertyType, scope=OrientableSurfaceType, documentation=u'This property element either references a surface via the XLink-attributes or contains the surface element. A surface element is any element which is substitutable for "_Surface".'))
OrientableSurfaceType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(OrientableSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(OrientableSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(OrientableSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
OrientableSurfaceType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(OrientableSurfaceType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
OrientableSurfaceType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(OrientableSurfaceType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'baseSurface')), min_occurs=1, max_occurs=1)
    )
OrientableSurfaceType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(OrientableSurfaceType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(OrientableSurfaceType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
OrientableSurfaceType._ContentModel = pyxb.binding.content.ParticleModel(OrientableSurfaceType._GroupModel, min_occurs=1, max_occurs=1)



BagType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'members'), ArrayAssociationType, scope=BagType))

BagType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'member'), AssociationType, scope=BagType))
BagType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(BagType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(BagType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(BagType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
BagType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(BagType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
BagType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(BagType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'member')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(BagType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'members')), min_occurs=0L, max_occurs=1)
    )
BagType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(BagType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(BagType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
BagType._ContentModel = pyxb.binding.content.ParticleModel(BagType._GroupModel, min_occurs=1, max_occurs=1)



PolygonPatchArrayPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'PolygonPatch'), PolygonPatchType, scope=PolygonPatchArrayPropertyType))
PolygonPatchArrayPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PolygonPatchArrayPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'PolygonPatch')), min_occurs=1, max_occurs=1)
    )
PolygonPatchArrayPropertyType._ContentModel = pyxb.binding.content.ParticleModel(PolygonPatchArrayPropertyType._GroupModel, min_occurs=0L, max_occurs=None)



DynamicFeatureType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'dataSource'), StringOrRefType, scope=DynamicFeatureType))

DynamicFeatureType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'history'), HistoryPropertyType, scope=DynamicFeatureType))

DynamicFeatureType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'validTime'), TimePrimitivePropertyType, scope=DynamicFeatureType))
DynamicFeatureType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
DynamicFeatureType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DynamicFeatureType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
DynamicFeatureType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location')), min_occurs=0L, max_occurs=1)
    )
DynamicFeatureType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DynamicFeatureType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DynamicFeatureType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
DynamicFeatureType._GroupModel_5 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'history')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(DynamicFeatureType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSource')), min_occurs=0L, max_occurs=1)
    )
DynamicFeatureType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DynamicFeatureType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DynamicFeatureType._GroupModel_5, min_occurs=1, max_occurs=1)
    )
DynamicFeatureType._ContentModel = pyxb.binding.content.ParticleModel(DynamicFeatureType._GroupModel, min_occurs=1, max_occurs=1)



ArrayType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'members'), ArrayAssociationType, scope=ArrayType))
ArrayType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(ArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(ArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
ArrayType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ArrayType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
ArrayType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'members')), min_occurs=0L, max_occurs=1)
    )
ArrayType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ArrayType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ArrayType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
ArrayType._ContentModel = pyxb.binding.content.ParticleModel(ArrayType._GroupModel, min_occurs=1, max_occurs=1)



FileType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'compression'), pyxb.binding.datatypes.anyURI, scope=FileType))

FileType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'mimeType'), pyxb.binding.datatypes.anyURI, scope=FileType))

FileType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'fileName'), pyxb.binding.datatypes.anyURI, scope=FileType))

FileType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'rangeParameters'), RangeParametersType, scope=FileType))

FileType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'fileStructure'), FileValueModelType, scope=FileType))
FileType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(FileType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rangeParameters')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(FileType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'fileName')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(FileType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'fileStructure')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(FileType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'mimeType')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(FileType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'compression')), min_occurs=0L, max_occurs=1)
    )
FileType._ContentModel = pyxb.binding.content.ParticleModel(FileType._GroupModel, min_occurs=1, max_occurs=1)



PolarCSRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'PolarCS'), PolarCSType, scope=PolarCSRefType))
PolarCSRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PolarCSRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'PolarCS')), min_occurs=1, max_occurs=1)
    )
PolarCSRefType._ContentModel = pyxb.binding.content.ParticleModel(PolarCSRefType._GroupModel, min_occurs=0L, max_occurs=1)



PassThroughOperationRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'PassThroughOperation'), PassThroughOperationType, scope=PassThroughOperationRefType))
PassThroughOperationRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PassThroughOperationRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'PassThroughOperation')), min_occurs=1, max_occurs=1)
    )
PassThroughOperationRefType._ContentModel = pyxb.binding.content.ParticleModel(PassThroughOperationRefType._GroupModel, min_occurs=0L, max_occurs=1)



TopoVolumePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopoVolume'), TopoVolumeType, scope=TopoVolumePropertyType))
TopoVolumePropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoVolumePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TopoVolume')), min_occurs=1, max_occurs=1)
    )
TopoVolumePropertyType._ContentModel = pyxb.binding.content.ParticleModel(TopoVolumePropertyType._GroupModel, min_occurs=1, max_occurs=1)



DefaultStylePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_Style'), AbstractStyleType, abstract=pyxb.binding.datatypes.boolean(1), scope=DefaultStylePropertyType, documentation=u'The value of the top-level property. It is an abstract element. Used as the head element of the substitution group for extensibility purposes.'))
DefaultStylePropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DefaultStylePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_Style')), min_occurs=0L, max_occurs=1)
    )
DefaultStylePropertyType._ContentModel = pyxb.binding.content.ParticleModel(DefaultStylePropertyType._GroupModel, min_occurs=1, max_occurs=1)



TopoCurvePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'TopoCurve'), TopoCurveType, scope=TopoCurvePropertyType))
TopoCurvePropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TopoCurvePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'TopoCurve')), min_occurs=1, max_occurs=1)
    )
TopoCurvePropertyType._ContentModel = pyxb.binding.content.ParticleModel(TopoCurvePropertyType._GroupModel, min_occurs=1, max_occurs=1)



ConcatenatedOperationType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesSingleOperation'), SingleOperationRefType, scope=ConcatenatedOperationType, documentation=u'Association to a single operation. '))
ConcatenatedOperationType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationName')), min_occurs=1, max_occurs=1)
    )
ConcatenatedOperationType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinateOperationID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'operationVersion')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validArea')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_positionalAccuracy')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sourceCRS')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'targetCRS')), min_occurs=0L, max_occurs=1)
    )
ConcatenatedOperationType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ConcatenatedOperationType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ConcatenatedOperationType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
ConcatenatedOperationType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ConcatenatedOperationType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesSingleOperation')), min_occurs=2L, max_occurs=None)
    )
ConcatenatedOperationType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ConcatenatedOperationType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ConcatenatedOperationType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
ConcatenatedOperationType._ContentModel = pyxb.binding.content.ParticleModel(ConcatenatedOperationType._GroupModel, min_occurs=1, max_occurs=1)


PolarCSType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PolarCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(PolarCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'csName')), min_occurs=1, max_occurs=1)
    )
PolarCSType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PolarCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'csID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(PolarCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(PolarCSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesAxis')), min_occurs=1, max_occurs=None)
    )
PolarCSType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PolarCSType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(PolarCSType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
PolarCSType._ContentModel = pyxb.binding.content.ParticleModel(PolarCSType._GroupModel, min_occurs=1, max_occurs=1)



MultiPolygonPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiPolygon'), MultiPolygonType, scope=MultiPolygonPropertyType, documentation=u'Deprecated with GML 3.0 and included for backwards compatibility with GML 2. Use the "MultiSurface" element instead.'))
MultiPolygonPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiPolygonPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'MultiPolygon')), min_occurs=1, max_occurs=1)
    )
MultiPolygonPropertyType._ContentModel = pyxb.binding.content.ParticleModel(MultiPolygonPropertyType._GroupModel, min_occurs=0L, max_occurs=1)



MultiPointCoverageType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiPointDomain'), MultiPointDomainType, scope=MultiPointCoverageType))
MultiPointCoverageType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
MultiPointCoverageType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiPointCoverageType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiPointDomain')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rangeSet')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiPointCoverageType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coverageFunction')), min_occurs=0L, max_occurs=1)
    )
MultiPointCoverageType._ContentModel = pyxb.binding.content.ParticleModel(MultiPointCoverageType._GroupModel, min_occurs=1, max_occurs=1)


CircleType._GroupModel_2 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(CircleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CircleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CircleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep')), min_occurs=1, max_occurs=1)
    )
CircleType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(CircleType._GroupModel_2, min_occurs=3L, max_occurs=3L),
    pyxb.binding.content.ParticleModel(CircleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CircleType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates')), min_occurs=1, max_occurs=1)
    )
CircleType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CircleType._GroupModel_, min_occurs=1, max_occurs=1)
    )
CircleType._ContentModel = pyxb.binding.content.ParticleModel(CircleType._GroupModel, min_occurs=1, max_occurs=1)


ValueArrayType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ValueArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(ValueArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValueArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
ValueArrayType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ValueArrayType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
ValueArrayType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ValueArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueComponent')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(ValueArrayType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'valueComponents')), min_occurs=0L, max_occurs=1)
    )
ValueArrayType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ValueArrayType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ValueArrayType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
ValueArrayType._ContentModel = pyxb.binding.content.ParticleModel(ValueArrayType._GroupModel, min_occurs=1, max_occurs=1)



ArcStringByBulgeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'normal'), VectorType, scope=ArcStringByBulgeType, documentation=u'The attribute "normal" is a vector normal (perpendicular) to the chord of the arc, the line joining the first and last\npoint of the arc. In a 2D coordinate system, there are only two possible directions for the normal, and it is often given as a signed real, indicating its length, with a positive sign indicating a left turn angle from the chord line, and a negative sign indicating a right turn from the chord. In 3D, the normal determines the plane of the arc, along with the start and endPoint of the arc.\nThe normal is usually a unit vector, but this is not absolutely necessary. If the normal is a zero vector, the geometric object becomes equivalent to the straight line between the two end points. The length of the normal sequence is exactly the same as for the bulge sequence, 1 less than the control point sequence length.'))

ArcStringByBulgeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), PointPropertyType, scope=ArcStringByBulgeType, documentation=u'This property element either references a point via the XLink-attributes or contains the point element. pointProperty \n\t\t\tis the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that \n\t\t\tis substitutable for Point.'))

ArcStringByBulgeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), PointPropertyType, scope=ArcStringByBulgeType, documentation=u'Deprecated with GML version 3.1.0. Use "pointProperty" instead. Included for backwards compatibility with GML 3.0.0.'))

ArcStringByBulgeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'bulge'), pyxb.binding.datatypes.double, scope=ArcStringByBulgeType, documentation=u'The bulge controls the offset of each arc\'s midpoint. The "bulge" is the real number multiplier for the normal that determines the offset direction of the midpoint of each arc. The length of the bulge sequence is exactly 1 less than the length of the control point array, since a bulge is needed for each pair of adjacent points in the control point array. The bulge is not given by a distance, since it is simply a multiplier for the normal.\nThe midpoint of the resulting arc is given by: midPoint = ((startPoint + endPoint)/2.0) + bulge*normal'))

ArcStringByBulgeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, scope=ArcStringByBulgeType, documentation=u''))

ArcStringByBulgeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'posList'), DirectPositionListType, scope=ArcStringByBulgeType, documentation=u''))

ArcStringByBulgeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), CoordinatesType, scope=ArcStringByBulgeType, documentation=u'Deprecated with GML version 3.1.0.'))
ArcStringByBulgeType._GroupModel_2 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(ArcStringByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ArcStringByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ArcStringByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep')), min_occurs=1, max_occurs=1)
    )
ArcStringByBulgeType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(ArcStringByBulgeType._GroupModel_2, min_occurs=2L, max_occurs=None),
    pyxb.binding.content.ParticleModel(ArcStringByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ArcStringByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates')), min_occurs=1, max_occurs=1)
    )
ArcStringByBulgeType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ArcStringByBulgeType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ArcStringByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'bulge')), min_occurs=1, max_occurs=None),
    pyxb.binding.content.ParticleModel(ArcStringByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'normal')), min_occurs=1, max_occurs=None)
    )
ArcStringByBulgeType._ContentModel = pyxb.binding.content.ParticleModel(ArcStringByBulgeType._GroupModel, min_occurs=1, max_occurs=1)



CubicSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointRep'), PointPropertyType, scope=CubicSplineType, documentation=u'Deprecated with GML version 3.1.0. Use "pointProperty" instead. Included for backwards compatibility with GML 3.0.0.'))

CubicSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'posList'), DirectPositionListType, scope=CubicSplineType, documentation=u''))

CubicSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, scope=CubicSplineType, documentation=u''))

CubicSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'vectorAtStart'), VectorType, scope=CubicSplineType, documentation=u'"vectorAtStart" is the unit tangent vector at the start point of the spline.'))

CubicSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'coordinates'), CoordinatesType, scope=CubicSplineType, documentation=u'Deprecated with GML version 3.1.0.'))

CubicSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), PointPropertyType, scope=CubicSplineType, documentation=u'This property element either references a point via the XLink-attributes or contains the point element. pointProperty \n\t\t\tis the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that \n\t\t\tis substitutable for Point.'))

CubicSplineType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'vectorAtEnd'), VectorType, scope=CubicSplineType, documentation=u'"vectorAtEnd" is the unit tangent vector at the end point of the spline.'))
CubicSplineType._GroupModel_2 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(CubicSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CubicSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CubicSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep')), min_occurs=1, max_occurs=1)
    )
CubicSplineType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(CubicSplineType._GroupModel_2, min_occurs=2L, max_occurs=None),
    pyxb.binding.content.ParticleModel(CubicSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CubicSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates')), min_occurs=1, max_occurs=1)
    )
CubicSplineType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CubicSplineType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CubicSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'vectorAtStart')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CubicSplineType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'vectorAtEnd')), min_occurs=1, max_occurs=1)
    )
CubicSplineType._ContentModel = pyxb.binding.content.ParticleModel(CubicSplineType._GroupModel, min_occurs=1, max_occurs=1)



RangeParametersType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Boolean'), pyxb.binding.datatypes.boolean, scope=RangeParametersType, documentation=u'A value from two-valued logic, using the XML Schema boolean type.  An instance may take the values {true, false, 1, 0}.'))

RangeParametersType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Count'), pyxb.binding.datatypes.integer, scope=RangeParametersType, documentation=u'An integer representing a frequency of occurrence.'))

RangeParametersType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CategoryExtent'), CategoryExtentType, scope=RangeParametersType, documentation=u'Utility element to store a 2-point range of ordinal values. If one member is a null, then this is a single ended interval.'))

RangeParametersType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CountExtent'), CountExtentType, scope=RangeParametersType, documentation=u'Utility element to store a 2-point range of frequency values. If one member is a null, then this is a single ended interval.'))

RangeParametersType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Category'), CodeType, scope=RangeParametersType, documentation=u'A term representing a classification.  It has an optional XML attribute codeSpace, whose value is a URI which identifies a dictionary, codelist or authority for the term.'))

RangeParametersType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'QuantityExtent'), QuantityExtentType, scope=RangeParametersType, documentation=u'Utility element to store a 2-point range of numeric values. If one member is a null, then this is a single ended interval.'))

RangeParametersType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'QuantityList'), MeasureOrNullListType, scope=RangeParametersType, documentation=u'A space separated list of amounts or nulls.  The amounts use the XML Schema type double.  A single XML attribute uom (unit of measure) is required, whose value is a URI which identifies the definition of the scale or units by which all the amounts in the list must be multiplied.'))

RangeParametersType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CompositeValue'), CompositeValueType, scope=RangeParametersType, documentation=u'Aggregate value built using the Composite pattern.'))

RangeParametersType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Quantity'), MeasureType, scope=RangeParametersType, documentation=u'A numeric value with a scale.  The content of the element is an amount using the XML Schema type double which permits decimal or scientific notation.  An XML attribute uom (unit of measure) is required, whose value is a URI which identifies the definition of the scale or units by which the numeric value must be multiplied.'))

RangeParametersType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'BooleanList'), booleanOrNullList, scope=RangeParametersType, documentation=u'XML List based on XML Schema boolean type.  An element of this type contains a space-separated list of boolean values {0,1,true,false}'))

RangeParametersType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CountList'), integerOrNullList, scope=RangeParametersType, documentation=u'A space-separated list of integers or nulls.'))

RangeParametersType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CategoryList'), CodeOrNullListType, scope=RangeParametersType, documentation=u'A space-separated list of terms or nulls.  A single XML attribute codeSpace may be provided, which authorises all the terms in the list.'))
RangeParametersType._GroupModel_2 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(RangeParametersType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Boolean')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(RangeParametersType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Category')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(RangeParametersType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Quantity')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(RangeParametersType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Count')), min_occurs=1, max_occurs=1)
    )
RangeParametersType._GroupModel_3 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(RangeParametersType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'BooleanList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(RangeParametersType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CategoryList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(RangeParametersType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'QuantityList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(RangeParametersType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CountList')), min_occurs=1, max_occurs=1)
    )
RangeParametersType._GroupModel_4 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(RangeParametersType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CategoryExtent')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(RangeParametersType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'QuantityExtent')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(RangeParametersType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CountExtent')), min_occurs=1, max_occurs=1)
    )
RangeParametersType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(RangeParametersType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(RangeParametersType._GroupModel_3, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(RangeParametersType._GroupModel_4, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(RangeParametersType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CompositeValue')), min_occurs=1, max_occurs=1)
    )
RangeParametersType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(RangeParametersType._GroupModel_, min_occurs=1, max_occurs=1)
    )
RangeParametersType._ContentModel = pyxb.binding.content.ParticleModel(RangeParametersType._GroupModel, min_occurs=0L, max_occurs=1)



MultiGeometryType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'geometryMembers'), GeometryArrayPropertyType, scope=MultiGeometryType, documentation=u'This property element contains a list of geometry elements. The order of the elements is significant and shall be preserved when processing the array.'))

MultiGeometryType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'geometryMember'), GeometryPropertyType, scope=MultiGeometryType, documentation=u'This property element either references a geometry element via the XLink-attributes or contains the geometry element.'))
MultiGeometryType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(MultiGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
MultiGeometryType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiGeometryType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
MultiGeometryType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'geometryMember')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(MultiGeometryType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'geometryMembers')), min_occurs=0L, max_occurs=1)
    )
MultiGeometryType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiGeometryType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(MultiGeometryType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
MultiGeometryType._ContentModel = pyxb.binding.content.ParticleModel(MultiGeometryType._GroupModel, min_occurs=1, max_occurs=1)



GeocentricCRSRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GeocentricCRS'), GeocentricCRSType, scope=GeocentricCRSRefType))
GeocentricCRSRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeocentricCRSRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'GeocentricCRS')), min_occurs=1, max_occurs=1)
    )
GeocentricCRSRefType._ContentModel = pyxb.binding.content.ParticleModel(GeocentricCRSRefType._GroupModel, min_occurs=0L, max_occurs=1)


ArcByBulgeType._GroupModel_2 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(ArcByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ArcByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ArcByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointRep')), min_occurs=1, max_occurs=1)
    )
ArcByBulgeType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(ArcByBulgeType._GroupModel_2, min_occurs=2L, max_occurs=2L),
    pyxb.binding.content.ParticleModel(ArcByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ArcByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'coordinates')), min_occurs=1, max_occurs=1)
    )
ArcByBulgeType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ArcByBulgeType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ArcByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'bulge')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ArcByBulgeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'normal')), min_occurs=1, max_occurs=1)
    )
ArcByBulgeType._ContentModel = pyxb.binding.content.ParticleModel(ArcByBulgeType._GroupModel, min_occurs=1, max_occurs=1)



TimeGeometricPrimitivePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'_TimeGeometricPrimitive'), AbstractTimeGeometricPrimitiveType, abstract=pyxb.binding.datatypes.boolean(1), scope=TimeGeometricPrimitivePropertyType, documentation=u'This abstract element acts as the head of the substitution group for temporal geometric primitives.'))
TimeGeometricPrimitivePropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TimeGeometricPrimitivePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_TimeGeometricPrimitive')), min_occurs=1, max_occurs=1)
    )
TimeGeometricPrimitivePropertyType._ContentModel = pyxb.binding.content.ParticleModel(TimeGeometricPrimitivePropertyType._GroupModel, min_occurs=0L, max_occurs=1)



TemporalCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesTemporalDatum'), TemporalDatumRefType, scope=TemporalCRSType, documentation=u'Association to the temporal datum used by this CRS. '))

TemporalCRSType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'usesTemporalCS'), TemporalCSRefType, scope=TemporalCRSType, documentation=u'Association to the temporal coordinate system used by this CRS. '))
TemporalCRSType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TemporalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TemporalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'srsName')), min_occurs=1, max_occurs=1)
    )
TemporalCRSType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TemporalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'srsID')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(TemporalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'remarks')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TemporalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validArea')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(TemporalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'scope')), min_occurs=0L, max_occurs=1)
    )
TemporalCRSType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TemporalCRSType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TemporalCRSType._GroupModel_3, min_occurs=1, max_occurs=1)
    )
TemporalCRSType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TemporalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesTemporalCS')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TemporalCRSType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'usesTemporalDatum')), min_occurs=1, max_occurs=1)
    )
TemporalCRSType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TemporalCRSType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(TemporalCRSType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
TemporalCRSType._ContentModel = pyxb.binding.content.ParticleModel(TemporalCRSType._GroupModel, min_occurs=1, max_occurs=1)


PriorityLocationPropertyType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(PriorityLocationPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'_Geometry')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(PriorityLocationPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'LocationKeyWord')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(PriorityLocationPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'LocationString')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(PriorityLocationPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Null')), min_occurs=1, max_occurs=1)
    )
PriorityLocationPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(PriorityLocationPropertyType._GroupModel_, min_occurs=1, max_occurs=1)
    )
PriorityLocationPropertyType._ContentModel = pyxb.binding.content.ParticleModel(PriorityLocationPropertyType._GroupModel, min_occurs=0L, max_occurs=1)



CylindricalCSRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CylindricalCS'), CylindricalCSType, scope=CylindricalCSRefType))
CylindricalCSRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CylindricalCSRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CylindricalCS')), min_occurs=1, max_occurs=1)
    )
CylindricalCSRefType._ContentModel = pyxb.binding.content.ParticleModel(CylindricalCSRefType._GroupModel, min_occurs=0L, max_occurs=1)



SecondDefiningParameterType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'inverseFlattening'), MeasureType, scope=SecondDefiningParameterType, documentation=u'Inverse flattening value of the ellipsoid. Value is a scale factor (or ratio) that has no physical unit. Uses the MeasureType with the restriction that the unit of measure referenced by uom must be suitable for a scale factor, such as percent, permil, or parts-per-million. '))

SecondDefiningParameterType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'semiMinorAxis'), MeasureType, scope=SecondDefiningParameterType, documentation=u'Length of the semi-minor axis of the ellipsoid. Uses the MeasureType with the restriction that the unit of measure referenced by uom must be suitable for a length, such as metres or feet. '))

SecondDefiningParameterType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'isSphere'), STD_ANON_12, scope=SecondDefiningParameterType, documentation=u'The ellipsoid is degenerate and is actually a sphere. The sphere is completely defined by the semi-major axis, which is the radius of the sphere. '))
SecondDefiningParameterType._GroupModel = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(SecondDefiningParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'inverseFlattening')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(SecondDefiningParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'semiMinorAxis')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(SecondDefiningParameterType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'isSphere')), min_occurs=1, max_occurs=1)
    )
SecondDefiningParameterType._ContentModel = pyxb.binding.content.ParticleModel(SecondDefiningParameterType._GroupModel, min_occurs=1, max_occurs=1)


ConeType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ConeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'row')), min_occurs=1, max_occurs=None)
    )
ConeType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ConeType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ConeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'rows')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(ConeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'columns')), min_occurs=0L, max_occurs=1)
    )
ConeType._ContentModel = pyxb.binding.content.ParticleModel(ConeType._GroupModel, min_occurs=1, max_occurs=1)



VerticalCRSRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'VerticalCRS'), VerticalCRSType, scope=VerticalCRSRefType))
VerticalCRSRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(VerticalCRSRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'VerticalCRS')), min_occurs=1, max_occurs=1)
    )
VerticalCRSRefType._ContentModel = pyxb.binding.content.ParticleModel(VerticalCRSRefType._GroupModel, min_occurs=0L, max_occurs=1)


GeodesicType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(GeodesicType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeodesicType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty')), min_occurs=1, max_occurs=1)
    )
GeodesicType._GroupModel = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(GeodesicType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GeodesicType._GroupModel_, min_occurs=2L, max_occurs=None)
    )
GeodesicType._ContentModel = pyxb.binding.content.ParticleModel(GeodesicType._GroupModel, min_occurs=1, max_occurs=1)



IsolatedPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Node'), NodeType, scope=IsolatedPropertyType))

IsolatedPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'Edge'), EdgeType, scope=IsolatedPropertyType))
IsolatedPropertyType._GroupModel = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(IsolatedPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Node')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(IsolatedPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Edge')), min_occurs=1, max_occurs=1)
    )
IsolatedPropertyType._ContentModel = pyxb.binding.content.ParticleModel(IsolatedPropertyType._GroupModel, min_occurs=0L, max_occurs=1)



TrackType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MovingObjectStatus'), MovingObjectStatusType, scope=TrackType))
TrackType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(TrackType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'MovingObjectStatus')), min_occurs=1, max_occurs=1)
    )
TrackType._ContentModel = pyxb.binding.content.ParticleModel(TrackType._GroupModel, min_occurs=1, max_occurs=None)


ScalarValuePropertyType._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(ScalarValuePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Boolean')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ScalarValuePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Category')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ScalarValuePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Quantity')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(ScalarValuePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'Count')), min_occurs=1, max_occurs=1)
    )
ScalarValuePropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(ScalarValuePropertyType._GroupModel_, min_occurs=1, max_occurs=1)
    )
ScalarValuePropertyType._ContentModel = pyxb.binding.content.ParticleModel(ScalarValuePropertyType._GroupModel, min_occurs=0L, max_occurs=1)



CTD_ANON_._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pos'), DirectPositionType, scope=CTD_ANON_, documentation=u''))

CTD_ANON_._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'posList'), DirectPositionListType, scope=CTD_ANON_, documentation=u''))

CTD_ANON_._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pointProperty'), PointPropertyType, scope=CTD_ANON_, documentation=u'This property element either references a point via the XLink-attributes or contains the point element. pointProperty \n\t\t\tis the predefined property which can be used by GML Application Schemas whenever a GML Feature has a property with a value that \n\t\t\tis substitutable for Point.'))
CTD_ANON_._GroupModel_2 = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(CTD_ANON_._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pos')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CTD_ANON_._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pointProperty')), min_occurs=1, max_occurs=1)
    )
CTD_ANON_._GroupModel_ = pyxb.binding.content.GroupChoice(
    pyxb.binding.content.ParticleModel(CTD_ANON_._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'posList')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(CTD_ANON_._GroupModel_2, min_occurs=1, max_occurs=None)
    )
CTD_ANON_._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CTD_ANON_._GroupModel_, min_occurs=1, max_occurs=1)
    )
CTD_ANON_._ContentModel = pyxb.binding.content.ParticleModel(CTD_ANON_._GroupModel, min_occurs=1, max_occurs=1)



IndexMapType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'lookUpTable'), integerList, scope=IndexMapType))
IndexMapType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(IndexMapType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sequenceRule')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(IndexMapType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'startPoint')), min_occurs=0L, max_occurs=1)
    )
IndexMapType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(IndexMapType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'lookUpTable')), min_occurs=1, max_occurs=1)
    )
IndexMapType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(IndexMapType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(IndexMapType._GroupModel_2, min_occurs=1, max_occurs=1)
    )
IndexMapType._ContentModel = pyxb.binding.content.ParticleModel(IndexMapType._GroupModel, min_occurs=1, max_occurs=1)



LabelType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'LabelExpression'), pyxb.binding.datatypes.string, scope=LabelType))
LabelType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(LabelType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'LabelExpression')), min_occurs=0L, max_occurs=None)
    )
LabelType._ContentModel = pyxb.binding.content.ParticleModel(LabelType._GroupModel, min_occurs=1, max_occurs=1)



CompositeSurfacePropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CompositeSurface'), CompositeSurfaceType, scope=CompositeSurfacePropertyType))
CompositeSurfacePropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CompositeSurfacePropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CompositeSurface')), min_occurs=1, max_occurs=1)
    )
CompositeSurfacePropertyType._ContentModel = pyxb.binding.content.ParticleModel(CompositeSurfacePropertyType._GroupModel, min_occurs=0L, max_occurs=1)



CompoundCRSRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'CompoundCRS'), CompoundCRSType, scope=CompoundCRSRefType))
CompoundCRSRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CompoundCRSRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'CompoundCRS')), min_occurs=1, max_occurs=1)
    )
CompoundCRSRefType._ContentModel = pyxb.binding.content.ParticleModel(CompoundCRSRefType._GroupModel, min_occurs=0L, max_occurs=1)



CTD_ANON_2._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'AffinePlacement'), AffinePlacementType, scope=CTD_ANON_2))
CTD_ANON_2._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(CTD_ANON_2._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'AffinePlacement')), min_occurs=1, max_occurs=1)
    )
CTD_ANON_2._ContentModel = pyxb.binding.content.ParticleModel(CTD_ANON_2._GroupModel, min_occurs=1, max_occurs=1)



DynamicFeatureCollectionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'dataSource'), StringOrRefType, scope=DynamicFeatureCollectionType))

DynamicFeatureCollectionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'validTime'), TimePrimitivePropertyType, scope=DynamicFeatureCollectionType))

DynamicFeatureCollectionType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'history'), HistoryPropertyType, scope=DynamicFeatureCollectionType))
DynamicFeatureCollectionType._GroupModel_4 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'metaDataProperty')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'description')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'name')), min_occurs=0L, max_occurs=None)
    )
DynamicFeatureCollectionType._GroupModel_3 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DynamicFeatureCollectionType._GroupModel_4, min_occurs=1, max_occurs=1)
    )
DynamicFeatureCollectionType._GroupModel_5 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'boundedBy')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'location')), min_occurs=0L, max_occurs=1)
    )
DynamicFeatureCollectionType._GroupModel_2 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DynamicFeatureCollectionType._GroupModel_3, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DynamicFeatureCollectionType._GroupModel_5, min_occurs=1, max_occurs=1)
    )
DynamicFeatureCollectionType._GroupModel_6 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMember')), min_occurs=0L, max_occurs=None),
    pyxb.binding.content.ParticleModel(DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'featureMembers')), min_occurs=0L, max_occurs=1)
    )
DynamicFeatureCollectionType._GroupModel_ = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DynamicFeatureCollectionType._GroupModel_2, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DynamicFeatureCollectionType._GroupModel_6, min_occurs=1, max_occurs=1)
    )
DynamicFeatureCollectionType._GroupModel_7 = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'validTime')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'history')), min_occurs=0L, max_occurs=1),
    pyxb.binding.content.ParticleModel(DynamicFeatureCollectionType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'dataSource')), min_occurs=0L, max_occurs=1)
    )
DynamicFeatureCollectionType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(DynamicFeatureCollectionType._GroupModel_, min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(DynamicFeatureCollectionType._GroupModel_7, min_occurs=1, max_occurs=1)
    )
DynamicFeatureCollectionType._ContentModel = pyxb.binding.content.ParticleModel(DynamicFeatureCollectionType._GroupModel, min_occurs=1, max_occurs=1)



GridEnvelopeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'high'), integerList, scope=GridEnvelopeType))

GridEnvelopeType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'low'), integerList, scope=GridEnvelopeType))
GridEnvelopeType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GridEnvelopeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'low')), min_occurs=1, max_occurs=1),
    pyxb.binding.content.ParticleModel(GridEnvelopeType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'high')), min_occurs=1, max_occurs=1)
    )
GridEnvelopeType._ContentModel = pyxb.binding.content.ParticleModel(GridEnvelopeType._GroupModel, min_occurs=1, max_occurs=1)



MultiSolidPropertyType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'MultiSolid'), MultiSolidType, scope=MultiSolidPropertyType))
MultiSolidPropertyType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(MultiSolidPropertyType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'MultiSolid')), min_occurs=1, max_occurs=1)
    )
MultiSolidPropertyType._ContentModel = pyxb.binding.content.ParticleModel(MultiSolidPropertyType._GroupModel, min_occurs=0L, max_occurs=1)



GeographicCRSRefType._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'GeographicCRS'), GeographicCRSType, scope=GeographicCRSRefType))
GeographicCRSRefType._GroupModel = pyxb.binding.content.GroupSequence(
    pyxb.binding.content.ParticleModel(GeographicCRSRefType._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'GeographicCRS')), min_occurs=1, max_occurs=1)
    )
GeographicCRSRefType._ContentModel = pyxb.binding.content.ParticleModel(GeographicCRSRefType._GroupModel, min_occurs=0L, max_occurs=1)

Dictionary._setSubstitutionGroup(Definition)

MultiCurveCoverage._setSubstitutionGroup(DiscreteCoverage)

CircleByCenterPoint._setSubstitutionGroup(ArcByCenterPoint)

GeocentricCRS._setSubstitutionGroup(CoordinateReferenceSystem)

GeometricAggregate._setSubstitutionGroup(Geometry)

DefinitionCollection._setSubstitutionGroup(Definition)

MultiSurfaceCoverage._setSubstitutionGroup(DiscreteCoverage)

TimeCalendarEra._setSubstitutionGroup(Definition)

GeneralOperationParameter._setSubstitutionGroup(Definition)

EnvelopeWithTimePeriod._setSubstitutionGroup(Envelope)

LineStringSegment._setSubstitutionGroup(CurveSegment)

trianglePatches._setSubstitutionGroup(patches)

Surface._setSubstitutionGroup(Surface_)

datumName._setSubstitutionGroup(name)

TimeReferenceSystem._setSubstitutionGroup(Definition)

MultiSolidCoverage._setSubstitutionGroup(DiscreteCoverage)

OperationParameter._setSubstitutionGroup(GeneralOperationParameter)

UnitDefinition._setSubstitutionGroup(Definition)

relativeInternalPositionalAccuracy._setSubstitutionGroup(positionalAccuracy)

DirectedObservationAtDistance._setSubstitutionGroup(DirectedObservation)

DefinitionProxy._setSubstitutionGroup(Definition)

DirectedObservation._setSubstitutionGroup(Observation)

GeneralTransformation._setSubstitutionGroup(Operation)

BaseUnit._setSubstitutionGroup(UnitDefinition)

ArcString._setSubstitutionGroup(CurveSegment)

GridCoverage._setSubstitutionGroup(DiscreteCoverage)

FeatureCollection._setSubstitutionGroup(Feature)

PrimeMeridian._setSubstitutionGroup(Definition)

gridDomain._setSubstitutionGroup(domainSet)

PolyhedralSurface._setSubstitutionGroup(Surface)

Clothoid._setSubstitutionGroup(CurveSegment)

Arc._setSubstitutionGroup(ArcString)

RectifiedGridCoverage._setSubstitutionGroup(DiscreteCoverage)

GeometryStyle._setSubstitutionGroup(GML)

ellipsoidName._setSubstitutionGroup(name)

ContinuousCoverage._setSubstitutionGroup(Coverage)

definitionMember._setSubstitutionGroup(dictionaryEntry)

TimeTopologyComplex._setSubstitutionGroup(TimeComplex)

Conversion._setSubstitutionGroup(GeneralConversion)

multiCurveDomain._setSubstitutionGroup(domainSet)

MultiPoint._setSubstitutionGroup(GeometricAggregate)

FeatureCollection_._setSubstitutionGroup(Feature)

GeodesicString._setSubstitutionGroup(CurveSegment)

DiscreteCoverage._setSubstitutionGroup(Coverage)

Solid._setSubstitutionGroup(Solid_)

CoordinateSystemAxis._setSubstitutionGroup(Definition)

CylindricalCS._setSubstitutionGroup(CoordinateSystem)

Ellipsoid._setSubstitutionGroup(Definition)

EllipsoidalCS._setSubstitutionGroup(CoordinateSystem)

GeographicCRS._setSubstitutionGroup(CoordinateReferenceSystem)

meridianName._setSubstitutionGroup(name)

Style._setSubstitutionGroup(GML)

ArcByCenterPoint._setSubstitutionGroup(CurveSegment)

Bezier._setSubstitutionGroup(BSpline)

CompositeSolid._setSubstitutionGroup(Solid_)

TimeObject._setSubstitutionGroup(GML)

GenericMetaData._setSubstitutionGroup(MetaData)

Surface_._setSubstitutionGroup(GeometricPrimitive)

ObliqueCartesianCS._setSubstitutionGroup(CoordinateSystem)

ImageDatum._setSubstitutionGroup(Datum)

ImplicitGeometry._setSubstitutionGroup(Geometry)

TimeClock._setSubstitutionGroup(TimeReferenceSystem)

Grid._setSubstitutionGroup(ImplicitGeometry)

TimeSlice._setSubstitutionGroup(GML)

MultiCurve._setSubstitutionGroup(GeometricAggregate)

Coverage._setSubstitutionGroup(Feature)

RectifiedGrid._setSubstitutionGroup(ImplicitGeometry)

Curve._setSubstitutionGroup(Curve_)

multiSurfaceDomain._setSubstitutionGroup(domainSet)

Sphere._setSubstitutionGroup(GriddedSurface)

Node._setSubstitutionGroup(TopoPrimitive)

Geometry._setSubstitutionGroup(GML)

CoordinateOperation._setSubstitutionGroup(Definition)

SphericalCS._setSubstitutionGroup(CoordinateSystem)

FeatureStyle._setSubstitutionGroup(GML)

Style_._setSubstitutionGroup(Style)

MultiPolygon._setSubstitutionGroup(GeometricAggregate)

Point._setSubstitutionGroup(GeometricPrimitive)

Rectangle._setSubstitutionGroup(SurfacePatch)

Polygon._setSubstitutionGroup(Surface_)

CompositeCurve._setSubstitutionGroup(Curve_)

MultiLineString._setSubstitutionGroup(GeometricAggregate)

TriangulatedSurface._setSubstitutionGroup(Surface)

Ring._setSubstitutionGroup(Ring_)

Ring_._setSubstitutionGroup(Geometry)

GeometricPrimitive._setSubstitutionGroup(Geometry)

TopoSolid._setSubstitutionGroup(TopoPrimitive)

BSpline._setSubstitutionGroup(CurveSegment)

outerBoundaryIs._setSubstitutionGroup(exterior)

GeometricComplex._setSubstitutionGroup(Geometry)

Curve_._setSubstitutionGroup(GeometricPrimitive)

ParametricCurveSurface._setSubstitutionGroup(SurfacePatch)

coordinateOperationName._setSubstitutionGroup(name)

LinearRing._setSubstitutionGroup(Ring_)

parameterValue._setSubstitutionGroup(generalParameterValue)

GriddedSurface._setSubstitutionGroup(ParametricCurveSurface)

OffsetCurve._setSubstitutionGroup(CurveSegment)

Operation._setSubstitutionGroup(SingleOperation)

Definition._setSubstitutionGroup(GML)

SingleOperation._setSubstitutionGroup(CoordinateOperation)

CompositeSurface._setSubstitutionGroup(Surface_)

methodName._setSubstitutionGroup(name)

ReferenceSystem._setSubstitutionGroup(Definition)

Tin._setSubstitutionGroup(TriangulatedSurface)

Cylinder._setSubstitutionGroup(GriddedSurface)

MetaData._setSubstitutionGroup(Object)

multiSolidDomain._setSubstitutionGroup(domainSet)

TimeCoordinateSystem._setSubstitutionGroup(TimeReferenceSystem)

DerivedCRS._setSubstitutionGroup(GeneralDerivedCRS)

TimeOrdinalReferenceSystem._setSubstitutionGroup(TimeReferenceSystem)

EngineeringDatum._setSubstitutionGroup(Datum)

Solid_._setSubstitutionGroup(GeometricPrimitive)

DerivedUnit._setSubstitutionGroup(UnitDefinition)

TimeInstant._setSubstitutionGroup(TimeGeometricPrimitive)

TemporalDatum._setSubstitutionGroup(Datum)

TimeCalendar._setSubstitutionGroup(TimeReferenceSystem)

rectifiedGridDomain._setSubstitutionGroup(domainSet)

VerticalDatum._setSubstitutionGroup(Datum)

OrientableCurve._setSubstitutionGroup(Curve_)

absoluteExternalPositionalAccuracy._setSubstitutionGroup(positionalAccuracy)

VerticalCRS._setSubstitutionGroup(CoordinateReferenceSystem)

TopologyStyle._setSubstitutionGroup(GML)

TimeNode._setSubstitutionGroup(TimeTopologyPrimitive)

GeodeticDatum._setSubstitutionGroup(Datum)

Transformation._setSubstitutionGroup(GeneralTransformation)

UserDefinedCS._setSubstitutionGroup(CoordinateSystem)

LineString._setSubstitutionGroup(Curve_)

covarianceMatrix._setSubstitutionGroup(positionalAccuracy)

ConventionalUnit._setSubstitutionGroup(UnitDefinition)

MultiSurface._setSubstitutionGroup(GeometricAggregate)

GML._setSubstitutionGroup(Object)

LabelStyle._setSubstitutionGroup(GML)

parameterValueGroup._setSubstitutionGroup(generalParameterValue)

CoordinateReferenceSystem._setSubstitutionGroup(CRS)

OrientableSurface._setSubstitutionGroup(Surface_)

MultiSolid._setSubstitutionGroup(GeometricAggregate)

GeneralDerivedCRS._setSubstitutionGroup(CoordinateReferenceSystem)

OperationParameterGroup._setSubstitutionGroup(GeneralOperationParameter)

Bag._setSubstitutionGroup(GML)

parameterName._setSubstitutionGroup(name)

TopoPrimitive._setSubstitutionGroup(Topology)

EngineeringCRS._setSubstitutionGroup(CoordinateReferenceSystem)

GraphStyle._setSubstitutionGroup(GML)

Array._setSubstitutionGroup(GML)

ProjectedCRS._setSubstitutionGroup(GeneralDerivedCRS)

TimeTopologyPrimitive._setSubstitutionGroup(TimePrimitive)

ImageCRS._setSubstitutionGroup(CoordinateReferenceSystem)

PolygonPatch._setSubstitutionGroup(SurfacePatch)

subject._setSubstitutionGroup(target)

TimePeriod._setSubstitutionGroup(TimeGeometricPrimitive)

LinearCS._setSubstitutionGroup(CoordinateSystem)

Datum._setSubstitutionGroup(Definition)

TopoComplex._setSubstitutionGroup(Topology)

includesValue._setSubstitutionGroup(generalParameterValue)

innerBoundaryIs._setSubstitutionGroup(interior)

MultiPointCoverage._setSubstitutionGroup(DiscreteCoverage)

Circle._setSubstitutionGroup(Arc)

ValueArray._setSubstitutionGroup(CompositeValue)

srsName._setSubstitutionGroup(name)

ArcStringByBulge._setSubstitutionGroup(CurveSegment)

CubicSpline._setSubstitutionGroup(CurveSegment)

ConcatenatedOperation._setSubstitutionGroup(CoordinateOperation)

polygonPatches._setSubstitutionGroup(patches)

Feature._setSubstitutionGroup(GML)

OperationMethod._setSubstitutionGroup(Definition)

TimePrimitive._setSubstitutionGroup(TimeObject)

MultiGeometry._setSubstitutionGroup(GeometricAggregate)

TimeEdge._setSubstitutionGroup(TimeTopologyPrimitive)

TimeComplex._setSubstitutionGroup(TimeObject)

PolarCS._setSubstitutionGroup(CoordinateSystem)

ArcByBulge._setSubstitutionGroup(ArcStringByBulge)

CRS._setSubstitutionGroup(ReferenceSystem)

TimeGeometricPrimitive._setSubstitutionGroup(TimePrimitive)

Triangle._setSubstitutionGroup(SurfacePatch)

CoordinateSystem._setSubstitutionGroup(Definition)

groupName._setSubstitutionGroup(name)

priorityLocation._setSubstitutionGroup(location)

csName._setSubstitutionGroup(name)

GeneralConversion._setSubstitutionGroup(Operation)

MovingObjectStatus._setSubstitutionGroup(TimeSlice)

CartesianCS._setSubstitutionGroup(CoordinateSystem)

TemporalCRS._setSubstitutionGroup(CoordinateReferenceSystem)

Face._setSubstitutionGroup(TopoPrimitive)

Cone._setSubstitutionGroup(GriddedSurface)

Geodesic._setSubstitutionGroup(GeodesicString)

track._setSubstitutionGroup(history)

CompoundCRS._setSubstitutionGroup(CRS)

PassThroughOperation._setSubstitutionGroup(SingleOperation)

IndexMap._setSubstitutionGroup(GridFunction)

Observation._setSubstitutionGroup(Feature)

VerticalCS._setSubstitutionGroup(CoordinateSystem)

Edge._setSubstitutionGroup(TopoPrimitive)

TemporalCS._setSubstitutionGroup(CoordinateSystem)

Topology._setSubstitutionGroup(GML)

multiPointDomain._setSubstitutionGroup(domainSet)
