<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>numdifftools.core.Gradient</title>
  <link rel="stylesheet" href="epydoc.css" type="text/css"></link>
</head>
<body bgcolor="white" text="black" link="blue" vlink="#204080"
      alink="#204080">

<!-- =========== START OF NAVBAR =========== -->
<table class="navbar" border="0" width="100%" cellpadding="0" bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="center">
    <th class="navbar">&nbsp;&nbsp;&nbsp;<a class="navbar" href="numdifftools-module.html">Home</a>&nbsp;&nbsp;&nbsp;</th>
    <th class="navbar">&nbsp;&nbsp;&nbsp;<a class="navbar" href="trees.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>
    <th class="navbar">&nbsp;&nbsp;&nbsp;<a class="navbar" href="indices.html">Index</a>&nbsp;&nbsp;&nbsp;</th>
    <th class="navbar">&nbsp;&nbsp;&nbsp;<a class="navbar" href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>
    <th class="navbar" width="100%"></th>
  </tr>
</table>
<table width="100%" cellpadding="0" cellspacing="0">
  <tr valign="top">
    <td width="100%">
      <font size="-1"><b class="breadcrumbs">
        <a href="numdifftools-module.html">Package&nbsp;numdifftools</a> ::
        <a href="numdifftools.core-module.html">Module&nbsp;core</a> ::
        Class&nbsp;Gradient
      </b></font></br>
    </td>
    <td><table cellpadding="0" cellspacing="0">
      <tr><td align="right"><font size="-2">[<a href="../private/numdifftools.core.Gradient-class.html">show&nbsp;private</a>&nbsp;|&nbsp;hide&nbsp;private]</font></td></tr>
      <tr><td align="right"><font size="-2">[<a href="frames.html"target="_top">frames</a>&nbsp;|&nbsp;<a href="numdifftools.core.Gradient-class.html" target="_top">no&nbsp;frames</a>]</font></td></tr>
    </table></td>
</tr></table>

<!-- =========== START OF CLASS DESCRIPTION =========== -->
<h2 class="class">Class Gradient</h2>

<pre class="base-tree">
     <a href="__builtin__.object-class.html"><code>object</code></a> --+        
              |        
<a href="..\private\numdifftools.core.Common_diff_par-class.html"><code>Common_diff_par</code></a> --+    
                  |    
         <a href="numdifftools.core.Derivative-class.html"><code>Derivative</code></a> --+
                      |
                     <b>Gradient</b>
</pre><br />

<hr/>

<pre class="literalblock">
Estimate gradient of fun at x0, with error estimate


Input arguments
===============
fun = function to differentiate.

**kwds
------
derOrder : Derivative order is always 1
metOrder : Integer from 1 to 4 defining order of basic method used.
             (For 'central' methods, it must be from the set [2,4].
             (Default 2)
method   : Method of estimation.  Valid options are:
              'central', 'forward' or 'backwards'.     (Default 'central')
numTerms : Number of Romberg terms used in the extrapolation.
             Must be an integer from 0 to 3.  (Default 2)
             Note: 0 disables the Romberg step completely.
stepFix  : If not None, it will define the maximum excursion from x0
             that is used and prevent the adaptive logic from working.
             This will be considerably faster, but not necessarily
             as accurate as allowing the adaptive logic to run.
            (Default: None)
stepMax  : Maximum allowed excursion from x0 as a multiple of x0. (Default 100)
stepRatio: Ratio used between sequential steps in the estimation
             of the derivative (Default 2)
vectorized : True  - if your function is vectorized.
               False - loop over the successive function calls (default).

Uses a semi-adaptive scheme to provide the best estimate of the
derivative by its automatic choice of a differencing interval. It uses
finite difference approximations of various orders, coupled with a
generalized (multiple term) Romberg extrapolation. This also yields the
error estimate provided. See the document DERIVEST.pdf for more explanation
of the algorithms behind the parameters.

 Note on metOrder: higher order methods will generally be more accurate,
         but may also suffer more from numerical problems. First order
         methods would usually not be recommended.
 Note on method: Central difference methods are usually the most accurate,
        but sometimes one can only allow evaluation in forward or backward
        direction.



Assumptions
-----------
  fun - SCALAR analytical function to differentiate.
        fun must be a function of the vector or array x0,
        but it needs not to be vectorized.

  x0  - vector location at which to differentiate fun
        If x0 is an N x M array, then fun is assumed to be
        a function of N*M variables.


Examples
--------
&gt;&gt;&gt; fun = lambda x: np.sum(x**2)
&gt;&gt;&gt; dfun = Gradient(fun)
&gt;&gt;&gt; dfun([1,2,3])
array([ 2.,  4.,  6.])

#At [x,y] = [1,1], compute the numerical gradient
#of the function sin(x-y) + y*exp(x)

&gt;&gt;&gt; sin = np.sin; exp = np.exp
&gt;&gt;&gt; z = lambda xy: sin(xy[0]-xy[1]) + xy[1]*exp(xy[0])
&gt;&gt;&gt; dz = Gradient(z)
&gt;&gt;&gt; grad2 = dz([1, 1])
&gt;&gt;&gt; grad2
array([ 3.71828183,  1.71828183])
&gt;&gt;&gt; dz.error_estimate
array([  1.05697754e-12,   6.39224510e-13])

#At the global minimizer (1,1) of the Rosenbrock function,
#compute the gradient. It should be essentially zero.

&gt;&gt;&gt; rosen = lambda x : (1-x[0])**2 + 105.*(x[1]-x[0]**2)**2
&gt;&gt;&gt; rd = Gradient(rosen)
&gt;&gt;&gt; grad3 = rd([1,1])
&gt;&gt;&gt; grad3
array([ 0.,  0.])
&gt;&gt;&gt; rd.error_estimate
array([  2.22044605e-15,   2.22044605e-15])


See also
--------
Derivative, Hessdiag, Hessian, Jacobian
</pre>
<hr/>


<!-- =========== START OF METHOD SUMMARY =========== -->
<table class="summary" border="1" cellpadding="3" cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="summary">
  <th colspan="2">Method Summary</th></tr>
<tr><td align="right" valign="top" width="15%"><font size="-1">&nbsp;</font></td>
  <td><code><a name="__call__"></a><span class="summary-sig"><span class="summary-sig-name">__call__</span>(<span class=summary-sig-arg>self</span>,
          <span class=summary-sig-arg>x00</span>)</span></code>
</td></tr>
<tr><td align="right" valign="top" width="15%"><font size="-1">&nbsp;</font></td>
  <td><code><span class="summary-sig"><a href="numdifftools.core.Gradient-class.html#gradient" class="summary-sig-name"><code>gradient</code></a>(<span class=summary-sig-arg>self</span>,
          <span class=summary-sig-arg>x00</span>)</span></code>
<br />
Gradient vector of an analytical function of n variables

CALL: [grad,err,finaldelta] = fun.gradient(x0)

 grad = first partial derivatives of fun evaluated at x0.</td></tr>
<tr bgcolor="#e8f0f8" class="group">
  <th colspan="2">&nbsp;&nbsp;&nbsp;&nbsp;Inherited from Derivative</th></tr>
<tr><td align="right" valign="top" width="15%"><font size="-1">&nbsp;</font></td>
  <td><code><span class="summary-sig"><a href="numdifftools.core.Derivative-class.html#__init__" class="summary-sig-name"><code>__init__</code></a>(<span class=summary-sig-arg>self</span>,
          <span class=summary-sig-arg>fun</span>,
          <span class="summary-sig-kwarg">**kwds</span>)</span></code>
</td></tr>
<tr><td align="right" valign="top" width="15%"><font size="-1">&nbsp;</font></td>
  <td><code><span class="summary-sig"><a href="numdifftools.core.Derivative-class.html#derivative" class="summary-sig-name"><code>derivative</code></a>(<span class=summary-sig-arg>self</span>,
          <span class=summary-sig-arg>x00</span>)</span></code>
<br />
Return estimate of n'th derivative of fun at x0 using romberg 
extrapolation</td></tr>
<tr bgcolor="#e8f0f8" class="group">
  <th colspan="2">&nbsp;&nbsp;&nbsp;&nbsp;Inherited from object</th></tr>
<tr><td align="right" valign="top" width="15%"><font size="-1">&nbsp;</font></td>
  <td><code><span class="summary-sig"><a href="__builtin__.object-class.html#__delattr__" class="summary-sig-name"><code>__delattr__</code></a>(<span class="summary-sig-vararg">...</span>)</span></code>
<br />
x.__delattr__('name') &lt;==&gt; del x.name</td></tr>
<tr><td align="right" valign="top" width="15%"><font size="-1">&nbsp;</font></td>
  <td><code><span class="summary-sig"><a href="__builtin__.object-class.html#__getattribute__" class="summary-sig-name"><code>__getattribute__</code></a>(<span class="summary-sig-vararg">...</span>)</span></code>
<br />
x.__getattribute__('name') &lt;==&gt; x.name</td></tr>
<tr><td align="right" valign="top" width="15%"><font size="-1">&nbsp;</font></td>
  <td><code><span class="summary-sig"><a href="__builtin__.object-class.html#__hash__" class="summary-sig-name"><code>__hash__</code></a>(<span class=summary-sig-arg>x</span>)</span></code>
<br />
x.__hash__() &lt;==&gt; hash(x)</td></tr>
<tr><td align="right" valign="top" width="15%"><font size="-1">&nbsp;</font></td>
  <td><code><span class="summary-sig"><a href="__builtin__.object-class.html#__reduce__" class="summary-sig-name"><code>__reduce__</code></a>(<span class="summary-sig-vararg">...</span>)</span></code>
<br />
helper for pickle</td></tr>
<tr><td align="right" valign="top" width="15%"><font size="-1">&nbsp;</font></td>
  <td><code><span class="summary-sig"><a href="__builtin__.object-class.html#__reduce_ex__" class="summary-sig-name"><code>__reduce_ex__</code></a>(<span class="summary-sig-vararg">...</span>)</span></code>
<br />
helper for pickle</td></tr>
<tr><td align="right" valign="top" width="15%"><font size="-1">&nbsp;</font></td>
  <td><code><span class="summary-sig"><a href="__builtin__.object-class.html#__repr__" class="summary-sig-name"><code>__repr__</code></a>(<span class=summary-sig-arg>x</span>)</span></code>
<br />
x.__repr__() &lt;==&gt; repr(x)</td></tr>
<tr><td align="right" valign="top" width="15%"><font size="-1">&nbsp;</font></td>
  <td><code><span class="summary-sig"><a href="__builtin__.object-class.html#__setattr__" class="summary-sig-name"><code>__setattr__</code></a>(<span class="summary-sig-vararg">...</span>)</span></code>
<br />
x.__setattr__('name', value) &lt;==&gt; x.name = value</td></tr>
<tr><td align="right" valign="top" width="15%"><font size="-1">&nbsp;</font></td>
  <td><code><span class="summary-sig"><a href="__builtin__.object-class.html#__str__" class="summary-sig-name"><code>__str__</code></a>(<span class=summary-sig-arg>x</span>)</span></code>
<br />
x.__str__() &lt;==&gt; str(x)</td></tr>
<tr bgcolor="#e8f0f8" class="group">
  <th colspan="2">&nbsp;&nbsp;&nbsp;&nbsp;Inherited from type</th></tr>
<tr><td align="right" valign="top" width="15%"><font size="-1">&nbsp;</font></td>
  <td><code><span class="summary-sig"><a href="__builtin__.type-class.html#__new__" class="summary-sig-name"><code>__new__</code></a>(<span class=summary-sig-arg>T</span>,
          <span class=summary-sig-arg>S</span>,
          <span class="summary-sig-vararg">...</span>)</span></code>
<br />
T.__new__(S, ...) -&gt; a new object with type S, a subtype of T</td></tr>
</table><br />


<!-- =========== START OF METHOD DETAILS =========== -->
<table class="details" border="1" cellpadding="3" cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="details">
  <th colspan="2">Method Details</th></tr>
</table>

<a name="gradient"></a>
<table width="100%" class="func-details" bgcolor="#e0e0e0"><tr><td>
  <h3><span class="sig"><span class="sig-name">gradient</span>(<span class=sig-arg>self</span>,
          <span class=sig-arg>x00</span>)</span>
  </h3>
<pre class="literalblock">
Gradient vector of an analytical function of n variables

CALL: [grad,err,finaldelta] = fun.gradient(x0)

 grad = first partial derivatives of fun evaluated at x0.    Size 1 x N
 err  = error estimates corresponding to each value in grad. Size 1 x N
 finaldelta = vector of final step sizes chosen for each partial derivative.
 fun  = analytical function to differentiate. fun must
       be a function of the vector or array x0.
 x0   = vector location at which to differentiate fun
       If x0 is an nxm array, then fun is assumed to be
       a function of N = n*m variables.

GRADEST estimate first partial derivatives of fun evaluated at x0.
GRADEST uses derivest to provide both derivative estimates
and error estimates. fun needs not be vectorized.

Examples

 #[grad,err] = gradest(&#64;(x) sum(x.^2),[1 2 3]) #  grad = [ 2,4, 6];
</pre>
  <dl><dt></dt><dd>
  </dd></dl>
</td></tr></table>
<br />


<!-- =========== START OF NAVBAR =========== -->
<table class="navbar" border="0" width="100%" cellpadding="0" bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="center">
    <th class="navbar">&nbsp;&nbsp;&nbsp;<a class="navbar" href="numdifftools-module.html">Home</a>&nbsp;&nbsp;&nbsp;</th>
    <th class="navbar">&nbsp;&nbsp;&nbsp;<a class="navbar" href="trees.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>
    <th class="navbar">&nbsp;&nbsp;&nbsp;<a class="navbar" href="indices.html">Index</a>&nbsp;&nbsp;&nbsp;</th>
    <th class="navbar">&nbsp;&nbsp;&nbsp;<a class="navbar" href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>
    <th class="navbar" width="100%"></th>
  </tr>
</table>

<table border="0" cellpadding="0" cellspacing="0" width="100%">
  <tr>
    <td align="left"><font size="-2">Generated by Epydoc 2.0 on Sat Nov 22 02:00:54 2008</font></td>
    <td align="right"><a href="http://epydoc.sourceforge.net"
                      ><font size="-2">http://epydoc.sf.net</font></a></td>
  </tr>
</table>
</body>
</html>
