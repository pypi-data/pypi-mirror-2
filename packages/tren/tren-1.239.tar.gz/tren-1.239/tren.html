<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.7: http://docutils.sourceforge.net/" />
<title></title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 6253 2010-03-02 00:24:53Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: left }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document">


<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#name" id="id1">NAME</a></li>
<li><a class="reference internal" href="#how-to-use-this-document" id="id2">HOW TO USE THIS DOCUMENT</a></li>
<li><a class="reference internal" href="#reference" id="id3">REFERENCE</a></li>
<li><a class="reference internal" href="#synopsis" id="id4">SYNOPSIS</a></li>
<li><a class="reference internal" href="#specifying-options" id="id5">SPECIFYING OPTIONS</a><ul>
<li><a class="reference internal" href="#options" id="id6">OPTIONS</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tutorial-and-description" id="id7">TUTORIAL AND DESCRIPTION</a><ul>
<li><a class="reference internal" href="#overview" id="id8">Overview</a></li>
<li><a class="reference internal" href="#a-word-about-program-defaults" id="id9">A Word About Program Defaults</a></li>
<li><a class="reference internal" href="#getting-help" id="id10">Getting Help</a></li>
<li><a class="reference internal" href="#controlling-program-output" id="id11">Controlling Program Output</a></li>
<li><a class="reference internal" href="#managing-complexity" id="id12">Managing Complexity</a></li>
<li><a class="reference internal" href="#renaming-basics" id="id13">Renaming Basics</a></li>
<li><a class="reference internal" href="#literal-string-substitution" id="id14">Literal String Substitution</a></li>
<li><a class="reference internal" href="#substitution-instances" id="id15">Substitution Instances</a></li>
<li><a class="reference internal" href="#limiting-renaming-to-only-part-of-name" id="id16">Limiting Renaming To Only Part Of Name</a></li>
<li><a class="reference internal" href="#more-about-slice-notation" id="id17">More About Slice Notation</a></li>
<li><a class="reference internal" href="#multiple-substitutions" id="id18">Multiple Substitutions</a></li>
<li><a class="reference internal" href="#more-about-command-line-pitfalls" id="id19">More About Command Line Pitfalls</a></li>
<li><a class="reference internal" href="#forcing-renaming" id="id20">Forcing Renaming</a></li>
<li><a class="reference internal" href="#ignoring-case" id="id21">Ignoring Case</a></li>
<li><a class="reference internal" href="#case-transformation" id="id22">Case Transformation</a></li>
<li><a class="reference internal" href="#the-strange-case-of-mac-os-x-and-windows" id="id23">The Strange Case Of Mac OS X And Windows</a></li>
<li><a class="reference internal" href="#using-regular-expressions" id="id24">Using Regular Expressions</a></li>
<li><a class="reference internal" href="#changing-the-renaming-separator-escape-characters" id="id25">Changing The Renaming Separator &amp; Escape Characters</a></li>
<li><a class="reference internal" href="#interactive-renaming" id="id26">Interactive Renaming</a></li>
<li><a class="reference internal" href="#an-overview-of-renaming-tokens" id="id27">An Overview Of Renaming Tokens</a></li>
<li><a class="reference internal" href="#renaming-token-pitfalls" id="id28">Renaming Token Pitfalls</a></li>
<li><a class="reference internal" href="#renaming-tokens-the-gory-details" id="id29">Renaming Tokens: The Gory Details</a></li>
<li><a class="reference internal" href="#what-s-the-difference-between-an-attribute-and-a-sequence" id="id30">What's The Difference Between An &quot;Attribute&quot; And A &quot;Sequence&quot;?</a></li>
<li><a class="reference internal" href="#how-tren-uses-file-metadata" id="id31">How <strong>tren</strong> Uses File Metadata</a></li>
<li><a class="reference internal" href="#general-attribute-renaming-tokens" id="id32">General Attribute Renaming Tokens</a></li>
<li><a class="reference internal" href="#time-related-attribute-renaming-tokens" id="id33">Time-Related Attribute Renaming Tokens</a></li>
<li><a class="reference internal" href="#system-renaming-tokens" id="id34">System Renaming Tokens</a></li>
<li><a class="reference internal" href="#sequence-renaming-tokens" id="id35">Sequence Renaming Tokens</a></li>
<li><a class="reference internal" href="#general-format-of-sequence-renaming-tokens" id="id36">General Format Of Sequence Renaming Tokens</a></li>
<li><a class="reference internal" href="#let-s-learn-the-alphabet" id="id37">Let's Learn The Alphabet</a></li>
<li><a class="reference internal" href="#counting-pattern-format" id="id38">Counting Pattern Format</a></li>
<li><a class="reference internal" href="#types-of-sequence-renaming-tokens" id="id39">Types Of Sequence Renaming Tokens</a></li>
</ul>
</li>
<li><a class="reference internal" href="#common-tasks-and-idioms" id="id40">COMMON TASKS AND IDIOMS</a></li>
<li><a class="reference internal" href="#odds-and-ends" id="id41">ODDS AND ENDS</a></li>
<li><a class="reference internal" href="#bugs-misfeatures-other" id="id42">BUGS, MISFEATURES, OTHER</a></li>
<li><a class="reference internal" href="#how-come-there-s-no-gui" id="id43">HOW COME THERE'S NO GUI?</a></li>
<li><a class="reference internal" href="#copyright-and-licensing" id="id44">COPYRIGHT AND LICENSING</a></li>
<li><a class="reference internal" href="#author" id="id45">AUTHOR</a></li>
<li><a class="reference internal" href="#document-revision-information" id="id46">DOCUMENT REVISION INFORMATION</a></li>
</ul>
</div>
<div class="section" id="name">
<h1><a class="toc-backref" href="#id1">NAME</a></h1>
<p><strong>tren</strong> - Advanced File Renaming</p>
</div>
<div class="section" id="how-to-use-this-document">
<h1><a class="toc-backref" href="#id2">HOW TO USE THIS DOCUMENT</a></h1>
<p><strong>tren</strong> is a powerful command line file/directory renaming tool.  It
implements a variety of sophisticated renaming features than can be a bit
complex to learn.  For this reason, this document is split into two
general sections: &quot;<a class="reference internal" href="#reference">REFERENCE</a>&quot; and &quot;<a class="reference internal" href="#tutorial-and-description">TUTORIAL AND DESCRIPTION</a>&quot;.  If
you are new to <strong>tren</strong>, start by studying the latter section first.
It will take you from very simple- to highly  complex <strong>tren</strong> renaming
operations.  Once you've got a sense of what
<strong>tren</strong> can do, the reference section will be handy to look up
options and their arguments.</p>
<div class="danger">
<p class="first admonition-title">!DANGER!</p>
<p class="last"><strong>tren</strong> is very powerful and can easily and
automatically rename things in ways you didn't intend.
It is <strong>strongly</strong> recommended that you try out new
<strong>tren</strong> operations with the <tt class="docutils literal"><span class="pre">-t</span></tt> option on the command
line.  This turns on the &quot;test mode&quot; and will show you
what the program <em>would</em> do without actually doing it.
It goes without saying that you should be even more
careful when using this program as the system root or
administrator.  It's quite easy to accidentally rename
system files and thereby clobber your OS.  You have been
warned!!!</p>
</div>
</div>
<div class="section" id="reference">
<h1><a class="toc-backref" href="#id3">REFERENCE</a></h1>
</div>
<div class="section" id="synopsis">
<h1><a class="toc-backref" href="#id4">SYNOPSIS</a></h1>
<pre class="literal-block">
tren.py [-aCcdfhqtvXx] [-A alphabet] [-I file] [-i range]  [-P esc] \
        [-R sep] [-r old=new] [-S suffix] [-w width]     file|dir ...
</pre>
</div>
<div class="section" id="specifying-options">
<h1><a class="toc-backref" href="#id5">SPECIFYING OPTIONS</a></h1>
<p>You may specify <em>tren</em> options in one of three ways:</p>
<blockquote>
<ol class="arabic simple">
<li>On the command line</li>
<li>In an &quot;include&quot; file specified with <tt class="docutils literal"><span class="pre">-I</span> filename</tt> on the command line</li>
<li>Via the <tt class="docutils literal">$TREN</tt> environment variable</li>
</ol>
</blockquote>
<p>Options specified on the command line are evaluated from left to right
and supercede any options specified in the environment variable.
Think of any options set in <tt class="docutils literal">$TREN</tt> as the &quot;leftmost command line
options&quot;.</p>
<p>All options must precede the list of files and/or directories being
renamed.  If one of your rename targets start with the <tt class="docutils literal">-</tt>
character, most command shells recognize the double dash as an
explicit &quot;end of options&quot; delimiter:</p>
<pre class="literal-block">
tren.py -opt -opt -- -this_file_starts_with_a_dash
</pre>
<p>The list of items targeted for renaming must name directories or files
that exist or be a wildcard that expands to existing directories or
files.  If you specify a non-existent renaming target, <tt class="docutils literal">tren</tt> will
display an error and stop further processing.</p>
<p>Most shells aren't too fussy about space between an option
that takes an argument, and that argument:</p>
<pre class="literal-block">
-i 1
-i1
</pre>
<p>Use whichever form you prefer.  Just be aware that there are places
where spaces matter.  For example, you can quote spaces on your
command line to create renaming requests that, say, replace spaces
with dashes..</p>
<p>Some options below are &quot;global&quot; - they change the state of the entire
program permanently and cannot be undone by subsequent options.  Some
options are &quot;toggles&quot;, they can be turned on- and off as you move from
left- to right on the command line.  In this way, certain options
(like case sensitivity, regular expression handling, and so on) can be
set differently for each individual renaming request (<tt class="docutils literal"><span class="pre">-r</span></tt>).  (If
you're very brave, you can select the <tt class="docutils literal"><span class="pre">-d</span></tt> option to do a debug
dump.  Among many other things, the <strong>tren</strong> debugger dumps the state
of each renaming request, and what options are in effect for that
request.)</p>
<div class="section" id="options">
<h2><a class="toc-backref" href="#id6">OPTIONS</a></h2>
<blockquote>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-A <var>alphabet</var></span></kbd></td>
<td><p class="first">Install a user-defined &quot;alphabet&quot; to be used by
sequence renaming tokens.</p>
<p>(<em>Default</em>: Built-in alphabets only)</p>
<p>The alphabet is specified in the form:</p>
<pre class="literal-block">
name:characterset
</pre>
<p>Both the name and the characterset are case- and
whitespace-sensitive (if your shell permits passing
spaces on the command line). The &quot;0th&quot; element
of the alphabet is the leftmost character.  The
counting base is the length of <tt class="docutils literal">characterset</tt>.
So, for instance, the following alphabet is
named <tt class="docutils literal">Foo</tt>, counts in base 5 in the
sequence, <tt class="docutils literal">a, b, c, d, e, ba, bb, ...</tt>:</p>
<pre class="last literal-block">
-A Foo:abcde
</pre>
</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-a</span></kbd></td>
<td><p class="first">Ask interactively before renaming each selected file or
directory.</p>
<blockquote>
(<em>Default</em>: off)</blockquote>
<p>If you invoke this option, <strong>tren</strong> will prompt you before
renaming each file.  The default (if you just hit <tt class="docutils literal">Enter</tt>) is
to <em>not</em> rename the file.  Otherwise, you have the following
options:</p>
<pre class="literal-block">
n - Don't rename the current file

y - Rename the current file

! - Rename all the remaining files
    without further prompting

q - Quit the program
</pre>
<p>These options are all insensitive to case.</p>
<p class="last">If you're doing forced renaming (<tt class="docutils literal"><span class="pre">-f</span></tt>), this option will
interactively ask you first about making any necessary backups
and then renaming the original target.  <em>If you decline to
do the backup renaming, but accept the renaming of the original
target, the file or directory that already exists with that
name will be lost!</em>.</p>
</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-b</span></kbd></td>
<td><p class="first">Turn off backups during forced renaming.</p>
<p>(<em>Default</em>: Do Backups)</p>
<p class="last">Ordinarily, <strong>tren</strong> will refuse to do a renaming if the new
name for a file- or directory already exists.  You can
override this with the <tt class="docutils literal"><span class="pre">-f</span></tt> (forced renaming) option.  By
default, forced renaming makes a backup copy of the existing
file (by appending <tt class="docutils literal">.backup</tt> to its name or some other
suffix you specify with the <tt class="docutils literal"><span class="pre">-S</span></tt> option) before doing the
renaming.  This prevents existing files from being lost due to
a renaming.  The <tt class="docutils literal"><span class="pre">-b</span></tt> option <em>inhibits backups</em> and allows
renaming over existing file- and directory names, thereby
losing the original file- or directory.</p>
</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-C</span></kbd></td>
<td><p class="first">Do case sensitive renaming</p>
<blockquote>
(<em>Default</em>: This is the program default)</blockquote>
<p>This option is provided so you can toggle the program back to
its default behavior after a previous <tt class="docutils literal"><span class="pre">-c</span></tt> on the command
line.</p>
<p class="last">This option is observed both for literal and regular
expression-based renaming (<tt class="docutils literal"><span class="pre">-x</span></tt>).  .</p>
</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-c</span></kbd></td>
<td><p class="first">Collapse case when doing string substitution.</p>
<blockquote>
(<em>Default</em>: Search for string to replace is case sensitive)</blockquote>
<p>When looking for a match on the old string to replace,
<strong>tren</strong> will ignore the case of the characters found
in the file name.  For example:</p>
<pre class="literal-block">
tren.py -cr Old=NEW Cold.txt fOlD.txt
</pre>
<p>This renames both files to <tt class="docutils literal">CNEW.txt</tt> and <tt class="docutils literal">fNEW.txt</tt>
respectively.  Notice that the new (replacement) string's case
is preserved.</p>
<p class="last">This option is observed both for literal and regular
expression-based renaming (<tt class="docutils literal"><span class="pre">-x</span></tt>).</p>
</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-d</span></kbd></td>
<td><p class="first">Dump debugging information</p>
<blockquote>
(<em>Default</em>: Off)</blockquote>
<p>Dumps all manner of information about <strong>tren</strong> internals - of
interest only to program developers and maintainers.  This
option provides internal program state <em>at the time it is
encountered on the command line</em>.  For maximum debug output,
place this as the last (rightmost) option on the command line,
right before the list of files and directories to rename.  You
can also place multiple <tt class="docutils literal"><span class="pre">-d</span></tt> options on the command line to
see how the internal tables of the program change as various
options are parsed.</p>
<p>This option also shows each incremental change to a file name
as each renaming request specified on the command line is
applied.  This can be helful when figuring out a new/complex
renaming operation.   This is most easily used by invoking
the &quot;quiet&quot; and &quot;test&quot; modes:</p>
<pre class="last literal-block">
tren.py -tqd -r... -r... file file...
</pre>
</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-e <var>casetype</var></span></kbd></td>
<td><p class="first">Force case change to <tt class="docutils literal">casetype</tt>.</p>
<p>(<em>Default</em>: No forced case.)</p>
<p>This option supports a number of <tt class="docutils literal">casetype</tt> arguments
to transform the case of the file name:</p>
<pre class="literal-block">
c - Capitalize the file name
l - Force file name to lower-case
s - Swap case of file name characters
t - Force file name to title case
u - Force file name to upper-case
</pre>
<p>&quot;Title case&quot; just means that any alphabetic character following
a non-alphabetic character will be capitalized:</p>
<pre class="literal-block">
tren.py -et fee_fi_fo # -&gt; Fee_Fi_Fo
</pre>
<p>Notice that these case transformations are a kind of special
built-in renaming request with one important difference: The
<tt class="docutils literal"><span class="pre">-i</span></tt> &quot;instance&quot; setting is ignored.  That's because the
<tt class="docutils literal"><span class="pre">-e</span></tt> option isn't based on replacing an &quot;old&quot; string like the
<tt class="docutils literal"><span class="pre">-r</span></tt> renaming option, but rather operates on the file name as
a whole.</p>
<p>There is, however, a way to limit the effect of the case
forcing options because the <tt class="docutils literal"><span class="pre">-T</span></tt> or &quot;target&quot; option <em>is</em>
observed.  You can thus limit the which portion of the file
name should have its case changed:</p>
<pre class="last literal-block">
tren.py -T4:6 -eu fee_fi_fo # -&gt; fee_FI_fo
</pre>
</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-f</span></kbd></td>
<td><p class="first">Force renaming even if target file or directory name already
exists.</p>
<p>(<em>Default</em>: Skip renaming if a file or directory already
exists by the same name as the target.)</p>
<p class="last">By default, <strong>tren</strong> will not rename something to a name that
is already in use by another file or directory.  This option
forces the renaming to take place.  However, the old file or
directory is not lost.  It is merely renamed itself first, by
appending a suffix to the original file name. (<em>Default</em>:
.backup, but you can change it via the <tt class="docutils literal"><span class="pre">-S</span></tt> option.)  This
way even forced renames don't clobber existing files or
directories.</p>
</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-h</span></kbd></td>
<td>Print help information.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-I <var>file</var></span></kbd></td>
<td><p class="first">&quot;Include&quot;  command line arguments from <tt class="docutils literal">file</tt></p>
<p>It is possible to perform multiple renaming operations in one
step using more than one <tt class="docutils literal"><span class="pre">-r</span></tt> option on the <strong>tren</strong> command
line.  However, this can make the command line very long and
hard to read.  This is especially true if the renaming strings
are complex, contain regular expressions or Renaming
Tokens, or if you make heavy use of command line toggles.</p>
<p>The <tt class="docutils literal"><span class="pre">-I</span></tt> option allows you to place any command line
arguments in a separate <em>file</em> in place of- or in addition to
the <strong>tren</strong> command line and/or the <tt class="docutils literal">$TREN</tt> environment
variable.  This file is read one line at a time and the
contents appended to any existing command line.  You can even
name the files you want renamed in the file, but they must
appear as the last lines of that file (because they must appear
last on the command line).</p>
<p>Whitespace is ignored as is anything from a <tt class="docutils literal">#</tt> to the end of
a line:</p>
<pre class="literal-block">
# Example replacement string file
# Each line appended sequentially
# to the command line

-xr t[ext]+=txt     # Appended first
-X
-r =/MYEAR/ -r foo=bar
my.file
your.file          # Appended last
</pre>
<p>You may &quot;nest&quot; includes.  That is, you can include file <tt class="docutils literal">x</tt>,
that includes file <tt class="docutils literal">y</tt>, that includes file <tt class="docutils literal">z</tt> and so on.
However, its easy to introduce a &quot;circular reference&quot; when you
do this.  Suppose file <tt class="docutils literal">z</tt> tried to include file <tt class="docutils literal">x</tt> in
this example?  You'd be specifying an infinite inclusion loop.
To avoid this, <strong>tren</strong> limits the total number of inclusions
to 1000.  If you exceed this, you'll get an error message and
the program will terminate.</p>
<p>Note that wildcard metacharacters like <tt class="docutils literal">*</tt> and <tt class="docutils literal">?</tt> that are
embedded in file names included this way are expanded as they
would be from the command shell.</p>
<p>You can define an environment  variable, <tt class="docutils literal">TRENINCL</tt>, to specify
a path to search to find the named include file(s).  <tt class="docutils literal">tren</tt> will
use the first (leftmost) instance of the include file it finds along
this path.  If none are found, <tt class="docutils literal">tren</tt> uses the file path as passed on
the command line.  This allows relative- and absolute include
file paths to be used along with files in an include path:</p>
<pre class="literal-block">
export TRENINCL=$HOME/.tren:/some/where/else
cp file1 $HOME/.tren/
tren.py -I file1 -I foo/file2 -I /foo/bar/file3 *

'file1' will be found in $HOME/.tren/
'file2' will be found relative to current dir
'file3' will be found on absolute path
</pre>
<p class="last">Note that when defining <tt class="docutils literal">TRENINCL</tt>, you must use the path
delimiter appropriate for the operating system in question.
For Windows, this is <tt class="docutils literal">;</tt>, For all other supported OSes, it
is <tt class="docutils literal">:</tt>.</p>
</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-i <var>instances</var></span></kbd></td>
<td><p class="first">Specifies which &quot;instances&quot; of matching strings should
be replaced.</p>
<p>(<em>Default</em>: 0 or leftmost)</p>
<p>A file may have multiple instances of the <tt class="docutils literal">old</tt>
renaming string in it.  The <tt class="docutils literal"><span class="pre">-i</span></tt> option lets you
specify which of these (one, several, all) you'd
like to have replaced.</p>
<p>Suppose you have a file called
<tt class="docutils literal"><span class="pre">foo1-foo2-foo3.foo4</span></tt>.  The leftmost <tt class="docutils literal">foo</tt> is
instance 0.  The rightmost <tt class="docutils literal">foo</tt> is instance 3.
You can also refer to instances relative to the
right.  So the -1 instance is the last (rightmost),
-2, second from the last, and so forth.</p>
<p>Often, you just want to replace a specific instance:</p>
<pre class="literal-block">
-i :3 -r foo=boo
-i :-1 -r foo=boo
</pre>
<p>Both of these refer to the last instance of old string
<tt class="docutils literal">foo</tt> (found at <tt class="docutils literal">foo4</tt> in our example name).</p>
<p>Sometimes, you'd like to replace a whole <em>range</em> of
instances.  An &quot;instance range&quot; is specified using the
<tt class="docutils literal">:</tt> separator in the form:</p>
<pre class="literal-block">
-i first-to-replace:stop-here
</pre>
<p>Notice that the &quot;stop-here&quot; instance is NOT replaced.
In our string above, the option:</p>
<pre class="literal-block">
-i 1:-1 -r foo=boo
</pre>
<p>Would change the file name to:</p>
<pre class="literal-block">
foo1-boo2-boo3.foo4
</pre>
<p>You can also provide partial ranges:</p>
<pre class="literal-block">
-i 1: # Instance 1 to end of name

-i :-2 # Instances to (not including) next-to-last

-i :   # All instances
</pre>
<p class="last">If you provide an instance range that makes no sense
or is out of range, <tt class="docutils literal">tren</tt> will ignore the argument
and leave the instance specification unchanged.</p>
</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-P <var>char</var></span></kbd></td>
<td><p class="first">Use <tt class="docutils literal">char</tt> as the escape symbol.</p>
<p class="last">(<em>Default</em>: <tt class="docutils literal">\</tt>)</p>
</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-q</span></kbd></td>
<td><p class="first">Quiet mode, do not show progress.</p>
<blockquote>
(<em>Default</em>: Display progress)</blockquote>
<p>Ordinarily, <strong>tren</strong> displays what it is doing as it processes
each file.  If you prefer to not see this &quot;noisy&quot; output, use
the <tt class="docutils literal"><span class="pre">-q</span></tt> option.  Note that this does not suppress warning
and error messages.</p>
<p class="last">It doesn't make much sense to use this option in test mode
(<tt class="docutils literal"><span class="pre">-t</span></tt>), although you can.  The whole point of test mode is
to see what would happen.  Using the quiet mode suppresses that
output.</p>
</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-R <var>char</var></span></kbd></td>
<td><p class="first">Use <tt class="docutils literal">char</tt> as the separator symbol in renaming
specifications.</p>
<p class="last">(<em>Default</em>: <tt class="docutils literal">=</tt>)</p>
</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-r <var>&lt;old=new&gt;</var></span></kbd></td>
<td><p class="first">Replace <tt class="docutils literal">old</tt> with <tt class="docutils literal">new</tt> in file or directory
names.</p>
<p>Use this option to specify which strings you want to
replace in each file name. These strings are treated
literally unless you also invoke the <tt class="docutils literal"><span class="pre">-x</span></tt> option.  In
that case, <tt class="docutils literal">old</tt> is treated as a Python style
regular expression.</p>
<p>Both <tt class="docutils literal">old</tt> and <tt class="docutils literal">new</tt> may optionally contain
<em>renaming tokens</em> described later in this document.</p>
<p>If you need to use the <tt class="docutils literal">=</tt> symbol <em>within</em> either
the old or new string, simply escape it: <tt class="docutils literal">\=</tt></p>
<p>If it is convenient, you can change the separator
character to something other than <tt class="docutils literal">=</tt> via the
<tt class="docutils literal"><span class="pre">-R</span></tt> option.  Similarly, you can change the
escape character via the <tt class="docutils literal"><span class="pre">-P</span></tt> option.</p>
<p>You can have multiple instances of this option on
your <strong>tren</strong> command line:</p>
<pre class="literal-block">
tren.py -r old=new -r txt:doc old-old.txt
</pre>
<p>This renames the file to:</p>
<pre class="literal-block">
new-old.doc
</pre>
<p>Remember that, by default, <strong>tren</strong> only replaces the first
(leftmost) instance of the old string with the new.</p>
<p>Each rename specification on the command line
&quot;remembers&quot; the current state of all the program
options and acts accordingly.  For example:</p>
<pre class="literal-block">
tren.py -cr A=bb -Cr B=cc ...
</pre>
<p class="last">The <tt class="docutils literal">A=bb</tt> replacement would be done without
regard to case (both <tt class="docutils literal">A</tt> and <tt class="docutils literal">a</tt> would match),
whereas the <tt class="docutils literal">B=cc</tt> request would only replace
<tt class="docutils literal">B</tt>.</p>
</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-S <var>suffix</var></span></kbd></td>
<td><p class="first">Suffix to append when making backup copies of existing
targets.</p>
<p>(<em>Default</em>: .backup)</p>
<p class="last">If you choose to force file renaming when the new
name already exists (<tt class="docutils literal"><span class="pre">-f</span></tt>), <strong>tren</strong> simply renames
the existing file or directory by appending a suffix to
it.  By default, this suffix is <tt class="docutils literal">.backup</tt>, but you
can change it to any string you like with the <tt class="docutils literal"><span class="pre">-S`</span></tt>
option.</p>
</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-T <var>range</var></span></kbd></td>
<td><p class="first">Target the range of characters within file name subject to renaming.</p>
<blockquote>
<p>(<em>Default</em>: Entire file name is subject to renaming.)</p>
<p>Ordinarily, <tt class="docutils literal">tren</tt> applies renaming requests and forced
case conversions to the entire file name.  The <tt class="docutils literal"><span class="pre">-T</span></tt>
option allows you to specify some substring of the name as
the &quot;target&quot; for renaming.  The &quot;range&quot; argument is in the
same slice notation used for the <tt class="docutils literal"><span class="pre">-i</span></tt> command.  So, for
example:</p>
<pre class="literal-block">
tren.py -T1:3 -r=XYZ abcdefg # -&gt; aXYZdefg
</pre>
<p>Similarly:</p>
<pre class="literal-block">
tren.py -T 1:4 -es aXYZdefg # -&gt; axyzdefg
</pre>
<p>The <tt class="docutils literal"><span class="pre">-T</span></tt> option operates on all subsequent renaming or
case forcing operations to the right of it on the command
line.  So, if you want to go back to the default behavior of
applying renaming to the entire file, you have to set the
&quot;target&quot; back to the entire file name:</p>
<pre class="literal-block">
tren.py -T1:4 -es -T: -rg=-X axyzdeg # -&gt; aXYZde-X
</pre>
</blockquote>
<p class="last">As with the <tt class="docutils literal"><span class="pre">-i</span></tt> option, range slices that make no sense
or are out of range, are simply ignored, and the portion of
the file name targeted for renaming is left unchanged.</p>
</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-t</span></kbd></td>
<td><p class="first">Test mode, don't rename, just show what the program <em>would</em> do.</p>
<p><strong>tren</strong> is very powerful and capable of doing nasty things to
your file and directory names.  For this reason, it is helpful
to test your <strong>tren</strong> commands before actually using them.
With this option enabled, <strong>tren</strong> will print out diagnostic
information about what your command <em>would</em> do, <em>without
actually doing it</em>.</p>
<p class="last">If your renaming requests contain random renaming tokens,
test mode will only show you an approximation of the renaming
to take place (because new random name strings are generated
each time the program runs).</p>
</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-v</span></kbd></td>
<td><p class="first">Print detailed program version information and keep running.</p>
<p class="last">This is handy if you're capturing <strong>tren</strong> output into a log
and you want a record of what version of the program was used.</p>
</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-w <var>length</var></span></kbd></td>
<td><p class="first">Set the length of diagnostic and error output.</p>
<p>(<em>Default</em>: 80)</p>
<p><strong>tren</strong> limits output to this length when dumping
debug information, errors, warnings, and general
information as it runs.  This option is especially
useful when you're capturing <strong>tren</strong> output into
a log and don't want lines wrapped:</p>
<pre class="literal-block">
tren.py -w999 ..... 2&gt;&amp;1 &gt; tren.log
</pre>
<p class="last"><strong>tren</strong> makes sure you don't set this to some
unreasonably small value such that output formatting
would be impossible.</p>
</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-X</span></kbd></td>
<td><p class="first">Treat the renaming strings literally</p>
<blockquote>
(<em>Default</em>: This is the program default)</blockquote>
<p class="last">This option is provided so you can toggle the program back to
its default behavior after a previous <tt class="docutils literal"><span class="pre">-x</span></tt> on the command
line.</p>
</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-x</span></kbd></td>
<td><p class="first">Treat the old string in a <tt class="docutils literal"><span class="pre">-r</span></tt> replacement as a Python
style regular expression for matching purposes.</p>
<blockquote class="last">
(<em>Default</em>: Treat the old string as literal text)</blockquote>
</td></tr>
</tbody>
</table>
</blockquote>
</div>
</div>
<div class="section" id="tutorial-and-description">
<h1><a class="toc-backref" href="#id7">TUTORIAL AND DESCRIPTION</a></h1>
<div class="danger">
<p class="first admonition-title">!DANGER!</p>
<p class="last">ONE MORE TIME: <strong>tren</strong> is a powerful file and directory
renaming tool.  Be <strong>sure</strong> you know what you're about to
do.  If you're not, run the program in test mode (invoke
with the <tt class="docutils literal"><span class="pre">-t</span></tt> option) to see what would happen.  You
have been warned!</p>
</div>
<p>The following sections are designed for the new- or occasional
<strong>tren</strong> user.  They begin with the simplest of <strong>tren</strong> operations
and incrementally build more and more complex examples, eventually
describing all of <strong>tren</strong>'s capabilities.</p>
<div class="section" id="overview">
<h2><a class="toc-backref" href="#id8">Overview</a></h2>
<p><strong>tren</strong> is a general purpose file and directory renaming tool. Unlike
commands like <tt class="docutils literal">mv</tt>, <strong>tren</strong> is particularly well suited for
renaming <em>batches</em> of files and/or directories with a single command
line invocation.  <strong>tren</strong> eliminates the tedium of having to script
simpler tools to provide higher-level renaming capabilities.</p>
<p><strong>tren</strong> is also adept at renaming only <em>part of an existing file
or directory name</em> either based on a literal string or a regular
expression pattern.  You can replace any single, group, or all
instances of a given string in a file or directory name.</p>
<p><strong>tren</strong> implements the idea of a &quot;renaming token&quot;.  These are special
names you can embed in your renaming requests that represent things
like the file's original name, its length, date of creation, and so
on.  There are even renaming tokens that will substitute the content
of any environment variable or the results of running a program from a
shell back into the new file name.</p>
<p><strong>tren</strong> can automatically generate <em>sequences</em> of file names based on
their dates, lengths, times within a given date, and so on.  In fact,
sequences can be generated on the basis of any of the file's
<tt class="docutils literal">stat</tt> information.  Sequence &quot;numbers&quot; can be ascending or
descending and the count can start at any initial value.  Counting can
take place in one of several internally defined counting &quot;alphabets&quot;
(decimal, hex, octal, alpha, etc.) OR you can define your own counting
alphabet.  This allows you to create sequences in any base (2 or
higher please :) using any symbol set for the count.</p>
</div>
<div class="section" id="a-word-about-program-defaults">
<h2><a class="toc-backref" href="#id9">A Word About Program Defaults</a></h2>
<p><strong>tren</strong> has many options, but its defaults are designed to do
two things:  a) Simplify the most common operations by making
them the default (no options required on the command line), and
2) Reduce the risk of accidentally modifying more of the file name
than you intented.  So, by default:</p>
<blockquote>
<p><strong>tren</strong> treats renaming requests <em>literally</em>.  That is, the &quot;old
string&quot; you specify for replacement is treated as literal text.  It
requires a command line option (<tt class="docutils literal"><span class="pre">-x</span></tt>) to treat it as a regular
expression.  <em>However</em>, any renaming tokens found in either the old-
or new strings of a renaming request <em>are</em> interpreted before the
renaming takes place.</p>
<p><strong>tren</strong> renaming is <em>case sensitive</em>. If you want to ignore case,
use the <tt class="docutils literal"><span class="pre">-c</span></tt> option.</p>
<p><strong>tren</strong> will only replace the <em>first (leftmost) instance</em> of &quot;old
string&quot; with &quot;new string&quot;.  If you want more- or different instances
replaced, use the <tt class="docutils literal"><span class="pre">-i</span></tt> option.</p>
<p><strong>tren</strong> will not allow you to rename a file or directory <em>if one
with the new name already exists</em>. Such attempts will cause no
change to the file or directory being processed and an error message
will be displayed.  This is intentional to force you to manually
rename or remove the file or directory that would have been
clobbered by a rename.  You can override this default and <em>force</em> a
renaming via the <tt class="docutils literal"><span class="pre">-f</span></tt> option.  This will cause the orginal file or
directory itself to be renamed with a <tt class="docutils literal">.backup</tt> suffix.  You can
change this suffix via the <tt class="docutils literal"><span class="pre">-S</span></tt> option.</p>
</blockquote>
</div>
<div class="section" id="getting-help">
<h2><a class="toc-backref" href="#id10">Getting Help</a></h2>
<p>There are three command line options that can give you some
measure of help and information about using <strong>tren</strong>:</p>
<blockquote>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-d</span></kbd></td>
<td>Dumps debug information out to stderr.  You can insert multiple
instances of this option on the command line to see how the
program has parsed everything <em>to the left</em> of it.  This is
primarily intended as a debugging tool for people maintaining
<strong>tren</strong> but it does provide considerable information on the
internal state of the program that advanced users may find
useful.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-h</span></kbd></td>
<td>Prints a summary of the program invocation syntax and all the
available options and then exits.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-v</span></kbd></td>
<td>Prints the program version number and keeps running.</td></tr>
</tbody>
</table>
</blockquote>
</div>
<div class="section" id="controlling-program-output">
<h2><a class="toc-backref" href="#id11">Controlling Program Output</a></h2>
<p>As <strong>tren</strong> runs, it produces a variety of diagnostic and
status information.  There are a number of options you can
use to control how this works:</p>
<blockquote>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-q</span></kbd></td>
<td>Sets &quot;quiet&quot; mode and suppresses everthing except
error messages.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-w <var>num</var></span></kbd></td>
<td>Tells <strong>tren</strong> to wrap lines after <tt class="docutils literal">num</tt> characters have been
printed.  If you're capturing output to a log, set this to a
very high number like 999 to inhibit line wrapping.</td></tr>
</tbody>
</table>
</blockquote>
<p>Error and debug messages are sent to <tt class="docutils literal">stderr</tt>.  Normal informational
messages are sent to <tt class="docutils literal">stdout</tt>.  If you want to capture them both in
a log, try something like this (depending on your OS and/or shell):</p>
<pre class="literal-block">
tren.py ..... 2&gt;&amp;1 &gt;tren.log
</pre>
</div>
<div class="section" id="managing-complexity">
<h2><a class="toc-backref" href="#id12">Managing Complexity</a></h2>
<p>As you learn more of the program features, the <strong>tren</strong> command line
can get long, complex, and easy to goof up.  It's also hard to
remember all the various options, how they work exactly, and which
specific one you need.  For this reason, it is <em>highly</em> recommended
that - once you have a renaming request working the way you like - if
you plan to use it again, save it as an &quot;include&quot; file.  That
way you can reuse it easily without having to keep track of the
details over and over.  Instead of this:</p>
<pre class="literal-block">
tren.pu -c -i -1 -r .jpeg=.jpg file ...
</pre>
<p>Do this:</p>
<pre class="literal-block">
tren.py -I jpeg-to-jpg.tren file...
</pre>
<p>What's in the <tt class="docutils literal"><span class="pre">jpeg-to-jpg.tren</span></tt> file?  Just this:</p>
<pre class="literal-block">
# tren Command Line
# Converts '.jpeg' (in any case mixture) file name suffix to '.jpg'

# Make the replacement case insensitive
-c   # Reset this later on the command line with -C

# Only replace the rightmost instance
 -i -1

# The actual replacement request
-r  .jpeg=.jpg
</pre>
<p>Notice that you can stick comments in the file anywhere you like and
that they begin with <tt class="docutils literal">#</tt>.  Notice also that the various options
can be entered on separate lines so it's simpler to read the include
file.  If you find it useful, you can even include other include
files <em>in</em> an include file:</p>
<pre class="literal-block">
# Get the jpeg -&gt; jpg suffix renaming

-I  jpeg-to-jpg.tren

# Let's make it fancy

-i -1 -r .jpg=.fancy.jpg
</pre>
<p>If you do this, take care not to create a circular include.  This can
happen when an include file tries to include itself, either directly,
or via another include file.  <strong>tren</strong> limits the total number of
includes to a very large number.  If it sees that the number has been
exceeded, it suspects a circular include and will issue an error
message to that effect and exit.</p>
<p>You can insert include options anywhere you like on the command line
and you can have as many as you like (up to a large number you'll
never hit in practice).  Each include reference will be replaced with
the contents of that file <em>at the position it appears on the command
line</em>.</p>
<p>If you find yourself using certain options most- or every time you use
the program, you can put them in the <strong>$TREN</strong> environment variable.
<strong>tren</strong> picks this up every time it starts.  This minimizes errors
and reduces typing tedium.  Just keep in mind that some options can be
overriden later on a command line, and some cannot.  For instance,
suppose you do this:</p>
<pre class="literal-block">
export TREN=-f -c
</pre>
<p>The <tt class="docutils literal"><span class="pre">-c</span></tt> option to ignore case can be undone on the command line
with a <tt class="docutils literal"><span class="pre">-C</span></tt> option.  However, the <tt class="docutils literal"><span class="pre">-f</span></tt> option cannot be undone.</p>
<p>So ... choose the options you want to make permanent in the
environment variable wisely.</p>
</div>
<div class="section" id="renaming-basics">
<h2><a class="toc-backref" href="#id13">Renaming Basics</a></h2>
<p><strong>tren</strong> supports a variety of renaming mechanisms.  The one thing
they have in common is that they're built with one or more <em>renaming
requests</em> that will be applied to one or more file- or directory
names.  Renaming requests look like this on the <strong>tren</strong> command
line:</p>
<pre class="literal-block">
tren.py ... -r old=new ... -r old=new ... list of files/directories
</pre>
<p>No matter how complicated they look, the basic logic of the
renaming request stays the same: &quot;When you find the string
<tt class="docutils literal">old</tt> in the file- or directory name, change it to the string
<tt class="docutils literal">new</tt>.</p>
<p>The <tt class="docutils literal">old</tt> and <tt class="docutils literal">new</tt> renaming strings are built using a variety of
building blocks:</p>
<blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr><td><em>Old Strings Are Built With:</em></td>
<td><em>New Strings Are Built With:</em></td>
</tr>
<tr><td>Literal Text</td>
<td>Literal Text</td>
</tr>
<tr><td>Regular Expressions</td>
<td>Renaming Tokens</td>
</tr>
<tr><td>Renaming Tokens</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
</blockquote>
<p>You can use any of these building blocks alone or combine them
to create expressive and powerful renaming schemes.</p>
</div>
<div class="section" id="literal-string-substitution">
<h2><a class="toc-backref" href="#id14">Literal String Substitution</a></h2>
<p>Literal String Substitution is just that - it replaces one literal
string with another to rename the target file or directory.  This is
the most common, and simplest way to use <strong>tren</strong>.  This is handy when
you have files and directories that have a common set of characters in
them you'd like to change.  For instance:</p>
<pre class="literal-block">
tren.py -r .Jpeg=.jpg *.Jpeg
</pre>
<p>This would rename all files (or directories) whose names contained the
string <tt class="docutils literal">.Jpeg</tt> and replace it with <tt class="docutils literal">.jpg</tt>.  Well ... that's not
quite right.  Unless you specify otherwise with the <tt class="docutils literal"><span class="pre">-i</span></tt> option,
<em>only the first (leftmost) instance of ``old`` is replaced with
``new``</em>.  So, for example, if you started out with the file,
<tt class="docutils literal">My.Jpeg.Jpeg</tt> and ran the command above, you'd end up with a new
file name of <tt class="docutils literal">My.jpg.Jpeg</tt></p>
<p>You can omit either <tt class="docutils literal">old</tt> or <tt class="docutils literal">new</tt> strings in a renaming
specification, but never both.</p>
<p>If you omit the <tt class="docutils literal">old</tt> string, you're telling <strong>tren</strong> to <em>change the
whole file name</em>:</p>
<pre class="literal-block">
tren.py -r =MyNewFilename foo  #New Name: MyNewFilename
</pre>
<p>Be careful with this one.  If you apply it to a list of files or
directories, it's going to try and name them all to the <em>same</em> name.
By default, <strong>tren</strong> will refuse to overwrite an existing file name, so
it will stop you from doing this.  If you absolutely insist on this
via the <tt class="docutils literal"><span class="pre">-f</span></tt> option, you'll get a bunch of files ending with
<tt class="docutils literal">.backup</tt>.  Say you have files <tt class="docutils literal">a</tt>, <tt class="docutils literal">b</tt>, and <tt class="docutils literal">c</tt>:</p>
<pre class="literal-block">
tren.py -fr =NewName a b c
</pre>
<p>When the command completes, the files will have been renamed
in this fashion:</p>
<pre class="literal-block">
a -&gt; NewName.backup.backup
b -&gt; NewName.backup
c -&gt; NewName
</pre>
<p>If you omit the <tt class="docutils literal">new</tt> string, you're telling <strong>tren</strong> to <em>remove</em>
the leftmost instance of <tt class="docutils literal">old</tt> string (or other instances via the
<tt class="docutils literal"><span class="pre">-i</span></tt> option described below) from the file- or directory name.  For
example:</p>
<pre class="literal-block">
tren.py -rfoo= foo1-foo2-foo3.foo4  # New name: 1-foo2-foo3.foo4
</pre>
<p>If you try to omit <em>both</em> <tt class="docutils literal">old</tt> and <tt class="docutils literal">new</tt> strings, you're
effectively telling <strong>tren</strong> to change the existing file name to
... nothing (a null string).  This is impossible because file names
must be at least one character long.  <strong>tren</strong> enforces both this
minimum length AND the maximum legal length of new file names.  It
will print an error and exit if your renaming attempt would violate
either of these limits.  (As of this writing, the maximum file- or
directory name length allowed by the operating systems on which
<strong>tren</strong> runs is 255 characters.)</p>
</div>
<div class="section" id="substitution-instances">
<h2><a class="toc-backref" href="#id15">Substitution Instances</a></h2>
<p>As we just saw above, sometimes the <tt class="docutils literal">old</tt> string appears in several
places in a file- or directory name.  By default, <strong>tren</strong> only
replaces the first, or leftmost &quot;instance&quot; of an <tt class="docutils literal">old</tt> string.
However, using the <tt class="docutils literal"><span class="pre">-i</span></tt> option you can specify <em>any</em> instance you'd
like to replace.  In fact, you can even specify a <em>range</em> of instances
to replace.</p>
<p>Instances are nothing more than <em>numbers</em> that tell <strong>tren</strong> just
where in the name you'd like the replacement to take place.  Positive
numbers means we're counting instances from the <em>left</em> end of the
name.  The leftmost instance is 0 (not 1!!!).</p>
<p>You can also count <em>backwards</em> from the right end of the string using
negative numbers.  -1 means the last instance, -2 means next-to-last,
and so on.  In summary, counting from the left starts at zero and
counting from the right starts at -1.</p>
<p>Suppose you have a file called:</p>
<pre class="literal-block">
foo1-foo2-foo3.foo4
</pre>
<p>The leftmost <tt class="docutils literal">foo1</tt> is instance 0 of old string <tt class="docutils literal">foo</tt>.  It is also
instance -4.  The rightmost <tt class="docutils literal">foo4</tt> is instance 3 of old string
<tt class="docutils literal">foo</tt>, and also instance -1.</p>
<p>You can specify a <em>single instance</em> to replace:</p>
<pre class="literal-block">
tren.py -i 1 -r f=b foo1-foo2-foo3.foo4 #New Name: foo1-boo2-foo3.foo4

tren.py -i -1 -r f=b foo1-foo2-foo3.foo4 #New Name: foo1-foo2-foo3.boo4
</pre>
<p>You can also specify a <em>range of instances</em> to replace using the
notation:</p>
<pre class="literal-block">
-i first-to-replace:stop-here
</pre>
<p>All instances from the &quot;first-to-replace&quot; up to, <em>but NOT including</em>
&quot;the stop-here&quot; are replaced:</p>
<pre class="literal-block">
tren.py -i 1:3 -r f=b foo1-foo2-foo3.foo4 #New Name: foo1-boo2-boo3.foo4

tren.py -i -4:-2 -r f=b foo1-foo2-foo3.foo4 #New Name: boo1-boo2-foo3.foo4
</pre>
<p><tt class="docutils literal"><span class="pre">-i</span> :</tt> means &quot;replace <em>all</em> instances&quot;:</p>
<pre class="literal-block">
tren.py -i: -r f=b foo1-foo2-foo3.foo4 #New Name: boo1-boo2-boo3.boo4
</pre>
<p>You can also use <em>partial range specifications</em>:</p>
<pre class="literal-block">
tren.py -i 1: -r f=b foo1-foo2-foo3.foo4 #New Name: foo1-boo2-boo3.boo4

tren.py -i :-2 -r f=b foo1-foo2-foo3.foo4 #New Name: boo1-boo2-foo3.foo4
</pre>
<p>Note that you cannot specify individual, non-adjacent instances.
There is no way to use a single <strong>tren</strong> command to replace, say, the
only the 2nd and the 4th instance of an <tt class="docutils literal">old</tt> string.  Doing that
requires two renaming requests.  As we'll see in the section below,
the good news is that we can do them both on a single <strong>tren</strong>
invocation.</p>
</div>
<div class="section" id="limiting-renaming-to-only-part-of-name">
<h2><a class="toc-backref" href="#id16">Limiting Renaming To Only Part Of Name</a></h2>
<p>Sometimes you just want to rename a <em>part</em> of a file- or directory
name (aka a name &quot;substring&quot;).  As described below, you can use a
Regular Expression to do this, but this can be complicated and is
often overkill for simple substitutions.  <strong>tren</strong> gives you the
ability to limit the renaming action to a &quot;targeted&quot; portion of the
name using the <tt class="docutils literal"><span class="pre">-T</span></tt> option.  You simply supply a &quot;slice&quot; describing
the portion of the name to be renamed:</p>
<pre class="literal-block">
tren.py -i: -T :3  -r=x  abcdef.text # -&gt; xdef.text
tren.py -i: -T :-4 -re=E abcdef.text # -&gt; abcdEf.text
</pre>
<p>It's important to understand how <tt class="docutils literal"><span class="pre">-i</span></tt> and <tt class="docutils literal"><span class="pre">-T</span></tt> interact.  Even
though all instances of a matching old string are specified via the
<tt class="docutils literal"><span class="pre">-i:</span></tt> option, the <tt class="docutils literal"><span class="pre">-T</span></tt> option that follows it limits the portion
of the name being considered for renaming.  For instance, in the
second example, removing the <tt class="docutils literal"><span class="pre">-T</span></tt> targeting gives us:</p>
<pre class="literal-block">
tren.py -i: -re=E abcdef.text # -&gt; abcdEf.tExt
</pre>
<p>So, <tt class="docutils literal"><span class="pre">-T</span></tt> lets you specify what substring of the full name is a
candidate for renaming.  All other renaming operations like <tt class="docutils literal"><span class="pre">-i</span></tt>,
<tt class="docutils literal"><span class="pre">-r</span></tt>, and so on operate <em>only upon the substring specified by</em>
<tt class="docutils literal"><span class="pre">-T</span></tt>.</p>
<p>If you specify multiple renaming operations on the command line, any
<tt class="docutils literal"><span class="pre">-T</span></tt> targeting will remain in effect <em>for each renaming request</em>.
For instance:</p>
<pre class="literal-block">
tren.py -T -1 -r=OO -r=x foo
</pre>
<p>This will yield incremental renamings of:</p>
<pre class="literal-block">
foo  -&gt; foOO
foOO -&gt; foOx   # Final name
</pre>
<p>In other words, each incremental renaming request honors the current
state of the <tt class="docutils literal"><span class="pre">-T</span></tt> option.  To turn off targeted renaming - that is,
make the whole file name the target again - simply include <tt class="docutils literal"><span class="pre">-T</span> :</tt> on
the command line.  All renaming requests to the right of it will then
target the whole name:</p>
<pre class="literal-block">
tren.py -T -1 -r=OO -T: -rO=x foo  # Yields: foxO
</pre>
</div>
<div class="section" id="more-about-slice-notation">
<h2><a class="toc-backref" href="#id17">More About Slice Notation</a></h2>
<p>Both the <tt class="docutils literal"><span class="pre">-i</span></tt> and <tt class="docutils literal"><span class="pre">-T</span></tt> options use &quot;slice&quot; notation so
it's useful to understand a bit more about how &quot;slices&quot; are
constructed.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Although both options use slice notation, they mean very
different things.  In the case of <tt class="docutils literal"><span class="pre">-i</span></tt>, the slice specifies
which <em>instances</em> of an old string are to be replaced.
In the case of <tt class="docutils literal"><span class="pre">-T</span></tt>, the slice defines which <em>characters</em>
in the original file name are &quot;targeted&quot; for renaming.</p>
</div>
<p><strong>tren</strong> is written in the Python programing language.  The slice
notation is lifted directly from that language.  if you're a Python
programmer, you can skip this section :)</p>
<p>Imagine you have a file name like this:</p>
<pre class="literal-block">
abcdef.txt
</pre>
<p>Each character in the name has an &quot;index&quot; or number that
tells you what position is occupies in the name.  You can
count from the <em>left end</em> of the name starting with 0:</p>
<pre class="literal-block">
Character        Index From Left
---------        ---------------
a                0
b                1
...
x                8
t                9
</pre>
<p>You can also count backwards relative to the <em>right end of
the name</em>:</p>
<pre class="literal-block">
Character        Index From Right
---------        ---------------=
a                -10
b                -9
...
x                -2
t                -1
</pre>
<p>Notice that left-relative indexes are positive numbers beginning with
0, but right-relative indexes are are negative numbers beginning at
-1.</p>
<p>So, what's a slice?  A slice is a way of specifying <em>a range of one or
more values</em>.  In the case of the <tt class="docutils literal"><span class="pre">-T</span></tt> option, &quot;values&quot; means
&quot;positions in the name string targeted for renaming.&quot;  In the case of
the <tt class="docutils literal"><span class="pre">-i</span></tt> option, &quot;values&quot; means <em>which instances of a given string
should be renamed</em>.</p>
<p>In our example above, the <tt class="docutils literal">bcd</tt> portion of the name could be defined
several different ways:</p>
<pre class="literal-block">
1:4
-9:-6
</pre>
<p>The general form of a slice is:</p>
<pre class="literal-block">
first character/instance:stop on this character/instance
</pre>
<p>This can be tricky to get used to.  The number on the righthand side
<em>is not included in he slice</em> - it is where the slice <em>ends</em>.</p>
<p>There are other shortcut forms of slice notation:</p>
<pre class="literal-block">
 :3         # Same as 0:3
3:          # From 4th char/instance through/including end
 :          # All chars/instances are included in the slice
</pre>
<p>In short, slices are a compact way to specify a range of things.  If
you specify a slice that makes no sense like <tt class="docutils literal"><span class="pre">-4:3</span></tt>, <strong>tren</strong> will
just ignore it and not do any consequent renaming.</p>
</div>
<div class="section" id="multiple-substitutions">
<h2><a class="toc-backref" href="#id18">Multiple Substitutions</a></h2>
<p>You can put as many renaming requests on a <strong>tren</strong> command line as
you like (.... well, up to the length limit imposed by your operating
system and shell, anyway).  As we just saw, this can be handy when
a single renaming request can't quite do everything we want.</p>
<p>BUT ... there's a catch.  In designing your renaming requests, you
have to keep in mind that <strong>tren</strong> processes the command line <em>from
left to right</em>, incrementally constructing the new name as it goes.
That is, the leftmost renaming request operates on the original file-
or directory name.  The next renaming request to the right operates on
<em>that</em> new name, and so on.  In other words, <em>each renaming request
modifies the name produced thus far by all the renaming requests to
the left of it on the command line</em>.</p>
<p>For instance:</p>
<pre class="literal-block">
tren.py -r foo=bar -r foo=baz  foo1-foo2-foo3.foo4
</pre>
<p>Produces ... wait a second ... why on earth are there two renaming
requests with identical <tt class="docutils literal">old</tt> strings on the same command line?
Shouldn't this produce a final name of <tt class="docutils literal"><span class="pre">baz1-foo2-foo3.foo4</span></tt>?</p>
<p>Nope.  After the leftmost renaming request has been processed,
the new name is <tt class="docutils literal"><span class="pre">bar1-foo2-foo3.foo4</span></tt>.  Remember that, by
default, <strong>tren</strong> only replaces the <em>leftmost</em> or 0th instance
of an <tt class="docutils literal">old</tt> string.  So, when the second renaming request is
processed, the instance 0 of <tt class="docutils literal">foo</tt> is now found in the
string <tt class="docutils literal">foo2</tt>.  So, the final name will be, <tt class="docutils literal"><span class="pre">bar1-baz2-foo3.foo4</span></tt>.</p>
<p>The lesson to learn from this is that multiple renaming requests
on the command line will work fine, but you have to do one of
two things (or both):</p>
<blockquote>
<ol class="arabic simple">
<li>Make sure you're tracking what the &quot;intermediate&quot; names
will look like as the new file name is being constructed,
renaming request, by renaming request.</li>
<li>Make sure the renaming requests operate on completely
disjoint parts of the file name.</li>
</ol>
</blockquote>
<div class="tip">
<p class="first admonition-title">Tip</p>
<p>Similarly, <strong>tren</strong> remembers the last state of each option
as you move from left to right on the command line. For instance:</p>
<pre class="literal-block">
tren.py -i1 -r f=F -r o=O foo1-foo2-foo3.foo4
</pre>
<p>You might be tempted to believe that this would produce:</p>
<pre class="literal-block">
fOo1-Foo2-foo3.foo4
</pre>
<p>But it doesn't.  It produces:</p>
<pre class="literal-block">
foO1-Foo2-foo3.foo4
</pre>
<p>instead because the <tt class="docutils literal"><span class="pre">-i</span> 1</tt> appears prior to <em>both</em>
renaming requests and thus applies to each of them.  If you
want the first instance of &quot;o&quot; to be replaced, you need a
command line like this:</p>
<pre class="literal-block">
tren.py -i1 -rf=F -i0 -ro=O foo1-foo2-foo3.foo4
</pre>
<p class="last">This sort of thing is generally true for <em>all</em> options, so
be sure they're set the way you want them to the left of a
renaming request.</p>
</div>
<p>As a practical matter, this can get really complicated to track.  If
in doubt, it's always better to run two separate <strong>tren</strong> commands in,
say, a shell script to make the renaming explicit, rather than to
obscure things with clever command line trickery.</p>
<p>So, let's go back to our example from the previous section.  We
want to replace the 2nd and 4th instances of the string &quot;foo&quot;
in our file name.  We do this with two renaming requests on the
same command line, considering what each one does to the name
as it is encountered:</p>
<pre class="literal-block">
tren.py -i1 -r foo=bar -i2 -r foo=bar foo1-foo2-foo3.foo4
</pre>
<p>A good way to get an idea of how incremental renamings <em>would</em> take
place is to run <strong>tren</strong> is test and debug modes because debug
will dump an incremental renaming sequence description as it goes:</p>
<pre class="literal-block">
tren.py -tdq -rfi=fud -et fee_fi_fo
</pre>
<p>The (partial) debug output will show you this:</p>
<pre class="literal-block">
tren.py DEBUG: Renaming Sequence: fee_fi_fo---&gt;fee_fud_fo---&gt;Fee_Fud_Fo
</pre>
</div>
<div class="section" id="more-about-command-line-pitfalls">
<h2><a class="toc-backref" href="#id19">More About Command Line Pitfalls</a></h2>
<p>As we just saw, you can get surprising results as <strong>tren</strong> works its
way through the command line from left to right.  There are other
potential pitfalls here, so it's helpful to understand just <em>how</em>
<strong>tren</strong> processes your command line, step-by-step:</p>
<blockquote>
<ol class="arabic">
<li><p class="first">Prepend the contents of $TREN to the user-provided command line.</p>
<blockquote>
<p>This allows you to configure your own default set of options so
you don't have to type them in every time.</p>
</blockquote>
</li>
<li><p class="first">Resolve all references to include files.</p>
<blockquote>
<p>This has to be done before anything that follows, because
include files add options to the command line.</p>
</blockquote>
</li>
<li><p class="first">Build a table of every file name to be renamed.</p>
<blockquote>
<p>We'll need this information if any of the renaming requests use
the file attribute- or sequence renaming tokens (discussed
later in this document).</p>
</blockquote>
</li>
<li><p class="first">Build a table containing each renaming request storing the
current state of every program option at that point on the
command line.</p>
<blockquote>
<p>This allows <strong>tren</strong> to apply options differently to different
renaming requests on the same command line.  This came in handy
in our example of the previous section.</p>
</blockquote>
</li>
<li><p class="first">Resolve any renaming tokens found in either the <tt class="docutils literal">old</tt> or
<tt class="docutils literal">new</tt> portions of the renaming request.</p>
<blockquote>
<p>At this point, both <tt class="docutils literal">old</tt> and <tt class="docutils literal">new</tt> are nothing more than
simple strings (although <tt class="docutils literal">old</tt> may be interpreted as a
regular expression rather than literally if the option to do so
is in effect).</p>
</blockquote>
</li>
<li><p class="first">Process each file found on the command line in left to right
order, applying each renaming request, in the order it appeared
from left to right on the command line.</p>
</li>
</ol>
</blockquote>
<p>Simple eh?  Well, mostly it is ... until it isn't.  As we just saw,
incrementally building up a new name with multiple renaming requests
can produce unexpected results and we have to plan for them.</p>
<p>Similarly, you can inadvertently accidentally give a file the <em>wrong
name entirely</em> ... this is usually a Bad Thing.</p>
<p>Say you have two files, <tt class="docutils literal">x</tt> and <tt class="docutils literal">y</tt>.  You want to rename <tt class="docutils literal">x</tt> to
<tt class="docutils literal">y</tt> and <tt class="docutils literal">y</tt> to <tt class="docutils literal">z1</tt>.  Well, order matters here.  Say you do
this:</p>
<pre class="literal-block">
tren.py -fr x=y -r y=z1 x y
</pre>
<p>Let's see what happens in order:</p>
<blockquote>
<ol class="arabic">
<li><p class="first">File <tt class="docutils literal">x</tt> renaming:</p>
<pre class="literal-block">
x -&gt; y
y -&gt; z1
</pre>
</li>
</ol>
<blockquote>
So, file <tt class="docutils literal">x</tt> is renamed <tt class="docutils literal">z1</tt> (!)</blockquote>
<ol class="arabic" start="2">
<li><p class="first">File <tt class="docutils literal">y</tt> renaming:</p>
<pre class="literal-block">
y -&gt; z1 .... oops, x1 exists, we need a backup

  z1 -&gt; z1.backup

y -&gt; z1
</pre>
</li>
</ol>
</blockquote>
<p>Um ... not quite what we wanted. However, if we shuffle around the
order of renaming arguments AND the order in which to process the
files, we can get what we want:</p>
<pre class="literal-block">
tren.py  -r y=z1  -r x=y   y x
</pre>
<p>Notice that we can drop the <tt class="docutils literal"><span class="pre">-f</span></tt> option because there is no longer a
naming conflict (see the next section for more about forced renaming).</p>
<div class="tip">
<p class="first admonition-title">Tip</p>
<p class="last">Always remember&quot; <strong>The Rightmost Renaming Request &quot;Wins&quot;!</strong></p>
</div>
<p>The point here, as we've said already, is that you have to be very
careful when constructing command lines, keeping track of options, and
<em>what order</em> you specify both renaming requests <em>and</em> the files- and
directories to be renamed.  As always, the simple way around this is
to run multiple, separate <strong>tren</strong> commands, each with its own single
renaming request.</p>
</div>
<div class="section" id="forcing-renaming">
<h2><a class="toc-backref" href="#id20">Forcing Renaming</a></h2>
<p>By default, <strong>tren</strong> will not allow you to perform a renaming operation
if the new name already exists.  For example, say you have three files,
<tt class="docutils literal">a</tt>, <tt class="docutils literal">aa</tt>, and <tt class="docutils literal">b</tt>, and you try this:</p>
<pre class="literal-block">
tren.py -r a=b a aa b
</pre>
<p><strong>tren</strong> will skip the renaming of file <tt class="docutils literal">a</tt> because a file named
<tt class="docutils literal">b</tt> already exists.  It will, however, continue to run and rename
<tt class="docutils literal">aa</tt>, to <tt class="docutils literal">ba</tt>.</p>
<p>This is designed to prevent you from accidentally clobbering files
that already exist.  You can, however, override this default behavior
and <em>force</em> the renaming to take place in such situations, using the
<tt class="docutils literal"><span class="pre">-f</span></tt> option.  Even then, the existing file isn't lost, it is simply
<em>renamed itself</em> by appending the suffix <tt class="docutils literal">.backup</tt> to its original
name.  That way, if you made a mistake, you haven't lost the original
file.  So, in our example above, the command becomes:</p>
<pre class="literal-block">
tren.py -fr a=b a aa b
</pre>
<p>When it's done, we end up with these files:</p>
<pre class="literal-block">
b          # The original 'a' file
b.backup   # The original 'b' file
ba         # The original 'aa' file
</pre>
<p>If you don't like the suffix, <tt class="docutils literal">.backup</tt>, you can change it to any
string (of length 1 or greater) via the <tt class="docutils literal"><span class="pre">-S</span></tt> option:</p>
<pre class="literal-block">
tren.py -S .bku -fr a=b a aa b
</pre>
<p>Now the backed up file will be named <tt class="docutils literal">b.bku</tt>.</p>
<p><strong>tren</strong> will even backup files that are themselves backups.  This can
be handy if your renaming request ends up mapping more than one file- or
directory name to the same new name:</p>
<pre class="literal-block">
tren.py -fr =newname a b c
</pre>
<p>This produces files named:</p>
<pre class="literal-block">
newname               # The original 'c' file
newname.backup        # The original 'b' file
newname.backup.backup # The original 'a' file
</pre>
<p>You can inhibit this behavior and prevent backups with the <tt class="docutils literal"><span class="pre">-b</span></tt>
option.  This effectively <em>erases the original file- or directory of
that name</em>.  This is <strong>very dangerous</strong> and should rarely be used.
It's better to do the backups and delete them later when you're sure
you do not need them.  The underlying operating system rules for
renaming will still apply in this case.  For instance, most OSs will
not allow you rename a file over the name of an existing directory and
vice versa.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p>The Unix <tt class="docutils literal">mv</tt> command will allow you to move a file
<em>into</em> a directory:</p>
<pre class="literal-block">
mv file dir
</pre>
<p class="last">However, this is an <tt class="docutils literal">mv</tt> &quot;move&quot; semantic, and is not
properly a renaming operation.  The underlying file system
will not permit a file to be renamed over a directory or
vice versa.  <strong>tren</strong> reflects this OS semantic ... it's not
intended to be a reimplementation of <tt class="docutils literal">mv</tt>.</p>
</div>
</div>
<div class="section" id="ignoring-case">
<h2><a class="toc-backref" href="#id21">Ignoring Case</a></h2>
<p>&quot;Literal&quot; string substitution means just that - <strong>tren</strong> must find an
exact instance of <tt class="docutils literal">old</tt> in the file name being renamed and replace
it with <tt class="docutils literal">new</tt>.  So, the default is to do <em>case sensitive</em> matching.
There are times, however, when you want to ignore case when doing this
matching.  For example, suppose you have file names with a variety of
suffixes in various case combinations like <tt class="docutils literal">.jpeg</tt>, <tt class="docutils literal">.Jpeg</tt>, and
<tt class="docutils literal">.JPEG</tt>.  Suppose you'd like these to all be changed to <tt class="docutils literal">.jpg</tt>.
Rather than having to do three separate renaming operations it's handy
to just ignore case <em>when matching the old string for replacement</em>.
That's what the <tt class="docutils literal"><span class="pre">-c</span></tt> option is for:</p>
<pre class="literal-block">
tren.py -i -1 -c -r.jpeg=.jpg *.jpeg *.Jpeg *.JPEG
</pre>
<p>Notice that the case insensitivity only applies to the <em>matching</em> of
the <tt class="docutils literal">old</tt> string.  Once <strong>tren</strong> has determined such a match exists,
the <tt class="docutils literal">new</tt> string is used <em>literally</em> with case intact.</p>
<p>You can turn case sensitivity on- and off for various renaming
requests on the same command line.  <tt class="docutils literal"><span class="pre">-C</span></tt> turns case sensitivity on,
and - as we just saw - <tt class="docutils literal"><span class="pre">-c</span></tt> turns it off:</p>
<pre class="literal-block">
tren.py -cr X=y -Cr A=b ...
</pre>
<p>The <tt class="docutils literal">X=y</tt> renaming request will be done in a case insensitive
manner, whereas the <tt class="docutils literal">A=b</tt> will be done only on literal instances of
upper case <tt class="docutils literal">A</tt> in the target file names.</p>
</div>
<div class="section" id="case-transformation">
<h2><a class="toc-backref" href="#id22">Case Transformation</a></h2>
<p>Sometimes you want to actually force the case of the characters
in a filename to change.  You do this with the <tt class="docutils literal"><span class="pre">-e</span></tt> option.
This option takes one of several arguments:</p>
<pre class="literal-block">
c - Capitalize the file name
l - Force file name to lower-case
s - Swap case of file name characters
t - Force file name to title case
u - Force file name to upper-case
</pre>
<p>&quot;Title case&quot; just means that any alphabetic character following
a non-alphabetic character will be capitalized:</p>
<pre class="literal-block">
tren.py -et fee_fi_fo # -&gt; Fee_Fi_Fo
</pre>
<p>These case transformations are a kind of special built-in renaming
request with one important difference: The <tt class="docutils literal"><span class="pre">-i</span></tt> &quot;instance&quot; setting
is ignored.  That's because the <tt class="docutils literal"><span class="pre">-e</span></tt> option isn't based on replacing
an &quot;old&quot; string like the <tt class="docutils literal"><span class="pre">-r</span></tt> renaming option, but rather operates
on the file name as a whole.</p>
<p>You can, however, limit what portion of the filename is &quot;targeted&quot;
for case conversion via the <tt class="docutils literal"><span class="pre">-T</span></tt> option:</p>
<pre class="literal-block">
tren.py -T 4:6 -et fee_fi_fo # -&gt; fee_Fi_fo
</pre>
<p>As with all renaming requests, <tt class="docutils literal"><span class="pre">-e</span></tt> is just another <em>incremental</em>
renaming operation on the command line:</p>
<pre class="literal-block">
tren.py -rfi=fud -et fee_fi_fo # -&gt; fee_fud_fo -&gt; Fee_Fud_Fo
</pre>
<p>You can actually see these incremental transformations by specifying
the <tt class="docutils literal"><span class="pre">-d</span></tt> option on the command line.</p>
</div>
<div class="section" id="the-strange-case-of-mac-os-x-and-windows">
<h2><a class="toc-backref" href="#id23">The Strange Case Of Mac OS X And Windows</a></h2>
<p>Mac OS X and Windows have an &quot;interesting&quot; property that makes case
renaming a bit tricky.  Both of these operating systems <em>preserve</em>
case in file and directory names, but they do not <em>observe</em> it.  (It
is possible to change this behavior in OS X when you first prepare a
drive, and make the filesystem case sensitive.  This is rarely done in
practice, however.)</p>
<p>These OSs show upper- and lower- case in file names as you request,
but they do not <em>distinguish</em> names on the basis of case.  For
instance, the files <tt class="docutils literal">Foo</tt>, <tt class="docutils literal">foo</tt>, and <tt class="docutils literal">FOO</tt>, are all the
same name in these operating systems, and only one of these can exist
in a given directory.  This can cause <strong>tren</strong> to do the unexpected
when your renaming command is doing nothing more than changing case.
Suppose you start with a file called <tt class="docutils literal">Aa.txt</tt> and run this
command:</p>
<pre class="literal-block">
tren.py -rA=a Aa.txt
</pre>
<p><strong>tren</strong> will immediately complain and tell you that the file
<tt class="docutils literal">aa.txt</tt> already exists and it is skipping the renaming.  Why?
Because from the point-of-view of OS X or Windows, <tt class="docutils literal">aa.txt</tt> (your
new file name) is the same as <tt class="docutils literal">Aa.txt</tt> (your original file name).
You can attempt to force the renaming:</p>
<pre class="literal-block">
tren.py -frA=a Aa.txt
</pre>
<p>Guess what happens?  Since <strong>tren</strong> thinks the new file name already
exists, it backs it up to <tt class="docutils literal">aa.txt.backup</tt>.  But now, when it goes
to rename the original file ... the file is <em>gone</em> (thanks to the
backup renaming operation)!  <strong>tren</strong> declares an error and
terminates.</p>
<p>This is not a limitation of <strong>tren</strong> but a consequence of a silly
design decision in these two operating systems.  As a practical
matter, the way to avoid this issue is to never do a renaming
operation in OS X or Windows <em>that only converts case</em>.  Try
to include some other change to the file name to keep  the
distinction between &quot;old name&quot; and &quot;new name&quot; clear to the
OS.  In the worst case, you'll have to resort to something like:</p>
<pre class="literal-block">
tren.py -rA=X Aa.txt
tren.py -rX=a Xa.txt
</pre>
</div>
<div class="section" id="using-regular-expressions">
<h2><a class="toc-backref" href="#id24">Using Regular Expressions</a></h2>
<p>Ordinarily <strong>tren</strong> treats both the old string you specify with the
<tt class="docutils literal"><span class="pre">-r</span></tt> option <em>literally</em>.  However, it is sometimes handy to be able
to write a regular expression to specify what you want replaced.  If
you specify the <tt class="docutils literal"><span class="pre">-x</span></tt> option, <strong>tren</strong> will treat your old string as
a regular expresion, compile it (or try to anyway!) and use it to
select which strings to replace.  This makes it much easier to rename
files that have repeated characters or patterns, and groups of files
that have similar, but not idential strings in their names you'd like
to replace.</p>
<p>Say you have a set of files that are similar, but not identical in
name, and you want to rename them all:</p>
<pre class="literal-block">
sbbs-1.txt
sbbbs-2.txt
sbbbbbbbbs-3.txt
</pre>
<p>Suppose you want to rename them, replacing two or more instances of
<tt class="docutils literal">b</tt> with <tt class="docutils literal">X</tt>. It is tedious to have to write a separate literal
<tt class="docutils literal"><span class="pre">-r</span> old=new</tt> string substitution for each instance above.  This is
where regular expressions can come in handy.  When you invoke the
<tt class="docutils literal"><span class="pre">-x</span></tt> option, <strong>tren</strong> understands this to mean that the <tt class="docutils literal">old</tt>
portion of the replacement option is to be treated as a <em>Python style
regular expression</em>.  That way, a single string can be used to match
many cases:</p>
<pre class="literal-block">
tren.py -x -r bb+=X *.txt
</pre>
<p>This renames the files to:</p>
<pre class="literal-block">
sXs-1.txt
sXs-2.txt
sXs-3.txt
</pre>
<p>Keep in mind that a literal string is a subset of a regular
expression.  This effectively means that with <tt class="docutils literal"><span class="pre">-x</span></tt> processing
enabled you can include <em>both</em> regular expressions and literal text in
your &quot;old string&quot; specification.  The only requirement is that the
string taken as a whole must be a valid Python regular expression.  If
it is not, <strong>tren</strong> will display an error message to that effect.</p>
<p>For more detail on the Python regular expression syntax, see:</p>
<blockquote>
<a class="reference external" href="http://docs.python.org/library/re.html">http://docs.python.org/library/re.html</a></blockquote>
<p>Because Python regular expressions can make use of the <tt class="docutils literal">=</tt> symbol,
you need a way to distinguish between an <tt class="docutils literal">=</tt> used in a regular
exression and the same symbol used to separate the old and new
operands for the <tt class="docutils literal"><span class="pre">-r</span></tt> option.  Where this symbol needs to appear in
a regular expression, it has to be escaped like this: <tt class="docutils literal">\=</tt>.  (You
can also get around this by changing the <tt class="docutils literal">old/new</tt> separator
character with the <tt class="docutils literal"><span class="pre">-R</span></tt> option.)</p>
<p>As with literal string renaming, regular expression renaming requests
honor both the case sensitivity options (<tt class="docutils literal"><span class="pre">-C</span></tt> and <tt class="docutils literal"><span class="pre">-c</span></tt>) as well
as the instance option, <tt class="docutils literal"><span class="pre">-i</span></tt>.  So, for example:</p>
<pre class="literal-block">
tren.py -x -ci -1 -r Bb+=X sbbsbbbsbbbbsbbbbbs
</pre>
<p>You'll rename the file to <tt class="docutils literal">sbbsbbbsbbbbsXs</tt></p>
</div>
<div class="section" id="changing-the-renaming-separator-escape-characters">
<h2><a class="toc-backref" href="#id25">Changing The Renaming Separator &amp; Escape Characters</a></h2>
<p>There may be times when the default renaming separator (<tt class="docutils literal">=</tt>) and/or
escape character (<tt class="docutils literal">\</tt>) make it clumsy to construct a renaming
request.  This can happen if, say, either the old- or new string in a
literal renaming needs to use the <tt class="docutils literal">=</tt> symbol many times.  Another
case where this may be helpful is when constructing complex regular
expressions that need to make use of these characters.</p>
<p>The <tt class="docutils literal"><span class="pre">-R</span></tt> and <tt class="docutils literal"><span class="pre">-P</span></tt> options can be used to change the character
used for renaming separator and escape character respectively.  You
can use any character you like (these must be a single character
each), but bear in mind that the underlying operating system
understands certain characters as being special.  Trying to use them
here will undoubtedly deeply confuse your command shell, and possibly
your file system.  For example, the <tt class="docutils literal">/</tt> character is used as a
path separator in Unix-derived systems.  It's therefore a Really Bad
Idea to try and use it as a renaming separator or escape character.</p>
</div>
<div class="section" id="interactive-renaming">
<h2><a class="toc-backref" href="#id26">Interactive Renaming</a></h2>
<p>By default, <strong>tren</strong> attempts to perform all the renaming requests on
all the file- and directory names given on the command line
automatically.  It is sometimes helpful to work <em>interactively</em>
wherein you're asked what to do for each proposed renaming.
Interactive renaming is requested via the <tt class="docutils literal"><span class="pre">-a</span></tt>, &quot;ask&quot; option:</p>
<pre class="literal-block">
tren.py -a -rfoo=Bar foo1.txt foo2.txt foo3.txt
</pre>
<p><strong>tren</strong> will compute each file's proposed new name and ask you
what you want to do.  You have 4 possible choices:</p>
<pre class="literal-block">
N, n, or Enter - No, don't rename this file
Y, y           - Yes, rename the file
!              - Yes, rename everything further without asking
Q, q           - Quit the program
</pre>
<p>There is one slight subtlety here to watch for when doing forced
renaming.  As we've seen, if you select the <tt class="docutils literal"><span class="pre">-f</span></tt> option and the new
file name already exists, <strong>tren</strong> will backup the existing file name
before doing the renaming.  In interactive mode, you will be asked
whether or not to proceed with the renaming both for the file in
question <em>and for any consequenent backups</em>.  If you decline to do the
backup but accept the primary renaming, this will have the same effect
as the <tt class="docutils literal"><span class="pre">-b</span></tt> option: The existing file- or directory will be
overwritten by the renaming operation.</p>
<p>If the <tt class="docutils literal"><span class="pre">-b</span></tt> option is selected in interactive mode, then you'll only
be prompted for the primary file renamings (because <tt class="docutils literal"><span class="pre">-b</span></tt> suppresses
the creation of backups).</p>
</div>
<div class="section" id="an-overview-of-renaming-tokens">
<h2><a class="toc-backref" href="#id27">An Overview Of Renaming Tokens</a></h2>
<p><strong>tren</strong> implements the notion of <em>renaming tokens</em>.  These can
be a bit complex to grasp at first, so we'll introduce them
&quot;gently&quot; in the next few sections and then dive into the detail
thereafter.</p>
<p>It is sometimes useful to be able to take a group of files or rename
them using some property they possess like creation date, size,
owner's name, and so on.  This is the purpose of renaming tokens.</p>
<p>Renaming tokens are nothing more than special symbols that represent
&quot;canned&quot; information <strong>tren</strong> knows about the file- or directory
being renamed, information from the OS itself, and information used to
sequence or order the files being renamed.</p>
<p>For instance, if you insert the <tt class="docutils literal">/MYEAR/</tt> token into a old- or new
string definition, <strong>tren</strong> will replace it with <em>the year the file or
directory being renamed was last modified</em> and use that string in the
renaming process:</p>
<pre class="literal-block">
tren.py -ryear=/MYEAR/ My-year.txt # New name: My-2010.txt
</pre>
<p>Renaming tokens can appear in either the <tt class="docutils literal">old</tt> or <tt class="docutils literal">new</tt> string
components of a <tt class="docutils literal"><span class="pre">-r</span></tt> renaming argument.  Wherever they appear,
they are &quot;resolved&quot; by <strong>tren</strong> before any renaming is attempted.
By &quot;resolved&quot;, we mean that the renaming token will be <em>replaced
with a string that represents its meaning</em>.  For example:</p>
<pre class="literal-block">
tren.py -i :  -r boo=/SIZE/ boors-and-boots.txt
</pre>
<p>This replaces all the instances of the literal string <tt class="docutils literal">boo</tt> with
the <em>length</em> of the file <tt class="docutils literal"><span class="pre">boors-and-boots.txt</span></tt>.  When we're done
the file will be renamed something like:</p>
<pre class="literal-block">
23rs-and-23ts.txt
</pre>
<p>This is a silly example but it serves to illustrate the point -
all renaming tokens get turned into <em>strings</em> before any renaming
is attempted.</p>
<blockquote>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Deep under the covers of it all, <strong>tren</strong> really only
knows how to do string replacement.  That is, it can
replace some <tt class="docutils literal">old</tt> string with some <tt class="docutils literal">new</tt> string.
All the rest of the features you see are sort of
syntactic sugar to make it easy for you to express your
renaming intent.  When <strong>tren</strong> runs, it must resolve all
that fancy syntax and boil it down to creating a new file
name the underling operating system knows how to produce
via its renaming services.</p>
</div>
</blockquote>
<p>A really handy way to use renaming tokens is to name your files in a
particular <em>order</em>.  For example, suppose you and your friends pool
your vacation photos but each of your cameras uses a slightly
different naming scheme.  You might want to just reorder them by the
date and time each picture was taken, for example.  That way you end
up with one coherent set of named and numbered files.  You might start
with something like this:</p>
<pre class="literal-block">
DSC002.jpg      # Bob's camera,  taken 1-5-2010 at noon
dc0234.Jpg      # Mary's camera, taken 1-5-2010 at 8am
032344.jpeg     # Sid's camera,  taken 1-3-2010 at 4pm
</pre>
<p>It would be nice to get these in order somehow.  We can, by combining
<em>attribute</em> renaming tokens (that know things about the file being
renamed) and <em>sequence</em> renaming tokens (that know how to order all
the files being renamed by some key like date, length, who owns it,
and so on):</p>
<pre class="literal-block">
tren.py -r =/MYEAR//MMON//MDAY/-MyVacation-/+MDATE::0001/.jpeg *.jp*
</pre>
<p>Every place you see something in the form <tt class="docutils literal"><span class="pre">/.../</span></tt>, think, &quot;That is a
renaming token whose value will be filled in by <strong>tren</strong>.&quot;  This
syntax is the same whether you're using an <em>attribute</em>-, <em>system</em>-, or
<em>sequence</em> renaming token.</p>
<p>This would rename all the files in the current directory ending with
<tt class="docutils literal">.jp*</tt>.  The <tt class="docutils literal"><span class="pre">/MYEAR/...</span></tt> would be replaced with the <em>date</em> the
picture was taken ( well, actually, the date the file was last
modified).  The <tt class="docutils literal"><span class="pre">/+MDATE::0001/</span></tt> refers to a <em>starting sequence
number</em> to uniquely identify files modified on the same date.  The
other strings, <tt class="docutils literal"><span class="pre">-MyVacation-</span></tt> and <tt class="docutils literal">.jpeg</tt>, are inserted
<em>literally</em> in the final file names.  After we ran this command, the
files above would end up with these names:</p>
<pre class="literal-block">
20100103-MyVacation-0001.jpeg       # Sid's
20100105-MyVacation-0001.jpeg       # Mary's
20100105-MyVacation-0002.jpeg       # Bob's
</pre>
<p>Notice that the files taken on the same date have been sequenced by
the time-of-day they were taken because we included the
<tt class="docutils literal"><span class="pre">/+MDATE.../</span></tt> sequence renaming token in our pattern.  The <tt class="docutils literal">+</tt>
here means to construct the sequence in <em>ascending</em> order.  A <tt class="docutils literal">-</tt>
would specify <em>descending</em> order.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Notice that there is <em>no old string</em> in our example above.
That is, there is nothing to the left of the <tt class="docutils literal">=</tt> symbol in
the <tt class="docutils literal"><span class="pre">-r</span></tt> option.  This effectively means &quot;replace
everything&quot; in the existing file or directory name with our
newly concocted naming scheme.</p>
</div>
<p>Of course, you don't <em>have</em> to replace the entire file name when
using tokens.  It's perfectly legitimate to replace only
a portion of the existing name:</p>
<pre class="literal-block">
tren.py -r file=/MYEAR/MMON//MDAY/-file  file-1 file.2
</pre>
<p>This would rename our files to: <tt class="docutils literal"><span class="pre">20100101-file-1</span></tt> and
<tt class="docutils literal"><span class="pre">20100101-file.2</span></tt> Notice that we combined literal text and a renaming
token to do this.</p>
<p>You can even use renaming tokens in your <em>old string</em> specification.
For instance, suppose you manage a number of different systems and you
set their system name in an environment variable called <tt class="docutils literal">SYSNAME</tt> and
this same name is used to identify backup files.  You might then do
something like this:</p>
<pre class="literal-block">
tren.py -xr '/$SYSNAME/.*bku$=/FNAME/.old' *
</pre>
<p>If your system name was <tt class="docutils literal">matrix</tt>, then the command above would only
rename files whose names began with <tt class="docutils literal">matrix</tt> and ended with <tt class="docutils literal">bku</tt>.
If your system name were <tt class="docutils literal">morton</tt>, then the command above would only
rename files whose names began with <tt class="docutils literal">morton</tt> and ended with <tt class="docutils literal">bku</tt>.</p>
<p>Notice that we combined a reference to an environment variable within
a regular expression. This was done to do the match on &quot;names
beginning with... and ending with ...&quot;.  Also notice that the renaming
token <tt class="docutils literal">/FNAME/</tt> is just the <em>original name of the file</em>.</p>
<p>In order for this to work, we had to single quote the renaming
request.  This is because Unix shells will themselves try to replace
<tt class="docutils literal">$SYSNAME</tt> which is not what we want.  If we don't single quote
(thereby turning off shell variable interpolation) and run this, say,
on a machine called &quot;matrix&quot;, the command will be handed to <strong>tren</strong>
looking like this:</p>
<pre class="literal-block">
tren.py -xr /matrix/.*.bku=/FNAME/.old *
</pre>
<p><strong>tren</strong> will then promptly error out and tell you that it doesn't
know about a renaming token called <tt class="docutils literal">/matrix/</tt>.</p>
<p>There are a several things to keep in mind when doing things like
this:</p>
<blockquote>
<ol class="arabic simple">
<li>The <tt class="docutils literal">/$SYSNAME/</tt> in the <tt class="docutils literal">old</tt> string is used to <em>find the
text to rename</em>, whereas the same renaming token in the <tt class="docutils literal">new</tt>
string means <em>insert the contents of that environment variable
here</em>.</li>
<li>Renaming tokens are always evaluated <em>before</em> any regular
expression processing takes place.  It's up to you to make sure
that when the two are combined (as we have in the example above),
<em>that the final result is still a valid Python regular
expression</em>.  This may involve explicit quoting of the renaming
tokens used in the <tt class="docutils literal">old</tt> string specification.</li>
</ol>
</blockquote>
<p><strong>tren</strong> has many other kinds of renaming tokens.  Their structure and
use is described in some detail in the section below entitled
&quot;<a class="reference internal" href="#renaming-tokens-the-gory-details">Renaming Tokens: The Gory Details</a>&quot;.</p>
</div>
<div class="section" id="renaming-token-pitfalls">
<h2><a class="toc-backref" href="#id28">Renaming Token Pitfalls</a></h2>
<p>As we saw in earlier sections, <strong>tren</strong> command line option and file
name interaction can be tricky.  It can depend on order and on whether
the various renaming requests &quot;collide&quot; with each other as a new file
name is computed.  A similar potential collision exists between
renaming tokens and renaming requests.  Recall from &quot;<a class="reference internal" href="#more-about-command-line-pitfalls">More About
Command Line Pitfalls</a>&quot; that renaming tokens are resolved <em>before</em> a
renaming request is processed.  This means that the string
substitution (literal or regular expression) of the renaming operation
can <em>conflict with the characters returned when the renaming token was
resolved</em>.  For example, suppose we do this:</p>
<pre class="literal-block">
tren.py -r =New-/FNAME/ -r My=Your MyFile.txt
</pre>
<p>The first renaming request computes the name <tt class="docutils literal"><span class="pre">New-MyFile.txt</span></tt>.
However, the second renaming request further modifies this to
<tt class="docutils literal"><span class="pre">New-YourFile.txt</span></tt>.  In effect, the second renaming request is
<em>overwriting part of the string produced by the renaming token
reference</em>.  This is an intentional feature of <strong>tren</strong> to allow
maximum renaming flexibility.  However, you need to understand how it
works so you don't get unexpected and strange results.  For example,
look what happens when you reverse the order of the renaming requests
in this case:</p>
<pre class="literal-block">
tren.py -r My=Your -r =New-/FNAME/ MyFile.txt
</pre>
<p><tt class="docutils literal">My</tt> gets replaces with <tt class="docutils literal">Your</tt>, but as soon as the second renaming
request is processed, the whole string is thrown away and replaced
with the final name <tt class="docutils literal"><span class="pre">New-MyFile.txt</span></tt>.  This is yet another
example of, <strong>&quot;The Rightmost Renaming Request Wins&quot;</strong>.</p>
</div>
<div class="section" id="renaming-tokens-the-gory-details">
<h2><a class="toc-backref" href="#id29">Renaming Tokens: The Gory Details</a></h2>
<p>As we've just seen, a <em>renaming token</em> is nothing more than
a string representing something <strong>tren</strong> knows about.  These
fit in one of three categories:</p>
<blockquote>
<ul class="simple">
<li>An attribute of the file or directory being renamed</li>
<li>An attribute of the underlying operating system environment</li>
<li>A sequence that reflects some ordering principle</li>
</ul>
</blockquote>
<p>Renaming tokens are delimited by <tt class="docutils literal">/</tt> characters, in the form:</p>
<pre class="literal-block">
/RentokenName/
</pre>
<p><strong>tren</strong> replaces these tokens with the corresponding information (see
descriptions below) wherever you indicated in either the <tt class="docutils literal">old</tt> or
<tt class="docutils literal">new</tt> strings of a <tt class="docutils literal"><span class="pre">-r</span></tt> rename command.</p>
<p>Currently, <strong>tren</strong> defines a number of renaming tokens.  Future
releases of  <strong>tren</strong> may add more of these, so it's good to
periodically reread this material.</p>
</div>
<div class="section" id="what-s-the-difference-between-an-attribute-and-a-sequence">
<h2><a class="toc-backref" href="#id30">What's The Difference Between An &quot;Attribute&quot; And A &quot;Sequence&quot;?</a></h2>
<p>Some renaming tokens return <em>attributes</em> (of either a file or
the underling operating system).  Some return <em>sequences</em>.  So,
what's the difference?</p>
<p>An &quot;attribute&quot; is a <em>value</em> associated with the file- or
directory being renamed (or something about the underlying
operating system).  It could be the length of the file, the
last year it was modified, and so on.  For example, <tt class="docutils literal">/MYEAR/</tt>
returns the year the file being renamed was last modified,
<tt class="docutils literal">/SIZE/</tt> returns the length of the file, and <tt class="docutils literal">/FNAME/</tt>
returns the original name of the file before renaming.
So, if we do this:</p>
<pre class="literal-block">
tren.py -r=/FNAME/-/MYEAR/-/SIZE/ file, file ...
</pre>
<p>Every file will be renamed in the form of:</p>
<pre class="literal-block">
original_name-YYYY-length  # Example: myfile-2010-4099
</pre>
<p>So... <em>attributes are string substitutions wherein the string
tells you something about the file or system on which you're working</em>.</p>
<p>&quot;Sequences&quot;, on the other hand, are just <em>numbers that represent some
ordering principle</em>.  Say you use the sequence renaming token ordered
by size, <tt class="docutils literal"><span class="pre">/+SIZE::001/</span></tt> to rename 10 files of different sizes:</p>
<pre class="literal-block">
tren.py -r=/+SIZE::01/-/FNAME/ file, file, ...
</pre>
<p>This will produce a new set of files named like this:</p>
<pre class="literal-block">
01-original_name
02-original_name
03-original_name
...
10-original_name
</pre>
<p>Where, <tt class="docutils literal"><span class="pre">01-original_name</span></tt> will be the <em>shortest length</em> file
and <tt class="docutils literal"><span class="pre">10-original_name</span></tt> will be the <em>longest length</em> file.</p>
<p>So... <em>sequences are strings of numbers used to put things in some
order</em>.</p>
<p>You can always tell the difference between an attribute- and sequence
renaming token, because sequence renaming tokens always start with
either a <tt class="docutils literal">+</tt> or <tt class="docutils literal">-</tt> sign (to indicate ascending or descending
counting respectively).  This distinction is important because some
attribute- and sequence renaming tokens share the same name.  For
instance, <tt class="docutils literal">/FNAME/</tt> is an attribute token representing the <em>original
name</em> of the file before it was renamed.  However, <tt class="docutils literal"><span class="pre">/+FNAME::003/</span></tt>
is a sequence renaming token that returns the <em>position</em> (order) of
the file name in alphabetic order starting counting from <tt class="docutils literal">003</tt>.
Although they are both based on the file name (hence the common
renaming token symbol), they do very different things.</p>
</div>
<div class="section" id="how-tren-uses-file-metadata">
<h2><a class="toc-backref" href="#id31">How <strong>tren</strong> Uses File Metadata</a></h2>
<p>To keep track of all these attributes and/or to compute sequences,
<strong>tren</strong> needs the so-called &quot;metadata&quot; associated with the files- and
directories you've named on the command line.  This metadata includes
information like who owns them, how long they are, what date they were
modified, and so on.  (This information is commonly described in a
data structure called <tt class="docutils literal">stat</tt>.  Even non-Unix systems like Windows
have some version of this data structure.)</p>
<p>The file attribute- and sequence renaming tokens are built on this
metadata, so it's worth taking a moment to understand just <em>how</em>
it is used.  <strong>tren</strong> keeps track of the following information
for every file- or directory you've named on the command line:</p>
<blockquote>
<ul class="simple">
<li>The order the file appears on <em>the command line</em></li>
<li>The order the file appears <em>alphabetically</em></li>
<li>The <em>original name</em> of the file before any renaming took place</li>
<li>The date/time it was last <em>accessed</em></li>
<li>The date/time it was last <em>modified</em></li>
<li>The date/time its directory entry (inode) was last <em>modified</em></li>
<li>The <em>inode number</em> for the file</li>
<li>The <em>device number</em> where the directory entry (inode) lives</li>
<li>The <em>numeric group ID</em> the file belongs to</li>
<li>The <em>name of the group</em> the file belongs to</li>
<li>The <em>numeric user ID</em> of the file owner</li>
<li>The <em>name of the user</em> that owns the file</li>
<li>The <em>mode or permissions</em> for the file</li>
<li>The <em>number of links</em> to the file</li>
<li>The <em>size</em> of the file</li>
</ul>
</blockquote>
<p><strong>tren</strong> then later uses this information to resolve file attribute
renaming tokens, compute the value of a particular sequence renaming
token and so on as it finds them in your renaming requests.  For
example, a sequence renaming token based on group <em>name</em> will order
the sequence <em>alphabetically by group name</em> whereas one based on
<em>group ID</em> will order it numerically.</p>
<p>It is likely that you'll only be interested in a small subset of
these. For completness, though, <strong>tren</strong> keeps track of all the
metadata available about the files- or directories named on the
command line and makes it available in the form of renaming tokens.</p>
<p>Most commonly, you'll find yourself using the command line,
alphabetic, original name, length, and various time/date renaming
tokens.</p>
</div>
<div class="section" id="general-attribute-renaming-tokens">
<h2><a class="toc-backref" href="#id32">General Attribute Renaming Tokens</a></h2>
<p>These tokens are derived from information about the file or
directory being renamed.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p><strong>Windows Users Take Note!</strong></p>
<p><strong>tren</strong> is portable across many operating systems because
it is written in the Python programming language.  Python
<em>mostly</em> works the exact same way everywhere.  However,
Windows presents some problems because it does not quite
work the same way as Unix-derived OSs do.  In particular, if
you need to make use of the <tt class="docutils literal">/GROUP/</tt> or <tt class="docutils literal">/USER/</tt>
renaming tokens on Windows, consider installing the
<tt class="docutils literal">win32all</tt> extensions to your Windows Python installation.
If you don't, <strong>tren</strong> will base its order on the generic
names <tt class="docutils literal">WindowsUser</tt> and <tt class="docutils literal">WindowsGroup</tt> which it will
apply to every file- or directory under consideration.</p>
<p class="last">In any case, <tt class="docutils literal">/DEV/</tt>, <tt class="docutils literal">/GID/</tt>, <tt class="docutils literal">/INODE/</tt>, <tt class="docutils literal">/NLINK/</tt>,
and <tt class="docutils literal">/UID/</tt> are not meaningful under Windows and default
to 0.  Avoid using these tokens on Windows systems, since
these will return the same value for every file- or
directory.</p>
</div>
<ul>
<li><p class="first"><tt class="docutils literal">/DEV/&nbsp;&nbsp;&nbsp; Returns File- Or Directory's Device ID</tt></p>
<blockquote>
<p>This is the ID of the device containing the file being
renamed.  You might want to rename files so that all the
files on a given device start with the same key.  That
way, their names group together in a sorted directory
listing:</p>
<pre class="literal-block">
tren.py -r=/DEV/-/FNAME/ file | dir, file | dir, ...
</pre>
<p>You end up with a sorted directory listing that looks
something like:</p>
<pre class="literal-block">
93-...
93-...
97-...
98-...
</pre>
<p>The file names are still preserved in our renaming reqest
above, now they're just preceded by the device ID of the
where they live with a trailing <tt class="docutils literal">-</tt> separator.</p>
</blockquote>
</li>
<li><p class="first"><tt class="docutils literal">/FNAME/&nbsp; Returns Original File- Or Directory Name</tt></p>
<blockquote>
<p>This is the name of the file- or directory you are
renaming <em>before</em> you apply any renaming requests.  This
allows you to create new names based, in part, on the old
name:</p>
<pre class="literal-block">
tren.py -r=/FNAME/-suffix  ...  # Adds &quot;-suffix&quot; to original name
tren.py -r=prefix-/FNAME/  ...  # Adds &quot;-prefix&quot; to original name
tren.py -r /FNAME/=newname ...  # Same as &quot;-r=newname&quot;
tren.py -r /FNAME/=/FNAME/ ...  # Does nothing: old/new are same
</pre>
</blockquote>
</li>
<li><p class="first"><tt class="docutils literal">/GID/&nbsp;&nbsp;&nbsp; Returns File- Or Directory's Group ID</tt></p>
<blockquote>
<p>This is the number for the group to which the file- or
directory belongs.  One way to use this is to prepend it
to every file name, thereby having all files (and or
directories) in the same group list together in a sorted
directory listing:</p>
<pre class="literal-block">
tren.py -r=/GID/-/FNAME/ *
</pre>
</blockquote>
</li>
<li><p class="first"><tt class="docutils literal">/GROUP/&nbsp; Returns File- Or Directory's Group Name</tt></p>
<blockquote>
<p>Essentially the same as <tt class="docutils literal">/GID/</tt> except it returns the
<em>name</em> of the group rather than the number.  Again, this
is useful when clustering names together in a sorted
directory listing:</p>
<pre class="literal-block">
tren.py -r=/GROUP/-/FNAME/ *
</pre>
</blockquote>
</li>
<li><p class="first"><tt class="docutils literal">/INODE/&nbsp; Returns File- Or Directory's Serial Number</tt></p>
<blockquote>
<p>This is typically an identifier to the directory entry
for the file- or directory being renamed.  <tt class="docutils literal">/DEV/</tt> and
<tt class="docutils literal">/INODE/</tt> taken together provide a unique systemwide
identifier for the file- or directory being renamed.</p>
</blockquote>
</li>
<li><p class="first"><tt class="docutils literal">/MODE/&nbsp;&nbsp; Returns File- Or Directory's Permissions</tt></p>
<blockquote>
<p>This is a numeric string that represents the permissions
of the file- or directory being renamed in standard Unix
format.</p>
</blockquote>
</li>
<li><p class="first"><tt class="docutils literal">/NLINK/&nbsp; Returns Number Of Links To File- Or Directory Being Renamed</tt></p>
<blockquote>
<p>Most operating systems allow a single file to have
multiple names.  These names are &quot;linked&quot; to the instance
of the file.  This replacement token is a numeric string
representing the number of such links.</p>
</blockquote>
</li>
<li><p class="first"><tt class="docutils literal">/SIZE/&nbsp;&nbsp; Returns File- Or Directory's Length In Bytes</tt></p>
<blockquote>
<p>This is handy if you want a sorted directory listing to
list all the files of the same size together.  You simply
prepend the file- or directory's length onto its name:</p>
<pre class="literal-block">
tren.py -r=/SIZE/-/FNAME/ *
</pre>
<p>Now all of the files of, say, length 23 will group
together in a sorted directory listing.</p>
</blockquote>
</li>
<li><p class="first"><tt class="docutils literal">/UID/&nbsp;&nbsp;&nbsp; Returns File- Or Directory's User ID</tt></p>
<blockquote>
<p>This is the number for the user that owns the file- or
directory being renamed.  One way to use this is to
prepend it to every file name, thereby having all files
(and or directories) owned by the same user cluster
together in a sorted directory listing:</p>
<pre class="literal-block">
tren.py -r=/UID/-/FNAME/ *
</pre>
</blockquote>
</li>
<li><p class="first"><tt class="docutils literal">/USER/&nbsp; Returns File- Or Directory's User Name</tt></p>
<blockquote>
<p>Essentially the same as <tt class="docutils literal">/UID/</tt> except it returns the
<em>name</em> of the user rather than the number.  Again, this
is useful when clustering names together in a sorted
directory listing:</p>
<pre class="literal-block">
tren.py -r=/USER/-/FNAME/ *
</pre>
</blockquote>
</li>
</ul>
</div>
<div class="section" id="time-related-attribute-renaming-tokens">
<h2><a class="toc-backref" href="#id33">Time-Related Attribute Renaming Tokens</a></h2>
<p>Modern operating system maintain three different kinds of timestamps
for files and directories, <tt class="docutils literal">ATIME</tt>, <tt class="docutils literal">CTIME</tt>, and <tt class="docutils literal">MTIME</tt>:</p>
<blockquote>
<p><tt class="docutils literal">ATIME</tt> refers to the last time the file- or directory was
<em>accessed</em>.</p>
<blockquote>
This is updated every time the file is read.</blockquote>
<p><tt class="docutils literal">CTIME</tt> refers to the last time the file- or directory's <em>inode
(directory entry) was modified</em>.</p>
<blockquote>
This is updated whenever a file- or directory's permissions or
ownership are changed.  It will also be updated when the file- or
directory itself is modified.</blockquote>
<p><tt class="docutils literal">MTIME</tt> refers to the last time the file- or directory <em>itself was
modified</em>.</p>
<blockquote>
This is updated whenever the file- or directory is closed after
modification.</blockquote>
</blockquote>
<p><strong>tren</strong> implements a set of time-related file attribute renaming
tokens intended to provide full access to these various timestamps.
As a practical matter, you're most likely to use the <tt class="docutils literal">MTIME</tt>-based
tokens, but components for all three time values are available should
you need them.  They are identically named, except that the first
letter of each of the time-related attribute tokens indicates which of
the three timestamps above is used to compute the value:</p>
<ul>
<li><p class="first"><tt class="docutils literal">/ADAY/, /CDAY/, /MDAY/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns Timestamp's Day Of The Month</tt></p>
<blockquote>
<p>Returns the day of the month of the timestamp in <tt class="docutils literal">dd</tt> format.</p>
</blockquote>
</li>
<li><p class="first"><tt class="docutils literal">/AHOUR, /CHOUR/, /MHOUR/&nbsp;&nbsp;&nbsp;&nbsp; Returns Timestamp's Hour Of The Day</tt></p>
<blockquote>
<p>Returns the hour of the day of the timestamp in <tt class="docutils literal">hh</tt> format.</p>
</blockquote>
</li>
<li><p class="first"><tt class="docutils literal">/AMIN/, /CMIN/, /MMIN/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns Timestamp's Minute Of The Hour</tt></p>
<blockquote>
<p>Returns the minute of the hour of the timestamp in <tt class="docutils literal">mm</tt> format.</p>
</blockquote>
</li>
<li><p class="first"><tt class="docutils literal">/AMON/, /CMON/, /MMON/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns Timestamp's Month Of The Year</tt></p>
<blockquote>
<p>Returns the month of the year of the timestamp in <tt class="docutils literal">mm</tt> format</p>
</blockquote>
</li>
<li><p class="first"><tt class="docutils literal">/AMONTH, /CMONTH/, /MMONTH/&nbsp; Returns Timestamp's Name Of The Month</tt></p>
<blockquote>
<p>Returns the name of the month of the timestamp in <tt class="docutils literal">Nnn</tt> format.</p>
</blockquote>
</li>
<li><p class="first"><tt class="docutils literal">/ASEC/, /CSEC/, /MSEC/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Returns Timestamp's Seconds Of The Minute</tt></p>
<blockquote>
<p>Returns the seconds of the minute of the timestamp in <tt class="docutils literal">ss</tt> format.</p>
</blockquote>
</li>
<li><p class="first"><tt class="docutils literal">/AWDAY, /CWDAY/, /MWDAY/&nbsp;&nbsp;&nbsp;&nbsp; Returns Timestamp's Name Of The Weekday</tt></p>
<blockquote>
<p>Returns the name of the day of the timestamp in <tt class="docutils literal">Ddd</tt> format.</p>
</blockquote>
</li>
<li><p class="first"><tt class="docutils literal">/AYEAR, /CYEAR/, /MYEAR/&nbsp;&nbsp;&nbsp;&nbsp; Returns Timestamp's Year</tt></p>
<blockquote>
<p>Returns the year of the timestamp in <tt class="docutils literal">yyyy</tt> format.</p>
</blockquote>
</li>
</ul>
<p>So, for example:</p>
<pre class="literal-block">
tren.py -r=/FNAME/-/MYEAR/-/MMON/-/MDAY/-/MMONTH/-/MWDAY/-/MHOUR/:/MMIN/:/MSEC/ foo
</pre>
<p>Might rename the file to something like:</p>
<pre class="literal-block">
foo-2005-01-07-Jan-Fri-01:23:33
</pre>
</div>
<div class="section" id="system-renaming-tokens">
<h2><a class="toc-backref" href="#id34">System Renaming Tokens</a></h2>
<p>These tokens are derived from the underlying operating system and
runtime environment.  Notice that, because command interpreters
(shells) on various systems work differently, the first two of these
have to be quoted in different ways.</p>
<ul>
<li><p class="first"><tt class="docutils literal">/NAMESOFAR/ Current state of new name</tt></p>
<blockquote>
<p><tt class="docutils literal">tren</tt> allows multiple renaming requests to be
specified on the command line .  Each of these operates
serially on the renaming target name: The leftmost
request operates on the original name.  The resulting
name is handed to the next request to the right
and so on.</p>
<p><tt class="docutils literal">/NAMESOFAR/</tt> allows the current state of a new name
to be included explicitly in a renaming request.  i.e.,
You can insert the name a renaming request starts out
with into its own renaming specification:</p>
<pre class="literal-block">
tren.py -rX=y -r=/NAMESOFAR/.text  Xray.txt
</pre>
<p>The first renaming request transforms the name from
<tt class="docutils literal">Xray.txt</tt> to <tt class="docutils literal">yray.txt</tt>.  This is thus the &quot;name
so far&quot; with which the second request begins.  So, the
second renaming request transforms the name
<tt class="docutils literal">yray.txt</tt> into <tt class="docutils literal">yray.txt.text</tt>.</p>
</blockquote>
</li>
<li><p class="first"><tt class="docutils literal">/$ENV/&nbsp;&nbsp;&nbsp;&nbsp; Environment variable</tt></p>
<blockquote>
<p>This token is replaced with the value of the
environment variable <tt class="docutils literal">ENV</tt>.  If that variable does
not exist, the token is replaced with an empty string:</p>
<pre class="literal-block">
tren.py -r ='/$ORGANIZATION/'-/FNAME/ *  # Unix shells
tren.py -r =/$ORGANIZATION/-/FNAME/ *    # Windows shells
</pre>
<p>This prepends the organization's name to everything in
the current directory.</p>
</blockquote>
</li>
<li><p class="first"><tt class="docutils literal">/`cmd`/&nbsp;&nbsp;&nbsp; Arbitrary command execution</tt></p>
<blockquote>
<p>This token is replaced with the string returned by
executing the <tt class="docutils literal">cmd</tt> command.  Note that newlines are
stripped from the results, since they don't belong in
file names.  Spaces, however, are preserved.</p>
<p>For instance, you might want to prepend the name of the
system to all your shell scripts:</p>
<pre class="literal-block">
tren.py -r ='/`uname -n`/'-/FNAME/ *.sh  # Unix shells
tren.py -r =&quot;/`uname -n`/&quot;-/FNAME/ *.sh  # Windows shells
</pre>
<p>This construct is more generally a way to synthesize
renaming tokens that are not built into <strong>tren</strong>. You
can write a script to do most anything you like,
execute it within the <tt class="docutils literal">/`cmd`/</tt> construct, and plug the
results into your new file name.  This effectively
provides <strong>tren</strong> an unlimited number of renaming
tokens.</p>
<blockquote>
<div class="warning">
<p class="first admonition-title">Warning</p>
<p class="last">Be <em>very</em> careful using this.  It's
possible to construct bizzarre,
overly long, and just plain
chowder-headed strings that make no
sense in a file name using this
token.  Moreover, if you attempt to
insert characters that don't belong
in a file- or directory name (like a
path separator), construct a file
name that is too long (or too
short), or just generally violate
something about the filesystem's
naming rules, this will cause
<strong>tren</strong> to abort and spit out an
error.  <em>However</em>, you will not be
prevented from creating file names
that are legal but undesirable, such
as file names that begin with the
<tt class="docutils literal">-</tt> character.  In other words, be
careful and be sure you know what
you're doing with this renaming
token.</p>
</div>
</blockquote>
</blockquote>
</li>
</ul>
<div class="tip">
<p class="first admonition-title">Tip</p>
<p><strong>MORE ABOUT QUOTING</strong> <tt class="docutils literal">/$ENV/</tt> <strong>AND</strong> <tt class="docutils literal">/`cmd`/</tt> <strong>SYSTEM RENAMING TOKENS</strong></p>
<p>Both of these constructs are supported directly from most
Unix command shells.  That is, most Unix shells will
themselves dereference constructs like <tt class="docutils literal">$ENV</tt> and
<tt class="docutils literal">`command`</tt>.  There's no need to pass them as renaming
tokens, you can just use the shell's capabilities:</p>
<pre class="literal-block">
tren.py -r =/FNAME/-`uname -n`-$LOGNAME
</pre>
<p>If you do want to use the renaming token form in a Unix
shell, you <em>must</em> single quote them to prevent the shell
from &quot;interpolating&quot; the variables before <strong>tren</strong> is
called.  If you don't do this, <strong>tren</strong> will complain about
encountering unknown renaming tokens:</p>
<pre class="literal-block">
tren.py -r='/`uname -n`/'-/FNAME/ *.sh # Right
tren.py -r=/`uname -n`/-/FNAME/ *.sh   # Wrong
</pre>
<p>The real reason for providing these renaming tokens at all
is because the Windows command interpreter does not have an
equivalent function.  The <em>only</em> way to achieve what these
do on Windows is via renaming tokens.  In Windows, you also
have to pay attention to quoting, particularly when there
are spaces in a <tt class="docutils literal">`cmd`</tt> renaming token:</p>
<pre class="literal-block">
tren.py -r=/FNAME/-/`command opts args`/ ...
</pre>
<p>This causes <strong>tren</strong> to complain mightily because it thinks
<tt class="docutils literal">/`command</tt>, <tt class="docutils literal">opts</tt>, <tt class="docutils literal">args</tt>, are all separate
(invalid) command line arguments.  To avoid this problem,
you need to pass the renaming token as a single command line
entity via quotes:</p>
<pre class="last literal-block">
tren.py -r=/FNAME/-&quot;/`command opts args`/&quot;  ...
</pre>
</div>
<ul>
<li><p class="first"><tt class="docutils literal">/RAND#/&nbsp;&nbsp;&nbsp; Random Number Generator</tt></p>
<blockquote>
<p>This generates a (quasi) random number string, <tt class="docutils literal">#</tt>
digits wide.</p>
<p>This can be useful when you want to guarantee that no
renaming operation will generate a new name that
conflicts with an existing name:</p>
<pre class="literal-block">
tren.py -r=/MYEAR//MMON//MDAY/-/RAND10/ *
</pre>
<p>This generates new file names with a 10 character
random number string suffix:</p>
<pre class="literal-block">
20100401-4708910871
</pre>
<p>In this case, just make sure the random number string
is long enough to make a name collision unlikely by
picking a sufficiently large <tt class="docutils literal">#</tt>.</p>
<p><tt class="docutils literal">#</tt> must be a positive integer greater than 0.  The
random number generator is reinitialized each time the
program runs, so test mode operations will only show
you the &quot;shape&quot; of the names with the embedded random
number strings, not the actual strings you'll end up
with.</p>
<p>Another nice use of this feature is to &quot;mask&quot; the
actual file names.  Say you have a bunch of encrypted
files, but you don't want a casual viewer to even know
what they are or what's in them.  You might do this:</p>
<pre class="literal-block">
tren.py -r=/RAND25/ * 2&gt;&amp;1 &gt;tren.log
</pre>
<p>Now you can encrypt <tt class="docutils literal">tren.log</tt> and send it along with
the files themselves over a non-secure channel.  The
recipient can decrypt the log, and figure out what the
original file names were, decrypt them, and store them
accordingly.</p>
</blockquote>
</li>
</ul>
</div>
<div class="section" id="sequence-renaming-tokens">
<h2><a class="toc-backref" href="#id35">Sequence Renaming Tokens</a></h2>
<p>Sometimes it's useful to rename files or directories based on some
<em>property they possess</em> like the date or time of creation, the size of
the file, who owns it, and so on.  That's the idea behind the
attribute renaming tokens described in the previous sections.</p>
<p>But another really interesting use of renaming tokens is to <em>order all
the files being renamed</em> based on one of these parameters.  For
instance, instead of actually embedding the date and time of creation
in a file or directory name, you might want to order the files from
oldest to newest with a naming convention like:</p>
<pre class="literal-block">
file-1.txt
file-2.txt
file-3.txt
</pre>
<p>This guarantees uniqueness in the final name and also sees to it that
a sorted directory listing will show you the files or directories in
the order you care about.</p>
<p>This is the purpose of <em>sequence renaming tokens</em>.  They give you
various ways to create sequences that can be embedded in the final
file or directory name.</p>
<blockquote>
<div class="tip">
<p class="first admonition-title">Tip</p>
<p>Many sequence renaming tokens described below share the
same name with an attribute renaming token described in
the previous sections.  That's because they are based on
the same property of the file- or directory being
renamed.  However, it's easy to tell which is which:
Sequence renaming tokens always begin with either <tt class="docutils literal">+</tt>
or <tt class="docutils literal">-</tt> (to indicate ascending- and descending ordering
respectively).</p>
<p class="last">So, <tt class="docutils literal">/GROUP/</tt> is an attribute renaming token that
returns the group <em>name</em> for the file.  However,
<tt class="docutils literal"><span class="pre">/+GROUP.../</span></tt> is a sequence renaming token that returns
a number indicating what <em>position</em> the file is in when
all the files named on the command line are <em>ordered by
their group names</em>.</p>
</div>
</blockquote>
</div>
<div class="section" id="general-format-of-sequence-renaming-tokens">
<h2><a class="toc-backref" href="#id36">General Format Of Sequence Renaming Tokens</a></h2>
<p>Sequence renaming tokens consist of four descriptive components and
have the following general format:</p>
<pre class="literal-block">
/OrderingType:Counting Alphabet:Counting Pattern/

  where,
         Ordering (Required):

               +  ascending
               -  descending

         Type (Required):

               The attribute used to create the ordering.

         Counting Alphabet (Optional):

               The name of the counting system to use.

         Counting Pattern (Optional):

               Establishes the first value in the counting
               sequence and/or provides a string to format
               the count.
</pre>
<p>Note that there is no space between the <em>Ordering</em> flag and <em>Type</em>.</p>
<p>An <em>Ordering</em> flag is mandatory.  It will either be <tt class="docutils literal">+</tt> to indicate
an ascending count or <tt class="docutils literal">-</tt> to indicate a descending count.</p>
<p>The <em>Type</em> is mandatory.  These are documented in the section
below entitled, &quot;<a class="reference internal" href="#types-of-sequence-renaming-tokens">Types Of Sequence Renaming Tokens</a>&quot;.</p>
<p>The <em>Counting Alphabet</em> is optional.  Counting alphabets are ways to
count in different bases and even to use something other than just
numbers to represent the count.  These are described in the section
below entitled, &quot;<a class="reference internal" href="#let-s-learn-the-alphabet">Let's Learn The Alphabet</a>&quot;.</p>
<p>If you omit naming a specific alphabet, <strong>tren</strong> will default to
counting in Decimal.  Note that you <em>cannot</em> omit the alphabet
delimiters, so the correct form of a sequence renaming token then
becomes:</p>
<pre class="literal-block">
/OrderingType::Counting Pattern/
</pre>
<p>A <em>Counting Pattern</em> is optional.  Counting patterns are used to do
two things: Set the initial value for the count and Describe the
layout of how the count should look.  This is described in the section
below entitled, &quot;<a class="reference internal" href="#counting-pattern-format">Counting Pattern Format</a>&quot;.</p>
<p>If you omit a counting pattern, <strong>tren</strong> will start counting from the
zero-th &quot;number&quot; in your chosen alphabet, producing a counting pattern
as &quot;wide&quot; as necessary to count all the items being renamed.  In that
case, the format of a sequence renaming token becomes:</p>
<pre class="literal-block">
/OrderingType:Alphabet:/    # With explicit alphabet
/OrderingType::/            # With default decimal alphabet
</pre>
</div>
<div class="section" id="let-s-learn-the-alphabet">
<h2><a class="toc-backref" href="#id37">Let's Learn The Alphabet</a></h2>
<p>Sequence renaming tokens are essentially &quot;counters&quot; that return a
number string representing where the file- or directory being renamed
sits in some order - say, by time, alphabetically or on the command
line.</p>
<p>To be as flexible as possible in creating renaming strings, it's
helpful to be able to &quot;count&quot; in any <em>base</em>, and use any <em>set of
symbols</em> when counting.  For instance, you may prefer sequences of
letters instead of numbers.  Such a sequence might look like this:</p>
<pre class="literal-block">
 a
 b
 ...
 z
aa
ab
...
az
ba
bb
</pre>
<p>And so on.</p>
<p><strong>tren</strong> has a number of standard such &quot;counting alphabets&quot; built in
for the most common counting situations.  As described in the previous
section, you specify which of these you want to use in each sequence
renaming token reference on the command line.  (If you omit naming a
specific alphabet, the token will default to counting in Decimal.)</p>
<p>The built in alphabets are:</p>
<pre class="literal-block">
Binary     -  Counting in Base 2 using numbers
Octal      -  Counting in Base 8 using numbers
Decimal    -  Counting in Base 10 using numbers
HexLower   -  Counting in Base 16 using numbers and lower case letters
HexUpper   -  Counting in Base 16 using numbers and upper case letters
Lower      -  Counting in Base 26 using lower case letters
LowerUpper -  Counting in Base 52 using lower- then upper case letters
Upper      -  Counting in Base 26 using upper case letters
UpperLower -  Counting in Base 52 using upper- then lower case letters
</pre>
<div class="tip">
<p class="first admonition-title">Tip</p>
<p><strong>The difference between a &quot;base&quot; and a &quot;symbol set&quot;.</strong></p>
<p class="last">In order to make such counting-based renamings as flexible
as possible, <strong>tren</strong> is built to be able to count <em>in any
base</em> (2 or higher) and <em>make use of any symbol set</em>.
What's the difference?  The &quot;base&quot; tells you how many
symbols there are in your counting system.  In Decimal, for
example, there are 10.  The &quot;symbol&quot; set, assigns a
character to represent each of those positions.  In Decimal,
we customarily use, &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, and so on.  However,
there is nothing magical about the symbol set.  It is the
<em>base</em> that defines the counting system.  The symbol set is
just an arbitarary representation.  For instance, there's no
reason we can count in base 10, using the symbols, &quot;)&quot;, &quot;!&quot;,
&quot;#&quot;, &quot;$&quot;, ... and so on.</p>
</div>
<p>This ability to use any symbol set in any base makes it easy to
construct counting strings that suit your particular renaming needs.
You do this by defining your own, custom counting &quot;alphabet&quot; via the
<tt class="docutils literal"><span class="pre">-A</span></tt> command line option:</p>
<pre class="literal-block">
-A AlphabetName:string-of-characters
</pre>
<p>Once defined, later renaming tokens on the command line can refer to
it via the <tt class="docutils literal"><span class="pre">/...:AlphabetName:.../</span></tt> syntax discussed previously.</p>
<p>Say we do this:</p>
<pre class="literal-block">
tren.py -A Foo:s2X -r=/+MTIME:Foo:/ *
</pre>
<p>This will rename all the files in the current directory in ascending
<tt class="docutils literal">mtime</tt> timestamp order using the following counting scheme:</p>
<pre class="literal-block">
 s
 2
 X
ss
s2
sX
2s
22
2X
</pre>
<p>And so on.  You can use most any combination of characters you like to
customize your sequence renaming token output.  There are a few things to
keep in mind, however:</p>
<ul>
<li><p class="first">The counting <em>base</em> is determined by the <em>number of symbols in the
symbol set</em> not what characters you use.  In the example above,
we're counting in base 3 irrespective of what symbols are used
to represent each &quot;number&quot;.</p>
</li>
<li><p class="first">You can define as many new alphabets as you like on the command line.
(Well ... up to the maximum command line length limit imposed by
the shell and/or operating system you're using.)</p>
</li>
<li><p class="first">The alphabet name is case sensitive.  <tt class="docutils literal">Foo</tt>, <tt class="docutils literal">FOO</tt>, and <tt class="docutils literal">foo</tt>
are all different alphabet names (assuming they are all defined).</p>
</li>
<li><p class="first">There is no requirement that the symbol set be built out of unique
characters.  <strong>tren</strong> does no analysis of your symbol set at all,
so this is permitted (if not recommended):</p>
<pre class="literal-block">
-A  Foo:abcx123xj3,m2
</pre>
</li>
<li><p class="first">Similarly, you can populate your alphabet with any symbols you
like, BUT remember they're going to be embedded in some file-
or directory name.  It's a good idea to make sure you avoid illegal
or undesirable characters like <tt class="docutils literal">/</tt>, <tt class="docutils literal">\</tt>, and <tt class="docutils literal">-</tt> in your
alphabets so they don't end up getting embedded in a name (or trying
to, anyway).</p>
</li>
<li><p class="first">If you use non-numerical counting schemes, your sorted directory
list will not reflect that order.  For example, suppose you have
a bunch of files in a directory, and you do this:</p>
<pre class="literal-block">
tren.py -r=/-MTIME:LowerUpper:/ *
</pre>
<p>Your files will get renamed in descending <tt class="docutils literal">mtime</tt> timestamp order
as:</p>
<pre class="literal-block">
a
b
...
A
B
...
aa
</pre>
<p>And so on, where <tt class="docutils literal">a</tt> is the oldest file- or directory.  However,
when you do a sorted directory listing, the names beginning with
<em>upper case</em> characters will be listed first.  Why?  Because directory
sorting is typically based on ASCII order wherein <tt class="docutils literal"><span class="pre">A-Z</span></tt> appear before
<tt class="docutils literal"><span class="pre">a-Z</span></tt>.</p>
</li>
</ul>
</div>
<div class="section" id="counting-pattern-format">
<h2><a class="toc-backref" href="#id38">Counting Pattern Format</a></h2>
<p>When using sequence renaming tokens, it's nice to be able to layout
the resulting counting string in some consistent way.  You can use an
optional &quot;counting pattern&quot; in your sequence renaming token to do
this.  The renaming pattern is used to specify two things: The width
of the sequence string, and, optionally, the starting value for the
sequence.  For instance:</p>
<pre class="literal-block">
Pattern      Results
-------      -------

0001    -&gt;   0001, 0002, 0003, ...
0000    -&gt;   0000, 0001, 0002, ...
03      -&gt;   03, 04, 05, ...
</pre>
<p>To understand counting patterns, you have to understand a few
basic rules <strong>tren</strong> uses to interpret them:</p>
<blockquote>
<ul>
<li><p class="first">The number of characters (of any kind) in the pattern fix the
<em>width</em> of the counting string.  These characters need not even be
in the counting alphabet:</p>
<pre class="literal-block">
tren.py -r=/+CTIME::abcde/ *
</pre>
<p>This produces files renamed in ascending <tt class="docutils literal">ctime</tt> timestamp order
like this:</p>
<pre class="literal-block">
abcd0
abcd1
...
abc10
</pre>
<p>And so on.</p>
</li>
<li><p class="first">When a count increments such that it would exceed the width of the
pattern, it &quot;rolls over&quot; and <strong>tren</strong> issues a warning message to
that effect.  Using the example above, we'd get:</p>
<pre class="literal-block">
9998
9999
0000  # Count rolls over and warning issued!
</pre>
<p>Notice that the count rolls over <em>in the selected counting
alphabet</em>, it does not restart from the original counting pattern.
In almost every case, you should avoid roll over and make your
counting pattern wide enough to hold a full count for all the
files- and directories you've named on the command line.  One
issue here is that rolling over is possibly going to create a name
collision and the renaming will either be skipped or have to be
forced (with backup) using the <tt class="docutils literal"><span class="pre">-f</span></tt> option.</p>
</li>
<li><p class="first">As we've seen, <strong>tren</strong> treats each position of the counting
pattern as a placeholder and &quot;eats&quot; characters as the count goes
up.  This allows you great flexibility in creating renaming
patterns that embed both a count and <em>a literal</em> string via
a single sequence renaming token.  You just have to make the
counting pattern wide enough so that the highest count never
consumes your literal string:</p>
<pre class="literal-block">
tren.py -r=/+MTIME:HexLower:InHexMtimeOrder-0x00000/ *
</pre>
<p>This yields new file names like this:</p>
<pre class="literal-block">
InHexMtimeOrder-0x00000
InHexMtimeOrder-0x00001
InHexMtimeOrder-0x00002
...
</pre>
<p>Notice that the <tt class="docutils literal">0x</tt> string may mean &quot;this is a hex number&quot; to
the human reader, but it is completely insignificant to <strong>tren</strong>.
If the count were to get large enough - bigger than 5 digits, the
<tt class="docutils literal">0x</tt> string itself would get overwritten.  Larger still, and
<tt class="docutils literal">InHexMtimeOrder-</tt> would start to get consumed.</p>
<div class="tip">
<p class="first admonition-title">Tip</p>
<p>We could avoid the possibility of having the count ever
consume our literal text, by taking it <em>out of the
sequence renaming token</em> and putting it in as a literal
argument to the <tt class="docutils literal"><span class="pre">-r</span></tt> option, thereby separating the
text from the count:</p>
<pre class="last literal-block">
-r=InHexMtimeOrder-0x/+MTIME:HexLower:00000/
</pre>
</div>
<p>In short, <strong>tren</strong> treats <em>every character in a counting pattern
the same</em> - with complete indifference.</p>
</li>
<li><p class="first">Well ... <em>almost</em> &quot;complete indifference&quot;.  When <strong>tren</strong> finds
characters that are <em>in</em> the selected counting alphabet, it
<em>adds them to the count</em>.  In this way we start counting at
some predermined initial value.  Note that <strong>tren</strong> always
produces sequence number <em>starting with 0</em> and, unless the
pattern indicates otherwise:</p>
<pre class="literal-block">
tren.py -r=/+CMDLINE::/ a b c
</pre>
<p>Produces:</p>
<pre class="literal-block">
0   # Formerly a, the 1st command line argument
1   # Formerly b, the 2nd command line argument
2   # Formerly c, the 3nd command line argument
</pre>
</li>
</ul>
<blockquote>
<p>But say we wanted to start counting from 1 instead:</p>
<pre class="literal-block">
  tren.py -r=/+CMDLINE::1/ a b c

Produces::

  1   # Formerly a, the 1st command line argument
  2   # Formerly b, the 2nd command line argument
  3   # Formerly c, the 3nd command line argument
</pre>
<p>Similarly, <tt class="docutils literal"><span class="pre">/+CMDLINE::101/</span></tt> would produce:</p>
<pre class="literal-block">
101 # Formerly a, the 1st command line argument
102 # Formerly b, the 2nd command line argument
103 # Formerly c, the 3nd command line argument
</pre>
<p>Because <strong>tren</strong> is insensitive to characters <em>outside</em>
the counting alphabet, you can produce really interesting
counting patterns like this:</p>
<pre class="literal-block">
  tren.py -r=/+CMDLINE::1x0/ a b c

Produces::

  1x0   # Formerly a, the 1st command line argument
  1x1   # Formerly b, the 2nd command line argument
  1x2   # Formerly c, the 3nd command line argument

If you had enough files named on the command line, the
count would eventually consume the out-of-alphabet
characters::

  1x0
  ...
  1x9
  110
  111
  ...
</pre>
<p>So, by mixing characters that are both in- and out of the counting
alphabet in a counting pattern, you &quot;prime&quot; the sequence renaming
token to start counting with a certain string.  Notice that you
can do this in <em>any</em> position within the pattern.  Say you do
this:</p>
<pre class="literal-block">
tren.py -r=/+CMDLINE::x1x4/ *
</pre>
<p>This will produce a counting sequence like this:</p>
<pre class="literal-block">
x1x4
x1x5
...
x110
...
x200
</pre>
<p>In other words, a character in any position of the pattern that is
in the counting alphabet will be added to the count.</p>
<p>This works for all alphabets, any base, and any symbol set:</p>
<pre class="literal-block">
tren.py -r=/+FNAME/:Upper:+0S/ *
</pre>
<p>Yields new file names:</p>
<pre class="literal-block">
+0S
+0T
...
+0Z
+BA
+BB
...
</pre>
</blockquote>
<ul>
<li><p class="first">There is no notion of starting the count from a &quot;negative number&quot;
and counting up.  You can sort of synthesize this by sticking a
<tt class="docutils literal">-</tt> in front of a sequence renaming token (or at the left end of
its counting pattern).  Keep in mind, though, that <strong>tren</strong> only
knows how to <em>increment</em> a count so you will always get an
&quot;increasing negative number&quot; when you do this:</p>
<pre class="literal-block">
tren.py -r=-/+CMDLINE::5/-/FNAME/ a b c
</pre>
<p>Will produce new file names:</p>
<pre class="literal-block">
-5-a
-6-b
-7-c
</pre>
<p>If you want the reverse order, specify a descending sequence
renaming token:</p>
<pre class="literal-block">
tren.py -r=-/-CMDLINE::5/-/FNAME/ a b c
</pre>
<p>Will produce new file names:</p>
<pre class="literal-block">
-5-c
-6-b
-7-a
</pre>
</li>
</ul>
</blockquote>
</div>
<div class="section" id="types-of-sequence-renaming-tokens">
<h2><a class="toc-backref" href="#id39">Types Of Sequence Renaming Tokens</a></h2>
<p>Sequence renaming tokens are thus a way to generate an ordering <em>based
on some property common to everything being renamed</em>.  That property
is used to return a string representing just where in that order a
particular file- or directory appears.  This string is formatted
according to the counting alphabet and counting pattern embedded in
the sequence renaming token as described in the previous sections.</p>
<p>Keep in mind that for purposes of sequencing, <strong>tren</strong> <em>makes no
distinction between a file and directory</em>.  It merely sequences based
on the property you requested.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p>There is one <em>very</em> important detail to keep in mind here.
When <strong>tren</strong> first starts up, it examines the metadata of
every file- and directory name on the command line.  It uses
this to pre-create the sequences for every possible ordering
(alphabetic, by date, within date, by length, and so on)
<em>whether or not every file actually ends up being renamed
later on</em>.  In other words, sequences are built on <em>the list
of names passed on the command line</em> NOT on the list of
files- or directories that actually get renamed.  If your
renaming requests only apply to some of the file names you
passed on the command line, you may find the resulting
sequence unexpected.  Say you have three files, <tt class="docutils literal">a</tt>,
<tt class="docutils literal">b</tt>, and <tt class="docutils literal">c</tt> and you do this:</p>
<pre class="literal-block">
tren.py -rb=/FNAME/-/+FNAME::001/ b c a
</pre>
<p class="last">Only file <tt class="docutils literal">b</tt> has a matching <tt class="docutils literal">old</tt> string and thus is
the only file renamed.  However, because it is second
alphabetically <em>of all the files named on the command line</em>,
it gets renamed to <tt class="docutils literal"><span class="pre">b-002</span></tt>.  The way to avoid this
surprise is to make sure any renaming request with sequence
renaming tokens in it is constructed so that it applies to
<em>all</em> the files- and directories named on the command line.</p>
</div>
<p>Sometimes, more than one file- or directory named on the command line
maps to the same sequencing key.  For example, when using the
<tt class="docutils literal"><span class="pre">/+GROUP.../</span></tt> sequence renaming token, dozens of files in a given
directory may only map to a few group names.  In this situation, all
the names that map to the same key <em>will be sequenced alphabetically
within the key</em>.  So if <tt class="docutils literal">a</tt> and <tt class="docutils literal">b</tt> are in group <tt class="docutils literal">foo</tt> and
<tt class="docutils literal">c</tt> and <tt class="docutils literal">d</tt> are in group <tt class="docutils literal">baz</tt>:</p>
<pre class="literal-block">
tren.py -r=/+GROUP/::/-/FNAME/ a b c d
</pre>
<p>Will create the new names:</p>
<pre class="literal-block">
0-c
1-d
2-a
3-b
</pre>
<p><strong>tren</strong> currently supports a variety of sequence renaming tokens.
Note that those associated with the various OS timestamps begin with
the corresponding first letter:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">/+-ADATE:Alphabet:Pattern/</span>&nbsp;&nbsp;&nbsp; Sequence based on atime WITHIN the same date</tt></p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">/+-CDATE:Alphabet:Pattern/</span>&nbsp;&nbsp;&nbsp; Sequence based on ctime WITHIN the same date</tt></p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">/+-MDATE:Alphabet:Pattern/</span>&nbsp;&nbsp;&nbsp; Sequence based on mtime WITHIN the same date</tt></p>
<p>These return sequences <em>within</em> a given day. This enables
renaming constructs like:</p>
<pre class="literal-block">
tren.py -r=/MYEAR//MMON/MDAY/-/+MDATE::001/ *
</pre>
<p>Yielding files named:</p>
<pre class="literal-block">
20100305-001
20100305-002
20100305-003
20100316-001
20100316-002
20100316-003
...
</pre>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">/+-ATIME:Alphabet:Pattern/</span>&nbsp;&nbsp;&nbsp; Sequence based on atime timestamp</tt></p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">/+-CTIME:Alphabet:Pattern/</span>&nbsp;&nbsp;&nbsp; Sequence based on ctime timestamp</tt></p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">/+-MTIME:Alphabet:Pattern/</span>&nbsp;&nbsp;&nbsp; Sequence based on mtime timestamp</tt></p>
<p>These return sequences in absolute timestamp order.  For example:</p>
<pre class="literal-block">
touch foo
touch bar
touch baz
tren.py -r =/+MTIME::/-/FNAME
</pre>
<p>Yields:</p>
<pre class="literal-block">
0-foo
1-bar
2-baz
</pre>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">/+-CMDLINE:Alphabet:Pattern/</span>&nbsp; Sequence based on the order of appearance on the command line</tt></p>
<p>This is nothing more than the command line order:</p>
<pre class="literal-block">
tren.py -r=/+CMDLINE/-/FNAME::01/-/FNAME/ z b a
</pre>
<p>Yields:</p>
<pre class="literal-block">
01-z
02-b
03-a
</pre>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">/+-DEV:Alphabet:Pattern/</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sequence based on the device ID number on which the file- or directory resides</tt></p>
<p>This is the a sequence ordered by which device ID contains the file-
or directory to be renamed.</p>
<p>This is not supported on Windows and defaults to an alphabetic
sequence equivalent to <tt class="docutils literal"><span class="pre">/+-FNAME.../</span></tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">/+-FNAME:Alphabet:Pattern/</span>&nbsp;&nbsp;&nbsp; Sequence based on alphabetic order of all targets on the command line</tt></p>
<p>This returns a sequence based on the alphabetic order of everything
you've named for renaming.  Note that this is done on <em>the fully
qualified path name for each argument</em>, not just the file- or
directory name itself:</p>
<pre class="literal-block">
tren.py -r=/+FNAME::/-/FNAME/ a/z b/b
</pre>
<p>Yields:</p>
<pre class="literal-block">
a/0-z
b/1-b
</pre>
<p>This is because the original file name <tt class="docutils literal">a/z</tt> sorts alphabetically
before <tt class="docutils literal">b/b</tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">/+-GID:Alphabet:Pattern/</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sequence based on the group ID number</tt></p>
<p>This returns a sequence ordered by the ID number of the group to which
the file- or directory belongs.</p>
<p>This is not supported on Windows and defaults to an alphabetic
sequence equivalent to <tt class="docutils literal"><span class="pre">/+-FNAME.../</span></tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">/+-GROUP:Alphabet:Pattern/</span>&nbsp;&nbsp;&nbsp; Sequence based on the group name</tt></p>
<p>This returns a sequence ordered by the name of the group to which the
file- or directory belongs.</p>
<p>This is only supported on Windows if the <tt class="docutils literal">win32all</tt> Python extensions
are installed.  Otherwise, this defaults to an alphabetic sequence equivalent to <tt class="docutils literal"><span class="pre">/+-FNAME.../</span></tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">/+-INODE:Alphabet:Pattern/</span>&nbsp;&nbsp;&nbsp; Sequence based on the inode number</tt></p>
<p>This returns a sequence ordered by the file- or directory inode numbers.</p>
<p>This is not supported on Windows and defaults to an alphabetic
sequence equivalent to <tt class="docutils literal"><span class="pre">/+-FNAME.../</span></tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">/+-MODE:Alphabet:Pattern/</span>&nbsp;&nbsp;&nbsp;&nbsp; Sequence based on permissions</tt></p>
<p>This returns a sequence ordered by the file- or directories permissions
value.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">/+-NLINK:Alphabet:Pattern/</span>&nbsp;&nbsp;&nbsp; Sequence based on the nlink count</tt></p>
<p>This returns a sequence ordered by the number of links associated
with the file- or directory.</p>
<p>This is not supported on Windows and defaults to an alphabetic
sequence equivalent to <tt class="docutils literal"><span class="pre">/+-FNAME.../</span></tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">/+-SIZE:Alphabet:Pattern/</span>&nbsp;&nbsp;&nbsp;&nbsp; Sequence based on size</tt></p>
<p>This returns a sequence ordered by the size of each file- or
directory.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">/+-UID</span> :Alphabet:Pattern/&nbsp;&nbsp;&nbsp;&nbsp; Sequence based on the user ID number</tt></p>
<p>This returns a sequence ordered by the ID number of the user that
owns the file- or directory.</p>
<p>This is not supported on Windows and defaults to an alphabetic
sequence equivalent to <tt class="docutils literal"><span class="pre">/+-FNAME.../</span></tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">/+-USER:Alphabet:Pattern/</span>&nbsp;&nbsp;&nbsp;&nbsp; Sequence based on user name</tt></p>
<p>This returns a sequence ordered by the name of the user that owns
the file- or directory.</p>
<p>This is only supported on Windows if the <tt class="docutils literal">win32all</tt> Python extensions
are installed.  Otherwise, this defaults to an alphabetic sequence equivalent to <tt class="docutils literal"><span class="pre">/+-FNAME.../</span></tt>.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="common-tasks-and-idioms">
<h1><a class="toc-backref" href="#id40">COMMON TASKS AND IDIOMS</a></h1>
<p>With a program as feature dense as <strong>tren</strong>, it's not possible to
document every possible use case.  The following examples cover many
common applications of the program.</p>
<ul>
<li><p class="first">Literal String Replacement</p>
<p>Sometimes, all you want to do is replace a single
substring in a name:</p>
<pre class="literal-block">
tren.py -r Old=New OldHair-OldPeople # Yields: NewHair-OldPeople
</pre>
</li>
<li><p class="first">Replacing Or Removing All Instances Of A String</p>
<p>Sometimes you want to replace every instance of the string:</p>
<pre class="literal-block">
tren.py -i : -r Old=New OldHair-OldPeople # Yields: NewHair-NewPeople
</pre>
</li>
<li><p class="first">Changing A File's &quot;Extension&quot; Suffix</p>
<p>Common where the suffix of a file is significant to an applications
program:</p>
<pre class="literal-block">
tren.py -i -1 -r .jpeg=.jpg *.jpeg
</pre>
</li>
<li><p class="first">Replace Spaces In A File Name With Underbars</p>
<p>Even though spaces are allowed in file names in most OSs, they're
a pain:</p>
<pre class="literal-block">
tren.py -i : -r &quot; &quot;=_ *
</pre>
</li>
<li><p class="first">Appending- Or Prepending Strings To An Existing File Name</p>
<p>Often, you want to keep the existing name, but add to it:</p>
<pre class="literal-block">
tren.py -r =Prefix-/FNAME/
tren.pu -r =/FNAME/-Suffix
</pre>
</li>
<li><p class="first">Ordering File Names By Last Modification Time</p>
<p>It's nice to be able to see files in the order they
were last modified.  Usually, we preserve the old name
when doing this:</p>
<pre class="literal-block">
tren.py -r =/+MTIME::001/-/FNAME/
</pre>
</li>
<li><p class="first">Ordering File Names By Modification Time Within Date</p>
<p>Sometimes, what we want is the order of modification
<em>within</em> the date it was changed:</p>
<pre class="literal-block">
tren.py -r =/MYEAR/-/MMON/-/MDAY/-/+MDATE::001/-/FNAME/ *
</pre>
</li>
<li><p class="first">Ordering File Names By Size</p>
<p>This is handy if we want a directory listing to list the files in
size order:</p>
<pre class="literal-block">
tren.py -r =/SIZE/-/FNAME/ *
</pre>
</li>
<li><p class="first">Undoing A Previous Renaming</p>
<p>In complex renamings, sometimes the only way to get back to your
original names is to examine the renaming log.  But in some cases
it's pretty automatic:</p>
<pre class="literal-block">
tren.py -r ='/$LOGNAME/'-/FNAME/ *
</pre>
<p>This can be undone by:</p>
<pre class="literal-block">
tren.py -r '/$LOGNAME/'-= *
</pre>
<p>Generally, if you can isolate the text introduced by the previous
renaming operation, and use it as the <tt class="docutils literal">old</tt> string in another
renaming request, this will work.</p>
</li>
</ul>
</div>
<div class="section" id="odds-and-ends">
<h1><a class="toc-backref" href="#id41">ODDS AND ENDS</a></h1>
<ul>
<li><p class="first">Quoting your command line arguments properly for the shell you use
is critical.  Things like spaces, <tt class="docutils literal">\</tt>, and <tt class="docutils literal">-</tt> have to be
properly quoted or either the shell or <strong>tren</strong> itself are going to
complain.  Similarly, when using the <tt class="docutils literal">/$ENV/</tt> and <tt class="docutils literal">/`cmd`/</tt>
renaming tokens, make sure to enclose them in single quotes if
you're using a standard Unix shell like <tt class="docutils literal">bash</tt>.</p>
</li>
<li><p class="first">Whitespace is almost always significant <em>within</em> a <strong>tren</strong> option.
You'll need to put proper quoting around it to perserve if for
<strong>tren</strong> to see, whether in a renaming request, an alphabet
definition, or some part of a sequence renaming token.</p>
</li>
<li><p class="first">Quoting can also be tricky in include files.  Remember that the
contents of the include file are presented to <strong>tren</strong> as if they
had been entered on the command line.  For example, to replace
spaces in a filename with underscores, we have to quote the space
to preserve it as an argument to be passed to <strong>tren</strong>:</p>
<pre class="literal-block">
# nospace: 'tren' include to get rid of spaces in filenames
-i: -r' '=_  -r_-_=-  -i0
</pre>
</li>
<li><p class="first">Watch out for situations where an include file changes default or
desired behavior.  In the example above,  the <tt class="docutils literal"><span class="pre">-i:</span></tt> is used to
force replacement of <em>all</em> instances of spaces.  The <tt class="docutils literal"><span class="pre">-i0</span></tt> at
the end of the include resets <strong>tren</strong> to the default behavior
of only replacing the first instance of a matching old string.
That's fine if the include statement appears on the command line
in a place where the default behavior was in force.  But look
what happens in a situation like this:</p>
<pre class="literal-block">
tren.py -i3 -rx=y -Inospace -ra=b ....
</pre>
<p>Prior to the include file being read, <strong>tren</strong> has been told to
replace the 4th instance of a matching string.  After the
<tt class="docutils literal">nospace</tt> include file has been read, this gets reset to replace
the 1st instance of a matching old string.  Make sure that's what
you want for the <tt class="docutils literal"><span class="pre">-ra=b</span></tt> renaming request.</p>
</li>
<li><p class="first">Most shells don't care if you leave a space between an option
and its argument. It's a really good idea to do so as a matter
of habit, especially when dealing with a complex command line
driven tool like <strong>tren</strong>.</p>
</li>
<li><p class="first"><strong>tren</strong> will attempt to do any requested renaming.  However, if you
manage to embed some character in the new name that the operating
system doesn't like, the renaming will fail and you'll be notified
of the fact.  Notwithstanding the fact that you can do all manner of
clever things with <strong>tren</strong>, some restraint is called for when
constructing new file- or directory names.</p>
</li>
<li><p class="first"><strong>tren</strong> will prevent you from trying to rename something to a null
string or a name too long for the operating system.  Mostly this is
not an issue <em>unless</em> you managed to concoct a renaming request that
ends up requiring recursive backups.  In that case, the backup
suffix can be tacked onto the file name enough times that the file
name becomes too long for the OS to catch.  While <strong>tren</strong> can, and
does catch this, <strong>it cannot unwind what it has done thus far and
you CAN LOSE FILES THIS WAY!!!</strong>.  The smart move here is to use
test mode and make sure your proposed renaming isn't going to
require deeply recursive backups.</p>
</li>
<li><p class="first">Save the output from your <strong>tren</strong> runs in logs.  That way, if you
have to unwind a renaming gone bad, you'll have a record of what was
done.</p>
</li>
<li><p class="first">The use of <tt class="docutils literal"><span class="pre">-bf</span></tt> is <strong>STRONGLY DISCOURAGED</strong> and is provided only
for the most sophisticated and careful users.</p>
</li>
</ul>
</div>
<div class="section" id="bugs-misfeatures-other">
<h1><a class="toc-backref" href="#id42">BUGS, MISFEATURES, OTHER</a></h1>
<p>You must be running Python 2.6.x or later.  <strong>tren</strong> makes use of
features not supported in releases prior to this.  <strong>tren</strong> has not
been tested with Python 3.x and is presumed not to work with it
until/unless otherwise demonstrated.</p>
<p>As a general matter, <strong>tren</strong> should run on any POSIX-compliant OS
that has this version (or later) of Python on it.  It will also run on
many Microsoft Windows systems.  If the Windows system has the
<tt class="docutils literal">win32all</tt> Python extensions installed, <strong>tren</strong> will take advantage
of them for purposes of deriving the names of the user and group that
own the file or directory being renamed.</p>
<p>This program is <strong>EXPERIMENTAL</strong> (see the license).  This means its
had some testing but is certainly not guaranteed to be perfect.  As of
this writing, it has been run on FreeBSD, Linux, Windows XP, and Mac
OS X.  It has not, however, been run on 64-bit versions of those OSs.</p>
<p>If you have experience, positive or negative, using <strong>tren</strong> on other
OS/bitsize systems, please contact us at the email address below.</p>
</div>
<div class="section" id="how-come-there-s-no-gui">
<h1><a class="toc-backref" href="#id43">HOW COME THERE'S NO GUI?</a></h1>
<p><strong>tren</strong> is primarily intented for use by power users, sys admins, and
advanced users that (mostly) find GUIs more of a nuisance than a help.
There are times, however when it would be handy to be able to select
the files to be renamed graphically.  TundraWare has a freely
available macro programmed file browser.  It will work nicely in such
applications:</p>
<blockquote>
<a class="reference external" href="http://www.tundraware.com/Software/twander/">http://www.tundraware.com/Software/twander/</a></blockquote>
</div>
<div class="section" id="copyright-and-licensing">
<h1><a class="toc-backref" href="#id44">COPYRIGHT AND LICENSING</a></h1>
<p><strong>tren</strong> is Copyright (c) 2010 TundraWare Inc.</p>
<p>For terms of use, see the <tt class="docutils literal"><span class="pre">tren-license.txt</span></tt> file in the
program distribution.  If you install <strong>tren</strong> on a FreeBSD
system using the 'ports' mechanism, you will also find this file in
<tt class="docutils literal">/usr/local/share/doc/tren</tt>.</p>
</div>
<div class="section" id="author">
<h1><a class="toc-backref" href="#id45">AUTHOR</a></h1>
<pre class="literal-block">
Tim Daneliuk
tren&#64;tundraware.com
</pre>
</div>
<div class="section" id="document-revision-information">
<h1><a class="toc-backref" href="#id46">DOCUMENT REVISION INFORMATION</a></h1>
<pre class="literal-block">
$Id: tren.rst,v 1.200 2010/11/17 19:52:56 tundra Exp $
</pre>
<p>You can find the latest version of this program at:</p>
<blockquote>
<a class="reference external" href="http://www.tundraware.com/Software/tren">http://www.tundraware.com/Software/tren</a></blockquote>
<p>This document was produced using reStructuredText:</p>
<blockquote>
<a class="reference external" href="http://docutils.sourceforge.net/rst.html">http://docutils.sourceforge.net/rst.html</a></blockquote>
</div>
</div>
</body>
</html>
