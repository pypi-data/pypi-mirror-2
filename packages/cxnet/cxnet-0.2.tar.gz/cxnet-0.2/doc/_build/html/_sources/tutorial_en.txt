=====================================================================
CXNet Tutorial
=====================================================================

`Magyarul (In Hungarian) <tutorial_hu.html>`_


This tutorial describes only the ``cxnet`` modul. There is also a ``network_evolution``
modul described in the section Network Evolution.

You can import the ``cxnet`` module as::

  import cxnet

It imports `IGraph <http://igraph.sourceforge.net>`_ module or if it can not do
the `NetworkX <http://networkx.lanl.gov/>`_ module.

Without one of these modules one can have a very limited functions.

CXNet
=========================================

If you use CXNet with igraph you will have a class :class:`CXNet`.
:class:`CXNet` is a class based on :class:`igraph.Graph`, so you can use all of the methods the base class has.
The network (graph) generation is the same as described in the
`python-igraph tutorial <http://www.cs.rhul.ac.uk/home/tamas/development/igraph/tutorial/tutorial.html#creating-a-graph-from-scratch>`_.

Here is an example::

  >>> import cxnet

  >>> net=cxnet.CXNet()

  >>> net.add_vertices(8)
  <cxnet.debnetworki.CXNet object at 0x8a3972c>

  >>> net.add_edges([(1,2), (2,4), (3,5)])
  <cxnet.debnetworki.CXNet object at 0x8a3972c>

  >>> net=igraph.Graph.Full(9)

  >>> net.delete_edges([(3,4), (6,7), (0,1)])
  <cxnet.debnetworki.CXNet object at 0x8a3972c>

  >>> cxnet.summary(g)
  9 nodes, 33 edges, undirected

  Number of components: 1
  Diameter: 2
  Density: 0.9167
  Average path length: 1.0833

  >>> cxnet.plot(net, layout="circular")
  <igraph.drawing.Plot object at 0x911556c>

But there are some special methods of CXNet.
These are usually starting with ``cx`` so with
the ``ipython`` shell we can find it easier.
These methods are usually useful with graphs,
which has vertex attribute ``name`` including
the package dependency network.


Creating deb package dependency network
=========================================

deb packages are originally developed for the Debian
distribution of GNU/Linux, but there are more distributions
using it, eg. the Ubuntu variants.

On Linux distributions using deb packages
you can create the dependency network of the deb packages
and get its main properties this way::

    >>> dn = cxnet.debnetwork()
    Getting package names and dependencies.
    Removing edges, which target is not in self.vertices.
    Transforming to numbered graph.
    Transforming to igraph.
    >>> cxnet.summary(dn)
    28212 nodes, 130173 edges, directed

    Number of components: 27668
    Diameter: 15
    Density: 0.0002
    Reciprocity: 0.0037
    Average path length: 3.6433

You can find packages wich name includins a string with the
:func:`cxfind` method::

    >>> dn.cxfind("firefox")
    ['firefox', 'firefox-2', 'firefox-2-dbg', 'firefox-2-dev',
    'firefox-2-dom-inspector', 'firefox-2-gnome-support', 'firefox-2-libthai',
    'firefox-3.0', 'firefox-3.0-dev', 'firefox-3.0-gnome-support',
    'firefox-3.5', 'firefox-3.5-branding', 'firefox-3.5-dbg',
    'firefox-3.5-dev', 'firefox-3.5-gnome-support', 'firefox-branding',
    'firefox-dbg', 'firefox-dev', 'firefox-gnome-support',
    'firefox-gnome-support-dbg', 'firefox-launchpad-plugin', 'firefox-notify',
    'firefox-ubuntu-it-menu', 'firefox-webdeveloper',
    'kubuntu-firefox-installer']

You can find the neighbors with the :func:`cxneighbors` method. It returns a pair of lists.
The first list includes the packages depending on the packages (the edges pointing to the package),
the second list includes the packages the given package depends on::

    >>> inn, outn = dn.cxneighbors("firefox")
    >>> inn
    ['firefox-dbg', 'pytrainer', 'wysihtml-el', 'gecko-mediaplayer',
    'firefox-gnome-support', 'abrowser', 'abrowser-branding', 'tiemu',
    'mozilla-gtk-vnc', 'xul-ext-firegpg', 'firefox-dev',
    'firefox-2-dom-inspector', 'webhttrack', 'mozvoikko', 'firefox-3.5',
    'gcu-plugin', 'mozilla-virt-viewer', 'mediatomb',
    'deejayd-webui-extension', 'kmozillahelper', 'firefox-branding',
    'mozilla-openthesaurus-de', 'firefox-2', 'firefox-launchpad-plugin',
    'firefox-2-libthai', 'gosa-desktop', 'firefox-3.0']
    >>> outn
    ['libxt6', 'libc6', 'libatk1.0-0', 'libx11-6', 'libglib2.0-0', 'libgcc1',
    'libcairo2', 'libfreetype6', 'libfontconfig1', 'zlib1g', 'libgtk2.0-0',
    'libstdc++6', 'debianutils', 'libstartup-notification0', 'libxext6',
    'libdbus-1-3', 'libpango1.0-0', 'psmisc', 'libdbus-glib-1-2',
    'libxrender1', 'libasound2', 'libnspr4-0d', 'fontconfig', 'libnss3-1d',
    'lsb-release', 'firefox-branding']

(You can not use ``in`` as variable name, it is a reserved word in Python.)

We can plot the neigborhood of the given package with the :func:`cxneighborhood` method::

    >>> dn.cxneighborhood("firefox", plot=True)
    <igraph.VertexSeq object at 0x94f6f7c>

You can store the dependency network with the function :func:`cxwrite`::

    >>> dn.cxwrite()
    See file(s) ubuntu-10.04-packages-2010-08-19.*
    'ubuntu-10.04-packages-2010-08-19'

We got two files with extensions ``.gml`` and ``.txt``.
The gml file can be read with cxnet, as described in the section `Getting network data`_.
The txt file contains information about the distribution and the used repositories.
 
You can get the vertices with the largest degrees (indegrees, outdegrees) with the :func:`cxlargest_degrees`:

>>> ld = dn.cxlargest_degrees()
 13037 libc6               
  3705 libgcc1             
  3654 libstdc++6          
  2770 perl                
  2563 libglib2.0-0        
  2072 python              
  (...)
>>> ldout = dn.cxlargest_degrees("in")
   124 ichthux-desktop     
   105 ubuntu-netbook      
   104 ubuntustudio-desktop
   102 texlive-full        
   100 ubuntu-desktop      
   (...)


DegreeDistribution class
=========================

You can create the degree distribution of a network with the :class:`DegreeDistribution` class::

    >>> dd=cxnet.DegreeDistribution(dn)

With this class you can use  an :class:`igraph.Graph` object,
a :class:`networkx.Graph` object or a degree list as first parameter. 

If you need indegree distribution or outdegree distribution instead, you need the direction argument::

    >>> ddin =cxnet.DegreeDistribution(dn, direction="in")
    >>> ddout=cxnet.DegreeDistribution(dn, direction="out")

If you expect the network is a scale-free one, you can get its exponent and its
standard deviation like this::

    >>> gamma, sigma = dd.exponent()
    >>> gamma, sigma
    (2.3182668687237862, 0.013005694686864753)

For details see the documentation of the :func:`exponent`.

You can plot this distribution if pylab (matplotlib) is installed::

    >>> dd.set_binning("log")
    >>> dd.loglog(); dd.plot_powerlaw()
    [<matplotlib.lines.Line2D object at 0xa66404c>]
    [<matplotlib.lines.Line2D object at 0xa46516c>]

:func:`loglog` plots the distribution with log scales on each axes. You can use :func:`plot`
(linear on each axes) or :func:`semilogy` (logaritmic on y axis) as well.
:func:`plot_powerlaw` plots a powerlaw distribution with the exponent calculated
by the :func:`exponent` method.

.. figure:: img/degree_distribution.png
    :scale: 70%

    The plot we get

Getting network data
=========================

If you have Web connection, you can download data of complex networkx::

    >>> cxnet.get_netdata()
    You need to choose an archive name.
    Archives are:
    - newman
    - deb_files
    >>> cxnet.get_netdata("newman")
    netdata_zip/karate.zip
    ['karate.gml', 'karate.txt']
    (...)

This will

* create two directories into the actual directory: ``netdata_zip`` and ``netdata``,
* download the zip files of netdata into the ``netdata_zip`` directory,
* unzip the zip files creating an gml file and a txt file from each archive.

The `gml <http://www.yworks.com/products/yfiles/doc/developers-guide/gml.html>`_ files can be read with ``cxnet`` or IGraph::

    >>> net =  cxnet.CXNet.Read("netdata/karate.gml")
    or
    >>> net = igraph.Graph.Read("netdata/karate.gml")

