<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pymta Documentation &mdash; pymta v0.5.1 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.5.1',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="pymta v0.5.1 documentation" href="#" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="#">pymta v0.5.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="pymta-documentation">
<h1>pymta Documentation<a class="headerlink" href="#pymta-documentation" title="Permalink to this headline">¶</a></h1>
<p>pymta is a library to build a custom SMTP server in Python. This is useful if
you want to...</p>
<ul class="simple">
<li>test mail-sending code against a real SMTP server even in your unit tests.</li>
<li>build a custom SMTP server with non-standard behavior without reimplementing
the whole SMTP protocol.</li>
<li>have a low-volume SMTP server which can be easily extended using Python.</li>
</ul>
<ul class="simple">
</ul>
<div class="section" id="goals-of-pymta">
<h2>Goals of pymta<a class="headerlink" href="#goals-of-pymta" title="Permalink to this headline">¶</a></h2>
<p>The main goal of pymta is to provide a basic SMTP server for unit tests. It must
be easy to inject custom behavior (policy checks) for every SMTP command.
Furthermore the library should come with an extensive set of tests to ensure that
does the right thing(tm).</p>
<p>Eventually I plan to build a highly customizable SMTP server which can be easily
hacked (just for the fun of it).</p>
</div>
<div class="section" id="development-status">
<h2>Development Status<a class="headerlink" href="#development-status" title="Permalink to this headline">¶</a></h2>
<p>Currently (06/2009, version 0.4) the library only implements basic SMTP with
very few extensions (e.g. PLAIN authentication). However, as far as I know, it
is the only MTA written in Python that implements a process-based strategy for
connection handling which is an advantage because many libraries - including
most Python DB API implementations - can not be used in an asynchronous
environment and you can use your CPUs to their fullest extent. And last but not
least pymta comes with many unit tests and good, comprehensive documentation.</p>
<p>&#8216;Advanced&#8217; features which are necessary for any decent MTA like TLS and
pipelining are not yet implemented. Currently pymta is used only in the unit
tests for <a class="reference external" href="http://www.python-turbomail.org">TurboMail</a>. Therefore it should
be considered as beta software.</p>
</div>
<div class="section" id="related-projects">
<h2>Related Projects<a class="headerlink" href="#related-projects" title="Permalink to this headline">¶</a></h2>
<p>There are some other SMTP server implementations in Python available which you
may want to use if you need a proven implementation right now:</p>
<ul class="simple">
<li><a class="reference external" href="http://docs.python.org/library/smtpd.html">Python&#8217;s smtpd</a></li>
<li><a class="reference external" href="http://twistedmatrix.com/trac/wiki/TwistedMail">Twisted Mail</a></li>
<li><a class="reference external" href="http://tmda.svn.sourceforge.net/viewvc/tmda/trunk/tmda/bin/tmda-ofmipd?revision=2194&amp;view=markup">tmda-ofmipd</a></li>
<li><a class="reference external" href="http://www.zedshaw.com/projects/sos/">Son Of Sam Email Server</a></li>
<li><a class="reference external" href="http://www.hare.demon.co.uk/pysmtp.html">smtps.py</a></li>
</ul>
<p>Python&#8217;s <strong>smtpd</strong> is a module which is included in the standard distribution of
Python for a long time. Though it implements only a <em>very</em> basic feature set
this module is used as a basis for many smaller SMTP server implementations.
In the beginning I used this module for my unit tests too but quite soon I had
to  realize that the code is old and messy and it is nearly impossible to
implement a custom behavior (e.g. reject certain recipients). pymta evolved out
of smtpd after multiple refactorings based on the idea to use a simple finite
state machine (initially repoze.workflow, now including a custom one).</p>
<p><strong>Twisted Mail</strong> is probably the most featureful SMTP server implementation
in Python available right now. It uses the twisted framework which can be
either a huge advantage or disadvantage, depending on your point of view. It can
use TLS via OpenSSL (using the Twisted infrastructure). When I started out with
the naïve idea of just extending Python&#8217;s smtpd a bit, I dismissed Twisted Mail
because it seemed to be quite hard to implement some custom behavior without
writing too much code.</p>
<p><strong>tmda-ofmipd</strong> is another implementation which is based on Python&#8217;s smtpd. It is
distributed only as part of a larger Python application which makes it harder
to use if you just need a plain Python SMTP server. Furthermore the code was not
cleaned up so it may be a bit hard to understand but it supports TLS (using
<a class="reference external" href="http://sourceforge.net/projects/tlslite/">tlslite</a>).</p>
<p><strong>Son Of Sam Email Server</strong> implements an SMTP server (based Python&#8217;s smtpd too)
but focuses on delivery and user info lookup. There are no changes to Python&#8217;s
smtpd so the server does not support any kind of recipient verification.</p>
<p><strong>smtps.py</strong> is a really simple, single-threaded SMTP server rewritten from
scratch with a quite clean design (compared to Python&#8217;s smtpd) although it only
implements the absolute minimum of SMTP and many things like the command parsing
are just hard-coded. On the other hand, the server&#8217;s behavior can be changed by
implementing a custom strategy class. <a class="reference external" href="http://trac.edgewall.org/browser/trunk/trac/tests/notification.py">Trac included an extended version</a>
of smtps in its test suite.</p>
</div>
<div class="section" id="installation-and-setup">
<h2>Installation and Setup<a class="headerlink" href="#installation-and-setup" title="Permalink to this headline">¶</a></h2>
<p>pymta is just a Python library which uses setuptools so it does not require
a special setup. To serve multiple connections in parallel, pymta uses the
<a class="reference external" href="http://docs.python.org/library/multiprocessing.html">multiprocessing</a> module
which was added to the standard library in Python 2.6 (there are backports for
Python 2.4 and 2.5). Furthermore you need to install
<a class="reference external" href="http://www.schwarz.eu/opensource/projects/pycerberus">pycerberus</a>.</p>
<p>pymta supports Python 2.3-2.6. With Python 2.3 you can only serve one
connection at a time due to the lack of a multiprocessing module.</p>
<div class="section" id="id1">
<h3>multiprocessing<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="http://docs.python.org/library/multiprocessing.html">multiprocessing</a>
module hides most the operating system differences when it comes to multiple
processes. The module is included in Python 2.6 but it is available standalone
via pypi:</p>
<div class="highlight-python"><pre>easy_install multiprocessing</pre>
</div>
<p>If multiprocessing is not installed, pymta will fall back to single-threaded
execution automatically (therefore multiprocessing is no hard requirement in the
egg file).</p>
</div>
</div>
</div>
<div class="section" id="architectural-overview">
<h1>Architectural Overview<a class="headerlink" href="#architectural-overview" title="Permalink to this headline">¶</a></h1>
<p>pytma uses multiple processes to handle more than one connection at the same
time. In order to do this in a platform-independent manner, it utilizes the
multiprocessing module.</p>
<p>The basic SMTP program flow is determined by two state machines: One for
the SMTP command parsing mode (single-line commands or data) in the
SMTPCommandParser and another much bigger state machine in the SMTPSession to
control the correct order of commands sent by the SMTP client.</p>
<p>The main idea of pymta was to make it easy adding custom behavior which is
considered configuration for &#8216;real&#8217; SMTP servers like <a class="reference external" href="http://www.exim.org">Exim</a>.
The &#8216;pymta.api&#8217; module contains classes which define interfaces for
customizations. These interfaces are part of the public API so I try to keep
them stable in future releases. Use IMTAPolicy to add restrictions on certain
SMTP commands (check recipient addresses, scan the message&#8217;s content for spam before
accepting it) and IAuthenticator to authenticate SMTP clients (check username
and password). With an IMessageDeliverer you can specify what to do with
received messages.</p>
<div class="section" id="problems-with-asynchronous-architectures">
<h2>Problems with asynchronous architectures<a class="headerlink" href="#problems-with-asynchronous-architectures" title="Permalink to this headline">¶</a></h2>
<p>The two most important SMTP implementations in Python (smtpd and Twisted Mail)
both use an asynchronous architecture so they can serve multiple connections at
the same time without the need to start multiple processes or threads. Because
of this they can avoid the increased overall complexity due to locking issues
and can save some resources (creating a process may be costly).</p>
<p>However there are some drawbacks with the asynchronous approach:</p>
<ul class="simple">
<li>SMTP servers are not necessarily I/O bound. Some operations like spam scanning
or other message checks may eat quite a lot of CPU. With Python you need to
use multiple processes if you really want to utilize multiple CPUs due to the
<a class="reference external" href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock">Global Interpreter Lock</a>.</li>
<li>All libraries must be able to deal with the asynchronous pattern otherwise you
risk to block all connections at the same time. Many programmers are not
familiar with this pattern so most libraries do not support this. This is
especially true for most of Python&#8217;s DB api implementations which is why
<a class="reference external" href="http://twistedmatrix.com/projects/core/documentation/howto/rdbms.html">Twisted implemented its own asynchronous DB layer</a>.
Unfortunately by using this layer you have to use plain SQL, because the most
popular ORMs like <a class="reference external" href="http://www.sqlalchemy.org/">SQLAlchemy</a> do not support
their layer.</li>
</ul>
<p>Given these conditions IMHO it looks like a bad design choice to use an
asynchronous architecture for a SMTP server library which should be easily
hackable to handle even uncommon cases.</p>
</div>
</div>
<div class="section" id="components">
<h1>Components<a class="headerlink" href="#components" title="Permalink to this headline">¶</a></h1>
<p>pymta consists of several main components (classes) which may be important to
know.</p>
<div class="section" id="pythonmta">
<h2>PythonMTA<a class="headerlink" href="#pythonmta" title="Permalink to this headline">¶</a></h2>
<p>The PythonMTA is the main server component which listens on a certain port for
new connections. There should be only one instance of this object. When a new
connection is received, the PythonMTA spawns WorkerProcess (if you have the
multiprocessing module installed) which triggers a SMTPCommand parser that
handles all the SMTP communitcation. When a message was submitted successfully,
the new_message_accepted() method of your IMessageDeliverer will be called so it
is in charge of actually doing something with the message.</p>
<p>You can instantiate a new server like that:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pymta</span> <span class="kn">import</span> <span class="n">PythonMTA</span><span class="p">,</span> <span class="n">BlackholeDeliverer</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c"># SMTP server will listen on localhost/port 8025</span>
    <span class="n">server</span> <span class="o">=</span> <span class="n">PythonMTA</span><span class="p">(</span><span class="s">&#39;localhost&#39;</span><span class="p">,</span> <span class="mi">8025</span><span class="p">,</span> <span class="n">BlackholeDeliverer</span><span class="p">())</span>
    <span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>Interface</strong></p>
<dl class="class">
<dt id="pymta.PythonMTA">
<em class="property">class </em><tt class="descclassname">pymta.</tt><tt class="descname">PythonMTA</tt><big>(</big><em>local_address</em>, <em>bind_port</em>, <em>deliverer_class</em>, <em>policy_class=None</em>, <em>authenticator_class=None</em><big>)</big><a class="headerlink" href="#pymta.PythonMTA" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new MTA which listens for new connections afterwards.
local_address is a string containing either the IP oder the DNS 
host name of the interface on which PythonMTA should listen. 
deliverer_class, policy_class and authenticator_class are callables which 
can be used to add custom behavior. Please note that they must be picklable
if you use forked worker processes (default).
Every new connection gets their own instance of policy_class and 
authenticator_class so these classes don&#8217;t have to be thread-safe. If 
you omit the policy, all syntactically valid SMTP commands are 
accepted. If there is no authenticator specified, authentication will 
not be available.</p>
<dl class="method">
<dt id="pymta.PythonMTA.shutdown_server">
<tt class="descname">shutdown_server</tt><big>(</big><em>timeout_seconds=None</em><big>)</big><a class="headerlink" href="#pymta.PythonMTA.shutdown_server" title="Permalink to this definition">¶</a></dt>
<dd>This method notifies the server that it should stop listening for 
new messages and shut down itself. If timeout_seconds was given, the
method will block for this many seconds at most.</dd></dl>

</dd></dl>

</div>
<div class="section" id="policies">
<h2>Policies<a class="headerlink" href="#policies" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pymta.api.IMTAPolicy">
<em class="property">class </em><tt class="descclassname">pymta.api.</tt><tt class="descname">IMTAPolicy</tt><a class="headerlink" href="#pymta.api.IMTAPolicy" title="Permalink to this definition">¶</a></dt>
<dd><p>Policies can change with behavior of an MTA dynamically (e.g. don&#8217;t allow 
relaying unless the client is located within the trusted company network,
enable authentication only for some connections). In established MTAs like
Exim and Postfix it&#8217;s a very important task for every system administrator 
to configure the message acceptance policies which are normally part of the
configuration file.</p>
<p>A policy does not change the SMTP implementation itself (the state machine) 
but can send out custom replies to the client. A policy doesn&#8217;t have to care 
if the commands were given in the correct order (the state machines will 
take care of that). The only thing is that the message object passed into 
many policy methods does not contain all data at certain stages (e.g. 
accept_mail_from can not access the recipients list because that was not 
submitted yet).</p>
<p>&#8216;IMTAPolicy&#8217; provides a very permissive policy (all commands are 
accepted) from which you can derive custom policies. Its methods are usually
named &#8216;accept_&lt;SMTP command name&gt;&#8217;.</p>
<p>Every method in the &#8216;IMTAPolicy&#8217; interface can return either a single
boolean value (True/False) or a tuple. A boolean value specifies if the
command should be accepted. The caller is responsible for sending the actual
default replies.</p>
<p>Alternatively a policy can choose to return a tuple to have more control 
over the reply sent to the client: (decision, (reply code, reply message)). 
The decision is the boolean known from the last paragraph. The reply code 
is an integer which should a be a valid SMTP code. reply message is either a 
basestring with a custom message or an iterable of basestrings (in case a 
a multi-line reply is sent).</p>
<p>Last but not least a PolicyDecision can be returned which embodies the 
decision as well as (optionally) a custom reply. The reply has the same 
format as described in the paragraph before. The PolicyDecision can ask the
server to close the connection unconditionally after or even before sending
the response to the client (in the latter case no response will be sent).</p>
<dl class="method">
<dt id="pymta.api.IMTAPolicy.accept_auth_plain">
<tt class="descname">accept_auth_plain</tt><big>(</big><em>username</em>, <em>password</em>, <em>message</em><big>)</big><a class="headerlink" href="#pymta.api.IMTAPolicy.accept_auth_plain" title="Permalink to this definition">¶</a></dt>
<dd><p>Decides if AUTH plain should be allowed for this client. Please note 
that username and password are not verified before, the authenticator 
will check them after the policy allowed this command.</p>
<p>The method must not return a response by itself in case it accepts the
AUTH PLAIN command!</p>
</dd></dl>

<dl class="method">
<dt id="pymta.api.IMTAPolicy.accept_data">
<tt class="descname">accept_data</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#pymta.api.IMTAPolicy.accept_data" title="Permalink to this definition">¶</a></dt>
<dd>Decides if we allow the client to start a message transfer (the 
actual message contents will be transferred after this method allowed 
it).</dd></dl>

<dl class="method">
<dt id="pymta.api.IMTAPolicy.accept_ehlo">
<tt class="descname">accept_ehlo</tt><big>(</big><em>ehlo_string</em>, <em>message</em><big>)</big><a class="headerlink" href="#pymta.api.IMTAPolicy.accept_ehlo" title="Permalink to this definition">¶</a></dt>
<dd>Decides if the EHLO command with the given helo_name should be 
accepted.</dd></dl>

<dl class="method">
<dt id="pymta.api.IMTAPolicy.accept_from">
<tt class="descname">accept_from</tt><big>(</big><em>sender</em>, <em>message</em><big>)</big><a class="headerlink" href="#pymta.api.IMTAPolicy.accept_from" title="Permalink to this definition">¶</a></dt>
<dd>Decides if the sender of this message (MAIL FROM) should be accepted.</dd></dl>

<dl class="method">
<dt id="pymta.api.IMTAPolicy.accept_helo">
<tt class="descname">accept_helo</tt><big>(</big><em>helo_string</em>, <em>message</em><big>)</big><a class="headerlink" href="#pymta.api.IMTAPolicy.accept_helo" title="Permalink to this definition">¶</a></dt>
<dd>Decides if the HELO command with the given helo_name should be 
accepted.</dd></dl>

<dl class="method">
<dt id="pymta.api.IMTAPolicy.accept_msgdata">
<tt class="descname">accept_msgdata</tt><big>(</big><em>msgdata</em>, <em>message</em><big>)</big><a class="headerlink" href="#pymta.api.IMTAPolicy.accept_msgdata" title="Permalink to this definition">¶</a></dt>
<dd>This method actually matches no real SMTP command. It is called 
after a message was transferred completely and this is the last check 
before the SMTP server takes the responsibility of transferring it to 
the recipients.</dd></dl>

<dl class="method">
<dt id="pymta.api.IMTAPolicy.accept_new_connection">
<tt class="descname">accept_new_connection</tt><big>(</big><em>peer</em><big>)</big><a class="headerlink" href="#pymta.api.IMTAPolicy.accept_new_connection" title="Permalink to this definition">¶</a></dt>
<dd>This method is called directly after a new connection is received. 
The  policy can decide if the given peer is allowed to connect to the 
SMTP server. If it declines, the connection will be closed 
immediately.</dd></dl>

<dl class="method">
<dt id="pymta.api.IMTAPolicy.accept_rcpt_to">
<tt class="descname">accept_rcpt_to</tt><big>(</big><em>new_recipient</em>, <em>message</em><big>)</big><a class="headerlink" href="#pymta.api.IMTAPolicy.accept_rcpt_to" title="Permalink to this definition">¶</a></dt>
<dd>Decides if recipient of this message (RCPT TO) should be accepted. 
If a message should be delivered to multiple recipients this method is 
called for every recipient.</dd></dl>

<dl class="method">
<dt id="pymta.api.IMTAPolicy.ehlo_lines">
<tt class="descname">ehlo_lines</tt><big>(</big><em>peer</em><big>)</big><a class="headerlink" href="#pymta.api.IMTAPolicy.ehlo_lines" title="Permalink to this definition">¶</a></dt>
<dd>Return an iterable for SMTP extensions to advertise after EHLO.
By default support for SMTP SIZE extension will be announced if you set
a max message size.</dd></dl>

<dl class="method">
<dt id="pymta.api.IMTAPolicy.max_message_size">
<tt class="descname">max_message_size</tt><big>(</big><em>peer</em><big>)</big><a class="headerlink" href="#pymta.api.IMTAPolicy.max_message_size" title="Permalink to this definition">¶</a></dt>
<dd>Return the maximum size (in bytes) for messages from this peer. When
this method returns an integer, there pymta will check the actual 
message size after the message was received (before the accept_msgdata
method is called) and will respond with the appropriate error message if
necessary.
If you return None, no size limit will be enforced by pymta (however you
can always reject a message using accept_msgdata().</dd></dl>

</dd></dl>

<p>Here is a short example how you can implement a custom behavior that checks the
HELO command given by the client:</p>
<div class="highlight-python"><pre>def accept_helo(self, helo_string, message):
    # pymta will return the default error message for the given command if
    # you just return False
    return False

    # This will send out a '553 Bad helo string' and the command is
    # rejected. pymta won't send any additional reply because you did that
    # already.
    return (False, (553, 'Bad helo string'))

    # This is basically the same as above but now it will trigger a
    # multi-line SMTP response:
    # 553-Bad helo string
    # 553 Evil IP
    return (False, (553, ('Bad helo string', 'Evil IP'))</pre>
</div>
</div>
<div class="section" id="authenticators">
<h2>Authenticators<a class="headerlink" href="#authenticators" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pymta.api.IAuthenticator">
<em class="property">class </em><tt class="descclassname">pymta.api.</tt><tt class="descname">IAuthenticator</tt><a class="headerlink" href="#pymta.api.IAuthenticator" title="Permalink to this definition">¶</a></dt>
<dd><p>Authenticators check if the user’s credentials are actually correct. This
may involve some checking against external subsystems (e.g. a database or a
LDAP directory).</p>
<dl class="method">
<dt id="pymta.api.IAuthenticator.authenticate">
<tt class="descname">authenticate</tt><big>(</big><em>username</em>, <em>password</em>, <em>peer</em><big>)</big><a class="headerlink" href="#pymta.api.IAuthenticator.authenticate" title="Permalink to this definition">¶</a></dt>
<dd>This method is called after the client issued an AUTH PLAIN command 
and must return a boolean value (True/False).</dd></dl>

</dd></dl>

</div>
<div class="section" id="deliverers">
<h2>Deliverers<a class="headerlink" href="#deliverers" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pymta.api.IMessageDeliverer">
<em class="property">class </em><tt class="descclassname">pymta.api.</tt><tt class="descname">IMessageDeliverer</tt><a class="headerlink" href="#pymta.api.IMessageDeliverer" title="Permalink to this definition">¶</a></dt>
<dd><p>Deliverers take care of the message routing/delivery after a message was
accepted (e.g. put it in a mailbox file, forward it to another server, ...).</p>
<dl class="method">
<dt id="pymta.api.IMessageDeliverer.new_message_accepted">
<tt class="descname">new_message_accepted</tt><big>(</big><em>msg</em><big>)</big><a class="headerlink" href="#pymta.api.IMessageDeliverer.new_message_accepted" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a new message was accepted by the server.
Now the MTA is then in charge of delivering the message to the 
specified recipients. Please note that you can not reject the message 
anymore at this stage (if there are problems you must generate a 
non-delivery report aka bounce).</p>
<p>There will be one deliverer instance per client connection so
this method may does not have to be thread-safe. However this method 
may get called multiple times when the client transmits more than one
message for the same connection.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="message">
<h2>Message<a class="headerlink" href="#message" title="Permalink to this headline">¶</a></h2>
<p>The Message is a data object contains all information about a message sent by
a client. This includes not only the actual RFC822 message contents but also
information about the SMTP envelope, the peer and the helo string used. The
information is filled as the client sends some commands so not all information
may be available at any time (e.g. the msg_data not available before the client
actually sent the RFC822 message).</p>
</div>
<div class="section" id="peer">
<h2>Peer<a class="headerlink" href="#peer" title="Permalink to this headline">¶</a></h2>
<p>The Peer is another data object which contains the remote host ip address and
the remote port.</p>
</div>
<div class="section" id="smtpsession">
<h2>SMTPSession<a class="headerlink" href="#smtpsession" title="Permalink to this headline">¶</a></h2>
<p>This class actually implements the most complicated part of the SMTP state
machine and is responsible for calling the policy. If you want to extend the
functionality or need to implement some custom behavior which is beyond what you
can do using Policies, check this class.</p>
<p>The SMTP state machine is quite strict currently but I consider this a feature
and not something I&#8217;ll try to improve in the near future.</p>
</div>
<div class="section" id="unit-test-utility-classes">
<h2>Unit Test Utility Classes<a class="headerlink" href="#unit-test-utility-classes" title="Permalink to this headline">¶</a></h2>
<p>pymta was created to ease testing SMTP communication without the need to set up
an external SMTP server. While writing tests for other applications I created
some utility classes which are probably helpful in your tests as well...</p>
<dl class="class">
<dt id="pymta.test_util.BlackholeDeliverer">
<em class="property">class </em><tt class="descclassname">pymta.test_util.</tt><tt class="descname">BlackholeDeliverer</tt><a class="headerlink" href="#pymta.test_util.BlackholeDeliverer" title="Permalink to this definition">¶</a></dt>
<dd>BlackholeDeliverer just stores all received messages in memory in the 
class attribute &#8216;received_messages&#8217; (which implements a Queue-like 
interface) so that you can examine the received messages later.</dd></dl>

<dl class="class">
<dt id="pymta.test_util.DebuggingMTA">
<em class="property">class </em><tt class="descclassname">pymta.test_util.</tt><tt class="descname">DebuggingMTA</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pymta.test_util.DebuggingMTA" title="Permalink to this definition">¶</a></dt>
<dd>DebuggingMTA is a very simple implementation of PythonMTA which just 
collects all incoming messages so that you can examine then afterwards.</dd></dl>

<dl class="class">
<dt id="pymta.test_util.MTAThread">
<em class="property">class </em><tt class="descclassname">pymta.test_util.</tt><tt class="descname">MTAThread</tt><big>(</big><em>server</em><big>)</big><a class="headerlink" href="#pymta.test_util.MTAThread" title="Permalink to this definition">¶</a></dt>
<dd><p>This class runs a PythonMTA in a separate thread which is helpful for 
unit testing.</p>
<p>Attention: Do not use this class together with multiprocessing! 
<a class="reference external" href="http://www.viraj.org/b2evolution/blogs/index.php/2007/02/10/threads_and_fork_a_bad_idea">http://www.viraj.org/b2evolution/blogs/index.php/2007/02/10/threads_and_fork_a_bad_idea</a></p>
<dl class="method">
<dt id="pymta.test_util.MTAThread.run">
<tt class="descname">run</tt><big>(</big><big>)</big><a class="headerlink" href="#pymta.test_util.MTAThread.run" title="Permalink to this definition">¶</a></dt>
<dd>Create a new thread which runs the server until stop() is called.</dd></dl>

<dl class="method">
<dt id="pymta.test_util.MTAThread.stop">
<tt class="descname">stop</tt><big>(</big><em>timeout_seconds=5.0</em><big>)</big><a class="headerlink" href="#pymta.test_util.MTAThread.stop" title="Permalink to this definition">¶</a></dt>
<dd>Stop the mail sink and shut down this thread. timeout_seconds
specifies how long the caller should wait for the mailsink server to
close down (default: 5 seconds). If the server did not stop in time, a
warning message is printed.</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymta.test_util.SMTPTestCase">
<em class="property">class </em><tt class="descclassname">pymta.test_util.</tt><tt class="descname">SMTPTestCase</tt><big>(</big><em>methodName='runTest'</em><big>)</big><a class="headerlink" href="#pymta.test_util.SMTPTestCase" title="Permalink to this definition">¶</a></dt>
<dd><p>The SMTPTestCase is a unittest.TestCase and provides you with a running
MTA listening on &#8216;localhost:[8000-40000]&#8217; which you can use in your 
tests. No messages will be delivered to the outside world because the MTA
configured by default uses the BlackholeDeliverer.</p>
<p>Please make sure that you call the super method for setUp and tearDown.</p>
<dl class="method">
<dt id="pymta.test_util.SMTPTestCase.build_mta">
<tt class="descname">build_mta</tt><big>(</big><em>hostname</em>, <em>listen_port</em>, <em>deliverer</em>, <em>policy_class=None</em><big>)</big><a class="headerlink" href="#pymta.test_util.SMTPTestCase.build_mta" title="Permalink to this definition">¶</a></dt>
<dd>Return a PythonMTA instance which is configured according to your
needs.</dd></dl>

<dl class="method">
<dt id="pymta.test_util.SMTPTestCase.get_received_messages">
<tt class="descname">get_received_messages</tt><big>(</big><big>)</big><a class="headerlink" href="#pymta.test_util.SMTPTestCase.get_received_messages" title="Permalink to this definition">¶</a></dt>
<dd>Return a list of received messages which are stored in the 
BlackholeDeliverer.</dd></dl>

<dl class="method">
<dt id="pymta.test_util.SMTPTestCase.init_mta">
<tt class="descname">init_mta</tt><big>(</big><em>policy_class=&lt;class 'pymta.api.IMTAPolicy'&gt;</em><big>)</big><a class="headerlink" href="#pymta.test_util.SMTPTestCase.init_mta" title="Permalink to this definition">¶</a></dt>
<dd>Starts the MTA in a separate thread with a BlackholeDeliver. This
method also ensures that the MTA is really listening on the specified
port.</dd></dl>

<dl class="method">
<dt id="pymta.test_util.SMTPTestCase.tearDown">
<tt class="descname">tearDown</tt><big>(</big><big>)</big><a class="headerlink" href="#pymta.test_util.SMTPTestCase.tearDown" title="Permalink to this definition">¶</a></dt>
<dd>Stops the MTA thread.</dd></dl>

</dd></dl>

</div>
<div class="section" id="example-smtp-server-application">
<h2>Example SMTP server application<a class="headerlink" href="#example-smtp-server-application" title="Permalink to this headline">¶</a></h2>
<p>In the examples directory you find a pymta-based implementation of a debugging
server that behaves like <a class="reference external" href="http://docs.python.org/library/smtpd.html#debuggingserver-objects">Python&#8217;s DebuggingServer</a>:
All received messages will be printed to STDOUT. Hopefully it can serve as a
short reference how to write very simple pymta-based servers too.</p>
</div>
<div class="section" id="speed">
<h2>Speed<a class="headerlink" href="#speed" title="Permalink to this headline">¶</a></h2>
<p>If you want to use pymta for a real SMTP server, you should not be concerned too
much about speed. If you go really for a high-volume setup with several million
messages per day and hundreds of simultaneous connections, you should tune one
of the well-known SMTP servers like Exim, Postfix or sendmail to get the maximum
performance. However, I measured theoretical peak performance using
<a class="reference external" href="http://doc.coker.com.au/projects/postal/">Postal 0.70</a> to give you some
theoretical figures.</p>
<p>Environment and benchmark settings:</p>
<blockquote>
<ul class="simple">
<li>System: Fedora 10 with an AMD x2 4200 (2.2 GHz), Python 2.5</li>
<li>pymta: version 0.3, DebuggingServer with NullDeliverer and no policy.</li>
<li>postal: 4 threads, no SSL connections, one message per connection (defaults)</li>
</ul>
</blockquote>
<p>With that configuration I got something between 1540-2270 messages per minute
(median 1879 messages) which is actually quite low. Many real SMTP servers would
deliver something between 5,000-10,000 messages per minute in a comparable
setting <a class="footnote-reference" href="#id4" id="id3">[1]</a>. During my measurements the system load was barely noticable (below
5%) so I guess most of the time is lost waiting for locks. Using a really fast
IPC mechanism or a custom PythonMTA implementation that uses the os.fork would
probably increase the throughput by quite easily.</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>However, as soon you add some more complicated database queries or spam
and virus checks to that, the real throughput will decrease dramatically
(even if the scanning takes only 0.1 seconds per message you won&#8217;t
exceed 600 messages per minute). In real setups the bare SMTP speed does
not matter that much.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="license-overview">
<h2>License Overview<a class="headerlink" href="#license-overview" title="Permalink to this headline">¶</a></h2>
<p>pymta itself is licensed under the very liberal <a class="reference external" href="http://creativecommons.org/licenses/MIT/">MIT license</a>
(see COPYING.txt in the source archive) so there are virtually no restrictions
where you can integrate the code.</p>
<p>However, pymta depends on some (few) other packages which come with different
licenses. In order to ease license auditing, I&#8217;ll list the other licenses here
(no guarantees though, check yourself before you trust):</p>
<ul class="simple">
<li><a class="reference external" href="http://www.python.org">Python</a> uses the
<a class="reference external" href="http://www.python.org/download/releases/2.4.2/license/">Python Software Foundation License 2</a>
which is a BSD-style license.</li>
<li>The <a class="reference external" href="http://docs.python.org/library/multiprocessing.html">multiprocessing</a>
uses a <a class="reference external" href="http://creativecommons.org/licenses/BSD/">3-clause BSD license</a>.</li>
<li><a class="reference external" href="http://www.schwarz.eu/opensource/projects/pycerberus">pycerberus</a> uses
the MIT license, just like pymta.</li>
</ul>
<p>I believe that all licenses are GPL compatible and do not require you to publish
your code if you don&#8217;t like to.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="#">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="#">pymta Documentation</a><ul>
<li><a class="reference external" href="#goals-of-pymta">Goals of pymta</a></li>
<li><a class="reference external" href="#development-status">Development Status</a></li>
<li><a class="reference external" href="#related-projects">Related Projects</a></li>
<li><a class="reference external" href="#installation-and-setup">Installation and Setup</a><ul>
<li><a class="reference external" href="#id1">multiprocessing</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference external" href="#architectural-overview">Architectural Overview</a><ul>
<li><a class="reference external" href="#problems-with-asynchronous-architectures">Problems with asynchronous architectures</a></li>
</ul>
</li>
<li><a class="reference external" href="#components">Components</a><ul>
<li><a class="reference external" href="#pythonmta">PythonMTA</a></li>
<li><a class="reference external" href="#policies">Policies</a></li>
<li><a class="reference external" href="#authenticators">Authenticators</a></li>
<li><a class="reference external" href="#deliverers">Deliverers</a></li>
<li><a class="reference external" href="#message">Message</a></li>
<li><a class="reference external" href="#peer">Peer</a></li>
<li><a class="reference external" href="#smtpsession">SMTPSession</a></li>
<li><a class="reference external" href="#unit-test-utility-classes">Unit Test Utility Classes</a></li>
<li><a class="reference external" href="#example-smtp-server-application">Example SMTP server application</a></li>
<li><a class="reference external" href="#speed">Speed</a></li>
<li><a class="reference external" href="#license-overview">License Overview</a></li>
</ul>
</li>
</ul>

            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="_sources/index.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li><a href="#">pymta v0.5.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2008-2010 Felix Schwarz.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.6.
    </div>
  </body>
</html>