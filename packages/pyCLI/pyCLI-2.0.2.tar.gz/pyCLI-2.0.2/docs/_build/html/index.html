

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>cli — command line tools &mdash; pyCLI v2.0.1 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '2.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="pyCLI v2.0.1 documentation" href="#" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">pyCLI v2.0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-cli">
<span id="cli-command-line-tools"></span><h1><a class="reference internal" href="#module-cli" title="cli"><tt class="xref py py-mod docutils literal"><span class="pre">cli</span></tt></a> &#8212; command line tools<a class="headerlink" href="#module-cli" title="Permalink to this headline">¶</a></h1>
<p>The cli package is a framework for making simple, correct command
line applications in Python. With cli, you can quickly add standard
<a class="reference external" href="http://www.python.org/dev/peps/pep-0389/#deprecation-of-optparse">command line parsing</a>; <a class="reference external" href="http://docs.python.org/library/logging.html">logging</a>; <a class="reference external" href="http://docs.python.org/library/unittest.html">unit</a> and <a class="reference external" href="http://pythonpaste.org/scripttest/">functional</a> testing;
and <a class="reference external" href="http://docs.python.org/library/profile.html">profiling</a> to your CLI apps. To make it easier to do the right 
thing, cli wraps all of these tools into a single, consistent application 
interface.</p>
<div class="section" id="installing-cli">
<h2>Installing <a class="reference internal" href="#module-cli" title="cli"><tt class="xref py py-mod docutils literal"><span class="pre">cli</span></tt></a><a class="headerlink" href="#installing-cli" title="Permalink to this headline">¶</a></h2>
<p>You can install the latest stable version of <a class="reference internal" href="#module-cli" title="cli"><tt class="xref py py-mod docutils literal"><span class="pre">cli</span></tt></a> using <strong class="command">pip</strong>:</p>
<div class="highlight-none"><div class="highlight"><pre>$ pip install pyCLI
</pre></div>
</div>
<p>Public repositories for the project are hosted at <a class="reference external" href="http://github.com/wcmaier/cli">github</a> and <a class="reference external" href="http://bitbucket.org/wcmaier/cli">bitbucket</a>, so
you can use either <a class="reference external" href="http://git-scm.com/">git</a> or <a class="reference external" href="http://mercurial.selenic.com/">Mercurial</a> to get a copy of the project&#8217;s code
and history:</p>
<div class="highlight-none"><div class="highlight"><pre>$ hg clone http://bitbucket.org/wcmaier/cli
$ git clone git://github.com/wcmaier/cli.git
</pre></div>
</div>
<p>If you notice a problem with <a class="reference internal" href="#module-cli" title="cli"><tt class="xref py py-mod docutils literal"><span class="pre">cli</span></tt></a>, please report it using the github
<a class="reference external" href="http://github.com/wcmaier/cli/issues">issue tracker</a> (or, if you have a fix, send a <a class="reference external" href="http://github.com/wcmaier/cli/pull/new/master">pull request</a>).</p>
<div class="section" id="a-note-about-versions">
<h3>A note about versions<a class="headerlink" href="#a-note-about-versions" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#module-cli" title="cli"><tt class="xref py py-mod docutils literal"><span class="pre">cli</span></tt></a> is developed along two branches. The first, &#8216;default&#8217; (or &#8216;master&#8217; in
git) contains new features and possible bugs &#8211; this branch is the active
development branch. The second, &#8216;stable&#8217;, contains releases both major and minor
as well as bugfixes. If you&#8217;d like to help improve <a class="reference internal" href="#module-cli" title="cli"><tt class="xref py py-mod docutils literal"><span class="pre">cli</span></tt></a>, take a look at
default/master. Otherwise, stick with stable.</p>
</div>
</div>
<div class="section" id="a-quick-tour-of-cli-s-features">
<h2>A quick tour of <a class="reference internal" href="#module-cli" title="cli"><tt class="xref py py-mod docutils literal"><span class="pre">cli</span></tt></a>&#8216;s features<a class="headerlink" href="#a-quick-tour-of-cli-s-features" title="Permalink to this headline">¶</a></h2>
<p>Command line parsing:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>
<span class="kn">import</span> <span class="nn">cli.app</span>

<span class="nd">@cli.app.CommandLineApp</span>
<span class="k">def</span> <span class="nf">ls</span><span class="p">(</span><span class="n">app</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">ls</span><span class="o">.</span><span class="n">add_param</span><span class="p">(</span><span class="s">&quot;-l&quot;</span><span class="p">,</span> <span class="s">&quot;--long&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">&quot;list in long format&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&quot;store_true&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">ls</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>When run, this script produces the following output:</p>
<div class="highlight-none"><div class="highlight"><pre>$ python ls.py -h
usage: ls [-h] [-l]

optional arguments:
  -h, --help  show this help message and exit
  -l, --long  list in long format
</pre></div>
</div>
<p>Logging:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">cli.log</span>

<span class="nd">@cli.log.LoggingApp</span>
<span class="k">def</span> <span class="nf">sleep</span><span class="p">(</span><span class="n">app</span><span class="p">):</span>
    <span class="n">app</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;About to sleep for </span><span class="si">%d</span><span class="s"> seconds&quot;</span> <span class="o">%</span> <span class="n">app</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">seconds</span><span class="p">)</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">seconds</span><span class="p">)</span>

<span class="n">sleep</span><span class="o">.</span><span class="n">add_param</span><span class="p">(</span><span class="s">&quot;seconds&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">&quot;time to sleep&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">sleep</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>Which produces the following:</p>
<div class="highlight-none"><div class="highlight"><pre>$ python sleep.py -h
usage: sleep [-h] [-l LOGFILE] [-q] [-s] [-v] seconds

positional arguments:
  seconds               time to sleep

optional arguments:
  -h, --help            show this help message and exit
  -l LOGFILE, --logfile LOGFILE
                        log to file (default: log to stdout)
  -q, --quiet           decrease the verbosity
  -s, --silent          only log warnings
  -v, --verbose         raise the verbosity
$ python sleep.py -vv 3
About to sleep for 3 seconds
</pre></div>
</div>
<p>Daemonizing:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>
<span class="kn">import</span> <span class="nn">cli.daemon</span>

<span class="nd">@cli.daemon.DaemonizingApp</span>
<span class="k">def</span> <span class="nf">daemon</span><span class="p">(</span><span class="n">app</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">app</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">daemonize</span><span class="p">:</span>
        <span class="n">app</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;About to daemonize&quot;</span><span class="p">)</span>
        <span class="n">app</span><span class="o">.</span><span class="n">daemonize</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">daemon</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>And on the command line:</p>
<div class="highlight-none"><div class="highlight"><pre>$ python daemon.py -h
usage: daemon [-h] [-l LOGFILE] [-q] [-s] [-v] [-d] [-u USER] [-p PIDFILE]

optional arguments:
  -h, --help            show this help message and exit
  -l LOGFILE, --logfile LOGFILE
                        log to file (default: log to stdout)
  -q, --quiet           decrease the verbosity
  -s, --silent          only log warnings
  -v, --verbose         raise the verbosity
  -d, --daemonize       run the application in the background
  -u USER, --user USER  change to USER[:GROUP] after daemonizing
  -p PIDFILE, --pidfile PIDFILE
                        write PID to PIDFILE after daemonizing
$ python daemon.py -d -vv
About to daemonize
</pre></div>
</div>
</div>
<div class="section" id="basic-usage">
<h2>Basic usage<a class="headerlink" href="#basic-usage" title="Permalink to this headline">¶</a></h2>
<p>While the <a class="reference internal" href="#module-cli" title="cli"><tt class="xref py py-mod docutils literal"><span class="pre">cli</span></tt></a> modules provide a simple API for designing your own
applications, the default implementations are intended to be flexible
enough to cover most use cases. No matter which <a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">cli.app.Application</span></tt></a> you
use, the basic pattern is the same: create a callable that does the
work, wrap it in an <a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">cli.app.Application</span></tt></a>, add some parameters and call
its <tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt> method.</p>
<p>Your callable may be a simple function or a more complex class that
implements the <tt class="xref py py-meth docutils literal"><span class="pre">__call__()</span></tt> protocol. Either way, it should accept a
single <a class="reference internal" href="#module-cli.app" title="cli.app"><tt class="xref py py-data docutils literal"><span class="pre">app</span></tt></a> instance as its only argument. It will use this
object to interact with the application framework, find out what
arguments were passed on the command line, log messages, etc.</p>
<p>You can wrap the callable in one of two ways. First,
<a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">cli.app.Application</span></tt></a> can be thought of as a decorator (see <span class="target" id="index-0"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0318"><strong>PEP 318</strong></a>
for more information). For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@cli.app.Application</span>
<span class="k">def</span> <span class="nf">yourapp</span><span class="p">(</span><span class="n">app</span><span class="p">):</span>
    <span class="n">do_stuff</span><span class="p">()</span>
</pre></div>
</div>
<p>If you need to pass keyword arguments to the application, you can still
use the decorator pattern:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@cli.app.CommandLineApp</span><span class="p">(</span><span class="n">argv</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;-v&quot;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">yourapp</span><span class="p">(</span><span class="n">app</span><span class="p">):</span>
    <span class="n">do_stuff</span><span class="p">()</span>
</pre></div>
</div>
<p>If you don&#8217;t like decorators (or your interpreter doesn&#8217;t support them),
you can also simply pass your application callable to the
<a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">cli.app.Application</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">yourapp</span><span class="p">(</span><span class="n">app</span><span class="p">):</span>
    <span class="n">do_stuff</span><span class="p">()</span>

<span class="n">yourapp</span> <span class="o">=</span> <span class="n">cli</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">CommandLineApp</span><span class="p">(</span><span class="n">yourapp</span><span class="p">)</span>
</pre></div>
</div>
<p>Some more complex scripts and applications may benefit from subclassing the
<a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">cli.app.Application</span></tt></a> class itself. This approach can help make your
code more reusable:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">YourApp</span><span class="p">(</span><span class="n">cli</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">CommandLineApp</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">do_stuff</span><span class="p">()</span>
</pre></div>
</div>
<p>When subclassing <a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">cli.app.Application</span></tt></a>, you&#8217;ll likely want to incorporate
functionality from the other application classes (like
<a class="reference internal" href="#cli.app.CommandLineApp" title="cli.app.CommandLineApp"><tt class="xref py py-class docutils literal"><span class="pre">cli.app.CommandLineApp</span></tt></a>). To do this, simply call methods from the
appropriate mixin classes (like <a class="reference internal" href="#cli.app.CommandLineMixin" title="cli.app.CommandLineMixin"><tt class="xref py py-class docutils literal"><span class="pre">cli.app.CommandLineMixin</span></tt></a>) &#8211; in fact,
this is how the application classes themselves work.</p>
<p>Most of the supplied <a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">cli.app.Application</span></tt></a> implementations support
parameters. Parameters determine how your users interact with your
program on the command line. To add parameters to your application, call
<tt class="xref py py-meth docutils literal"><span class="pre">add_param()</span></tt> after you&#8217;ve wrapped your callable (or in its <tt class="xref py py-meth docutils literal"><span class="pre">setup()</span></tt>
method):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">yourapp</span><span class="o">.</span><span class="n">add_param</span><span class="p">(</span><span class="s">&quot;-v&quot;</span><span class="p">,</span> <span class="s">&quot;--verbose&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&quot;count&quot;</span><span class="p">,</span>
    <span class="n">help</span><span class="o">=</span><span class="s">&quot;increase the verbosity&quot;</span><span class="p">,</span> <span class="p">)</span>
</pre></div>
</div>
<p>The interface here is the same as that implemented by
<tt class="xref py py-class docutils literal"><span class="pre">argparse.ArgumentParser</span></tt>. In this case, an <tt class="xref py py-attr docutils literal"><span class="pre">verbose</span></tt>
attribute will be created on the <tt class="xref py py-attr docutils literal"><span class="pre">app.params</span></tt> object with an
integer representing the desired verbosity level.</p>
<p>Once you&#8217;ve added all the parameters you need (if any &#8211; the default
implementations include sensible defaults), simply call the <tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt>
method on the wrapped callable. It&#8217;s best to do this only if your script
is actually being run, so shield it with a conditional:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">yourapp</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>This will allow you to import your application and tweak it
programmatically from another script without actually invoking it.</p>
</div>
<div class="section" id="projects-using-cli">
<h2>Projects using <a class="reference internal" href="#module-cli" title="cli"><tt class="xref py py-mod docutils literal"><span class="pre">cli</span></tt></a><a class="headerlink" href="#projects-using-cli" title="Permalink to this headline">¶</a></h2>
<p>The following projects are known to use <a class="reference internal" href="#module-cli" title="cli"><tt class="xref py py-mod docutils literal"><span class="pre">cli</span></tt></a>; please email
<a class="reference external" href="mailto:willmaier&#37;&#52;&#48;ml1&#46;net">willmaier<span>&#64;</span>ml1<span>&#46;</span>net</a> if you&#8217;d like to see your
project listed here.</p>
<ul class="simple">
<li><a class="reference external" href="http://code.google.com/p/gc3pie/">gc3pie</a> - Python libraries and tools for running applications on diverse
Grids and clusters</li>
</ul>
</div>
<div class="section" id="best-practices">
<h2>Best practices<a class="headerlink" href="#best-practices" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#module-cli" title="cli"><tt class="xref py py-mod docutils literal"><span class="pre">cli</span></tt></a> is designed to encourage a simple set of best practices in
script development. Following this simple guide will help you write
robust, maintainable and user-friendly scripts.</p>
<div class="section" id="use-a-standard-style">
<h3>Use a standard style<a class="headerlink" href="#use-a-standard-style" title="Permalink to this headline">¶</a></h3>
<p>A standard and clear coding style will make it easier for you to read
your scripts months or years after you first wrote them. A good style
will also help other people quickly understand your code so that they
can use it, too and (hopefully) help you improve it.</p>
<p>Since you&#8217;re writing your scripts in Python, it is strongly recommended
that you follow the coding style described in <span class="target" id="index-1"></span><a class="pep reference external" href="http://www.python.org/dev/peps/pep-0008"><strong>PEP 8</strong></a>. This style is
easy to read and will be recognized by most people familiar with Python.</p>
</div>
<div class="section" id="modularize">
<h3>Modularize<a class="headerlink" href="#modularize" title="Permalink to this headline">¶</a></h3>
<p>Monolithic code is hard to read. By breaking your script into functions,
classes and maybe even separate modules, you help the reader (including
your future self) navigate the code. Modular code can also be easily
reused so that you don&#8217;t have to continually reimplement useful
functions in all of your scripts.</p>
<p>When writing or refactoring your code to make it more modular, a good
rule of thumb is to break large functions or methods into chunks that
fit on a single screen (perhaps up to 50 lines of code or so). These
chunks are large enough to get the job done but small enough for your
reader to fully comprehend them.</p>
</div>
<div class="section" id="share-your-code">
<h3>Share your code<a class="headerlink" href="#share-your-code" title="Permalink to this headline">¶</a></h3>
<p>If you&#8217;ve written modular code, you&#8217;ll find it easy to package it for
wider distribution. Sharing your code helps other programmers or system
administrators solve similar problems. Even better, the more users you
have, the more likely you are to receive support or contributions from
your community.</p>
<p>Start with the <a class="reference external" href="http://guide.python-distribute.org/">Hitchhiker&#8217;s Guide to Packaging</a>, which will soon become
part of the official <a class="reference external" href="http://www.python.org/doc/">Python documentation</a>.</p>
</div>
<div class="section" id="test-your-code">
<h3>Test your code<a class="headerlink" href="#test-your-code" title="Permalink to this headline">¶</a></h3>
<p>In most cases, you can make your code more robust by adding tests to
verify specific algorithms or even the macro behavior of the entire
script. For testing small chunks of your code (unit tests), <a class="reference internal" href="#module-cli" title="cli"><tt class="xref py py-mod docutils literal"><span class="pre">cli</span></tt></a>
provides <a class="reference internal" href="#cli.test.AppTest" title="cli.test.AppTest"><tt class="xref py py-class docutils literal"><span class="pre">cli.test.AppTest</span></tt></a>, a <tt class="xref py py-class docutils literal"><span class="pre">unittest.TestCase</span></tt>
with a few customizations to make it more useful for testing
command line applications. To test larger behavior (functional
tests), use <a class="reference internal" href="#cli.test.FunctionalTest" title="cli.test.FunctionalTest"><tt class="xref py py-class docutils literal"><span class="pre">cli.test.FunctionalTest</span></tt></a>. <a class="reference internal" href="#module-cli" title="cli"><tt class="xref py py-mod docutils literal"><span class="pre">cli</span></tt></a> itself
uses both of these classes for its own tests; for examples, see the
<tt class="file docutils literal"><span class="pre">tests/functional/</span></tt> directory shipped with the <a class="reference internal" href="#module-cli" title="cli"><tt class="xref py py-mod docutils literal"><span class="pre">cli</span></tt></a> package.</p>
<p>When packaging your scripts, use Titus&#8217; <a class="reference external" href="http://github.com/ctb/SomePackage">SomePackage</a> as a guide for
integrating your tests.</p>
</div>
</div>
<div class="section" id="module-cli.app">
<span id="api"></span><h2>API<a class="headerlink" href="#module-cli.app" title="Permalink to this headline">¶</a></h2>
<div class="section" id="cli-app-basic-applications">
<h3><a class="reference internal" href="#module-cli.app" title="cli.app"><tt class="xref py py-mod docutils literal"><span class="pre">cli.app</span></tt></a> &#8211; basic applications<a class="headerlink" href="#cli-app-basic-applications" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="#module-cli.app" title="cli.app"><tt class="xref py py-mod docutils literal"><span class="pre">cli.app</span></tt></a> module establishes the basis for all of the other
applications and is a good place to start when looking to extend
<a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">Application</span></tt></a> functionality or to understand the basic API.</p>
<dl class="class">
<dt id="cli.app.Application">
<em class="property">class </em><tt class="descclassname">cli.app.</tt><tt class="descname">Application</tt><big>(</big><em>main=None</em>, <em>name=None</em>, <em>exit_after_main=True</em>, <em>stdin=None</em>, <em>stdout=None</em>, <em>stderr=None</em>, <em>version=None</em>, <em>description=None</em>, <em>argv=None</em>, <em>profiler=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#cli.app.Application" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>An application.</p>
<p><a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">Application</span></tt></a> constructors should always be called with
keyword arguments, though the <em>main</em> argument may be passed
positionally (as when <a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">Application</span></tt></a> or its subclasses are
instantiated as decorators). Arguments are:</p>
<p><em>main</em> is the callable object that performs the main work of the
application. The callable must accept an <a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">Application</span></tt></a>
instance as its sole argument. If <em>main</em> is <tt class="xref docutils literal"><span class="pre">None</span></tt>, it is assumed that
a valid callable will be passed to the <a class="reference internal" href="#cli.app.Application.__call__" title="cli.app.Application.__call__"><tt class="xref py py-meth docutils literal"><span class="pre">__call__()</span></tt></a> method (when
using an <a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">Application</span></tt></a> instance as a decorator). If <em>main</em> is
not None, the <a class="reference internal" href="#cli.app.Application.setup" title="cli.app.Application.setup"><tt class="xref py py-meth docutils literal"><span class="pre">setup()</span></tt></a> method will be called, allowing
subclasses to customize the order in which certain setup steps are
executed.</p>
<p><em>name</em> is the name of the application itself. If <em>name</em> is not <tt class="xref docutils literal"><span class="pre">None</span></tt>,
the <a class="reference internal" href="#cli.app.Application.name" title="cli.app.Application.name"><tt class="xref py py-attr docutils literal"><span class="pre">name</span></tt></a> property will inspect the <tt class="xref py py-attr docutils literal"><span class="pre">main</span></tt> callable and
use its function or class name.</p>
<p><em>exit_after_main</em> determines whether the application will call
<tt class="xref py py-func docutils literal"><span class="pre">sys.exit()</span></tt> after <tt class="xref py py-attr docutils literal"><span class="pre">main</span></tt> completes.</p>
<p><em>stdin</em>, <em>stderr</em> and <em>stdout</em> are file objects that represent the 
usual application input and outputs. If they are <tt class="xref docutils literal"><span class="pre">None</span></tt>, they will
be replaced with <tt class="xref py py-data docutils literal"><span class="pre">sys.stdin</span></tt>, <tt class="xref py py-data docutils literal"><span class="pre">sys.stderr</span></tt> and
<tt class="xref py py-data docutils literal"><span class="pre">sys.stdout</span></tt>, respectively.</p>
<p><em>version</em> is a string representing the application&#8217;s version.</p>
<p><em>description</em> is a string describing the application. If
<em>description</em> is <tt class="xref docutils literal"><span class="pre">None</span></tt>, the <a class="reference internal" href="#cli.app.Application.description" title="cli.app.Application.description"><tt class="xref py py-attr docutils literal"><span class="pre">description</span></tt></a> property will use
the <tt class="xref py py-attr docutils literal"><span class="pre">main</span></tt> callable&#8217;s <tt class="xref py py-attr docutils literal"><span class="pre">__doc__</span></tt> attribute instead.</p>
<p><em>argv</em> is a list of strings representing the options passed on the
command line. If <em>argv</em> is <tt class="xref docutils literal"><span class="pre">None</span></tt>, <tt class="xref py py-data docutils literal"><span class="pre">sys.argv</span></tt> will be used
instead.</p>
<p><em>profiler</em> is a <a class="reference internal" href="#cli.profiler.Profiler" title="cli.profiler.Profiler"><tt class="xref py py-class docutils literal"><span class="pre">cli.profiler.Profiler</span></tt></a> instance, or <tt class="xref docutils literal"><span class="pre">None</span></tt> (default).
If not <tt class="xref docutils literal"><span class="pre">None</span></tt>, the profiler will be available to the running application.</p>
<p>In all but a very few cases, subclasses that override the constructor
should call <tt class="xref py py-meth docutils literal"><span class="pre">Application.__init__()</span></tt> at the end of the
overridden method to ensure that the <a class="reference internal" href="#cli.app.Application.setup" title="cli.app.Application.setup"><tt class="xref py py-meth docutils literal"><span class="pre">setup()</span></tt></a> method is
called.</p>
<dl class="method">
<dt id="cli.app.Application.__call__">
<tt class="descname">__call__</tt><big>(</big><em>main</em><big>)</big><a class="headerlink" href="#cli.app.Application.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrap the <em>main</em> callable and return an <a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">Application</span></tt></a> instance.</p>
<p>This method is useful when it is necessary to pass keyword
arguments to the <a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">Application</span></tt></a> constructor when
decorating callables. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@cli.Application</span><span class="p">(</span><span class="n">stderr</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">app</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>In this case, <a class="reference internal" href="#cli.app.Application.setup" title="cli.app.Application.setup"><tt class="xref py py-meth docutils literal"><span class="pre">setup()</span></tt></a> will occur during <a class="reference internal" href="#cli.app.Application.__call__" title="cli.app.Application.__call__"><tt class="xref py py-meth docutils literal"><span class="pre">__call__()</span></tt></a>,
not when the <a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">Application</span></tt></a> is first constructed.</p>
</dd></dl>

<dl class="attribute">
<dt id="cli.app.Application.description">
<tt class="descname">description</tt><a class="headerlink" href="#cli.app.Application.description" title="Permalink to this definition">¶</a></dt>
<dd><p>A string describing the application.</p>
<p>Unless specified when the <a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">Application</span></tt></a> was created, this
property will examine the <tt class="xref py py-attr docutils literal"><span class="pre">main</span></tt> callable and use its
docstring (<tt class="xref py py-attr docutils literal"><span class="pre">__doc__</span></tt> attribute).</p>
</dd></dl>

<dl class="attribute">
<dt id="cli.app.Application.name">
<tt class="descname">name</tt><a class="headerlink" href="#cli.app.Application.name" title="Permalink to this definition">¶</a></dt>
<dd><p>A string identifying the application.</p>
<p>Unless specified when the <a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">Application</span></tt></a> was created, this
property will examine the <tt class="xref py py-attr docutils literal"><span class="pre">main</span></tt> callable and use its
name (<tt class="xref py py-attr docutils literal"><span class="pre">__name__</span></tt> or <tt class="xref py py-attr docutils literal"><span class="pre">func_name</span></tt> for classes or
functions, respectively).</p>
</dd></dl>

<dl class="method">
<dt id="cli.app.Application.post_run">
<tt class="descname">post_run</tt><big>(</big><em>returned</em><big>)</big><a class="headerlink" href="#cli.app.Application.post_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean up after the application.</p>
<p>After <tt class="xref py py-attr docutils literal"><span class="pre">main</span></tt> has been called, <a class="reference internal" href="#cli.app.Application.run" title="cli.app.Application.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a> passes the return value
(or <tt class="xref py py-class docutils literal"><span class="pre">Exception</span></tt> instance raised) to this method. By default,
<a class="reference internal" href="#cli.app.Application.post_run" title="cli.app.Application.post_run"><tt class="xref py py-meth docutils literal"><span class="pre">post_run()</span></tt></a> decides whether to call <tt class="xref py py-func docutils literal"><span class="pre">sys.exit()</span></tt> (based on the
value of the <tt class="xref py py-attr docutils literal"><span class="pre">exit_after_main</span></tt> attribute) or pass the value back
to <a class="reference internal" href="#cli.app.Application.run" title="cli.app.Application.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a>. Subclasses should probably preserve this behavior.</p>
</dd></dl>

<dl class="method">
<dt id="cli.app.Application.pre_run">
<tt class="descname">pre_run</tt><big>(</big><big>)</big><a class="headerlink" href="#cli.app.Application.pre_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform any last-minute configuration.</p>
<p>The <a class="reference internal" href="#cli.app.Application.pre_run" title="cli.app.Application.pre_run"><tt class="xref py py-meth docutils literal"><span class="pre">pre_run()</span></tt></a> method is called by the <a class="reference internal" href="#cli.app.Application.run" title="cli.app.Application.run"><tt class="xref py py-meth docutils literal"><span class="pre">run()</span></tt></a> method
before <tt class="xref py py-attr docutils literal"><span class="pre">main</span></tt> is executed. This is a good time to do
things like read a configuration file or parse command line
arguments. The base implementation does nothing.</p>
</dd></dl>

<dl class="method">
<dt id="cli.app.Application.run">
<tt class="descname">run</tt><big>(</big><big>)</big><a class="headerlink" href="#cli.app.Application.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the application, returning its return value.</p>
<p>This method first calls <a class="reference internal" href="#cli.app.Application.pre_run" title="cli.app.Application.pre_run"><tt class="xref py py-meth docutils literal"><span class="pre">pre_run()</span></tt></a> and then calls <tt class="xref py py-attr docutils literal"><span class="pre">main</span></tt>,
passing it an instance of the <a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">Application</span></tt></a> itself as its only
argument. The return value (or <tt class="xref py py-class docutils literal"><span class="pre">Exception</span></tt> instance raised) is
then passed to <a class="reference internal" href="#cli.app.Application.post_run" title="cli.app.Application.post_run"><tt class="xref py py-meth docutils literal"><span class="pre">post_run()</span></tt></a> which may modify it (or terminate the
application entirely).</p>
</dd></dl>

<dl class="method">
<dt id="cli.app.Application.setup">
<tt class="descname">setup</tt><big>(</big><big>)</big><a class="headerlink" href="#cli.app.Application.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure the <a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">Application</span></tt></a>.</p>
<p>This method is provided so that subclasses can easily customize
the configuration process without having to reimplement the base
constructor. <a class="reference internal" href="#cli.app.Application.setup" title="cli.app.Application.setup"><tt class="xref py py-meth docutils literal"><span class="pre">setup()</span></tt></a> is called once, either by the base
constructor or <a class="reference internal" href="#cli.app.Application.__call__" title="cli.app.Application.__call__"><tt class="xref py py-meth docutils literal"><span class="pre">__call__()</span></tt></a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cli.app.CommandLineApp">
<em class="property">class </em><tt class="descclassname">cli.app.</tt><tt class="descname">CommandLineApp</tt><big>(</big><em>main=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#cli.app.CommandLineApp" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cli.app.CommandLineMixin" title="cli.app.CommandLineMixin"><tt class="xref py py-class docutils literal"><span class="pre">cli.app.CommandLineMixin</span></tt></a>, <a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">cli.app.Application</span></tt></a></p>
<p>A command line application.</p>
<p>This class simply glues together the base <a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">Application</span></tt></a> and
<a class="reference internal" href="#cli.app.CommandLineMixin" title="cli.app.CommandLineMixin"><tt class="xref py py-class docutils literal"><span class="pre">CommandLineMixin</span></tt></a>.</p>
<p>Actual functionality moved to <a class="reference internal" href="#cli.app.CommandLineMixin" title="cli.app.CommandLineMixin"><tt class="xref py py-class docutils literal"><span class="pre">CommandLineMixin</span></tt></a>.</p>
</dd></dl>

<dl class="class">
<dt id="cli.app.CommandLineMixin">
<em class="property">class </em><tt class="descclassname">cli.app.</tt><tt class="descname">CommandLineMixin</tt><big>(</big><em>usage=None</em>, <em>epilog=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#cli.app.CommandLineMixin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A command line application.</p>
<p>Command line applications extend the basic <a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">Application</span></tt></a>
framework to support command line parsing using the <tt class="xref py py-mod docutils literal"><span class="pre">argparse</span></tt>
module. As with <a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">Application</span></tt></a> itself, <em>main</em> should be a
callable. Other arguments are:</p>
<p><em>usage</em> is a string describing command line usage of the
application. If it is not supplied, <tt class="xref py py-mod docutils literal"><span class="pre">argparse</span></tt> will
automatically generate a usage statement based on the application&#8217;s
parameters.</p>
<p><em>epilog</em> is text appended to the argument descriptions.</p>
<p>The rest of the arguments are passed to the <a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">Application</span></tt></a>
constructor.</p>
<dl class="method">
<dt id="cli.app.CommandLineMixin.add_param">
<tt class="descname">add_param</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#cli.app.CommandLineMixin.add_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a parameter.</p>
<p><a class="reference internal" href="#cli.app.CommandLineMixin.add_param" title="cli.app.CommandLineMixin.add_param"><tt class="xref py py-meth docutils literal"><span class="pre">add_param()</span></tt></a> wraps
<tt class="xref py py-meth docutils literal"><span class="pre">argparse.ArgumentParser.add_argument()</span></tt>, storing the
parameter options in a dictionary. This information can be used
later by other subclasses when deciding whether to override
parameters.</p>
</dd></dl>

<dl class="attribute">
<dt id="cli.app.CommandLineMixin.argparser_factory">
<tt class="descname">argparser_factory</tt><a class="headerlink" href="#cli.app.CommandLineMixin.argparser_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">ArgumentParser</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="cli.app.CommandLineMixin.formatter">
<tt class="descname">formatter</tt><a class="headerlink" href="#cli.app.CommandLineMixin.formatter" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">HelpFormatter</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="cli.app.CommandLineMixin.params">
<tt class="descname">params</tt><a class="headerlink" href="#cli.app.CommandLineMixin.params" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#cli.app.CommandLineMixin.params" title="cli.app.CommandLineMixin.params"><tt class="xref py py-attr docutils literal"><span class="pre">params</span></tt></a> attribute is an object with attributes
containing the values of the parsed command line arguments.
Specifically, its an instance of <tt class="xref py py-class docutils literal"><span class="pre">argparse.Namespace</span></tt>,
but only the mapping of attributes to argument values should be
relied upon.</p>
</dd></dl>

<dl class="method">
<dt id="cli.app.CommandLineMixin.pre_run">
<tt class="descname">pre_run</tt><big>(</big><big>)</big><a class="headerlink" href="#cli.app.CommandLineMixin.pre_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse command line.</p>
<p>During <a class="reference internal" href="#cli.app.CommandLineMixin.pre_run" title="cli.app.CommandLineMixin.pre_run"><tt class="xref py py-meth docutils literal"><span class="pre">pre_run()</span></tt></a>, <a class="reference internal" href="#cli.app.CommandLineMixin" title="cli.app.CommandLineMixin"><tt class="xref py py-class docutils literal"><span class="pre">CommandLineMixin</span></tt></a>
calls <tt class="xref py py-meth docutils literal"><span class="pre">argparse.ArgumentParser.parse_args()</span></tt>. The results are
stored in <a class="reference internal" href="#cli.app.CommandLineMixin.params" title="cli.app.CommandLineMixin.params"><tt class="xref py py-attr docutils literal"><span class="pre">params</span></tt></a>.</p>
<p>..versionchanged:: 1.1.1</p>
<p>If <tt class="xref py py-meth docutils literal"><span class="pre">argparse.ArgumentParser.parse_args()</span></tt> raises SystemExit but
<tt class="xref py py-attr docutils literal"><span class="pre">exit_after_main</span></tt> is not True, raise Abort instead.</p>
</dd></dl>

<dl class="method">
<dt id="cli.app.CommandLineMixin.setup">
<tt class="descname">setup</tt><big>(</big><big>)</big><a class="headerlink" href="#cli.app.CommandLineMixin.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure the <a class="reference internal" href="#cli.app.CommandLineMixin" title="cli.app.CommandLineMixin"><tt class="xref py py-class docutils literal"><span class="pre">CommandLineMixin</span></tt></a>.</p>
<p>During setup, the application instantiates the
<tt class="xref py py-class docutils literal"><span class="pre">argparse.ArgumentParser</span></tt> and adds a version parameter
(<em class="xref std std-option">-V</em>, to avoid clashing with <em class="xref std std-option">-v</em>
verbose).</p>
</dd></dl>

<dl class="method">
<dt id="cli.app.CommandLineMixin.update_params">
<tt class="descname">update_params</tt><big>(</big><em>params</em>, <em>newparams</em><big>)</big><a class="headerlink" href="#cli.app.CommandLineMixin.update_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Update a parameter namespace.</p>
<p>The <em>params</em> instance will be updated with the names and values
from <em>newparams</em> and then returned.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 1.0.2: </span><a class="reference internal" href="#cli.app.CommandLineMixin.update_params" title="cli.app.CommandLineMixin.update_params"><tt class="xref py py-meth docutils literal"><span class="pre">update_params()</span></tt></a> expects and returns
<tt class="xref py py-class docutils literal"><span class="pre">argparse.Namespace</span></tt> instances; previously, it took
keyword arguments and updated <a class="reference internal" href="#cli.app.CommandLineMixin.params" title="cli.app.CommandLineMixin.params"><tt class="xref py py-attr docutils literal"><span class="pre">params</span></tt></a> itself. This is
now left to the caller.</p>
</dd></dl>

</dd></dl>

</div>
<span class="target" id="module-cli.log"></span><div class="section" id="cli-log-logging-applications">
<h3><a class="reference internal" href="#module-cli.log" title="cli.log"><tt class="xref py py-mod docutils literal"><span class="pre">cli.log</span></tt></a> &#8211; logging applications<a class="headerlink" href="#cli-log-logging-applications" title="Permalink to this headline">¶</a></h3>
<p>Logging applications use the standard library <tt class="xref py py-mod docutils literal"><span class="pre">logging</span></tt> module to
handle log messages.</p>
<dl class="class">
<dt id="cli.log.LoggingApp">
<em class="property">class </em><tt class="descclassname">cli.log.</tt><tt class="descname">LoggingApp</tt><big>(</big><em>main=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#cli.log.LoggingApp" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cli.log.LoggingMixin" title="cli.log.LoggingMixin"><tt class="xref py py-class docutils literal"><span class="pre">cli.log.LoggingMixin</span></tt></a>, <a class="reference internal" href="#cli.app.CommandLineMixin" title="cli.app.CommandLineMixin"><tt class="xref py py-class docutils literal"><span class="pre">cli.app.CommandLineMixin</span></tt></a>, <a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">cli.app.Application</span></tt></a></p>
<p>A logging application.</p>
<p>This class simply glues together the base <tt class="xref py py-class docutils literal"><span class="pre">Application</span></tt>,
<a class="reference internal" href="#cli.log.LoggingMixin" title="cli.log.LoggingMixin"><tt class="xref py py-class docutils literal"><span class="pre">LoggingMixin</span></tt></a> and other mixins that provide necessary functionality.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 1.0.4: </span>Actual functionality moved to <a class="reference internal" href="#cli.log.LoggingMixin" title="cli.log.LoggingMixin"><tt class="xref py py-class docutils literal"><span class="pre">LoggingMixin</span></tt></a>.</p>
</dd></dl>

<dl class="class">
<dt id="cli.log.LoggingMixin">
<em class="property">class </em><tt class="descclassname">cli.log.</tt><tt class="descname">LoggingMixin</tt><big>(</big><em>stream=&lt;open file '&lt;stdout&gt;'</em>, <em>mode 'w' at 0x7df24078&gt;</em>, <em>logfile=None</em>, <em>message_format='%(asctime)s %(message)s'</em>, <em>date_format='%Y-%m-%dT%H:%M:%S'</em>, <em>root=True</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#cli.log.LoggingMixin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A mixin for command-line applications that knows how to log.</p>
<p>The <a class="reference internal" href="#cli.log.LoggingMixin" title="cli.log.LoggingMixin"><tt class="xref py py-class docutils literal"><span class="pre">LoggingMixin</span></tt></a> requires <a class="reference internal" href="#cli.app.CommandLineMixin" title="cli.app.CommandLineMixin"><tt class="xref py py-class docutils literal"><span class="pre">cli.app.CommandLineMixin</span></tt></a>
and allows command line configuration of the application logger. In
addition to those supported by the standard <a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">cli.app.Application</span></tt></a> and
<a class="reference internal" href="#cli.app.CommandLineMixin" title="cli.app.CommandLineMixin"><tt class="xref py py-class docutils literal"><span class="pre">cli.app.CommandLineMixin</span></tt></a>, arguments are:</p>
<p><em>stream</em> is an open file object to which the log messages will be
written. By default, this is standard output (not standard error, as
might be expected).</p>
<p><em>logfile</em> is the name of a file which will be opened by the
<tt class="xref py py-class docutils literal"><span class="pre">logging.FileHandler</span></tt>.</p>
<p><em>message_format</em> and <em>date_format</em> are passed directly to the 
<a class="reference internal" href="#cli.log.CommandLineLogger" title="cli.log.CommandLineLogger"><tt class="xref py py-class docutils literal"><span class="pre">CommandLineLogger</span></tt></a> and are interpreted as in the 
<tt class="xref py py-mod docutils literal"><span class="pre">logging</span></tt> package.</p>
<p>If <em>root</em> is True, the <a class="reference internal" href="#cli.log.LoggingMixin" title="cli.log.LoggingMixin"><tt class="xref py py-class docutils literal"><span class="pre">LoggingMixin</span></tt></a> will make itself the root
logger. This means that, for example, code that knows nothing about
the <a class="reference internal" href="#cli.log.LoggingMixin" title="cli.log.LoggingMixin"><tt class="xref py py-class docutils literal"><span class="pre">LoggingMixin</span></tt></a> can inherit its verbosity level, formatters
and handlers.</p>
<dl class="method">
<dt id="cli.log.LoggingMixin.pre_run">
<tt class="descname">pre_run</tt><big>(</big><big>)</big><a class="headerlink" href="#cli.log.LoggingMixin.pre_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the verbosity level and configure the logger.</p>
<p>The application passes the <tt class="xref py py-attr docutils literal"><span class="pre">params</span></tt> object
to the <a class="reference internal" href="#cli.log.CommandLineLogger" title="cli.log.CommandLineLogger"><tt class="xref py py-class docutils literal"><span class="pre">CommandLineLogger</span></tt></a>&#8216;s special
<a class="reference internal" href="#cli.log.CommandLineLogger.setLevel" title="cli.log.CommandLineLogger.setLevel"><tt class="xref py py-meth docutils literal"><span class="pre">CommandLineLogger.setLevel()</span></tt></a> method to set the logger&#8217;s
verbosity and then initializes the logging handlers. If the
<tt class="xref py py-attr docutils literal"><span class="pre">logfile</span></tt> attribute is not <tt class="xref docutils literal"><span class="pre">None</span></tt>, it is passed to a
<tt class="xref py py-class docutils literal"><span class="pre">logging.FileHandler</span></tt> instance and that is added to the
handler list. Otherwise, if the <tt class="xref py py-attr docutils literal"><span class="pre">stream</span></tt> attribute is
not <tt class="xref docutils literal"><span class="pre">None</span></tt>, it is passed to a <tt class="xref py py-class docutils literal"><span class="pre">logging.StreamHandler</span></tt>
instance and that becomes the main handler.</p>
</dd></dl>

<dl class="method">
<dt id="cli.log.LoggingMixin.setup">
<tt class="descname">setup</tt><big>(</big><big>)</big><a class="headerlink" href="#cli.log.LoggingMixin.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure the <a class="reference internal" href="#cli.log.LoggingMixin" title="cli.log.LoggingMixin"><tt class="xref py py-class docutils literal"><span class="pre">LoggingMixin</span></tt></a>.</p>
<p>This method adds the <em class="xref std std-option">-l</em>, <em class="xref std std-option">q</em>,
<em class="xref std std-option">-s</em> and <em class="xref std std-option">-v</em> parameters to the
application and instantiates the <tt class="xref py py-attr docutils literal"><span class="pre">log</span></tt> attribute.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cli.log.CommandLineLogger">
<em class="property">class </em><tt class="descclassname">cli.log.</tt><tt class="descname">CommandLineLogger</tt><big>(</big><em>name</em>, <em>level=0</em><big>)</big><a class="headerlink" href="#cli.log.CommandLineLogger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">logging.Logger</span></tt></p>
<p>Provide extra configuration smarts for loggers.</p>
<p>In addition to the powers of a regular logger, a
<a class="reference internal" href="#cli.log.CommandLineLogger" title="cli.log.CommandLineLogger"><tt class="xref py py-class docutils literal"><span class="pre">CommandLineLogger</span></tt></a> can set its verbosity levels based on a
populated <tt class="xref py py-class docutils literal"><span class="pre">argparse.Namespace</span></tt>.</p>
<dl class="attribute">
<dt id="cli.log.CommandLineLogger.default_level">
<tt class="descname">default_level</tt><a class="headerlink" href="#cli.log.CommandLineLogger.default_level" title="Permalink to this definition">¶</a></dt>
<dd><p>An integer representing the default logging level.</p>
<p>Default: <tt class="xref py py-data docutils literal"><span class="pre">logging.WARN</span></tt> (only warning messages will be
shown).</p>
</dd></dl>

<dl class="method">
<dt id="cli.log.CommandLineLogger.setLevel">
<tt class="descname">setLevel</tt><big>(</big><em>ns</em><big>)</big><a class="headerlink" href="#cli.log.CommandLineLogger.setLevel" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the logger verbosity level.</p>
<p><em>ns</em> is an object with <tt class="xref py py-attr docutils literal"><span class="pre">verbose</span></tt>, <tt class="xref py py-attr docutils literal"><span class="pre">quiet</span></tt> and
<tt class="xref py py-attr docutils literal"><span class="pre">silent</span></tt> attributes. <tt class="xref py py-attr docutils literal"><span class="pre">verbose</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">quiet</span></tt> may
be positive integers or zero; <tt class="xref py py-attr docutils literal"><span class="pre">silent</span></tt> is <tt class="xref docutils literal"><span class="pre">True</span></tt> or <tt class="xref docutils literal"><span class="pre">False</span></tt>.
If <tt class="xref py py-attr docutils literal"><span class="pre">silent</span></tt> is True, the logger&#8217;s level will be set to
<a class="reference internal" href="#cli.log.CommandLineLogger.silent_level" title="cli.log.CommandLineLogger.silent_level"><tt class="xref py py-attr docutils literal"><span class="pre">silent_level</span></tt></a>. Otherwise, the difference between
<tt class="xref py py-attr docutils literal"><span class="pre">quiet</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">verbose</span></tt> will be multiplied by 10 so it
fits on the standard logging scale and then added to
<a class="reference internal" href="#cli.log.CommandLineLogger.default_level" title="cli.log.CommandLineLogger.default_level"><tt class="xref py py-attr docutils literal"><span class="pre">default_level</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="cli.log.CommandLineLogger.silent_level">
<tt class="descname">silent_level</tt><a class="headerlink" href="#cli.log.CommandLineLogger.silent_level" title="Permalink to this definition">¶</a></dt>
<dd><p>An integer representing the silent logging level.</p>
<p>Default: <tt class="xref py py-data docutils literal"><span class="pre">logging.CRITICAL</span></tt> (only critical messages will
be shown).</p>
</dd></dl>

</dd></dl>

</div>
<span class="target" id="module-cli.daemon"></span><div class="section" id="cli-daemon-daemonizing-applications">
<h3><a class="reference internal" href="#module-cli.daemon" title="cli.daemon"><tt class="xref py py-mod docutils literal"><span class="pre">cli.daemon</span></tt></a> &#8211; daemonizing applications<a class="headerlink" href="#cli-daemon-daemonizing-applications" title="Permalink to this headline">¶</a></h3>
<p>Daemonizing applications run in the background, forking themselves off.</p>
<dl class="class">
<dt id="cli.daemon.DaemonizingApp">
<em class="property">class </em><tt class="descclassname">cli.daemon.</tt><tt class="descname">DaemonizingApp</tt><big>(</big><em>main=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#cli.daemon.DaemonizingApp" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cli.daemon.DaemonizingMixin" title="cli.daemon.DaemonizingMixin"><tt class="xref py py-class docutils literal"><span class="pre">cli.daemon.DaemonizingMixin</span></tt></a>, <a class="reference internal" href="#cli.log.LoggingMixin" title="cli.log.LoggingMixin"><tt class="xref py py-class docutils literal"><span class="pre">cli.log.LoggingMixin</span></tt></a>, <a class="reference internal" href="#cli.app.CommandLineMixin" title="cli.app.CommandLineMixin"><tt class="xref py py-class docutils literal"><span class="pre">cli.app.CommandLineMixin</span></tt></a>, <a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">cli.app.Application</span></tt></a></p>
<p>A daemonizing application.</p>
<p>This class simply glues together the base <tt class="xref py py-class docutils literal"><span class="pre">Application</span></tt>,
<a class="reference internal" href="#cli.daemon.DaemonizingMixin" title="cli.daemon.DaemonizingMixin"><tt class="xref py py-class docutils literal"><span class="pre">DaemonizingMixin</span></tt></a> and other mixins that provide necessary
functionality.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 1.0.4: </span>Actual functionality moved to <a class="reference internal" href="#cli.daemon.DaemonizingMixin" title="cli.daemon.DaemonizingMixin"><tt class="xref py py-class docutils literal"><span class="pre">DaemonizingMixin</span></tt></a>.</p>
</dd></dl>

<dl class="class">
<dt id="cli.daemon.DaemonizingMixin">
<em class="property">class </em><tt class="descclassname">cli.daemon.</tt><tt class="descname">DaemonizingMixin</tt><big>(</big><em>pidfile=None</em>, <em>chdir='/'</em>, <em>null='/dev/null'</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#cli.daemon.DaemonizingMixin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A command-line application that knows how to daemonize.</p>
<p>The <a class="reference internal" href="#cli.daemon.DaemonizingMixin" title="cli.daemon.DaemonizingMixin"><tt class="xref py py-class docutils literal"><span class="pre">DaemonizingMixin</span></tt></a> requires the <a class="reference internal" href="#cli.log.LoggingMixin" title="cli.log.LoggingMixin"><tt class="xref py py-class docutils literal"><span class="pre">cli.log.LoggingMixin</span></tt></a>
(for it&#8217;s not very helpful to daemonize without being able to log
messages somewhere). In addition to those supported by the standard
<a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">cli.app.Application</span></tt></a>, <a class="reference internal" href="#cli.app.CommandLineMixin" title="cli.app.CommandLineMixin"><tt class="xref py py-class docutils literal"><span class="pre">cli.app.CommandLineMixin</span></tt></a> and
<a class="reference internal" href="#cli.log.LoggingMixin" title="cli.log.LoggingMixin"><tt class="xref py py-class docutils literal"><span class="pre">cli.log.LoggingMixin</span></tt></a>, arguments are:</p>
<p><em>pidfile</em> is a string pointing to a file where the application will
write its process ID after it daemonizes. If it is <tt class="xref docutils literal"><span class="pre">None</span></tt>, no such
file will be created.</p>
<p><em>chdir</em> is a string pointing to a directory to which the application
will change after it daemonizes.</p>
<p><em>null</em> is a string representing a file that will be opened to
replace stdin, stdout and stderr when the application daemonizes. By
default, this <tt class="xref py py-data docutils literal"><span class="pre">os.path.devnull</span></tt>.</p>
<dl class="method">
<dt id="cli.daemon.DaemonizingMixin.daemonize">
<tt class="descname">daemonize</tt><big>(</big><big>)</big><a class="headerlink" href="#cli.daemon.DaemonizingMixin.daemonize" title="Permalink to this definition">¶</a></dt>
<dd><p>Run in the background.</p>
<p><a class="reference internal" href="#cli.daemon.DaemonizingMixin.daemonize" title="cli.daemon.DaemonizingMixin.daemonize"><tt class="xref py py-meth docutils literal"><span class="pre">daemonize()</span></tt></a> must be called explicitly by the application
when it&#8217;s ready to fork into the background. It forks, flushes
and replaces stdin, stderr and stdout with the open <tt class="xref py py-attr docutils literal"><span class="pre">null</span></tt>
file and, if requested on the command line, writes its PID to a
file and changes user/group.</p>
</dd></dl>

<dl class="method">
<dt id="cli.daemon.DaemonizingMixin.setup">
<tt class="descname">setup</tt><big>(</big><big>)</big><a class="headerlink" href="#cli.daemon.DaemonizingMixin.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure the <a class="reference internal" href="#cli.daemon.DaemonizingMixin" title="cli.daemon.DaemonizingMixin"><tt class="xref py py-class docutils literal"><span class="pre">DaemonizingMixin</span></tt></a>.</p>
<p>This method adds the <em class="xref std std-option">-d</em>, <em class="xref std std-option">u</em>,
and <em class="xref std std-option">-p</em> parameters to the application.</p>
</dd></dl>

</dd></dl>

</div>
<span class="target" id="module-cli.profiler"></span><div class="section" id="cli-profiler-statistical-and-deterministic-application-profiling">
<h3><a class="reference internal" href="#module-cli.profiler" title="cli.profiler"><tt class="xref py py-mod docutils literal"><span class="pre">cli.profiler</span></tt></a> &#8211; statistical and deterministic application profiling<a class="headerlink" href="#cli-profiler-statistical-and-deterministic-application-profiling" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="#cli.profiler.Profiler" title="cli.profiler.Profiler"><tt class="xref py py-class docutils literal"><span class="pre">Profiler</span></tt></a> can help you quickly measure your application&#8217;s
overall performance or focus on specific sections.</p>
<dl class="class">
<dt id="cli.profiler.Profiler">
<em class="property">class </em><tt class="descclassname">cli.profiler.</tt><tt class="descname">Profiler</tt><big>(</big><em>stdout=None</em>, <em>anonymous=False</em>, <em>count=1000</em>, <em>repeat=3</em><big>)</big><a class="headerlink" href="#cli.profiler.Profiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A profiling tool.</p>
<p>The <a class="reference internal" href="#cli.profiler.Profiler" title="cli.profiler.Profiler"><tt class="xref py py-class docutils literal"><span class="pre">Profiler</span></tt></a> provides two decorator methods which can help
you improve the performance of your code. Arguments are:</p>
<p><em>stdout</em> is a file-like object into which the profiling report will
be written.</p>
<p>If <em>anonymous</em> is True, the profiling decorators will run in-place.
Be careful when combining this option with <em>count</em> greater than 1 if
the block of code in question may have side effects. This is useful
for testing a specific block of code within a larger program; for
example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">profiler</span> <span class="o">=</span> <span class="n">Profiler</span><span class="p">(</span><span class="n">anonymous</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">biglist</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c"># The profiler will measure the code defined in the anonymous</span>
<span class="c"># block function and then proceed with the rest of the script.</span>
<span class="c"># Note that you must take extra precautions to make sure that</span>
<span class="c"># names defined in the anonymous block are valid outside of its</span>
<span class="c"># scope.</span>
<span class="nd">@profiler.deterministic</span>
<span class="k">def</span> <span class="nf">block</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">biglist</span>
    <span class="n">biglist</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">5</span><span class="p">)</span>

<span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">biglist</span><span class="p">)</span>
</pre></div>
</div>
<p><em>count</em> and <em>repeat</em> control the number of iterations the code in
question will be run in the <a class="reference internal" href="#cli.profiler.Profiler.statistical" title="cli.profiler.Profiler.statistical"><tt class="xref py py-meth docutils literal"><span class="pre">statistical()</span></tt></a> profiler.</p>
<dl class="method">
<dt id="cli.profiler.Profiler.deterministic">
<tt class="descname">deterministic</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#cli.profiler.Profiler.deterministic" title="Permalink to this definition">¶</a></dt>
<dd><p>Deterministically evaluate <em>func</em>&#8216;s performance.</p>
<p><em>func</em> should be a callable. It will be decorated with
a simple function that uses the standard library&#8217;s
<tt class="xref py py-class docutils literal"><span class="pre">profile.Profile</span></tt> to trace and time each step of <em>func</em>&#8216;s
execution. After <em>func</em> is profiled, a report will be written
to <tt class="xref py py-attr docutils literal"><span class="pre">stdout</span></tt>. The profiling statistics are saved to the
<tt class="xref py py-attr docutils literal"><span class="pre">stats</span></tt> attribute after the run.</p>
</dd></dl>

<dl class="method">
<dt id="cli.profiler.Profiler.isanon">
<tt class="descname">isanon</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#cli.profiler.Profiler.isanon" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the <em>name</em> seems to be anonymous.</p>
<p>Callables whose names are &#8220;anonymous&#8221; or that start with
&#8220;__profiler_&#8221; are considered anonymous.</p>
</dd></dl>

<dl class="method">
<dt id="cli.profiler.Profiler.statistical">
<tt class="descname">statistical</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#cli.profiler.Profiler.statistical" title="Permalink to this definition">¶</a></dt>
<dd><p>Run <em>func</em> many times, reporting the best run time.</p>
<p>This profiling method wraps <em>func</em> with a decorator that
performs <tt class="xref py py-attr docutils literal"><span class="pre">repeat</span></tt> runs, executing <em>func</em> <tt class="xref py py-attr docutils literal"><span class="pre">count</span></tt>
times each run. The profiler will average the execution time for
each loop and report the best time on <tt class="xref py py-attr docutils literal"><span class="pre">stdout</span></tt>. The result
is saved at <tt class="xref py py-attr docutils literal"><span class="pre">result</span></tt> &#8211; divide this number by
<tt class="xref py py-attr docutils literal"><span class="pre">count</span></tt> to determine the average execution time.</p>
<p>This profiler is useful for comparing the speed of equivalent
implementations of similar algorithms.</p>
</dd></dl>

<dl class="method">
<dt id="cli.profiler.Profiler.wrap">
<tt class="descname">wrap</tt><big>(</big><em>wrapper</em>, <em>wrapped</em><big>)</big><a class="headerlink" href="#cli.profiler.Profiler.wrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrap callable <em>wrapped</em> with <em>wrapper</em>.</p>
<p><a class="reference internal" href="#cli.profiler.Profiler.wrap" title="cli.profiler.Profiler.wrap"><tt class="xref py py-meth docutils literal"><span class="pre">wrap()</span></tt></a> calls <tt class="xref py py-func docutils literal"><span class="pre">functools.update_wrapper()</span></tt> (or an
equivalent implementation if not available) to preserve the
callable&#8217;s metadata. If <tt class="xref py py-attr docutils literal"><span class="pre">anonymous</span></tt> is True or the
<em>wrapped</em> callable&#8217;s name is anonymous (see <a class="reference internal" href="#cli.profiler.Profiler.isanon" title="cli.profiler.Profiler.isanon"><tt class="xref py py-meth docutils literal"><span class="pre">isanon()</span></tt></a>),
the wrapped callable will be executed in-place. Otherwise, the
wrapped callable will simply be returned (like a decorator).</p>
</dd></dl>

</dd></dl>

</div>
<span class="target" id="module-cli.test"></span><div class="section" id="cli-test-functional-and-unit-test-support">
<h3><a class="reference internal" href="#module-cli.test" title="cli.test"><tt class="xref py py-mod docutils literal"><span class="pre">cli.test</span></tt></a> &#8211; functional and unit test support<a class="headerlink" href="#cli-test-functional-and-unit-test-support" title="Permalink to this headline">¶</a></h3>
<p>This module provides support for easily writing both functional and
unit tests for your scripts.</p>
<p class="versionadded">
<span class="versionmodified">New in version 1.0.2.</span></p>
<dl class="class">
<dt id="cli.test.AppTest">
<em class="property">class </em><tt class="descclassname">cli.test.</tt><tt class="descname">AppTest</tt><big>(</big><em>methodName='runTest'</em><big>)</big><a class="headerlink" href="#cli.test.AppTest" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">unittest.TestCase</span></tt></p>
<p>An application test, based on <tt class="xref py py-class docutils literal"><span class="pre">unittest.TestCase</span></tt>.</p>
<p><a class="reference internal" href="#cli.test.AppTest" title="cli.test.AppTest"><tt class="xref py py-class docutils literal"><span class="pre">AppTest</span></tt></a> provides a simple <a class="reference internal" href="#cli.test.AppTest.setUp" title="cli.test.AppTest.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a> method
to instantiate <a class="reference internal" href="#cli.test.AppTest.app_cls" title="cli.test.AppTest.app_cls"><tt class="xref py py-attr docutils literal"><span class="pre">app_cls</span></tt></a>, your application&#8217;s class.
<a class="reference internal" href="#cli.test.AppTest.default_kwargs" title="cli.test.AppTest.default_kwargs"><tt class="xref py py-attr docutils literal"><span class="pre">default_kwargs</span></tt></a> will be passed to the new application then.</p>
<p class="deprecated">
<span class="versionmodified">Deprecated since version 1.1.1: </span>Use <tt class="xref py py-class docutils literal"><span class="pre">AppMixin</span></tt> instead.</p>
<dl class="attribute">
<dt id="cli.test.AppTest.app_cls">
<tt class="descname">app_cls</tt><a class="headerlink" href="#cli.test.AppTest.app_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>An application, usually descended from <a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">cli.app.Application</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="cli.test.AppTest.default_kwargs">
<tt class="descname">default_kwargs</tt><a class="headerlink" href="#cli.test.AppTest.default_kwargs" title="Permalink to this definition">¶</a></dt>
<dd><p>Default keyword arguments that will be passed to the new <a class="reference internal" href="#cli.app.Application" title="cli.app.Application"><tt class="xref py py-class docutils literal"><span class="pre">cli.app.Application</span></tt></a> instance.</p>
<p>By default, the application won&#8217;t see any command line arguments and
will not raise SystemExit when the <tt class="xref py py-func docutils literal"><span class="pre">main()</span></tt> function returns.</p>
</dd></dl>

<dl class="method">
<dt id="cli.test.AppTest.setUp">
<tt class="descname">setUp</tt><big>(</big><big>)</big><a class="headerlink" href="#cli.test.AppTest.setUp" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up the application.</p>
<p><a class="reference internal" href="#cli.test.AppTest.setUp" title="cli.test.AppTest.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a> instantiates <a class="reference internal" href="#cli.test.AppTest.app_cls" title="cli.test.AppTest.app_cls"><tt class="xref py py-attr docutils literal"><span class="pre">app_cls</span></tt></a> and
stores it at <tt class="xref py py-attr docutils literal"><span class="pre">app</span></tt>. Test methods should call
the application&#8217;s <a class="reference internal" href="#cli.app.Application.setup" title="cli.app.Application.setup"><tt class="xref py py-meth docutils literal"><span class="pre">cli.app.Application.setup()</span></tt></a>,
<a class="reference internal" href="#cli.app.Application.pre_run" title="cli.app.Application.pre_run"><tt class="xref py py-meth docutils literal"><span class="pre">cli.app.Application.pre_run()</span></tt></a> and
<a class="reference internal" href="#cli.app.Application.run" title="cli.app.Application.run"><tt class="xref py py-meth docutils literal"><span class="pre">cli.app.Application.run()</span></tt></a> methods as necessary.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cli.test.FunctionalTest">
<em class="property">class </em><tt class="descclassname">cli.test.</tt><tt class="descname">FunctionalTest</tt><big>(</big><em>methodName='runTest'</em><big>)</big><a class="headerlink" href="#cli.test.FunctionalTest" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">unittest.TestCase</span></tt></p>
<p>A functional test, also based on <tt class="xref py py-class docutils literal"><span class="pre">unittest.TestCase</span></tt>.</p>
<p>Functional tests monitor an application&#8217;s &#8216;macro&#8217; behavior, making
it easy to spot regressions. They can also be simpler to write and
maintain as they don&#8217;t rely on any application internals.</p>
<p>The <a class="reference internal" href="#cli.test.FunctionalTest" title="cli.test.FunctionalTest"><tt class="xref py py-class docutils literal"><span class="pre">FunctionalTest</span></tt></a> will look for scripts to run under
<tt class="xref py py-attr docutils literal"><span class="pre">scriptdir</span></tt>. It uses <tt class="xref py py-class docutils literal"><span class="pre">scripttest.TestFileEnvironment</span></tt>
to provide temporary working areas for the scripts; these scratch
areas will be created under <tt class="xref py py-attr docutils literal"><span class="pre">testdir</span></tt> (and are created and
removed before and after each test is run).</p>
<dl class="method">
<dt id="cli.test.FunctionalTest.assertScriptDoes">
<tt class="descname">assertScriptDoes</tt><big>(</big><em>result</em>, <em>stdout=''</em>, <em>stderr=''</em>, <em>returncode=0</em>, <em>trim_output=True</em><big>)</big><a class="headerlink" href="#cli.test.FunctionalTest.assertScriptDoes" title="Permalink to this definition">¶</a></dt>
<dd><p>Fail if the result object&#8217;s stdout, stderr and returncode are unexpected.</p>
<p><em>result</em> is usually a <tt class="xref py py-class docutils literal"><span class="pre">scripttest.ProcResult</span></tt> with
stdout, stderr and returncode attributes.</p>
</dd></dl>

<dl class="method">
<dt id="cli.test.FunctionalTest.run_script">
<tt class="descname">run_script</tt><big>(</big><em>script</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#cli.test.FunctionalTest.run_script" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a test script.</p>
<p><em>script</em>, <em>args</em> and <em>kwargs</em> are passed to <tt class="xref py py-attr docutils literal"><span class="pre">env</span></tt>. Default keyword
arguments are specified in <tt class="xref py py-attr docutils literal"><span class="pre">run_kwargs</span></tt>.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 1.1.1: </span><tt class="xref py py-attr docutils literal"><span class="pre">scriptdir</span></tt> is no longer prepended to <em>script</em> before passing it
to <tt class="xref py py-attr docutils literal"><span class="pre">env</span></tt>. Instead, it is added to the env&#8217;s <em>script_path</em> during
<a class="reference internal" href="#cli.test.FunctionalTest.setUp" title="cli.test.FunctionalTest.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="cli.test.FunctionalTest.setUp">
<tt class="descname">setUp</tt><big>(</big><big>)</big><a class="headerlink" href="#cli.test.FunctionalTest.setUp" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare for the functional test.</p>
<p><a class="reference internal" href="#cli.test.FunctionalTest.setUp" title="cli.test.FunctionalTest.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a> creates the test&#8217;s working directory. If
the <tt class="xref py py-mod docutils literal"><span class="pre">unittest2</span></tt> package is present, it also makes sure that
differences in the test&#8217;s standard err and output are presented
using <tt class="xref py py-class docutils literal"><span class="pre">unittest2.TestCase.assertMultiLineEqual</span></tt>. Finally,
<a class="reference internal" href="#cli.test.FunctionalTest.setUp" title="cli.test.FunctionalTest.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a> instantiates the
<tt class="xref py py-class docutils literal"><span class="pre">scripttest.TestFileEnvironment</span></tt> and stores it at
<tt class="xref py py-attr docutils literal"><span class="pre">env</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="cli.test.FunctionalTest.tearDown">
<tt class="descname">tearDown</tt><big>(</big><big>)</big><a class="headerlink" href="#cli.test.FunctionalTest.tearDown" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean up after the test.</p>
<p><a class="reference internal" href="#cli.test.FunctionalTest.tearDown" title="cli.test.FunctionalTest.tearDown"><tt class="xref py py-meth docutils literal"><span class="pre">tearDown()</span></tt></a> removes the temporary working directory created
during <a class="reference internal" href="#cli.test.FunctionalTest.setUp" title="cli.test.FunctionalTest.setUp"><tt class="xref py py-meth docutils literal"><span class="pre">setUp()</span></tt></a>.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="testing-cli">
<h2>Testing <a class="reference internal" href="#module-cli" title="cli"><tt class="xref py py-mod docutils literal"><span class="pre">cli</span></tt></a><a class="headerlink" href="#testing-cli" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#module-cli" title="cli"><tt class="xref py py-mod docutils literal"><span class="pre">cli</span></tt></a> ships with a number of unit tests that help ensure that the code runs
correctly. To run the tests, use the <a class="reference external" href="http://codespeak.net/tox/">tox</a> automated testing tool:</p>
<div class="highlight-python"><pre>$ tox</pre>
</div>
<p>By default, <strong class="command">tox</strong> will attempt to run the unittests on all of the
platforms currently supported by <a class="reference internal" href="#module-cli" title="cli"><tt class="xref py py-mod docutils literal"><span class="pre">cli</span></tt></a>. See the <a class="reference external" href="http://codespeak.net/tox/index.html">tox documentation</a> for
more information about how to run tests.</p>
<p>You can get a sense for how completely the unit tests exercise <a class="reference internal" href="#module-cli" title="cli"><tt class="xref py py-mod docutils literal"><span class="pre">cli</span></tt></a> by
running the unittests directly with <a class="reference external" href="http://somethingaboutorange.com/mrl/projects/nose/">nose</a> and <a class="reference external" href="http://nedbatchelder.com/code/coverage/">coverage</a>:</p>
<div class="highlight-python"><pre>$ nosetests --with-coverage --cover-package=cli
$ coverage report --omit "lib/cli/*ext*,lib/cli/tests/*"</pre>
</div>
<p>All new code in <a class="reference internal" href="#module-cli" title="cli"><tt class="xref py py-mod docutils literal"><span class="pre">cli</span></tt></a> should be accompanied by unit tests. Eventually,
the unit tests should be complemented by a set of functional tests
(especially to stress things like the daemon code).</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><tt class="docutils literal"><span class="pre">cli</span></tt> &#8212; command line tools</a><ul>
<li><a class="reference internal" href="#installing-cli">Installing <tt class="docutils literal"><span class="pre">cli</span></tt></a><ul>
<li><a class="reference internal" href="#a-note-about-versions">A note about versions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-quick-tour-of-cli-s-features">A quick tour of <tt class="docutils literal"><span class="pre">cli</span></tt>&#8216;s features</a></li>
<li><a class="reference internal" href="#basic-usage">Basic usage</a></li>
<li><a class="reference internal" href="#projects-using-cli">Projects using <tt class="docutils literal"><span class="pre">cli</span></tt></a></li>
<li><a class="reference internal" href="#best-practices">Best practices</a><ul>
<li><a class="reference internal" href="#use-a-standard-style">Use a standard style</a></li>
<li><a class="reference internal" href="#modularize">Modularize</a></li>
<li><a class="reference internal" href="#share-your-code">Share your code</a></li>
<li><a class="reference internal" href="#test-your-code">Test your code</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-cli.app">API</a><ul>
<li><a class="reference internal" href="#cli-app-basic-applications"><tt class="docutils literal"><span class="pre">cli.app</span></tt> &#8211; basic applications</a></li>
<li><a class="reference internal" href="#cli-log-logging-applications"><tt class="docutils literal"><span class="pre">cli.log</span></tt> &#8211; logging applications</a></li>
<li><a class="reference internal" href="#cli-daemon-daemonizing-applications"><tt class="docutils literal"><span class="pre">cli.daemon</span></tt> &#8211; daemonizing applications</a></li>
<li><a class="reference internal" href="#cli-profiler-statistical-and-deterministic-application-profiling"><tt class="docutils literal"><span class="pre">cli.profiler</span></tt> &#8211; statistical and deterministic application profiling</a></li>
<li><a class="reference internal" href="#cli-test-functional-and-unit-test-support"><tt class="docutils literal"><span class="pre">cli.test</span></tt> &#8211; functional and unit test support</a></li>
</ul>
</li>
<li><a class="reference internal" href="#testing-cli">Testing <tt class="docutils literal"><span class="pre">cli</span></tt></a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/index.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">pyCLI v2.0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2009-2010 Will Maier &lt;will@m.aier.us&gt;.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>