.. _moduleStream:

music21.stream
==============

.. WARNING: DO NOT EDIT THIS FILE: AUTOMATICALLY GENERATED.  Edit the .py file directly

.. module:: music21.stream

The :class:`~music21.stream.Stream` and its subclasses, a subclass of the :class:`~music21.base.Music21Object`, is the fundamental container of offset-positioned notation and musical elements in music21. Common Stream subclasses, such as the :class:`~music21.stream.Measure` and :class:`~music21.stream.Score` objects, are defined in this module. 


Stream
------

Inherits from: :class:`~music21.base.Music21Object`, :class:`~music21.base.JSONSerializer`

.. class:: Stream(givenElements=None, *args, **keywords)

    This is the fundamental container for Music21Objects; objects may be ordered and/or placed in time based on offsets from the start of this container's offset. 

    Like the base class, Music21Object, Streams have offsets, priority, id, and groups they also have an elements attribute which returns a list of elements; 

    The Stream has a duration that is usually the release time of the chronologically last element in the Stream (that is, the highest onset plus duration of any element in the Stream). However, it can either explicitly set in which case we say that the duration is unlinked. 

    Streams may be embedded within other Streams. 

    The first element passed to the Stream is an optional list, tuple, or other Stream of music21 objects which is used to populate the Stream by inserting each object at its `.offset` property.  Other arguments and keywords are ignored, but are allowed so that subclassing the Stream is easier. 

    

    >>> from music21 import *
    >>> s1 = stream.Stream()
    >>> s1.append(note.HalfNote('C#4'))
    >>> s1.append(note.QuarterNote('D5'))
    >>> s1.duration.quarterLength
    3.0 
    >>> for thisNote in s1.notes:
    ...     print thisNote.octave 
    4 
    5 

    
    Demonstration of starting a Stream with other elements, 
    including embedded Streams (in this case, :class:`music21.stream.Part`, 
    a Stream subclass): 

    
    >>> c1 = clef.TrebleClef()
    >>> c1.offset = 0.0
    >>> n1 = note.EighthNote("E-6")
    >>> n1.offset = 1.0
    >>> p1 = stream.Part()
    >>> p1.offset = 0.0
    >>> p1.id = 'embeddedPart'
    >>> p1.append(note.Rest()) # quarter rest
    >>> s2 = stream.Stream([c1, n1, p1])
    >>> s2.show('text')
    {0.0} <music21.clef.TrebleClef object at 0x...> 
    {0.0} <music21.stream.Part embeddedPart> 
    {0.0} <music21.note.Rest rest> 
    {1.0} <music21.note.Note E-> 

    

    **Stream** **attributes**

        .. attribute:: isFlat

            Boolean describing whether this Stream contains embedded sub-Streams or Stream subclasses (not flat). 

        .. attribute:: autoSort

            Boolean describing whether the Stream is automatically sorted by offset whenever necessary. 

        .. attribute:: isSorted

            Boolean describing whether the Stream is sorted or not. 

        .. attribute:: flattenedRepresentationOf

            When this flat Stream is derived from another non-flat stream, a reference to the source Stream is stored here. 

        Attributes without Documentation: `isMeasure`

        Attributes inherited from :class:`~music21.base.Music21Object`: :attr:`~music21.base.Music21Object.classSortOrder`, :attr:`~music21.base.Music21Object.hideObjectOnPrint`, :attr:`~music21.base.Music21Object.id`, :attr:`~music21.base.Music21Object.groups`

    **Stream** **properties**

        .. attribute:: notes

            The notes property of a Stream returns a new Stream object that consists only of the notes (including :class:`~music21.note.Note`, :class:`~music21.chord.Chord`, :class:`~music21.note.Rest`, etc.) found in the stream. 

            >>> from music21 import *
            >>> s1 = stream.Stream()
            >>> k1 = key.KeySignature(0) # key of C
            >>> n1 = note.Note('B')
            >>> c1 = chord.Chord(['A', 'B-'])
            >>> s1.append([k1, n1, c1])
            >>> s1.show('text')
            {0.0} <music21.key.KeySignature of no sharps or flats> 
            {0.0} <music21.note.Note B> 
            {1.0} <music21.chord.Chord A B-> 
            >>> notes1 = s1.notes
            >>> notes1.show('text')
            {0.0} <music21.note.Note B> 
            {1.0} <music21.chord.Chord A B-> 

        .. attribute:: pitches

            Returns all :class:`~music21.pitch.Pitch` objects found in any element in the Stream as a Python List. Elements such as Streams, and Chords will have their Pitch objects accumulated as well. For that reason, a flat representation may not be required. 

            Pitch objects are returned in a List, not a Stream.  This usage differs from the notes property, but makes sense since Pitch objects are usually durationless.  (That's the main difference between them and :class:`music21.note.Note` objects) 

            

            >>> from music21 import corpus
            >>> a = corpus.parse('bach/bwv324.xml')
            >>> voiceOnePitches = a.parts[0].pitches
            >>> len(voiceOnePitches)
            25 
            >>> voiceOnePitches[0:10]
            [B4, D5, B4, B4, B4, B4, C5, B4, A4, A4] 

            
            Note that the pitches returned above are 
            objects, not text: 

            
            >>> voiceOnePitches[0].octave
            4 

            
            Since pitches are found from within internal objects, 
            flattening the stream is not required: 

            
            >>> len(a.pitches)
            104 

            
            Pitch objects are also retrieved when stored directly on a Stream. 

            
            >>> from music21 import *
            >>> pitch1 = pitch.Pitch()
            >>> st1 = stream.Stream()
            >>> st1.append(pitch1)
            >>> foundPitches = st1.pitches
            >>> len(foundPitches)
            1 
            >>> foundPitches[0] is pitch1
            True 

            

            
            Chords get their pitches found as well: 
            >>> c = chord.Chord(['C4','E4','G4'])
            >>> n = note.Note('F#4')
            >>> m = stream.Measure()
            >>> m.append(n)
            >>> m.append(c)
            >>> m.pitches
            [F#4, C4, E4, G4] 

            

            

            

        .. attribute:: beat

            No documentation. 

        .. attribute:: beatDuration

            unlike other Music21Objects, streams always have beatDuration of None 

        .. attribute:: beatStr

            unlike other Music21Objects, streams always have beatStr (beat string) of None 

        .. attribute:: beatStrength

            unlike other Music21Objects, streams always have beatStrength of None 

        .. attribute:: derivationChain

            Return a list Stream subclasses that this Stream was derved from. This provides a way to obtain all Streams that this element passed through, such as those created by getElementsByClass or flat searches. 

            >>> from music21 import *
            >>> s1 = stream.Stream()
            >>> s1.repeatAppend(note.Note(), 10)
            >>> s1.repeatAppend(note.Rest(), 10)
            >>> s2 = s1.getElementsByClass('GeneralNote')
            >>> s3 = s2.getElementsByClass('Note')
            >>> s3.derivationChain == [s2, s1]
            True 

        .. attribute:: derivationMethod

            Returns or sets a string representing how this stream was derived from another stream. 

            There are currently no limitations on this string. This might change. For instance: 

            >>> from music21 import *
            >>> s1 = converter.parse("C2 D2", "2/4")
            >>> s1m = s1.makeMeasures()
            >>> s1m1 = s1m.measure(1)
            >>> s1m1.derivesFrom is s1m
            True 
            >>> s1m1.derivationMethod
            'measure' 
            >>> s1m1.derivationMethod = 'getElementsByClass'
            >>> s1m1.derivationMethod
            'getElementsByClass' 

        .. attribute:: derivesFrom

            Return a reference to the Stream that created this Stream, if such a Stream exists. 

            >>> from music21 import *
            >>> s1 = stream.Stream()
            >>> s1.repeatAppend(note.Note(), 10)
            >>> s1.repeatAppend(note.Rest(), 10)
            >>> s2 = s1.getElementsByClass('Note')
            >>> s2.derivesFrom == s1
            True 

        .. attribute:: duration

            Returns the total duration of the Stream, from the beginning of the stream until the end of the final element. May be set independently by supplying a Duration object. 

            >>> from music21 import *
            >>> a = stream.Stream()
            >>> q = note.QuarterNote()
            >>> a.repeatInsert(q, [0,1,2,3])
            >>> a.highestOffset
            3.0 
            >>> a.highestTime
            4.0 
            >>> a.duration.quarterLength
            4.0 

            
            Advanced usage: override the duration from what is set: 

            
            >>> newDuration = duration.Duration("half")
            >>> newDuration.quarterLength
            2.0 
            >>> a.duration = newDuration
            >>> a.duration.quarterLength
            2.0 

            
            Note that the highestTime for the stream is the same 
            whether duration is overriden or not: 

            
            >>> a.highestTime
            4.0 

        .. attribute:: elements

            The low-level storage list of all Streams. Directly getting, setting, and manipulating this list is reserved for advanced usage. 

        .. attribute:: flat

            A very important property that returns a new Stream that has all sub-containers "flattened" within it, that is, it returns a new Stream where no elements nest within other elements. 

            Here is a simple example of the usefulness of .flat.  We will create a Score with two Parts in it, each with two Notes: 

            

            >>> from music21 import *
            >>> sc = stream.Score()
            >>> p1 = stream.Part()
            >>> p1.id = 'part1'
            >>> n1 = note.Note('C4')
            >>> n2 = note.Note('D4')
            >>> p1.append(n1)
            >>> p1.append(n2)
            >>> p2 = stream.Part()
            >>> p2.id = 'part2'
            >>> n3 = note.Note('E4')
            >>> n4 = note.Note('F4')
            >>> p2.append(n3)
            >>> p2.append(n4)
            >>> sc.insert(0, p1)
            >>> sc.insert(0, p2)

            
            When we look at sc, we will see only the two parts: 

            
            >>> sc.elements
            [<music21.stream.Part part1>, <music21.stream.Part part2>] 

            
            we can get at the notes by using the indices of the 
            stream to get the parts and then looking at the .elements 
            there: 

            
            >>> sc[0].elements
            [<music21.note.Note C>, <music21.note.Note D>] 
            >>> sc.getElementById('part2').elements
            [<music21.note.Note E>, <music21.note.Note F>] 

            
            but if we want to get all the notes, the easiest way 
            is via calling .flat on sc and looking at the elements 
            there: 

            
            >>> sc.flat.elements
            [<music21.note.Note C>, <music21.note.Note E>, <music21.note.Note D>, <music21.note.Note F>] 

            
            Flattening a stream is a great way to get at all the notes in 
            a larger piece.  For instance if we load a four-part 
            Bach chorale into music21 from the integrated corpus, it 
            will appear at first that there are no notes in the piece: 

            
            >>> bwv66 = corpus.parse('bach/bwv66.6')
            >>> len(bwv66.notes)
            0 

            
            This is because all the notes in the piece lie within :class:`music21.stream.Measure` 
            objects and those measures lie within :class:`music21.stream.Part` 
            objects.  It'd be a pain to navigate all the way through all those 
            objects just to count notes.  Fortunately we can get a Stream of 
            all the notes in the piece with .flat.notes and then use the 
            length of that Stream to count notes: 

            
            >>> bwv66flat = bwv66.flat
            >>> len(bwv66flat.notes)
            165 

            

            
            If you look back to our simple example of four notes above, 
            you can see that the E (the first note in part2) comes before the D 
            (the second note of part1).  This is because the flat stream 
            is automatically sorted like all streams are by default.  The 
            next example shows how to change this behavior. 

            
            >>> s = stream.Stream()
            >>> s.autoSort = False
            >>> s.repeatInsert(note.Note("C#"), [0, 2, 4])
            >>> s.repeatInsert(note.Note("D-"), [1, 3, 5])
            >>> s.isSorted
            False 
            >>> g = ""
            >>> for myElement in s:
            ...    g += "%s: %s; " % (myElement.offset, myElement.name) 
            >>> g
            '0.0: C#; 2.0: C#; 4.0: C#; 1.0: D-; 3.0: D-; 5.0: D-; ' 
            >>> y = s.sorted
            >>> y.isSorted
            True 
            >>> g = ""
            >>> for myElement in y:
            ...    g += "%s: %s; " % (myElement.offset, myElement.name) 
            >>> g
            '0.0: C#; 1.0: D-; 2.0: C#; 3.0: D-; 4.0: C#; 5.0: D-; ' 
            >>> q = stream.Stream()
            >>> for i in range(5):
            ...   p = stream.Stream() 
            ...   p.repeatInsert(music21.Music21Object(), range(5)) 
            ...   q.insert(i * 10, p) 
            >>> len(q)
            5 
            >>> qf = q.flat
            >>> len(qf)
            25 
            >>> qf[24].offset
            44.0 

        .. attribute:: highestOffset

            Get start time of element with the highest offset in the Stream. Note the difference between this property and highestTime which gets the end time of the highestOffset 

            >>> from music21 import *
            >>> stream1 = stream.Stream()
            >>> for offset in [0, 4, 8]:
            ...     n = note.WholeNote('G#') 
            ...     stream1.insert(offset, n) 
            >>> stream1.highestOffset
            8.0 
            >>> stream1.highestTime
            12.0 

        .. attribute:: highestTime

            Returns the maximum of all Element offsets plus their Duration in quarter lengths. This value usually represents the last "release" in the Stream. 

            Stream.duration is usually equal to the highestTime expressed as a Duration object, but it can be set separately for advanced operations. 

            Example: Insert a dotted half note at position 0 and see where it cuts off: 

            

            >>> from music21 import *
            >>> n = note.Note('A-')
            >>> n.quarterLength = 3
            >>> p1 = stream.Stream()
            >>> p1.insert(0, n)
            >>> p1.highestTime
            3.0 

            
            Now insert in the same stream, the dotted half note 
            at positions 1, 2, 3, 4 and see when the final note cuts off: 

            

            
            >>> p1.repeatInsert(n, [1, 2, 3, 4])
            >>> p1.highestTime
            7.0 

        .. attribute:: isGapless

            No documentation. 

        .. attribute:: lily

            returns or sets the lilypond output for the Stream. Note that (for now at least), setting the Lilypond output for a Stream does not change the stream itself.  It's just a way of overriding what is printed when .lily is called. 

            >>> from music21 import *
            >>> s1 = stream.Stream()
            >>> s1.append(clef.BassClef())
            >>> s1.append(meter.TimeSignature("3/4"))
            >>> k1 = key.KeySignature(5)
            >>> k1.mode = 'minor'
            >>> s1.append(k1)
            >>> s1.append(note.Note("B-3"))   # quarter note
            >>> s1.append(note.HalfNote("C#2"))
            >>> s1.lily
            { \clef "bass"  \time 3/4  \key gis \minor bes4 cis,2  } 

            

        .. attribute:: lowestOffset

            Get the start time of the Element with the lowest offset in the Stream. 

            >>> from music21 import *
            >>> stream1 = stream.Stream()
            >>> for x in range(3,5):
            ...     n = note.Note('G#') 
            ...     stream1.insert(x, n) 
            ... 
            >>> stream1.lowestOffset
            3.0 

            
            If the Stream is empty, then the lowest offset is 0.0: 

            
            >>> stream2 = stream.Stream()
            >>> stream2.lowestOffset
            0.0 

            

        .. attribute:: metadata

            Get or set the :class:`~music21.metadata.Metadata` object found at the beginning (offset 0) of this Stream. 

            >>> from music21 import *
            >>> s = stream.Stream()
            >>> s.metadata = metadata.Metadata()
            >>> s.metadata.composer = 'frank'
            >>> s.metadata.composer
            'frank' 

        .. attribute:: midiFile

            Get or set a :class:`music21.midi.base.MidiFile` object. 

        .. attribute:: midiTracks

            Get or set this Stream from a list of :class:`music21.midi.base.MidiTracks` objects. 

            >>> from music21 import *
            >>> s = stream.Stream()
            >>> n = note.Note('g#3')
            >>> n.quarterLength = .5
            >>> s.repeatAppend(n, 6)
            >>> len(s.midiTracks[0].events)
            28 

        .. attribute:: musicxml

            Return a complete MusicXML reprsentatoin as a string. 

        .. attribute:: mx

            Create and return a musicxml Score object. 

            >>> from music21 import *
            >>> n1 = note.Note()
            >>> measure1 = stream.Measure()
            >>> measure1.insert(n1)
            >>> str1 = stream.Stream()
            >>> str1.insert(measure1)
            >>> mxScore = str1.mx

        .. attribute:: offsetMap

            returns a list where each element is a dictionary consisting of the 'offset' of each element in a stream, the 'endTime' (that is, the offset plus the duration) and the 'element' itself.  Also contains a 'voiceIndex' entry which contains the voice number of the element, or None if there are no voices. 

            >>> from music21 import *
            >>> n1 = note.QuarterNote()
            >>> c1 = clef.AltoClef()
            >>> n2 = note.HalfNote()
            >>> s1 = stream.Stream()
            >>> s1.append([n1, c1, n2])
            >>> om = s1.offsetMap
            >>> om[2]['offset']
            1.0 
            >>> om[2]['endTime']
            3.0 
            >>> om[2]['element'] is n2
            True 
            >>> om[2]['voiceIndex']

        .. attribute:: rootDerivation

            Return a reference to the oldest source of this Stream; that is, chain calls to derivesFrom until we get to a Stream that cannot be further derived. 

            >>> from music21 import *
            >>> s1 = stream.Stream()
            >>> s1.repeatAppend(note.Note(), 10)
            >>> s1.repeatAppend(note.Rest(), 10)
            >>> s2 = s1.getElementsByClass('Note')
            >>> s2.derivesFrom == s1
            True 

        .. attribute:: semiFlat

            Returns a flat-like Stream representation. Stream sub-classed containers, such as Measure or Part, are retained in the output Stream, but positioned at their relative offset. 

            >>> from music21 import *
            >>> s = stream.Stream()
            >>> p1 = stream.Part()
            >>> p1.id = 'part1'
            >>> n1 = note.Note('C5')
            >>> p1.append(n1)
            >>> p2 = stream.Part()
            >>> p2.id = 'part2'
            >>> n2 = note.Note('D5')
            >>> p2.append(n2)
            >>> s.insert(0, p1)
            >>> s.insert(0, p2)
            >>> sf = s.semiFlat
            >>> sf.elements
            [<music21.stream.Part part1>, <music21.note.Note C>, <music21.stream.Part part2>, <music21.note.Note D>] 
            >>> sf[0]
            <music21.stream.Part part1> 
            >>> sf[1]
            <music21.note.Note C> 
            >>> sf[0][0]
            <music21.note.Note C> 

            

        .. attribute:: sorted

            Returns a new Stream where all the elements are sorted according to offset time, then priority, then classSortOrder (so that, for instance, a Clef at offset 0 appears before a Note at offset 0) if this Stream is not flat, then only the highest elements are sorted.  To sort all, run myStream.flat.sorted For instance, here is an unsorted Stream 

            >>> from music21 import *
            >>> s = stream.Stream()
            >>> s.autoSort = False # if true, sorting is automatic
            >>> s.insert(1, note.Note("D"))
            >>> s.insert(0, note.Note("C"))
            >>> s.show('text')
            {1.0} <music21.note.Note D> 
            {0.0} <music21.note.Note C> 

            
            But a sorted version of the Stream puts the C first: 

            
            >>> s.sorted.show('text')
            {0.0} <music21.note.Note C> 
            {1.0} <music21.note.Note D> 

            
            While the original stream remains unsorted: 

            
            >>> s.show('text')
            {1.0} <music21.note.Note D> 
            {0.0} <music21.note.Note C> 

            

        .. attribute:: spanners

            Return all :class:`~music21.spanner.Spanner` objects (things such as Slurs, long trills, or anything that connects many objects) into a :class:`~music21.stream.Stream` or Stream subclass. 

            

            >>> from music21 import *
            >>> s = stream.Stream()
            >>> s.insert(0, spanner.Slur())
            >>> s.insert(0, spanner.Slur())
            >>> len(s.spanners)
            2 

        .. attribute:: voices

            Return all :class:`~music21.stream.Voices` objects in a :class:`~music21.stream.Stream` or Stream subclass. 

            >>> from music21 import *
            >>> s = stream.Stream()
            >>> s.insert(0, stream.Voice())
            >>> s.insert(0, stream.Voice())
            >>> len(s.voices)
            2 

        Properties inherited from :class:`~music21.base.Music21Object`: :attr:`~music21.base.Music21Object.activeSite`, :attr:`~music21.base.Music21Object.classes`, :attr:`~music21.base.Music21Object.derivationHierarchy`, :attr:`~music21.base.Music21Object.measureNumber`, :attr:`~music21.base.Music21Object.offset`, :attr:`~music21.base.Music21Object.priority`

        Properties inherited from :class:`~music21.base.JSONSerializer`: :attr:`~music21.base.JSONSerializer.json`

    **Stream** **methods**

        .. method:: append(others)

            Add Music21Objects (including other Streams) to the Stream (or multiple if passed a list) with offset equal to the highestTime (that is the latest "release" of an object), that is, directly after the last element ends. if the objects are not Music21Objects, they are wrapped in ElementWrappers runs fast for multiple addition and will preserve isSorted if True 

            >>> from music21 import *
            >>> a = stream.Stream()
            >>> notes = []
            >>> for x in range(0,3):
            ...     n = note.Note('G#') 
            ...     n.duration.quarterLength = 3 
            ...     notes.append(n) 
            >>> a.append(notes[0])
            >>> a.highestOffset, a.highestTime
            (0.0, 3.0) 
            >>> a.append(notes[1])
            >>> a.highestOffset, a.highestTime
            (3.0, 6.0) 
            >>> a.append(notes[2])
            >>> a.highestOffset, a.highestTime
            (6.0, 9.0) 
            >>> notes2 = []

            
            since notes are not embedded in Elements here, their offset 
            changes when they are added to a stream! 

            
            >>> for x in range(0,3):
            ...     n = note.Note("A-") 
            ...     n.duration.quarterLength = 3 
            ...     n.offset = 0 
            ...     notes2.append(n) 
            >>> a.append(notes2) # add em all again
            >>> a.highestOffset, a.highestTime
            (15.0, 18.0) 
            >>> a.isSequence()
            True 

            
            Adding a note that already has an offset set does nothing different 
            from above!  That is, it is still added to the end of the Stream: 

            
            >>> n3 = note.Note("B-")
            >>> n3.offset = 1
            >>> n3.duration.quarterLength = 3
            >>> a.append(n3)
            >>> a.highestOffset, a.highestTime
            (18.0, 21.0) 
            >>> n3.getOffsetBySite(a)
            18.0 

        .. method:: insert(offsetOrItemOrList, itemOrNone=None, ignoreSort=False, setActiveSite=True)

            Inserts an item(s) at the given offset(s). If `ignoreSort` is True then the inserting does not change whether the Stream is sorted or not (much faster if you're going to be inserting dozens of items that don't change the sort status) The `setActiveSite` parameter should nearly always be True; only for advanced Stream manipulation would you not change the activeSite after inserting an element. Has three forms: in the two argument form, inserts an element at the given offset: 

            

            >>> from music21 import *
            >>> st1 = stream.Stream()
            >>> st1.insert(32, note.Note("B-"))
            >>> st1._getHighestOffset()
            32.0 

            
            In the single argument form with an object, inserts the element at its stored offset: 

            
            >>> n1 = note.Note("C#")
            >>> n1.offset = 30.0
            >>> st1 = stream.Stream()
            >>> st1.insert(n1)
            >>> st2 = stream.Stream()
            >>> st2.insert(40.0, n1)
            >>> n1.getOffsetBySite(st1)
            30.0 

            
            In single argument form with a list, the list should contain pairs that alternate 
            offsets and items; the method then, obviously, inserts the items 
            at the specified offsets: 

            
            >>> n1 = note.Note("G")
            >>> n2 = note.Note("F#")
            >>> st3 = stream.Stream()
            >>> st3.insert([1.0, n1, 2.0, n2])
            >>> n1.getOffsetBySite(st3)
            1.0 
            >>> n2.getOffsetBySite(st3)
            2.0 
            >>> len(st3)
            2 

            

        .. method:: insertAndShift(offsetOrItemOrList, itemOrNone=None)

            Insert an item at a specified or native offset, and shit any elements found in the Stream to start at the end of the added elements. This presently does not shift elements that have durations that extend into the lowest insert position. 

            >>> from music21 import *
            >>> st1 = stream.Stream()
            >>> st1.insertAndShift(32, note.Note("B-"))
            >>> st1.highestOffset
            32.0 
            >>> st1.insertAndShift(32, note.Note("B-"))
            >>> st1.highestOffset
            33.0 

            
            In the single argument form with an object, inserts the element at its stored offset: 

            
            >>> n1 = note.Note("C#")
            >>> n1.offset = 30.0
            >>> n2 = note.Note("C#")
            >>> n2.offset = 30.0
            >>> st1 = stream.Stream()
            >>> st1.insertAndShift(n1)
            >>> st1.insertAndShift(n2) # should shift offset of n1
            >>> n1.getOffsetBySite(st1)
            31.0 
            >>> n2.getOffsetBySite(st1)
            30.0 
            >>> st2 = stream.Stream()
            >>> st2.insertAndShift(40.0, n1)
            >>> st2.insertAndShift(40.0, n2)
            >>> n1.getOffsetBySite(st2)
            41.0 

            
            In single argument form with a list, the list should contain pairs that alternate 
            offsets and items; the method then, obviously, inserts the items 
            at the specified offsets: 

            
            >>> n1 = note.Note("G")
            >>> n2 = note.Note("F#")
            >>> st3 = stream.Stream()
            >>> st3.insertAndShift([1.0, n1, 2.0, n2])
            >>> n1.getOffsetBySite(st3)
            1.0 
            >>> n2.getOffsetBySite(st3)
            2.0 
            >>> len(st3)
            2 

        .. method:: transpose(value, inPlace=False, classFilterList=['Note', 'Chord'])

            Transpose all specified classes in the Stream by the user-provided value. If the value is an integer, the transposition is treated in half steps. If the value is a string, any Interval string specification can be provided. returns a new Stream by default, but if the optional "inPlace" key is set to True then it modifies pitches in place. 

            >>> from music21 import *
            >>> aInterval = interval.Interval('d5')
            >>> aStream = corpus.parse('bach/bwv324.xml')
            >>> part = aStream.parts[0]
            >>> aStream.parts[0].pitches[:10]
            [B4, D5, B4, B4, B4, B4, C5, B4, A4, A4] 
            >>> bStream = aStream.parts[0].flat.transpose('d5')
            >>> bStream.pitches[:10]
            [F5, A-5, F5, F5, F5, F5, G-5, F5, E-5, E-5] 
            >>> aStream.parts[0].pitches[:10]
            [B4, D5, B4, B4, B4, B4, C5, B4, A4, A4] 
            >>> cStream = bStream.flat.transpose('a4')
            >>> cStream.pitches[:10]
            [B5, D6, B5, B5, B5, B5, C6, B5, A5, A5] 
            >>> cStream.flat.transpose(aInterval, inPlace=True)
            >>> cStream.pitches[:10]
            [F6, A-6, F6, F6, F6, F6, G-6, F6, E-6, E-6] 

        .. method:: augmentOrDiminish(amountToScale, inPlace=False)

            Given a number greater than zero, multiplies the current quarterLength of the duration of each element by this number as well as their offset and returns a new Stream. Or if `inPlace` is set to True, modifies the durations of each element within the stream. 

            A number of .5 will halve the durations and relative offset positions; a number of 2 will double the durations and relative offset positions. 

            

            Note that the default for inPlace is the opposite of what it is for augmentOrDiminish on a Duration. This is done purposely to reflect the most common usage. 

            

            >>> from music21 import *
            >>> s = stream.Stream()
            >>> n = note.Note()
            >>> s.repeatAppend(n, 10)
            >>> s.highestOffset, s.highestTime
            (9.0, 10.0) 
            >>> s1 = s.augmentOrDiminish(2)
            >>> s1.highestOffset, s1.highestTime
            (18.0, 20.0) 
            >>> s1 = s.augmentOrDiminish(.5)
            >>> s1.highestOffset, s1.highestTime
            (4.5, 5.0) 

        .. method:: scaleOffsets(amountToScale, anchorZero=lowest, anchorZeroRecurse=None, inPlace=True)

            Scale all offsets by a multiplication factor given in `amountToScale`. Durations are not altered. 

            To augment or diminish a Stream, see the :meth:`~music21.stream.Stream.augmentOrDiminish` method. 

            The `anchorZero` parameter determines if and/or where the zero offset is established for the set of offsets in this Stream before processing. Offsets are shifted to make either the lower or upper values the new zero; then offsets are scaled; then the shifts are removed. Accepted values are None (no offset shifting), "lowest", or "highest". 

            The `anchorZeroRecurse` parameter determines the anchorZero for all embedded Streams, and Streams embedded within those Streams. If the lowest offset in an embedded Stream is non-zero, setting this value to None will a the space between the start of that Stream and the first element to be scaled. If the lowest offset in an embedded Stream is non-zero, setting this value to 'lowest' will not alter the space between the start of that Stream and the first element to be scaled. 

            To shift all the elements in a Stream, see the :meth:`~music21.stream.Stream.shiftElements` method. 

            

            

        .. method:: scaleDurations(amountToScale, inPlace=True)

            Scale all durations by a provided scalar. Offsets are not modified. To augment or diminish a Stream, see the :meth:`~music21.stream.Stream.augmentOrDiminish` method. 

            

        .. method:: addGroupForElements(group, classFilter=None)

            Add the group to the groups attribute of all elements. if `classFilter` is set then only those elements whose objects belong to a certain class (or for Streams which are themselves of a certain class) are set. 

            >>> from music21 import *
            >>> a = stream.Stream()
            >>> a.repeatAppend(note.Note('A-'), 30)
            >>> a.repeatAppend(note.Rest(), 30)
            >>> a.addGroupForElements('flute')
            >>> a[0].groups
            ['flute'] 
            >>> a.addGroupForElements('quietTime', note.Rest)
            >>> a[0].groups
            ['flute'] 
            >>> a[50].groups
            ['flute', 'quietTime'] 
            >>> a[1].groups.append('quietTime') # set one note to it
            >>> a[1].step = "B"
            >>> b = a.getElementsByGroup('quietTime')
            >>> len(b)
            31 
            >>> c = b.getElementsByClass(note.Note)
            >>> len(c)
            1 
            >>> c[0].name
            'B-' 

            

        .. method:: allPlayingWhileSounding(el, elStream=None, requireClass=False)

            Returns a new Stream of elements in this stream that sound at the same time as `el`, an element presumably in another Stream. 

            The offset of this new Stream is set to el's offset, while the offset of elements within the Stream are adjusted relative to their position with respect to the start of el.  Thus, a note that is sounding already when el begins would have a negative offset.  The duration of otherStream is forced to be the length of el -- thus a note sustained after el ends may have a release time beyond that of the duration of the Stream. 

            as above, elStream is an optional Stream to look up el's offset in. 

            The method always returns a Stream, but it might be an empty Stream. 

            

        .. method:: analyze(*args, **keywords)

            Given an analysis method, return an analysis on this Stream. For details on arguments, see :func:`~music21.analysis.discrete.analyzeStream`. Available plots include the following: ambitus -- runs :class:`~music21.analysis.discrete.Ambitus` key -- :class:`~music21.analysis.discrete.KrumhanslSchmuckler` 

            >>> from music21 import *
            >>> s = corpus.parse('bach/bwv66.6')
            >>> s.analyze('ambitus')
            <music21.interval.Interval m21> 
            >>> s.analyze('key')
            <music21.key.Key of F# minor> 

        .. method:: attachIntervalsBetweenStreams(cmpStream)

            For each element in self, creates an interval.Interval object in the element's editorial that is the interval between it and the element in cmpStream that is sounding at the moment the element in srcStream is attacked. 

            Remember that if you are comparing two streams with measures, etc., you'll need to flatten each stream as follows: 

            

            >>> stream1.flat.attachIntervvalsBetweenStreams(stream2.flat)

            
            Example usage: 

            
            >>> from music21 import *
            >>> s1 = converter.parse('C4 d8 e f# g A2', '5/4')
            >>> s2 = converter.parse('g4 e8 d c4   a2', '5/4')
            >>> s1.attachIntervalsBetweenStreams(s2)
            >>> for n in s1.notes:
            ...     if "Rest" in n.classes: continue  # safety check 
            ...     if n.editorial.harmonicInterval is None: continue # if other voice had a rest... 
            ...     print n.editorial.harmonicInterval.directedName 
            P12 
            M2 
            M-2 
            A-4 
            P-5 
            P8 

            

        .. method:: attributeCount(classFilterList, attrName=quarterLength)

            Return a dictionary of attribute usage for one or more classes provided in a the `classFilterList` list and having the attribute specified by `attrName`. 

            >>> from music21 import corpus
            >>> a = corpus.parse('bach/bwv324.xml')
            >>> a.parts[0].flat.attributeCount(note.Note, 'quarterLength')
            {1.0: 12, 2.0: 11, 4.0: 2} 

        .. method:: bestClef(allowTreble8vb=False)

            Returns the clef that is the best fit for notes and chords found in this Stream. This does not automatically get a flat representation of the Stream. 

            >>> from music21 import *
            >>> a = stream.Stream()
            >>> for x in range(30):
            ...    n = note.Note() 
            ...    n.midi = random.choice(range(60,72)) 
            ...    a.insert(n) 
            >>> b = a.bestClef()
            >>> b.line
            2 
            >>> b.sign
            'G' 
            >>> c = stream.Stream()
            >>> for x in range(30):
            ...    n = note.Note() 
            ...    n.midi = random.choice(range(35,55)) 
            ...    c.insert(n) 
            >>> d = c.bestClef()
            >>> d.line
            4 
            >>> d.sign
            'F' 

        .. method:: expandRepeats()

            Expand all repeats, as well as all repeat indications given by text expressions such as D.C. al Segno. This method always returns a new Stream, with deepcopies of all contained elements at all levels. NOTE: This preliminary implementation only handles repeats designated with repeat signs. 

            

        .. method:: explode()

            Create a multi-part extraction from a single polyphonic Part. 

            Currently just runs :meth:`~music21.stream.Stream.voicesToParts` but that will change as part explosion develops, and this method will use our best available quick method for part extraction. 

        .. method:: extendDuration(objName, inPlace=True)

            Given a Stream and an object class name, go through the Stream and find each instance of the desired object. The time between adjacent objects is then assigned to the duration of each object. The last duration of the last object is assigned to extend to the end of the Stream. If `inPlace` is True, this is done in-place; if `inPlace` is False, this returns a modified deep copy. 

            >>> from music21 import *
            >>> stream1 = stream.Stream()
            >>> n = note.QuarterNote()
            >>> n.duration.quarterLength
            1.0 
            >>> stream1.repeatInsert(n, [0, 10, 20, 30, 40])
            >>> dyn = dynamics.Dynamic('ff')
            >>> stream1.insert(15, dyn)
            >>> sort1 = stream1.sorted
            >>> sort1[-1].offset # offset of last element
            40.0 
            >>> sort1.duration.quarterLength # total duration
            41.0 
            >>> len(sort1)
            6 
            >>> stream2 = sort1.flat.extendDuration(note.GeneralNote)
            >>> len(stream2)
            6 
            >>> stream2[0].duration.quarterLength
            10.0 
            >>> stream2[1].duration.quarterLength # all note durs are 10
            10.0 
            >>> stream2[-1].duration.quarterLength # or extend to end of stream
            1.0 
            >>> stream2.duration.quarterLength
            41.0 
            >>> stream2[-1].offset
            40.0 
            >>> from music21.musicxml import testFiles
            >>> from music21 import converter
            >>> # testing a file a file with dynamics
            >>> a = converter.parse(testFiles.schumannOp48No1)
            >>> b = a.flat.extendDuration(dynamics.Dynamic)

        .. method:: extractContext(searchElement, before=4.0, after=4.0, maxBefore=None, maxAfter=None, forceOutputClass=None)

            Extracts elements around the given element within (before) quarter notes and (after) quarter notes (default 4), and returns a new Stream. 

            >>> from music21 import *
            >>> qn = note.QuarterNote()
            >>> qtrStream = stream.Stream()
            >>> qtrStream.repeatInsert(qn, [0, 1, 2, 3, 4, 5])
            >>> hn = note.HalfNote()
            >>> hn.name = "B-"
            >>> qtrStream.append(hn)
            >>> qtrStream.repeatInsert(qn, [8, 9, 10, 11])
            >>> hnStream = qtrStream.extractContext(hn, 1.0, 1.0)
            >>> hnStream.show('text')
            {5.0} <music21.note.Note C> 
            {6.0} <music21.note.Note B-> 
            {8.0} <music21.note.Note C> 

        .. method:: findConsecutiveNotes(skipRests=False, skipChords=False, skipUnisons=False, skipOctaves=False, skipGaps=False, getOverlaps=False, noNone=False, **keywords)

            Returns a list of consecutive *pitched* Notes in a Stream.  A single "None" is placed in the list at any point there is a discontinuity (such as if there is a rest between two pitches). 

            How to determine consecutive pitches is a little tricky and there are many options. skipUnison uses the midi-note value (.ps) to determine unisons, so enharmonic transitions (F# -> Gb) are also skipped if skipUnisons is true.  We believe that this is the most common usage.  However, because of this, you cannot completely be sure that the x.findConsecutiveNotes() - x.findConsecutiveNotes(skipUnisons = True) will give you the number of P1s in the piece, because there could be d2's in there as well. See Test.testFindConsecutiveNotes() for usage details. 

            

        .. method:: findGaps(minimumQuarterLength=0.001)

            Returns either (1) a Stream containing Elements (that wrap the None object) whose offsets and durations are the length of gaps in the Stream or (2) None if there are no gaps. N.B. there may be gaps in the flattened representation of the stream but not in the unflattened.  Hence why "isSequence" calls self.flat.isGapless 

        .. method:: getClefs(searchActiveSite=False, searchContext=True, returnDefault=True)

            Collect all :class:`~music21.clef.Clef` objects in this Stream in a new Stream. Optionally search the activeSite Stream and/or contexts. If no Clef objects are defined, get a default using :meth:`~music21.stream.Stream.bestClef` 

            >>> from music21 import *
            >>> a = stream.Stream()
            >>> b = clef.AltoClef()
            >>> a.insert(0, b)
            >>> a.repeatInsert(note.Note("C#"), range(10))
            >>> c = a.getClefs()
            >>> len(c) == 1
            True 

        .. method:: getElementAfterElement(element, classList=None)

            given an element, get the next element.  If classList is specified, check to make sure that the element is an instance of the class list 

            >>> from music21 import *
            >>> st1 = stream.Stream()
            >>> n1 = note.Note()
            >>> n2 = note.Note()
            >>> r3 = note.Rest()
            >>> st1.append([n1, n2, r3])
            >>> t2 = st1.getElementAfterElement(n1)
            >>> t2 is n2
            True 
            >>> t3 = st1.getElementAfterElement(t2)
            >>> t3 is r3
            True 
            >>> t4 = st1.getElementAfterElement(t3)
            >>> t4
            >>> st1.getElementAfterElement("hi")
            Traceback (most recent call last): 
            StreamException: ... 
            >>> t5 = st1.getElementAfterElement(n1, [note.Rest])
            >>> t5 is r3
            True 
            >>> t6 = st1.getElementAfterElement(n1, [note.Rest, note.Note])
            >>> t6 is n2
            True 

        .. method:: getElementAfterOffset(offset, classList=None)

            Get element after a provided offset TODO: write this 

        .. method:: getElementAtOrAfter(offset, classList=None)

            Given an offset, find the element at this offset, or with the offset greater than and nearest to. TODO: write this 

        .. method:: getElementAtOrBefore(offset, classList=None)

            Given an offset, find the element at this offset, or with the offset less than and nearest to. Return one element or None if no elements are at or preceded by this offset. 

            >>> from music21 import *
            >>> stream1 = stream.Stream()
            >>> x = note.Note('D4')
            >>> x.id = 'x'
            >>> y = note.Note('E4')
            >>> y.id = 'y'
            >>> z = note.Rest()
            >>> z.id = 'z'
            >>> stream1.insert(20, x)
            >>> stream1.insert(10, y)
            >>> stream1.insert( 0, z)
            >>> b = stream1.getElementAtOrBefore(21)
            >>> b.offset, b.id
            (20.0, 'x') 
            >>> b = stream1.getElementAtOrBefore(19)
            >>> b.offset, b.id
            (10.0, 'y') 
            >>> b = stream1.getElementAtOrBefore(0)
            >>> b.offset, b.id
            (0.0, 'z') 
            >>> b = stream1.getElementAtOrBefore(0.1)
            >>> b.offset, b.id
            (0.0, 'z') 

            

            
            You can give a list of acceptable classes to return, and non-matching 
            elements will be ignored 

            
            >>> c = stream1.getElementAtOrBefore(100, [music21.clef.TrebleClef, music21.note.Rest])
            >>> c.offset, c.id
            (0.0, 'z') 

            
            Getting an object via getElementAtOrBefore sets the activeSite 
            for that object to the Stream, and thus sets its offset 

            
            >>> stream2 = stream.Stream()
            >>> stream2.insert(100.5, x)
            >>> x.offset
            100.5 
            >>> d = stream1.getElementAtOrBefore(20)
            >>> d is x
            True 
            >>> x.activeSite is stream1
            True 
            >>> x.offset
            20.0 

            

        .. method:: getElementBeforeElement(element, classList=None)

            given an element, get the element before TODO: write this 

        .. method:: getElementBeforeOffset(offset, classList=None)

            Get element before a provided offset TODO: write this 

        .. method:: getElementById(id, classFilter=None)

            Returns the first encountered element for a given id. Return None if no match 

            >>> from music21 import *
            >>> a = stream.Stream()
            >>> ew = note.Note()
            >>> a.insert(0, ew)
            >>> a[0].id = 'green'
            >>> None == a.getElementById(3)
            True 
            >>> a.getElementById('green').id
            'green' 
            >>> a.getElementById('Green').id  # case does not matter
            'green' 

            
            Getting an element by getElementById changes its activeSite 

            
            >>> b = stream.Stream()
            >>> b.append(ew)
            >>> ew.activeSite is b
            True 
            >>> ew2 = a.getElementById('green')
            >>> ew2 is ew
            True 
            >>> ew2.activeSite is a
            True 
            >>> ew.activeSite is a
            True 

        .. method:: getElementByObjectId(objId)

            Low-level tool to get an element based only on the object id. This does not yet handle ElementWrapper objects 

        .. method:: getElementsByClass(classFilterList, returnStreamSubClass=True)

            Return a list of all Elements that match one or more classes in the `classFilterList`. A single class can be provided to the `classFilterList` parameter. 

            >>> from music21 import *
            >>> a = stream.Score()
            >>> a.repeatInsert(note.Rest(), range(10))
            >>> for x in range(4):
            ...     n = note.Note('G#') 
            ...     n.offset = x * 3 
            ...     a.insert(n) 
            >>> found = a.getElementsByClass(note.Note)
            >>> len(found)
            4 
            >>> found[0].pitch.accidental.name
            'sharp' 
            >>> b = stream.Stream()
            >>> b.repeatInsert(note.Rest(), range(15))
            >>> a.insert(b)
            >>> # here, it gets elements from within a stream
            >>> # this probably should not do this, as it is one layer lower
            >>> found = a.getElementsByClass(note.Rest)
            >>> len(found)
            10 
            >>> found = a.flat.getElementsByClass(note.Rest)
            >>> len(found)
            25 
            >>> found.__class__.__name__
            'Score' 

        .. method:: getElementsByGroup(groupFilterList)

            

            >>> from music21 import *
            >>> n1 = note.Note("C")
            >>> n1.groups.append('trombone')
            >>> n2 = note.Note("D")
            >>> n2.groups.append('trombone')
            >>> n2.groups.append('tuba')
            >>> n3 = note.Note("E")
            >>> n3.groups.append('tuba')
            >>> s1 = stream.Stream()
            >>> s1.append(n1)
            >>> s1.append(n2)
            >>> s1.append(n3)
            >>> tboneSubStream = s1.getElementsByGroup("trombone")
            >>> for thisNote in tboneSubStream:
            ...     print(thisNote.name) 
            C 
            D 
            >>> tubaSubStream = s1.getElementsByGroup("tuba")
            >>> for thisNote in tubaSubStream:
            ...     print(thisNote.name) 
            D 
            E 

        .. method:: getElementsByOffset(offsetStart, offsetEnd=None, includeEndBoundary=True, mustFinishInSpan=False, mustBeginInSpan=True)

            Returns a Stream containing all Music21Objects that are found at a certain offset or within a certain offset time range (given the start and optional stop values). 

            There are several attributes that govern how this range is determined: 

            If `mustFinishInSpan` is True then an event that begins between offsetStart and offsetEnd but which ends after offsetEnd will not be included.  The default is False. 

            For instance, a half note at offset 2.0 will be found in getElementsByOffset(1.5, 2.5) or getElementsByOffset(1.5, 2.5, mustFinishInSpan = False) but not by getElementsByOffset(1.5, 2.5, mustFinishInSpan = True). 

            The `includeEndBoundary` option determines if an element begun just at the offsetEnd should be included.  For instance, the half note at offset 2.0 above would be found by getElementsByOffset(0, 2.0) or by getElementsByOffset(0, 2.0, includeEndBoundary = True) but not by getElementsByOffset(0, 2.0, includeEndBoundary = False). 

            Setting includeEndBoundary to False at the same time as mustFinishInSpan is set to True is probably NOT what you want to do unless you want to find things like clefs at the end of the region to display as courtesy clefs. 

            The `mustBeginInSpan` option determines whether notes or other objects that do not begin in the region but are still sounding at the beginning of the region are excluded.  The default is True -- that is, these notes will not be included. For instance the half note at offset 2.0 from above would not be found by getElementsByOffset(3.0, 3.5) or getElementsByOffset(3.0, 3.5, mustBeginInSpan = True) but it would be found by getElementsByOffset(3.0, 3.5, mustBeginInSpan = False) 

            This chart, and the examples below, demonstrate the various features of getElementsByOffset.  It is one of the most complex methods of music21 but also one of the most powerful, so it is worth learning at least the basics. 

            


            .. image:: images/getElementsByOffset.*
                :width: 600


            

            >>> from music21 import *
            >>> st1 = stream.Stream()
            >>> n0 = note.Note("C")
            >>> n0.duration.type = "half"
            >>> n0.offset = 0
            >>> st1.insert(n0)
            >>> n2 = note.Note("D")
            >>> n2.duration.type = "half"
            >>> n2.offset = 2
            >>> st1.insert(n2)
            >>> out1 = st1.getElementsByOffset(2)
            >>> len(out1)
            1 
            >>> out1[0].step
            'D' 
            >>> out2 = st1.getElementsByOffset(1, 3)
            >>> len(out2)
            1 
            >>> out2[0].step
            'D' 
            >>> out3 = st1.getElementsByOffset(1, 3, mustFinishInSpan = True)
            >>> len(out3)
            0 
            >>> out4 = st1.getElementsByOffset(1, 2)
            >>> len(out4)
            1 
            >>> out4[0].step
            'D' 
            >>> out5 = st1.getElementsByOffset(1, 2, includeEndBoundary = False)
            >>> len(out5)
            0 
            >>> out6 = st1.getElementsByOffset(1, 2, includeEndBoundary = False, mustBeginInSpan = False)
            >>> len(out6)
            1 
            >>> out6[0].step
            'C' 
            >>> out7 = st1.getElementsByOffset(1, 3, mustBeginInSpan = False)
            >>> len(out7)
            2 
            >>> [el.step for el in out7]
            ['C', 'D'] 

            

            
            >>> a = stream.Stream()
            >>> n = note.Note('G')
            >>> n.quarterLength = .5
            >>> a.repeatInsert(n, range(8))
            >>> b = stream.Stream()
            >>> b.repeatInsert(a, [0, 3, 6])
            >>> c = b.getElementsByOffset(2,6.9)
            >>> len(c)
            2 
            >>> c = b.flat.getElementsByOffset(2,6.9)
            >>> len(c)
            10 

        .. method:: getElementsNotOfClass(classFilterList)

            Return a list of all Elements that do not match the one or more classes in the `classFilterList`. A single class can be provided to the `classFilterList` parameter. 

            >>> from music21 import *
            >>> a = stream.Stream()
            >>> a.repeatInsert(note.Rest(), range(10))
            >>> for x in range(4):
            ...     n = note.Note('G#') 
            ...     n.offset = x * 3 
            ...     a.insert(n) 
            >>> found = a.getElementsNotOfClass(note.Note)
            >>> len(found)
            10 
            >>> b = stream.Stream()
            >>> b.repeatInsert(note.Rest(), range(15))
            >>> a.insert(b)
            >>> # here, it gets elements from within a stream
            >>> # this probably should not do this, as it is one layer lower
            >>> found = a.flat.getElementsNotOfClass(note.Rest)
            >>> len(found)
            4 
            >>> found = a.flat.getElementsNotOfClass(note.Note)
            >>> len(found)
            25 

        .. method:: getInstrument(searchActiveSite=True, returnDefault=True)

            Search this stream or activeSite streams for :class:`~music21.instrument.Instrument` objects, otherwise return a default Instrument 

            >>> from music21 import *
            >>> s = stream.Score()
            >>> p1 = stream.Part()
            >>> p1.insert(instrument.Violin())
            >>> m1p1 = stream.Measure()
            >>> m1p1.append(note.Note('g'))
            >>> p1.append(m1p1)
            >>> p2 = stream.Part()
            >>> p2.insert(instrument.Viola())
            >>> m1p2 = stream.Measure()
            >>> m1p2.append(note.Note('f#'))
            >>> p2.append(m1p2)
            >>> s.insert(0, p1)
            >>> s.insert(0, p2)
            >>> p1.getInstrument(returnDefault=False).instrumentName
            'Violin' 
            >>> p2.getInstrument(returnDefault=False).instrumentName
            'Viola' 

        .. method:: getKeySignatures(searchActiveSite=True, searchContext=True)

            Collect all :class:`~music21.key.KeySignature` objects in this Stream in a new Stream. Optionally search the activeSite stream and/or contexts. If no KeySignature objects are defined, returns an empty Stream 

            >>> from music21 import *
            >>> a = stream.Stream()
            >>> b = key.KeySignature(3)
            >>> a.insert(0, b)
            >>> a.repeatInsert(note.Note("C#"), range(10))
            >>> c = a.getKeySignatures()
            >>> len(c) == 1
            True 

        .. method:: getOffsetByElement(obj)

            Given an object, return the offset of that object in the context of this Stream. This method can be called on a flat representation to return the ultimate position of a nested structure. 

            >>> from music21 import *
            >>> n1 = note.Note('A')
            >>> n2 = note.Note('B')
            >>> s1 = stream.Stream()
            >>> s1.insert(10, n1)
            >>> s1.insert(100, n2)
            >>> s2 = stream.Stream()
            >>> s2.insert(10, s1)
            >>> s2.flat.getOffsetBySite(n1) # this will not work
            Traceback (most recent call last): 
            DefinedContextsException: ... 
            >>> s2.flat.getOffsetByElement(n1)
            20.0 
            >>> s2.flat.getOffsetByElement(n2)
            110.0 

        .. method:: getOverlaps(includeDurationless=True, includeEndBoundary=False)

            Find any elements that overlap. Overlaping might include elements that have no duration but that are simultaneous. Whether elements with None durations are included is determined by includeDurationless. This method returns a dictionary, where keys are the start time of the first overlap and value are a list of all objects included in that overlap group. This example demonstrates end-joing overlaps: there are four quarter notes each following each other. Whether or not these count as overlaps is determined by the includeEndBoundary parameter. 

            >>> from music21 import *
            >>> a = stream.Stream()
            >>> for x in range(4):
            ...     n = note.Note('G#') 
            ...     n.duration = duration.Duration('quarter') 
            ...     n.offset = x * 1 
            ...     a.insert(n) 
            ... 
            >>> d = a.getOverlaps(True, False)
            >>> len(d)
            0 
            >>> d = a.getOverlaps(True, True) # including coincident boundaries
            >>> len(d)
            1 
            >>> len(d[0])
            4 
            >>> a = stream.Stream()
            >>> for x in [0,0,0,0,13,13,13]:
            ...     n = note.Note('G#') 
            ...     n.duration = duration.Duration('half') 
            ...     n.offset = x 
            ...     a.insert(n) 
            ... 
            >>> d = a.getOverlaps()
            >>> len(d[0])
            4 
            >>> len(d[13])
            3 
            >>> a = stream.Stream()
            >>> for x in [0,0,0,0,3,3,3]:
            ...     n = note.Note('G#') 
            ...     n.duration = duration.Duration('whole') 
            ...     n.offset = x 
            ...     a.insert(n) 
            ... 
            >>> # default is to not include coincident boundaries
            >>> d = a.getOverlaps()
            >>> len(d[0])
            7 

            

            

        .. method:: getSimultaneous(includeDurationless=True)

            Find and return any elements that start at the same time. 

            >>> from music21 import *
            >>> stream1 = stream.Stream()
            >>> for x in range(4):
            ...     n = note.Note('G#') 
            ...     n.offset = x * 0 
            ...     stream1.insert(n) 
            ... 
            >>> b = stream1.getSimultaneous()
            >>> len(b[0]) == 4
            True 
            >>> stream2 = stream.Stream()
            >>> for x in range(4):
            ...     n = note.Note('G#') 
            ...     n.offset = x * 3 
            ...     stream2.insert(n) 
            ... 
            >>> d = stream2.getSimultaneous()
            >>> len(d) == 0
            True 

        .. method:: getTimeSignatures(searchContext=True, returnDefault=True, sortByCreationTime=True)

            Collect all :class:`~music21.meter.TimeSignature` objects in this stream. If no TimeSignature objects are defined, get a default (4/4 or whatever is defined in the defaults.py file). 

            

            >>> from music21 import *
            >>> a = stream.Stream()
            >>> b = meter.TimeSignature('3/4')
            >>> a.insert(b)
            >>> a.repeatInsert(note.Note("C#"), range(10))
            >>> c = a.getTimeSignatures()
            >>> len(c) == 1
            True 

        .. method:: groupCount()

            Get a dictionary for each groupId and the count of instances. 

            >>> from music21 import *
            >>> a = stream.Stream()
            >>> n = note.Note()
            >>> a.repeatAppend(n, 30)
            >>> a.addGroupForElements('P1')
            >>> a.groupCount()
            {'P1': 30} 
            >>> a[12].groups.append('green')
            >>> a.groupCount()
            {'P1': 30, 'green': 1} 

        .. method:: groupElementsByOffset(returnDict=False)

            returns a List of lists in which each entry in the main list is a list of elements occurring at the same time. list is ordered by offset (since we need to sort the list anyhow in order to group the elements), so there is no need to call stream.sorted before running this, but it can't hurt. 

            it is DEFINITELY a feature that this method does not find elements within substreams that have the same absolute offset.  See Score.lily for how this is useful.  For the other behavior, call Stream.flat first. 

            

            

            

            

        .. method:: hasElement(obj)

            Return True if an element, provided as an argument, is contained in this Stream. 

            >>> from music21 import *
            >>> s = stream.Stream()
            >>> n1 = note.Note('g')
            >>> n2 = note.Note('g#')
            >>> s.append(n1)
            >>> s.hasElement(n1)
            True 

        .. method:: hasMeasures()

            Return a boolean value showing if this Stream contains Measures 

        .. method:: hasPartLikeStreams()

            Return a boolean value showing if this Stream contains multiple Parts, or Part-like sub-Streams. 

        .. method:: hasVoices()

            Return a boolean value showing if this Stream contains Voices 

        .. method:: index(obj)

            Return the first matched index for the specified object. 

            >>> from music21 import *
            >>> a = stream.Stream()
            >>> fSharp = note.Note("F#")
            >>> a.repeatInsert(note.Note("A#"), range(10))
            >>> a.append(fSharp)
            >>> a.index(fSharp)
            10 

        .. method:: indexList(obj, firstMatchOnly=False)

            Return a list of one or more index values where the supplied object is found on this Stream's `elements` list. To just return the first matched index, set `firstMatchOnly` to True. The `obj` parameter may be an object or an id of an object. No matches are found, an empty list is returned. Matching is based exclusively on id() of objects. 

            >>> from music21 import *
            >>> s = stream.Stream()
            >>> n1 = note.Note('g')
            >>> n2 = note.Note('g#')
            >>> s.insert(0, n1)
            >>> s.insert(5, n2)
            >>> len(s)
            2 
            >>> s.indexList(n1)
            [0] 
            >>> s.indexList(n2)
            [1] 

        .. method:: insertAtNativeOffset(item)

            Inserts an item at the offset that was defined before the item was inserted into a Stream. That is item.getOffsetBySite(None); in fact, the entire code is self.insert(item.getOffsetBySite(None), item) 

            >>> from music21 import *
            >>> n1 = note.Note("F-")
            >>> n1.offset = 20.0
            >>> stream1 = stream.Stream()
            >>> stream1.append(n1)
            >>> n1.getOffsetBySite(stream1)
            0.0 
            >>> n1.offset
            0.0 
            >>> stream2 = stream.Stream()
            >>> stream2.insertAtNativeOffset(n1)
            >>> stream2[0].offset
            20.0 
            >>> n1.getOffsetBySite(stream2)
            20.0 

        .. method:: internalize(container=None, classFilterList=['GeneralNote', 'Rest', 'Chord'])

            Gather all notes and related classes of this Stream and place inside a new container (like a Voice) in this Stream. 

        .. method:: invertDiatonic(inversionNote=<music21.note.Note C>, inPlace=True)

            inverts a stream diatonically around the given note (by default, middle C) For pieces where the key signature does not change throughout the piece it is MUCH faster than for pieces where the key signature changes. Here in this test, we put Ciconia's Quod Jactatur (a single voice piece that should have a canon solution: see trecento.quodJactatur) into 3 flats (instead of its original 1 flat) in measure 1, but into 5 sharps in measure 2 and then invert around F4, creating a new piece. 

            >>> from music21 import *
            >>> qj = corpus.parse('ciconia/quod_jactatur').parts[0]
            >>> qj.measures(1,2).show('text')
            {0.0} <music21.stream.Measure 1 offset=0.0> 
            {0.0} <music21.clef.Treble8vbClef object at 0x...> 
            {0.0} <music21.instrument.Instrument P1: MusicXML Part: Grand Piano> 
            {0.0} <music21.key.KeySignature of 1 flat> 
            {0.0} <music21.meter.TimeSignature 2/4> 
            {0.0} <music21.layout.SystemLayout object at 0x...> 
            {0.0} <music21.note.Note C> 
            {1.5} <music21.note.Note D> 
            {2.0} <music21.stream.Measure 2 offset=2.0> 
            {0.0} <music21.note.Note E> 
            {0.5} <music21.note.Note D> 
            {1.0} <music21.note.Note C> 
            {1.5} <music21.note.Note D> 
            >>> k1 = qj.flat.getElementsByClass(key.KeySignature)[0]
            >>> qj.flat.replace(k1, key.KeySignature(-3))
            >>> qj.getElementsByClass(stream.Measure)[1].insert(0, key.KeySignature(5))
            >>> qj2 = qj.invertDiatonic(note.Note('F4'), inPlace = False)
            >>> qj2.measures(1,2).show('text')
            {0.0} <music21.stream.Measure 1 offset=0.0> 
            {0.0} <music21.clef.Treble8vbClef object at 0x...> 
            {0.0} <music21.instrument.Instrument P1: MusicXML Part: Grand Piano> 
            {0.0} <music21.key.KeySignature of 3 flats> 
            {0.0} <music21.meter.TimeSignature 2/4> 
            {0.0} <music21.layout.SystemLayout object at 0x...> 
            {0.0} <music21.note.Note B-> 
            {1.5} <music21.note.Note A-> 
            {2.0} <music21.stream.Measure 2 offset=2.0> 
            {2.0} <music21.key.KeySignature of 5 sharps> 
            {2.0} <music21.note.Note G#> 
            {2.5} <music21.note.Note A#> 
            {3.0} <music21.note.Note B> 
            {3.5} <music21.note.Note A#> 

        .. method:: isSequence(includeDurationless=True, includeEndBoundary=False)

            A stream is a sequence if it has no overlaps. 

            >>> from music21 import *
            >>> a = stream.Stream()
            >>> for x in [0,0,0,0,3,3,3]:
            ...     n = note.Note('G#') 
            ...     n.duration = duration.Duration('whole') 
            ...     n.offset = x * 1 
            ...     a.insert(n) 
            ... 
            >>> a.isSequence()
            False 

        .. method:: makeAccidentals(pitchPast=None, useKeySignature=True, alteredPitches=None, searchKeySignatureByContext=False, cautionaryPitchClass=True, cautionaryAll=False, inPlace=True, overrideStatus=False, cautionaryNotImmediateRepeat=True)

            A method to set and provide accidentals given varous conditions and contexts. If `useKeySignature` is True, a :class:`~music21.key.KeySignature` will be searched for in this Stream or this Stream's defined contexts. An alternative KeySignature can be supplied with this object and used for temporary pitch processing. If `alteredPitches` is a list of modified pitches (Pitches with Accidentals) that can be directly supplied to Accidental processing. These are the same values obtained from a :class:`music21.key.KeySignature` object using the :attr:`~music21.key.KeySignature.alteredPitches` property. If `cautionaryPitchClass` is True, comparisons to past accidentals are made regardless of register. That is, if a past sharp is found two octaves above a present natural, a natural sign is still displayed. If `cautionaryAll` is True, all accidentals are shown. If `overrideStatus` is True, this method will ignore any current `displayStatus` stetting found on the Accidental. By default this does not happen. If `displayStatus` is set to None, the Accidental's `displayStatus` is set. If `cautionaryNotImmediateRepeat` is True, cautionary accidentals will be displayed for an altered pitch even if that pitch had already been displayed as altered. The :meth:`~music21.pitch.Pitch.updateAccidentalDisplay` method is used to determine if an accidental is necessary. This will assume that the complete Stream is the context of evaluation. For smaller context ranges, call this on Measure objects. If `inPlace` is True, this is done in-place; if `inPlace` is False, this returns a modified deep copy. 

            

        .. method:: makeBeams(inPlace=True)

            Return a new measure with beams applied to all notes. In the process of making Beams, this method also updates tuplet types. This is destructive and thus changes an attribute of Durations in Notes. If `inPlace` is True, this is done in-place; if `inPlace` is False, this returns a modified deep copy. 

            >>> from music21 import *
            >>> aMeasure = stream.Measure()
            >>> aMeasure.timeSignature = meter.TimeSignature('4/4')
            >>> aNote = note.Note()
            >>> aNote.quarterLength = .25
            >>> aMeasure.repeatAppend(aNote,16)
            >>> bMeasure = aMeasure.makeBeams()

        .. method:: makeChords(minimumWindowSize=0.125, includePostWindow=True, removeRedundantPitches=True, gatherArticulations=True, gatherExpressions=True, inPlace=False)

            Gathers simultaneously sounding :class:`~music21.note.Note` objects into :class:`~music21.chord.Chord` objects, each of which contains all the pitches sounding together. 

            This first example puts a part with three quarter notes (C4, D4, E4) together with a part consisting of a half note (C#5) and a quarter note (E#5) to make two Chords, the first containing the three :class:`~music21.pitch.Pitch` objects sounding at the beginning, the second consisting of the two Pitches sounding on offset 2.0 (beat 3): 

            

            >>> from music21 import *
            >>> p1 = stream.Part()
            >>> p1.append([note.QuarterNote("C4"), note.QuarterNote("D4"), note.QuarterNote("E4")])
            >>> p2 = stream.Part()
            >>> p2.append([note.HalfNote("C#5"), note.QuarterNote("E#5")])
            >>> sc1 = stream.Score()
            >>> sc1.insert(0, p1)
            >>> sc1.insert(0, p2)
            >>> scChords = sc1.flat.makeChords()
            >>> scChords.show('text')
            {0.0} <music21.chord.Chord C4 C#5 D4> 
            {2.0} <music21.chord.Chord E4 E#5> 

            

            
            The gathering of elements, starting from offset 0.0, uses 
            the `minimumWindowSize`, in quarter lengths, to collect 
            all Notes that start between 0.0 and the minimum window 
            size (this permits overlaps within a minimum tolerance). 

            
            After collection, the maximum duration of collected elements 
            is found; this duration is then used to set the new 
            starting offset. A possible gap then results between the end 
            of the window and offset specified by the maximum duration; 
            these additional notes are gathered in a second pass if 
            `includePostWindow` is True. 

            
            The new start offset is shifted to the larger of either 
            the minimum window or the maximum duration found in the 
            collected group. The process is repeated until all offsets 
            are covered. 

            
            Each collection of Notes is formed into a Chord. The Chord 
            is given the longest duration of all constituents, and is 
            inserted at the start offset of the window from which it 
            was gathered. 

            
            Chords can gather both articulations and expressions from found Notes 
            using `gatherArticulations` and `gatherExpressions`. 

            
            The resulting Stream, if not in-place, can also gather 
            additional objects by placing class names in the `collect` list. 
            By default, TimeSignature and KeySignature objects are collected. 

            

            

        .. method:: makeMeasures(meterStream=None, refStreamOrTimeRange=None, inPlace=False)

            Takes a stream and places all of its elements into measures (:class:`~music21.stream.Measure` objects) based on the :class:`~music21.meter.TimeSignature` objects placed within the stream. If no TimeSignatures are found in the stream, a default of 4/4 is used. 

            If `inPlace` is True, the original Stream is modified and lost if `inPlace` is False, this returns a modified deep copy. 

            Two advanced features are provided: 

            (1) If a `meterStream` is provided, the TimeSignatures in this stream are used instead of any found in the Stream. Alternatively, a single TimeSignature object can be provided in lieu of the stream. This feature lets you test out how a group of notes might be interpreted as measures in a number of different metrical schemes. 

            (2) If `refStreamOrTimeRange` is provided, this Stream or List is used to give the span that you want to make measures for necessary to fill empty rests at the ends or beginnings of Streams, etc.  Say for instance you'd like to make a complete score from a short ossia section, then you might use another Part from the Score as a `refStreamOrTimeRange` to make sure that the appropriate measures of rests are added at either side. 

            Here is a simple example of makeMeasures: a single measure of 4/4 is created by from a stream containing only three quarter notes: 

            >>> from music21 import *
            >>> sSrc = stream.Stream()
            >>> sSrc.append(note.QuarterNote('C4'))
            >>> sSrc.append(note.QuarterNote('D4'))
            >>> sSrc.append(note.QuarterNote('E4'))
            >>> sMeasures = sSrc.makeMeasures()
            >>> sMeasures.show('text')
            {0.0} <music21.stream.Measure 1 offset=0.0> 
            {0.0} <music21.meter.TimeSignature 4/4> 
            {0.0} <music21.clef.TrebleClef object at 0x...> 
            {0.0} <music21.note.Note C> 
            {1.0} <music21.note.Note D> 
            {2.0} <music21.note.Note E> 

            
            Notice that the last measure is incomplete -- makeMeasures 
            does not fill up incomplete measures. 
            We can also check that the measure created has 
            the correct TimeSignature: 

            
            >>> sMeasures[0].timeSignature
            <music21.meter.TimeSignature 4/4> 

            
            Now let's redo this work in 2/4 by putting a TimeSignature 
            of 2/4 at the beginning of the stream and rerunning 
            makeMeasures. Now we will have two measures, each with 
            correct measure numbers: 

            
            >>> sSrc.insert(0.0, meter.TimeSignature('2/4'))
            >>> sMeasuresTwoFour = sSrc.makeMeasures()
            >>> sMeasuresTwoFour.show('text')
            {0.0} <music21.stream.Measure 1 offset=0.0> 
            {0.0} <music21.meter.TimeSignature 2/4> 
            {0.0} <music21.clef.TrebleClef object at 0x...> 
            {0.0} <music21.note.Note C> 
            {1.0} <music21.note.Note D> 
            {2.0} <music21.stream.Measure 2 offset=2.0> 
            {0.0} <music21.note.Note E> 

            
            Let us put 10 quarter notes in a Part. 
            After we run makeMeasures, we will have 
            3 measures of 4/4 in a new Part object. This experiment 
            demonstrates that running makeMeasures does not 
            change the type of Stream you are using: 

            
            >>> sSrc = stream.Part()
            >>> n = note.Note('E-4')
            >>> n.quarterLength = 1
            >>> sSrc.repeatAppend(n, 10)
            >>> sMeasures = sSrc.makeMeasures()
            >>> len(sMeasures.getElementsByClass('Measure'))
            3 
            >>> sMeasures.__class__.__name__
            'Part' 

            
            If after running makeMeasures you run makeTies, it will also split 
            long notes into smaller notes with ties.  Lyrics and articulations 
            are attached to the first note.  Expressions (fermatas, 
            etc.) will soon be attached to the last note but this is not yet done: 

            
            >>> p1 = stream.Part()
            >>> p1.append(meter.TimeSignature('3/4'))
            >>> longNote = note.Note("D#4")
            >>> longNote.quarterLength = 7.5
            >>> longNote.articulations = [articulations.Staccato()]
            >>> longNote.lyric = "hi"
            >>> p1.append(longNote)
            >>> partWithMeasures = p1.makeMeasures()
            >>> dummy = partWithMeasures.makeTies(inPlace = True)
            >>> partWithMeasures.show('text')
            {0.0} <music21.stream.Measure 1 offset=0.0> 
            {0.0} <music21.meter.TimeSignature 3/4> 
            {0.0} <music21.clef.TrebleClef object at 0x...> 
            {0.0} <music21.note.Note D#> 
            {3.0} <music21.stream.Measure 2 offset=3.0> 
            {0.0} <music21.note.Note D#> 
            {6.0} <music21.stream.Measure 3 offset=6.0> 
            {0.0} <music21.note.Note D#> 
            >>> allNotes = partWithMeasures.flat.notes
            >>> [allNotes[0].articulations, allNotes[1].articulations, allNotes[2].articulations]
            [[<music21.articulations.Staccato>], [], []] 
            >>> [allNotes[0].lyric, allNotes[1].lyric, allNotes[2].lyric]
            ['hi', None, None] 

        .. method:: makeNotation(meterStream=None, refStreamOrTimeRange=None, inPlace=False)

            This method calls a sequence of Stream methods on this Stream to prepare notation, including creating Measures if necessary, creating ties, beams, and accidentals. If `inPlace` is True, this is done in-place; if `inPlace` is False, this returns a modified deep copy. 

            >>> from music21 import *
            >>> s = stream.Stream()
            >>> n = note.Note('g')
            >>> n.quarterLength = 1.5
            >>> s.repeatAppend(n, 10)
            >>> sMeasures = s.makeNotation()
            >>> len(sMeasures.getElementsByClass('Measure'))
            4 

        .. method:: makeRests(refStreamOrTimeRange=None, fillGaps=False, inPlace=True)

            Given a Stream with an offset not equal to zero, fill with one Rest preeceding this offset. If `refStreamOrTimeRange` is provided as a Stream, this Stream is used to get min and max offsets. If a list is provided, the list assumed to provide minimum and maximum offsets. Rests will be added to fill all time defined within refStream. If `fillGaps` is True, this will create rests in any time regions that have no active elements. If `inPlace` is True, this is done in-place; if `inPlace` is False, this returns a modified deepcopy. 

            >>> from music21 import *
            >>> a = stream.Stream()
            >>> a.insert(20, note.Note())
            >>> len(a)
            1 
            >>> a.lowestOffset
            20.0 
            >>> b = a.makeRests()
            >>> len(b)
            2 
            >>> b.lowestOffset
            0.0 

        .. method:: makeTies(meterStream=None, inPlace=True, displayTiedAccidentals=False)

            Given a stream containing measures, examine each element in the Stream. If the elements duration extends beyond the measures boundary, create a tied entity, placing the split Note in the next Measure. Note that his method assumes that there is appropriate space in the next Measure: this will not shift Note, but instead allocate them evenly over barlines. Generall, makeMeasures is called prior to calling this method. If `inPlace` is True, this is done in-place; if `inPlace` is False, this returns a modified deep copy. 

            >>> from music21 import *
            >>> d = stream.Stream()
            >>> n = note.Note()
            >>> n.quarterLength = 12
            >>> d.repeatAppend(n, 10)
            >>> d.repeatInsert(n, [x+.5 for x in range(10)])
            >>> x = d.makeMeasures()
            >>> x = x.makeTies()

        .. method:: makeTupletBrackets(inPlace=True)

            Given a Stream of mixed durations, the first and last tuplet of any group of tuplets must be designated as the start and end. Need to not only look at Notes, but components within Notes, as these might contain additional tuplets. 

        .. method:: measure(measureNumber, collect=[<class 'music21.clef.Clef'>, <class 'music21.meter.TimeSignature'>, <class 'music21.instrument.Instrument'>, <class 'music21.key.KeySignature'>])

            Given a measure number, return a single :class:`~music21.stream.Measure` object if the Measure number exists, otherwise return None. This method is distinguished from :meth:`~music21.stream.Stream.measures` in that this method returns a single Measure object, not a Stream containing one or more Measure objects. 

            >>> from music21 import *
            >>> a = corpus.parse('bach/bwv324.xml')
            >>> a.parts[0].measure(3)
            <music21.stream.Measure 3 offset=0.0> 

        .. method:: measureOffsetMap(classFilterList=None)

            If this Stream contains Measures, provide a dictionary whose keys are the offsets of the start of each measure and whose values are a list of references to the :class:`~music21.stream.Measure` objects that start at that offset. 

            Even in normal music there may be more than one Measure starting at each offset because each :class:`~music21.stream.Part` might define its own Measure. However, you are unlikely to encounter such things unless you run Score.semiFlat, which retains all the containers found in the score. 

            The offsets are always measured relative to the calling Stream (self). 

            You can specify a `classFilterList` argument as a list of classes to find instead of Measures.  But the default will of course find Measure objects. 

            Example 1: This Bach chorale is in 4/4 without a pickup, so as expected, measures are found every 4 offsets, until the weird recitation in m. 7 which in our edition lasts 10 beats and thus causes a gap in measureOffsetMap from 24.0 to 34.0. 

            


            .. image:: images/streamMeasureOffsetMapBWV324.*
                :width: 572


            

            

            >>> from music21 import *
            >>> chorale = corpus.parse('bach/bwv324.xml')
            >>> alto = chorale.parts['alto']
            >>> altoMeasures = alto.measureOffsetMap()
            >>> sorted(altoMeasures.keys())
            [0.0, 4.0, 8.0, 12.0, 16.0, 20.0, 24.0, 34.0, 38.0] 

            
            altoMeasures is a dictionary (hash) of the measures 
            that are found in the alto part, so we can get 
            the measure beginning on offset 4.0 (measure 2) 
            and display it (though it's the only measure 
            found at offset 4.0, there might be others as 
            in example 2, so we need to call altoMeasures[4.0][0] 
            to get this measure.): 

            
            >>> altoMeasures[4.0]
            [<music21.stream.Measure 2 offset=4.0>] 
            >>> altoMeasures[4.0][0].show('text')
            {0.0} <music21.note.Note D> 
            {1.0} <music21.note.Note D#> 
            {2.0} <music21.note.Note E> 
            {3.0} <music21.note.Note F#> 

            
            Example 2: How to get all the measures from all parts (not the 
            most efficient way, but it works!).  Note that 
            you first need to call semiFlat, which finds all containers 
            (and other elements) nested inside all parts: 

            
            >>> choraleSemiFlat = chorale.semiFlat
            >>> choraleMeasures = chorale.measureOffsetMap()
            >>> choraleMeasures[4.0]
            [<music21.stream.Measure 2 offset=4.0>, <music21.stream.Measure 2 offset=4.0>, <music21.stream.Measure 2 offset=4.0>, <music21.stream.Measure 2 offset=4.0>] 

            

            

        .. method:: measures(numberStart, numberEnd, collect=[<class 'music21.clef.Clef'>, <class 'music21.meter.TimeSignature'>, <class 'music21.instrument.Instrument'>, <class 'music21.key.KeySignature'>], gatherSpanners=True)

            Get a region of Measures based on a start and end Measure number, were the boundary numbers are both included. That is, a request for measures 4 through 10 will return 7 Measures, numbers 4 through 10. Additionally, any number of associated classes can be gathered as well. Associated classes are the last found class relevant to this Stream or Part. While all elements in the source are made available in the extracted region, new Measure objects are created and returned. 

            >>> from music21 import *
            >>> a = corpus.parse('bach/bwv324.xml')
            >>> b = a.parts[0].measures(4,6)
            >>> len(b)
            3 

            

        .. method:: melodicIntervals(*skipArgs, **skipKeywords)

            Returns a Stream of :class:`~music21.interval.Interval` objects between Notes (and by default, Chords) that follow each other in a stream. the offset of the Interval is the offset of the beginning of the interval (if two notes are adjacent, then this offset is equal to the offset of the second note) See Stream.findConsecutiveNotes for a discussion of what consecutive notes mean, and which keywords are allowed. The interval between a Note and a Chord (or between two chords) is the interval between pitches[0]. For more complex interval calculations, run findConsecutiveNotes and then use notesToInterval. Returns None of there are not at least two elements found by findConsecutiveNotes. See Test.testMelodicIntervals() for usage details. 

            

        .. method:: mergeElements(other, classFilterList=[])

            Given another Stream, store references of each element in the other Stream in this Stream. This does not make copies of any elements, but simply stores all of them in this Stream. Optionally, provide a list of classes to exclude with the `classFilter` list. This method provides functionality like a shallow copy, but manages locations properly, only copies elements, and permits filtering by class type. 

            >>> from music21 import *
            >>> s1 = stream.Stream()
            >>> s2 = stream.Stream()
            >>> n1 = note.Note('f#')
            >>> n2 = note.Note('g')
            >>> s1.append(n1)
            >>> s1.append(n2)
            >>> s2.mergeElements(s1)
            >>> len(s2)
            2 
            >>> s1[0] is s2[0]
            True 
            >>> s1[1] is s2[1]
            True 

        .. method:: pitchAttributeCount(pitchAttr=name)

            Return a dictionary of pitch class usage (count) by selecting an attribute of the Pitch object. 

            >>> from music21 import corpus
            >>> a = corpus.parse('bach/bwv324.xml')
            >>> a.pitchAttributeCount('pitchClass')
            {0: 3, 2: 25, 3: 3, 4: 14, 6: 15, 7: 13, 9: 17, 11: 14} 
            >>> a.pitchAttributeCount('name')
            {u'A': 17, u'C': 3, u'B': 14, u'E': 14, u'D': 25, u'G': 13, u'D#': 3, u'F#': 15} 
            >>> a.pitchAttributeCount('nameWithOctave')
            {u'E3': 4, u'G4': 2, u'F#4': 2, u'A2': 2, u'E2': 1, u'G2': 1, u'D3': 9, u'D#3': 1, u'B4': 7, u'A3': 5, u'F#3': 13, u'A4': 10, u'B2': 3, u'B3': 4, u'C3': 2, u'E4': 9, u'D4': 14, u'D5': 2, u'D#4': 2, u'C5': 1, u'G3': 10} 

        .. method:: playingWhenAttacked(el, elStream=None)

            Given an element (from another Stream) returns the single element in this Stream that is sounding while the given element starts. 

            If there are multiple elements sounding at the moment it is attacked, the method returns the first element of the same class as this element, if any. If no element is of the same class, then the first element encountered is returned. For more complex usages, use allPlayingWhileSounding. 

            Returns None if no elements fit the bill. 

            The optional elStream is the stream in which el is found. If provided, el's offset in that Stream is used.  Otherwise, the current offset in el is used.  It is just in case you are paranoid that el.offset might not be what you want, because of some fancy manipulation of el.activeSite 

            

            >>> from music21 import *
            >>> n1 = note.Note("G#")
            >>> n2 = note.Note("D#")
            >>> s1 = stream.Stream()
            >>> s1.insert(20.0, n1)
            >>> s1.insert(21.0, n2)
            >>> n3 = note.Note("C#")
            >>> s2 = stream.Stream()
            >>> s2.insert(20.0, n3)
            >>> s1.playingWhenAttacked(n3).name
            'G#' 
            >>> n3.setOffsetBySite(s2, 20.5)
            >>> s1.playingWhenAttacked(n3).name
            'G#' 
            >>> n3.setOffsetBySite(s2, 21.0)
            >>> n3.offset
            21.0 
            >>> s1.playingWhenAttacked(n3).name
            'D#' 

            

            
            Optionally, specify the site to get the offset from: 

            

            
            >>> n3.setOffsetBySite(None, 100)
            >>> n3.activeSite = None
            >>> s1.playingWhenAttacked(n3)
            <BLANKLINE> 
            >>> s1.playingWhenAttacked(n3, s2).name
            'D#' 

            

            

        .. method:: plot(*args, **keywords)

            Given a method and keyword configuration arguments, create and display a plot. Note: plot() requires the Python package matplotib to be installed. For details on arguments this function takes, see :func:`~music21.graph.plotStream`. Available plots include the following Plot classes: :class:`~music21.graph.PlotHistogramPitchSpace` :class:`~music21.graph.PlotHistogramPitchClass` :class:`~music21.graph.PlotHistogramQuarterLength` :class:`~music21.graph.PlotScatterPitchSpaceQuarterLength` :class:`~music21.graph.PlotScatterPitchClassQuarterLength` :class:`~music21.graph.PlotScatterPitchClassOffset` :class:`~music21.graph.PlotScatterPitchSpaceDynamicSymbol` :class:`~music21.graph.PlotHorizontalBarPitchSpaceOffset` :class:`~music21.graph.PlotHorizontalBarPitchClassOffset` :class:`~music21.graph.PlotScatterWeightedPitchSpaceQuarterLength` :class:`~music21.graph.PlotScatterWeightedPitchClassQuarterLength` :class:`~music21.graph.PlotScatterWeightedPitchSpaceDynamicSymbol` :class:`~music21.graph.Plot3DBarsPitchSpaceQuarterLength` :class:`~music21.graph.PlotWindowedKrumhanslSchmuckler` :class:`~music21.graph.PlotWindowedKrumhanslKessler` :class:`~music21.graph.PlotWindowedAardenEssen` :class:`~music21.graph.PlotWindowedSimpleWeights` :class:`~music21.graph.PlotWindowedBellmanBudge` :class:`~music21.graph.PlotWindowedTemperleyKostkaPayne` :class:`~music21.graph.PlotWindowedAmbitus` 

            >>> from music21 import *
            >>> s = corpus.parse('bach/bwv57.8')
            >>> s.plot('pianoroll')


            .. image:: images/PlotHorizontalBarPitchSpaceOffset.*
                :width: 600


            

        .. method:: pop(index)

            Return and remove the object found at the user-specified index value. Index values are those found in `elements` and are not necessary offset order. 

            >>> from music21 import *
            >>> a = stream.Stream()
            >>> a.repeatInsert(note.Note("C"), range(10))
            >>> junk = a.pop(0)
            >>> len(a)
            9 

        .. method:: quantize(quarterLengthDivisors=[4, 3], processOffsets=True, processDurations=False)

            Quantize time values in this Stream by snapping offsets and/or durations to the nearest multiple of a quarter length value given as one or more divisors of 1 quarter length. The quantized value found closest to a divisor multiple will be used. The `quarterLengthDivisors` provides a flexible way to provide quantization settings. For example, [2] will snap all events to eighth note grid. [4, 3] will snap events to sixteenth notes and eighth note triplets, whichever is closer. [4, 6] will snap events to sixteenth notes and sixteenth note triplets. 

            >>> from music21 import *
            >>> n = note.Note()
            >>> n.quarterLength = .49
            >>> s = stream.Stream()
            >>> s.repeatInsert(n, [0.1, .49, .9, 1.51])
            >>> s.quantize([4], processOffsets=True, processDurations=True)
            >>> [e.offset for e in s]
            [0.0, 0.5, 1.0, 1.5] 
            >>> [e.duration.quarterLength for e in s]
            [0.5, 0.5, 0.5, 0.5] 

        .. method:: recurse(direction=downward, streamsOnly=False, restoreActiveSites=True, skipDuplicates=True, classFilter=[])

            Return a list of all Music21Objects, starting with self, continuing with self's elements, and whenever finding a Stream subclass in self, that Stream subclasse's elements. 

        .. method:: remove(target, firstMatchOnly=True)

            Remove an object from this Stream. Additionally, this Stream is removed from the object's sites in :class:`~music21.base.DefinedContexts`. By default, only the first match is removed. This can be adjusted with the `firstMatchOnly` parameters. 

            >>> from music21 import *
            >>> s = stream.Stream()
            >>> n1 = note.Note('g')
            >>> n2 = note.Note('g#')
            >>> # copies of an object are not the same as the object
            >>> n3 = copy.deepcopy(n2)
            >>> s.insert(10, n1)
            >>> s.insert(5, n2)
            >>> s.remove(n1)
            >>> len(s)
            1 
            >>> s.insert(20, n3)
            >>> s.remove(n3)
            >>> [e for e in s] == [n2]
            True 

        .. method:: repeatAppend(item, numberOfTimes)

            Given an object and a number, run append that many times on a deepcopy of the object. numberOfTimes should of course be a positive integer. 

            >>> from music21 import *
            >>> a = stream.Stream()
            >>> n = note.Note()
            >>> n.duration.type = "whole"
            >>> a.repeatAppend(n, 10)
            >>> a.duration.quarterLength
            40.0 
            >>> a[9].offset
            36.0 

        .. method:: repeatInsert(item, offsets)

            Given an object, create a deep copy of each object at each positions specified by the offset list: 

            >>> from music21 import *
            >>> a = stream.Stream()
            >>> n = note.Note('G-')
            >>> n.quarterLength = 1
            >>> a.repeatInsert(n, [0, 2, 3, 4, 4.5, 5, 6, 7, 8, 9, 10, 11, 12])
            >>> len(a)
            13 
            >>> a[10].offset
            10.0 

        .. method:: replace(target, replacement, firstMatchOnly=False, allTargetSites=True)

            Given a `target` object, replace all references of that object with references to the supplied `replacement` object. 

            

            If `allTargetSites` is True (as it is by default), all sites that have a reference for the replacement will be similarly changed. This is useful for altering both a flat and nested representation. 

        .. method:: setDerivation(target)

            Manually set the Stream that this Stream was derived from. This operation is generally completed automatically. 

        .. method:: setupPickleScaffold()

            Prepare this stream and all of its contents for pickling, that is, storing on disk. 

            >>> from music21 import *
            >>> a = stream.Stream()
            >>> n = note.Note()
            >>> n.duration.type = "whole"
            >>> a.repeatAppend(n, 10)
            >>> a.setupPickleScaffold()

        .. method:: shiftElements(offset, classFilterList=None)

            Add the given offset value to every offset of the objects found in the Stream. Objects that are specifically placed at the end of the Stream via .storeAtEnd() (such as right barlines) are not affected. 

            >>> from music21 import *
            >>> a = stream.Stream()
            >>> a.repeatInsert(note.Note("C"), range(0,10))
            >>> a.shiftElements(30)
            >>> a.lowestOffset
            30.0 
            >>> a.shiftElements(-10)
            >>> a.lowestOffset
            20.0 

        .. method:: simultaneousAttacks(stream2)

            returns an ordered list of offsets where elements are started (attacked) at the same time in both self and stream2. 

            In this example, we create one stream of Qtr, Half, Qtr, and one of Half, Qtr, Qtr. There are simultaneous attacks at offset 0.0 (the beginning) and at offset 3.0, but not at 1.0 or 2.0: 

            

            >>> from music21 import *
            >>> st1 = stream.Stream()
            >>> st2 = stream.Stream()
            >>> st1.append([note.QuarterNote(), note.HalfNote(), note.QuarterNote()])
            >>> st2.append([note.HalfNote(), note.QuarterNote(), note.QuarterNote()])
            >>> print st1.simultaneousAttacks(st2)
            [0.0, 3.0] 

        .. method:: sliceAtOffsets(offsetList, target=None, addTies=True, inPlace=False, displayTiedAccidentals=False)

            Given a list of quarter lengths, slice and optionally tie all Durations at these points. 

            >>> from music21 import *
            >>> s = stream.Stream()
            >>> n = note.Note()
            >>> n.quarterLength = 4
            >>> s.append(n)
            >>> post = s.sliceAtOffsets([1, 2, 3], inPlace=True)
            >>> [(e.offset, e.quarterLength) for e in s]
            [(0.0, 1.0), (1.0, 1.0), (2.0, 1.0), (3.0, 1.0)] 

        .. method:: sliceByBeat(target=None, addTies=True, inPlace=False, displayTiedAccidentals=False)

            Slice all elements in the Stream that have a Duration at the offsets determined to be the beat from the local TimeSignature. 

        .. method:: sliceByGreatestDivisor(addTies=True, inPlace=False)

            Slice all :class:`~music21.duration.Duration` objects on all Notes of this Stream. Duration are sliced according to the approximate GCD found in all durations. 

        .. method:: sliceByQuarterLengths(quarterLengthList, target=None, addTies=True, inPlace=False)

            Slice all :class:`~music21.duration.Duration` objects on all Notes of this Stream. Duration are sliced according to values provided in `quarterLengthList` list. If the sum of these values is less than the Duration, the values are accumulated in a loop to try to fill the Duration. If a match cannot be found, an Exception is raised. If `target` == None, the entire Stream is processed. Otherwise, only the element specified is manipulated. 

        .. method:: sort()

            Sort this Stream in place by offset, then priority, then standard class sort order (e.g., Clefs before KeySignatures before TimeSignatures). Note that Streams automatically sort themsevlves unless autoSort is set to False (as in the example below) 

            

            >>> from music21 import *
            >>> n1 = note.Note('a')
            >>> n2 = note.Note('b')
            >>> s = stream.Stream()
            >>> s.autoSort = False
            >>> s.insert(100, n2)
            >>> s.insert(0, n1) # now a has a lower offset by higher index
            >>> [n.name for n in s]
            ['B', 'A'] 
            >>> s.sort()
            >>> [n.name for n in s]
            ['A', 'B'] 

        .. method:: splitByClass(classObj, fx)

            Given a stream, get all objects of type classObj and divide them into two new streams depending on the results of fx. Fx should be a lambda or other function on elements. All elements where fx returns True go in the first stream. All other elements are put in the second stream. 

            If classObj is None then all elements are returned.  ClassObj can also be a list of classes. 

            In this example, we will create 50 notes from midi note 30 (two octaves and a tritone below middle C) to midi note 80 (an octave and a minor sixth above middle C) and add them to a Stream. We then create a lambda function to split between those notes below middle C (midi note 60) and those above (google "lambda functions in Python" for more information on what these powerful tools are). 

            

            >>> from music21 import *
            >>> stream1 = stream.Stream()
            >>> for x in range(30,81):
            ...     n = note.Note() 
            ...     n.midi = x 
            ...     stream1.append(n) 
            >>> fx = lambda n: n.midi < 60
            >>> b, c = stream1.splitByClass(note.Note, fx)

            
            Stream b now contains all the notes below middle C, 
            that is, 30 notes, beginning with F#1 and ending with B3 
            while Stream c has the 21 notes from C4 to A-5: 

            
            >>> len(b)
            30 
            >>> (b[0].nameWithOctave, b[-1].nameWithOctave)
            ('F#1', 'B3') 
            >>> len(c)
            21 
            >>> (c[0].nameWithOctave, c[-1].nameWithOctave)
            ('C4', 'G#5') 

        .. method:: storeAtEnd(itemOrList, ignoreSort=False)

            Inserts an item or items at the end of the Stream, stored in the special box (called _endElements). This method is useful for putting things such as right bar lines or courtesy clefs that should always be at the end of a Stream no matter what else is appended to it As sorting is done only by priority and class, it cannot avoid setting isSorted to False. 

            

        .. method:: stripTies(inPlace=False, matchByPitch=False, retainContainers=False)

            Find all notes that are tied; remove all tied notes, then make the first of the tied notes have a duration equal to that of all tied constituents. Lastly, remove the formerly-tied notes. This method can be used on Stream and Stream subclasses. When used on a Score, Parts and Measures are retained. If `retainContainers` is False (by default), this method only returns Note objects; Measures and other structures are stripped from the Stream. Set `retainContainers` to True to remove ties from a :class:`~music21.part.Part` Stream that contains :class:`~music21.stream.Measure` Streams, and get back a multi-Measure structure. Presently, this only works if tied notes are sequentual; ultimately this will need to look at .to and .from attributes (if they exist) In some cases (under makeMeasures()) a continuation note will not have a Tie object with a stop attribute set. In that case, we need to look for sequential notes with matching pitches. The `matchByPitch` option can be used to use this technique. 

            >>> from music21 import *
            >>> a = stream.Stream()
            >>> n = note.Note()
            >>> n.quarterLength = 6
            >>> a.append(n)
            >>> m = a.makeMeasures()
            >>> m = m.makeTies()
            >>> len(m.flat.notes)
            2 
            >>> m = m.stripTies()
            >>> len(m.flat.notes)
            1 
            >>>

        .. method:: teardownPickleScaffold()

            After rebuilding this stream from pickled storage, prepare this as a normal Stream. 

            >>> from music21 import *
            >>> a = stream.Stream()
            >>> n = note.Note()
            >>> n.duration.type = "whole"
            >>> a.repeatAppend(n, 10)
            >>> a.setupPickleScaffold()
            >>> a.teardownPickleScaffold()

        .. method:: transferOffsetToElements()

            Transfer the offset of this stream to all internal elements; then set the offset of this stream to zero. 

            >>> from music21 import *
            >>> a = stream.Stream()
            >>> a.repeatInsert(note.Note("C"), range(0,10))
            >>> a.offset = 30
            >>> a.transferOffsetToElements()
            >>> a.lowestOffset
            30.0 
            >>> a.offset
            0.0 
            >>> a.offset = 20
            >>> a.transferOffsetToElements()
            >>> a.lowestOffset
            50.0 

        .. method:: trimPlayingWhileSounding(el, elStream=None, requireClass=False, padStream=False)

            Returns a Stream of deepcopies of elements in otherStream that sound at the same time as`el. but with any element that was sounding when el. begins trimmed to begin with el. and any element sounding when el ends trimmed to end with el. if padStream is set to true then empty space at the beginning and end is filled with a generic Music21Object, so that no matter what otherStream is the same length as el. Otherwise is the same as allPlayingWhileSounding -- but because these elements are deepcopies, the difference might bite you if you're not careful. Note that you can make el an empty stream of offset X and duration Y to extract exactly that much information from otherStream. 

            

        .. method:: voicesToParts()

            If this Stream defines one or more voices, extract each into a Part, returning a Score. If this Stream has no voice, return the Stream as a Part within a Score. 

        Methods inherited from :class:`~music21.base.Music21Object`: :meth:`~music21.base.Music21Object.addContext`, :meth:`~music21.base.Music21Object.addLocation`, :meth:`~music21.base.Music21Object.addLocationAndActiveSite`, :meth:`~music21.base.Music21Object.freezeIds`, :meth:`~music21.base.Music21Object.getAllContextsByClass`, :meth:`~music21.base.Music21Object.getCommonSiteIds`, :meth:`~music21.base.Music21Object.getCommonSites`, :meth:`~music21.base.Music21Object.getContextAttr`, :meth:`~music21.base.Music21Object.getContextByClass`, :meth:`~music21.base.Music21Object.getOffsetBySite`, :meth:`~music21.base.Music21Object.getSiteIds`, :meth:`~music21.base.Music21Object.getSites`, :meth:`~music21.base.Music21Object.getSpannerSites`, :meth:`~music21.base.Music21Object.hasContext`, :meth:`~music21.base.Music21Object.mergeAttributes`, :meth:`~music21.base.Music21Object.purgeLocations`, :meth:`~music21.base.Music21Object.removeLocationBySite`, :meth:`~music21.base.Music21Object.removeLocationBySiteId`, :meth:`~music21.base.Music21Object.searchParentByAttr`, :meth:`~music21.base.Music21Object.setContextAttr`, :meth:`~music21.base.Music21Object.setOffsetBySite`, :meth:`~music21.base.Music21Object.show`, :meth:`~music21.base.Music21Object.splitAtDurations`, :meth:`~music21.base.Music21Object.splitAtQuarterLength`, :meth:`~music21.base.Music21Object.splitByQuarterLengths`, :meth:`~music21.base.Music21Object.unfreezeIds`, :meth:`~music21.base.Music21Object.unwrapWeakref`, :meth:`~music21.base.Music21Object.wrapWeakref`, :meth:`~music21.base.Music21Object.write`

        Methods inherited from :class:`~music21.base.JSONSerializer`: :meth:`~music21.base.JSONSerializer.jsonAttributes`, :meth:`~music21.base.JSONSerializer.jsonComponentFactory`, :meth:`~music21.base.JSONSerializer.jsonPrint`, :meth:`~music21.base.JSONSerializer.jsonRead`, :meth:`~music21.base.JSONSerializer.jsonWrite`


Measure
-------

Inherits from: :class:`~music21.stream.Stream`, :class:`~music21.base.Music21Object`, :class:`~music21.base.JSONSerializer`

.. class:: Measure(*args, **keywords)

    A representation of a Measure organized as a Stream. All properties of a Measure that are Music21 objects are found as part of the Stream's elements. 

    **Measure** **attributes**

        .. attribute:: number

            A number representing the displayed or shown Measure number as presented in a written Score. 

        .. attribute:: timeSignatureIsNew

            Boolean describing if the TimeSignature is different than the previous Measure. 

        .. attribute:: layoutWidth

            A suggestion for layout width, though most rendering systems do not support this designation. Use :class:`~music21.layout.SystemLayout` objects instead. 

        .. attribute:: clefIsNew

            Boolean describing if the Clef is different than the previous Measure. 

        .. attribute:: keyIsNew

            Boolean describing if KeySignature is different than the previous Measure. 

        .. attribute:: numberSuffix

            If a Measure number has a string annotation, such as "a" or similar, this string is stored here. 

        Attributes without Documentation: `isMeasure`, `filled`, `paddingLeft`, `paddingRight`

        Attributes inherited from :class:`~music21.stream.Stream`: :attr:`~music21.stream.Stream.isFlat`, :attr:`~music21.stream.Stream.autoSort`, :attr:`~music21.stream.Stream.isSorted`, :attr:`~music21.stream.Stream.flattenedRepresentationOf`

        Attributes inherited from :class:`~music21.base.Music21Object`: :attr:`~music21.base.Music21Object.classSortOrder`, :attr:`~music21.base.Music21Object.hideObjectOnPrint`, :attr:`~music21.base.Music21Object.id`, :attr:`~music21.base.Music21Object.groups`

    **Measure** **properties**

        .. attribute:: barDuration

            Return the bar duration, or the Duration specified by the TimeSignature. TimeSignature is found first within the Measure, or within a context based search. 

        .. attribute:: clef

            

            >>> from music21 import *
            >>> a = stream.Measure()
            >>> a.clef = clef.TrebleClef()
            >>> a.clef.sign  # clef is an element
            'G' 

        .. attribute:: keySignature

            

            >>> from music21 import *
            >>> a = stream.Measure()
            >>> a.keySignature = key.KeySignature(0)
            >>> a.keySignature.sharps
            0 

        .. attribute:: leftBarline

            Get or set the left barline, or the Barline object found at offset zero of the Measure. 

        .. attribute:: musicxml

            Provide a complete MusicXML representation of the measure. 

        .. attribute:: mx

            Return a music21.musicxml.Measure object, populated with notes, chords, rests and a music21.musixcml.Attributes object, populated with time, meter, key, etc Not needed for most users.  Call myMeasure.show('musicxml') or myMeasure.write('musicxml') instead. 

            >>> from music21 import *
            >>> a = note.Note()
            >>> a.quarterLength = 4
            >>> b = stream.Measure()
            >>> b.insert(0, a)
            >>> len(b)
            1 
            >>> mxMeasure = b.mx
            >>> len(mxMeasure)
            1 

        .. attribute:: rightBarline

            Get or set the right barline, or the Barline object found at the offset equal to the bar duration. 

            >>> from music21 import *
            >>> b = bar.Barline('light-heavy')
            >>> m = stream.Measure()
            >>> m.rightBarline = b
            >>> m.rightBarline.style
            'light-heavy' 

            

        .. attribute:: timeSignature

            

            >>> from music21 import *
            >>> a = stream.Measure()
            >>> a.timeSignature = meter.TimeSignature('2/4')
            >>> a.timeSignature.numerator, a.timeSignature.denominator
            (2, 4) 

        Properties inherited from :class:`~music21.stream.Stream`: :attr:`~music21.stream.Stream.beat`, :attr:`~music21.stream.Stream.beatDuration`, :attr:`~music21.stream.Stream.beatStr`, :attr:`~music21.stream.Stream.beatStrength`, :attr:`~music21.stream.Stream.derivationChain`, :attr:`~music21.stream.Stream.derivationMethod`, :attr:`~music21.stream.Stream.derivesFrom`, :attr:`~music21.stream.Stream.duration`, :attr:`~music21.stream.Stream.elements`, :attr:`~music21.stream.Stream.flat`, :attr:`~music21.stream.Stream.highestOffset`, :attr:`~music21.stream.Stream.highestTime`, :attr:`~music21.stream.Stream.isGapless`, :attr:`~music21.stream.Stream.lily`, :attr:`~music21.stream.Stream.lowestOffset`, :attr:`~music21.stream.Stream.metadata`, :attr:`~music21.stream.Stream.midiFile`, :attr:`~music21.stream.Stream.midiTracks`, :attr:`~music21.stream.Stream.notes`, :attr:`~music21.stream.Stream.offsetMap`, :attr:`~music21.stream.Stream.pitches`, :attr:`~music21.stream.Stream.rootDerivation`, :attr:`~music21.stream.Stream.semiFlat`, :attr:`~music21.stream.Stream.sorted`, :attr:`~music21.stream.Stream.spanners`, :attr:`~music21.stream.Stream.voices`

        Properties inherited from :class:`~music21.base.Music21Object`: :attr:`~music21.base.Music21Object.activeSite`, :attr:`~music21.base.Music21Object.classes`, :attr:`~music21.base.Music21Object.derivationHierarchy`, :attr:`~music21.base.Music21Object.measureNumber`, :attr:`~music21.base.Music21Object.offset`, :attr:`~music21.base.Music21Object.priority`

        Properties inherited from :class:`~music21.base.JSONSerializer`: :attr:`~music21.base.JSONSerializer.json`

    **Measure** **methods**

        .. method:: addRepeat()

            No documentation. 

        .. method:: addTimeDependentDirection(time, direction)

            No documentation. 

        .. method:: barDurationProportion(barDuration=None)

            Return a floating point value greater than 0 showing the proportion of the bar duration that is filled based on the highest time of all elements. 0.0 is empty, 1.0 is filled; 1.5 specifies of an overflow of half. Bar duration refers to the duration of the Measure as suggested by the TimeSignature. This value cannot be determined without a Time Signature. An already-obtained Duration object can be supplied with the `barDuration` optional argument. 

            >>> from music21 import *
            >>> m = stream.Measure()
            >>> m.timeSignature = meter.TimeSignature('3/4')
            >>> n = note.Note()
            >>> n.quarterLength = 1
            >>> m.append(copy.deepcopy(n))
            >>> m.barDurationProportion()
            0.33333... 
            >>> m.append(copy.deepcopy(n))
            >>> m.barDurationProportion()
            0.66666... 
            >>> m.append(copy.deepcopy(n))
            >>> m.barDurationProportion()
            1.0 
            >>> m.append(copy.deepcopy(n))
            >>> m.barDurationProportion()
            1.33333... 

        .. method:: bestTimeSignature()

            Given a Measure with elements in it, get a TimeSignature that contains all elements. Note: this does not yet accommodate triplets. 

        .. method:: measureNumberWithSuffix()

            No documentation. 

        .. method:: mergeAttributes(other)

            Given another Measure, configure all non-element attributes of this Measure with the attributes of the other Measure. No elements will be changed or copied. This method is necessary because Measures, unlike some Streams, have attributes independent of any stored elements. 

        .. method:: padAsAnacrusis()

            Given an incompletely filled Measure, adjust the paddingLeft value to to represent contained events as shifted to fill the left-most duration of the bar. Calling this method will overwrite any previously set paddingLeft value, based on the current TimeSignature-derived `barDuration` attribute. 

            >>> from music21 import *
            >>> m = stream.Measure()
            >>> m.timeSignature = meter.TimeSignature('3/4')
            >>> n = note.Note()
            >>> n.quarterLength = 1
            >>> m.append(copy.deepcopy(n))
            >>> m.padAsAnacrusis()
            >>> m.paddingLeft
            2.0 
            >>> m.timeSignature = meter.TimeSignature('5/4')
            >>> m.padAsAnacrusis()
            >>> m.paddingLeft
            4.0 

        Methods inherited from :class:`~music21.stream.Stream`: :meth:`~music21.stream.Stream.addGroupForElements`, :meth:`~music21.stream.Stream.allPlayingWhileSounding`, :meth:`~music21.stream.Stream.analyze`, :meth:`~music21.stream.Stream.append`, :meth:`~music21.stream.Stream.attachIntervalsBetweenStreams`, :meth:`~music21.stream.Stream.attributeCount`, :meth:`~music21.stream.Stream.augmentOrDiminish`, :meth:`~music21.stream.Stream.bestClef`, :meth:`~music21.stream.Stream.expandRepeats`, :meth:`~music21.stream.Stream.explode`, :meth:`~music21.stream.Stream.extendDuration`, :meth:`~music21.stream.Stream.extractContext`, :meth:`~music21.stream.Stream.findConsecutiveNotes`, :meth:`~music21.stream.Stream.findGaps`, :meth:`~music21.stream.Stream.getClefs`, :meth:`~music21.stream.Stream.getElementAfterElement`, :meth:`~music21.stream.Stream.getElementAfterOffset`, :meth:`~music21.stream.Stream.getElementAtOrAfter`, :meth:`~music21.stream.Stream.getElementAtOrBefore`, :meth:`~music21.stream.Stream.getElementBeforeElement`, :meth:`~music21.stream.Stream.getElementBeforeOffset`, :meth:`~music21.stream.Stream.getElementById`, :meth:`~music21.stream.Stream.getElementByObjectId`, :meth:`~music21.stream.Stream.getElementsByClass`, :meth:`~music21.stream.Stream.getElementsByGroup`, :meth:`~music21.stream.Stream.getElementsByOffset`, :meth:`~music21.stream.Stream.getElementsNotOfClass`, :meth:`~music21.stream.Stream.getInstrument`, :meth:`~music21.stream.Stream.getKeySignatures`, :meth:`~music21.stream.Stream.getOffsetByElement`, :meth:`~music21.stream.Stream.getOverlaps`, :meth:`~music21.stream.Stream.getSimultaneous`, :meth:`~music21.stream.Stream.getTimeSignatures`, :meth:`~music21.stream.Stream.groupCount`, :meth:`~music21.stream.Stream.groupElementsByOffset`, :meth:`~music21.stream.Stream.hasElement`, :meth:`~music21.stream.Stream.hasMeasures`, :meth:`~music21.stream.Stream.hasPartLikeStreams`, :meth:`~music21.stream.Stream.hasVoices`, :meth:`~music21.stream.Stream.index`, :meth:`~music21.stream.Stream.indexList`, :meth:`~music21.stream.Stream.insert`, :meth:`~music21.stream.Stream.insertAndShift`, :meth:`~music21.stream.Stream.insertAtNativeOffset`, :meth:`~music21.stream.Stream.internalize`, :meth:`~music21.stream.Stream.invertDiatonic`, :meth:`~music21.stream.Stream.isSequence`, :meth:`~music21.stream.Stream.makeAccidentals`, :meth:`~music21.stream.Stream.makeBeams`, :meth:`~music21.stream.Stream.makeChords`, :meth:`~music21.stream.Stream.makeMeasures`, :meth:`~music21.stream.Stream.makeNotation`, :meth:`~music21.stream.Stream.makeRests`, :meth:`~music21.stream.Stream.makeTies`, :meth:`~music21.stream.Stream.makeTupletBrackets`, :meth:`~music21.stream.Stream.measure`, :meth:`~music21.stream.Stream.measureOffsetMap`, :meth:`~music21.stream.Stream.measures`, :meth:`~music21.stream.Stream.melodicIntervals`, :meth:`~music21.stream.Stream.mergeElements`, :meth:`~music21.stream.Stream.pitchAttributeCount`, :meth:`~music21.stream.Stream.playingWhenAttacked`, :meth:`~music21.stream.Stream.plot`, :meth:`~music21.stream.Stream.pop`, :meth:`~music21.stream.Stream.quantize`, :meth:`~music21.stream.Stream.recurse`, :meth:`~music21.stream.Stream.remove`, :meth:`~music21.stream.Stream.repeatAppend`, :meth:`~music21.stream.Stream.repeatInsert`, :meth:`~music21.stream.Stream.replace`, :meth:`~music21.stream.Stream.scaleDurations`, :meth:`~music21.stream.Stream.scaleOffsets`, :meth:`~music21.stream.Stream.setDerivation`, :meth:`~music21.stream.Stream.setupPickleScaffold`, :meth:`~music21.stream.Stream.shiftElements`, :meth:`~music21.stream.Stream.simultaneousAttacks`, :meth:`~music21.stream.Stream.sliceAtOffsets`, :meth:`~music21.stream.Stream.sliceByBeat`, :meth:`~music21.stream.Stream.sliceByGreatestDivisor`, :meth:`~music21.stream.Stream.sliceByQuarterLengths`, :meth:`~music21.stream.Stream.sort`, :meth:`~music21.stream.Stream.splitByClass`, :meth:`~music21.stream.Stream.storeAtEnd`, :meth:`~music21.stream.Stream.stripTies`, :meth:`~music21.stream.Stream.teardownPickleScaffold`, :meth:`~music21.stream.Stream.transferOffsetToElements`, :meth:`~music21.stream.Stream.transpose`, :meth:`~music21.stream.Stream.trimPlayingWhileSounding`, :meth:`~music21.stream.Stream.voicesToParts`

        Methods inherited from :class:`~music21.base.Music21Object`: :meth:`~music21.base.Music21Object.addContext`, :meth:`~music21.base.Music21Object.addLocation`, :meth:`~music21.base.Music21Object.addLocationAndActiveSite`, :meth:`~music21.base.Music21Object.freezeIds`, :meth:`~music21.base.Music21Object.getAllContextsByClass`, :meth:`~music21.base.Music21Object.getCommonSiteIds`, :meth:`~music21.base.Music21Object.getCommonSites`, :meth:`~music21.base.Music21Object.getContextAttr`, :meth:`~music21.base.Music21Object.getContextByClass`, :meth:`~music21.base.Music21Object.getOffsetBySite`, :meth:`~music21.base.Music21Object.getSiteIds`, :meth:`~music21.base.Music21Object.getSites`, :meth:`~music21.base.Music21Object.getSpannerSites`, :meth:`~music21.base.Music21Object.hasContext`, :meth:`~music21.base.Music21Object.purgeLocations`, :meth:`~music21.base.Music21Object.removeLocationBySite`, :meth:`~music21.base.Music21Object.removeLocationBySiteId`, :meth:`~music21.base.Music21Object.searchParentByAttr`, :meth:`~music21.base.Music21Object.setContextAttr`, :meth:`~music21.base.Music21Object.setOffsetBySite`, :meth:`~music21.base.Music21Object.show`, :meth:`~music21.base.Music21Object.splitAtDurations`, :meth:`~music21.base.Music21Object.splitAtQuarterLength`, :meth:`~music21.base.Music21Object.splitByQuarterLengths`, :meth:`~music21.base.Music21Object.unfreezeIds`, :meth:`~music21.base.Music21Object.unwrapWeakref`, :meth:`~music21.base.Music21Object.wrapWeakref`, :meth:`~music21.base.Music21Object.write`

        Methods inherited from :class:`~music21.base.JSONSerializer`: :meth:`~music21.base.JSONSerializer.jsonAttributes`, :meth:`~music21.base.JSONSerializer.jsonComponentFactory`, :meth:`~music21.base.JSONSerializer.jsonPrint`, :meth:`~music21.base.JSONSerializer.jsonRead`, :meth:`~music21.base.JSONSerializer.jsonWrite`


Opus
----

Inherits from: :class:`~music21.stream.Stream`, :class:`~music21.base.Music21Object`, :class:`~music21.base.JSONSerializer`

.. class:: Opus(*args, **keywords)

    A Stream subclass for handling multi-work music encodings. Many ABC files, for example, define multiple works or parts within a single file. 

    **Opus** **attributes**

        Attributes inherited from :class:`~music21.stream.Stream`: :attr:`~music21.stream.Stream.isMeasure`, :attr:`~music21.stream.Stream.isFlat`, :attr:`~music21.stream.Stream.autoSort`, :attr:`~music21.stream.Stream.isSorted`, :attr:`~music21.stream.Stream.flattenedRepresentationOf`

        Attributes inherited from :class:`~music21.base.Music21Object`: :attr:`~music21.base.Music21Object.classSortOrder`, :attr:`~music21.base.Music21Object.hideObjectOnPrint`, :attr:`~music21.base.Music21Object.id`, :attr:`~music21.base.Music21Object.groups`

    **Opus** **properties**

        .. attribute:: scores

            Return all :class:`~music21.stream.Score` objects in a :class:`~music21.stream.Opus`. 

            >>> from music21 import *

        Properties inherited from :class:`~music21.stream.Stream`: :attr:`~music21.stream.Stream.notes`, :attr:`~music21.stream.Stream.pitches`, :attr:`~music21.stream.Stream.beat`, :attr:`~music21.stream.Stream.beatDuration`, :attr:`~music21.stream.Stream.beatStr`, :attr:`~music21.stream.Stream.beatStrength`, :attr:`~music21.stream.Stream.derivationChain`, :attr:`~music21.stream.Stream.derivationMethod`, :attr:`~music21.stream.Stream.derivesFrom`, :attr:`~music21.stream.Stream.duration`, :attr:`~music21.stream.Stream.elements`, :attr:`~music21.stream.Stream.flat`, :attr:`~music21.stream.Stream.highestOffset`, :attr:`~music21.stream.Stream.highestTime`, :attr:`~music21.stream.Stream.isGapless`, :attr:`~music21.stream.Stream.lily`, :attr:`~music21.stream.Stream.lowestOffset`, :attr:`~music21.stream.Stream.metadata`, :attr:`~music21.stream.Stream.midiFile`, :attr:`~music21.stream.Stream.midiTracks`, :attr:`~music21.stream.Stream.musicxml`, :attr:`~music21.stream.Stream.mx`, :attr:`~music21.stream.Stream.offsetMap`, :attr:`~music21.stream.Stream.rootDerivation`, :attr:`~music21.stream.Stream.semiFlat`, :attr:`~music21.stream.Stream.sorted`, :attr:`~music21.stream.Stream.spanners`, :attr:`~music21.stream.Stream.voices`

        Properties inherited from :class:`~music21.base.Music21Object`: :attr:`~music21.base.Music21Object.activeSite`, :attr:`~music21.base.Music21Object.classes`, :attr:`~music21.base.Music21Object.derivationHierarchy`, :attr:`~music21.base.Music21Object.measureNumber`, :attr:`~music21.base.Music21Object.offset`, :attr:`~music21.base.Music21Object.priority`

        Properties inherited from :class:`~music21.base.JSONSerializer`: :attr:`~music21.base.JSONSerializer.json`

    **Opus** **methods**

        .. method:: getNumbers()

            Return a list of all numbers defined in this Opus. 

            >>> from music21 import *
            >>> o = corpus.parse('josquin/ovenusbant')
            >>> o.getNumbers()
            ['1', '2', '3'] 

        .. method:: getScoreByNumber(opusMatch)

            Get Score objects from this Stream by number. Performs title search using the :meth:`~music21.metadata.Metadata.search` method, and returns the first result. 

            >>> from music21 import *
            >>> o = corpus.parse('josquin/ovenusbant')
            >>> o.getNumbers()
            ['1', '2', '3'] 
            >>> s = o.getScoreByNumber(2)
            >>> s.metadata.title
            'O Venus bant' 
            >>> s.metadata.alternativeTitle
            'Tenor' 

        .. method:: getScoreByTitle(titleMatch)

            Get Score objects from this Stream by a title. Performs title search using the :meth:`~music21.metadata.Metadata.search` method, and returns the first result. 

            >>> from music21 import *
            >>> o = corpus.parse('essenFolksong/erk5')
            >>> s = o.getScoreByTitle('Vrienden, kommt alle gaere')
            >>> s = o.getScoreByTitle('(.*)kommt(.*)') # regular expression
            >>> s.metadata.title
            'Vrienden, kommt alle gaere' 

        .. method:: mergeScores()

            Some Opus object represent numerous scores that are individual parts of the same work. This method will treat each contained Score as a Part, merging and returning a single Score with merged Metadata. 

            >>> from music21 import *
            >>> o = corpus.parse('josquin/milleRegrets')
            >>> s = o.mergeScores()
            >>> s.metadata.title
            'Mille regrets' 
            >>> len(s.parts)
            4 

        .. method:: show(fmt=None, app=None)

            Displays an object in a format provided by the fmt argument or, if not provided, the format set in the user's Environment. This method overrides the behavior specified in :class:`~music21.base.Music21Object`. 

        .. method:: write(fmt=None, fp=None)

            Displays an object in a format provided by the fmt argument or, if not provided, the format set in the user's Environment. This method overrides the behavior specified in :class:`~music21.base.Music21Object`. 

        Methods inherited from :class:`~music21.stream.Stream`: :meth:`~music21.stream.Stream.append`, :meth:`~music21.stream.Stream.insert`, :meth:`~music21.stream.Stream.insertAndShift`, :meth:`~music21.stream.Stream.transpose`, :meth:`~music21.stream.Stream.augmentOrDiminish`, :meth:`~music21.stream.Stream.scaleOffsets`, :meth:`~music21.stream.Stream.scaleDurations`, :meth:`~music21.stream.Stream.addGroupForElements`, :meth:`~music21.stream.Stream.allPlayingWhileSounding`, :meth:`~music21.stream.Stream.analyze`, :meth:`~music21.stream.Stream.attachIntervalsBetweenStreams`, :meth:`~music21.stream.Stream.attributeCount`, :meth:`~music21.stream.Stream.bestClef`, :meth:`~music21.stream.Stream.expandRepeats`, :meth:`~music21.stream.Stream.explode`, :meth:`~music21.stream.Stream.extendDuration`, :meth:`~music21.stream.Stream.extractContext`, :meth:`~music21.stream.Stream.findConsecutiveNotes`, :meth:`~music21.stream.Stream.findGaps`, :meth:`~music21.stream.Stream.getClefs`, :meth:`~music21.stream.Stream.getElementAfterElement`, :meth:`~music21.stream.Stream.getElementAfterOffset`, :meth:`~music21.stream.Stream.getElementAtOrAfter`, :meth:`~music21.stream.Stream.getElementAtOrBefore`, :meth:`~music21.stream.Stream.getElementBeforeElement`, :meth:`~music21.stream.Stream.getElementBeforeOffset`, :meth:`~music21.stream.Stream.getElementById`, :meth:`~music21.stream.Stream.getElementByObjectId`, :meth:`~music21.stream.Stream.getElementsByClass`, :meth:`~music21.stream.Stream.getElementsByGroup`, :meth:`~music21.stream.Stream.getElementsByOffset`, :meth:`~music21.stream.Stream.getElementsNotOfClass`, :meth:`~music21.stream.Stream.getInstrument`, :meth:`~music21.stream.Stream.getKeySignatures`, :meth:`~music21.stream.Stream.getOffsetByElement`, :meth:`~music21.stream.Stream.getOverlaps`, :meth:`~music21.stream.Stream.getSimultaneous`, :meth:`~music21.stream.Stream.getTimeSignatures`, :meth:`~music21.stream.Stream.groupCount`, :meth:`~music21.stream.Stream.groupElementsByOffset`, :meth:`~music21.stream.Stream.hasElement`, :meth:`~music21.stream.Stream.hasMeasures`, :meth:`~music21.stream.Stream.hasPartLikeStreams`, :meth:`~music21.stream.Stream.hasVoices`, :meth:`~music21.stream.Stream.index`, :meth:`~music21.stream.Stream.indexList`, :meth:`~music21.stream.Stream.insertAtNativeOffset`, :meth:`~music21.stream.Stream.internalize`, :meth:`~music21.stream.Stream.invertDiatonic`, :meth:`~music21.stream.Stream.isSequence`, :meth:`~music21.stream.Stream.makeAccidentals`, :meth:`~music21.stream.Stream.makeBeams`, :meth:`~music21.stream.Stream.makeChords`, :meth:`~music21.stream.Stream.makeMeasures`, :meth:`~music21.stream.Stream.makeNotation`, :meth:`~music21.stream.Stream.makeRests`, :meth:`~music21.stream.Stream.makeTies`, :meth:`~music21.stream.Stream.makeTupletBrackets`, :meth:`~music21.stream.Stream.measure`, :meth:`~music21.stream.Stream.measureOffsetMap`, :meth:`~music21.stream.Stream.measures`, :meth:`~music21.stream.Stream.melodicIntervals`, :meth:`~music21.stream.Stream.mergeElements`, :meth:`~music21.stream.Stream.pitchAttributeCount`, :meth:`~music21.stream.Stream.playingWhenAttacked`, :meth:`~music21.stream.Stream.plot`, :meth:`~music21.stream.Stream.pop`, :meth:`~music21.stream.Stream.quantize`, :meth:`~music21.stream.Stream.recurse`, :meth:`~music21.stream.Stream.remove`, :meth:`~music21.stream.Stream.repeatAppend`, :meth:`~music21.stream.Stream.repeatInsert`, :meth:`~music21.stream.Stream.replace`, :meth:`~music21.stream.Stream.setDerivation`, :meth:`~music21.stream.Stream.setupPickleScaffold`, :meth:`~music21.stream.Stream.shiftElements`, :meth:`~music21.stream.Stream.simultaneousAttacks`, :meth:`~music21.stream.Stream.sliceAtOffsets`, :meth:`~music21.stream.Stream.sliceByBeat`, :meth:`~music21.stream.Stream.sliceByGreatestDivisor`, :meth:`~music21.stream.Stream.sliceByQuarterLengths`, :meth:`~music21.stream.Stream.sort`, :meth:`~music21.stream.Stream.splitByClass`, :meth:`~music21.stream.Stream.storeAtEnd`, :meth:`~music21.stream.Stream.stripTies`, :meth:`~music21.stream.Stream.teardownPickleScaffold`, :meth:`~music21.stream.Stream.transferOffsetToElements`, :meth:`~music21.stream.Stream.trimPlayingWhileSounding`, :meth:`~music21.stream.Stream.voicesToParts`

        Methods inherited from :class:`~music21.base.Music21Object`: :meth:`~music21.base.Music21Object.addContext`, :meth:`~music21.base.Music21Object.addLocation`, :meth:`~music21.base.Music21Object.addLocationAndActiveSite`, :meth:`~music21.base.Music21Object.freezeIds`, :meth:`~music21.base.Music21Object.getAllContextsByClass`, :meth:`~music21.base.Music21Object.getCommonSiteIds`, :meth:`~music21.base.Music21Object.getCommonSites`, :meth:`~music21.base.Music21Object.getContextAttr`, :meth:`~music21.base.Music21Object.getContextByClass`, :meth:`~music21.base.Music21Object.getOffsetBySite`, :meth:`~music21.base.Music21Object.getSiteIds`, :meth:`~music21.base.Music21Object.getSites`, :meth:`~music21.base.Music21Object.getSpannerSites`, :meth:`~music21.base.Music21Object.hasContext`, :meth:`~music21.base.Music21Object.mergeAttributes`, :meth:`~music21.base.Music21Object.purgeLocations`, :meth:`~music21.base.Music21Object.removeLocationBySite`, :meth:`~music21.base.Music21Object.removeLocationBySiteId`, :meth:`~music21.base.Music21Object.searchParentByAttr`, :meth:`~music21.base.Music21Object.setContextAttr`, :meth:`~music21.base.Music21Object.setOffsetBySite`, :meth:`~music21.base.Music21Object.splitAtDurations`, :meth:`~music21.base.Music21Object.splitAtQuarterLength`, :meth:`~music21.base.Music21Object.splitByQuarterLengths`, :meth:`~music21.base.Music21Object.unfreezeIds`, :meth:`~music21.base.Music21Object.unwrapWeakref`, :meth:`~music21.base.Music21Object.wrapWeakref`

        Methods inherited from :class:`~music21.base.JSONSerializer`: :meth:`~music21.base.JSONSerializer.jsonAttributes`, :meth:`~music21.base.JSONSerializer.jsonComponentFactory`, :meth:`~music21.base.JSONSerializer.jsonPrint`, :meth:`~music21.base.JSONSerializer.jsonRead`, :meth:`~music21.base.JSONSerializer.jsonWrite`


Part
----

Inherits from: :class:`~music21.stream.Stream`, :class:`~music21.base.Music21Object`, :class:`~music21.base.JSONSerializer`

.. class:: Part(*args, **keywords)

    A Stream subclass for designating music that is considered a single part. May be enclosed in a staff (for instance, 2nd and 3rd trombone on a single staff), may enclose staves (piano treble and piano bass), or may not enclose or be enclosed by a staff (in which case, it assumes that this part fits on one staff and shares it with no other part 


PartStaff
---------

Inherits from: :class:`~music21.stream.Part`, :class:`~music21.stream.Stream`, :class:`~music21.base.Music21Object`, :class:`~music21.base.JSONSerializer`

.. class:: PartStaff(*args, **keywords)

    A Part subclass for designating music that is represented on a single staff but may only be one of many staffs for a single part. 

    


Score
-----

Inherits from: :class:`~music21.stream.Stream`, :class:`~music21.base.Music21Object`, :class:`~music21.base.JSONSerializer`

.. class:: Score(*args, **keywords)

    A Stream subclass for handling multi-part music. Absolutely optional (the largest containing Stream in a piece could be a generic Stream, or a Part, or a Staff).  And Scores can be embedded in other Scores (in fact, our original thought was to call this class a Fragment because of this possibility of continuous embedding), but we figure that many people will like calling the largest container a Score and that this will become a standard. 

    **Score** **attributes**

        Attributes inherited from :class:`~music21.stream.Stream`: :attr:`~music21.stream.Stream.isMeasure`, :attr:`~music21.stream.Stream.isFlat`, :attr:`~music21.stream.Stream.autoSort`, :attr:`~music21.stream.Stream.isSorted`, :attr:`~music21.stream.Stream.flattenedRepresentationOf`

        Attributes inherited from :class:`~music21.base.Music21Object`: :attr:`~music21.base.Music21Object.classSortOrder`, :attr:`~music21.base.Music21Object.hideObjectOnPrint`, :attr:`~music21.base.Music21Object.id`, :attr:`~music21.base.Music21Object.groups`

    **Score** **properties**

        .. attribute:: lily

            returns the lily code for a score. 

        .. attribute:: parts

            Return all :class:`~music21.stream.Part` objects in a :class:`~music21.stream.Score`. 

            >>> from music21 import *
            >>> s = corpus.parse('bach/bwv66.6')
            >>> parts = s.parts
            >>> len(parts)
            4 

        Properties inherited from :class:`~music21.stream.Stream`: :attr:`~music21.stream.Stream.notes`, :attr:`~music21.stream.Stream.pitches`, :attr:`~music21.stream.Stream.beat`, :attr:`~music21.stream.Stream.beatDuration`, :attr:`~music21.stream.Stream.beatStr`, :attr:`~music21.stream.Stream.beatStrength`, :attr:`~music21.stream.Stream.derivationChain`, :attr:`~music21.stream.Stream.derivationMethod`, :attr:`~music21.stream.Stream.derivesFrom`, :attr:`~music21.stream.Stream.duration`, :attr:`~music21.stream.Stream.elements`, :attr:`~music21.stream.Stream.flat`, :attr:`~music21.stream.Stream.highestOffset`, :attr:`~music21.stream.Stream.highestTime`, :attr:`~music21.stream.Stream.isGapless`, :attr:`~music21.stream.Stream.lowestOffset`, :attr:`~music21.stream.Stream.metadata`, :attr:`~music21.stream.Stream.midiFile`, :attr:`~music21.stream.Stream.midiTracks`, :attr:`~music21.stream.Stream.musicxml`, :attr:`~music21.stream.Stream.mx`, :attr:`~music21.stream.Stream.offsetMap`, :attr:`~music21.stream.Stream.rootDerivation`, :attr:`~music21.stream.Stream.semiFlat`, :attr:`~music21.stream.Stream.sorted`, :attr:`~music21.stream.Stream.spanners`, :attr:`~music21.stream.Stream.voices`

        Properties inherited from :class:`~music21.base.Music21Object`: :attr:`~music21.base.Music21Object.activeSite`, :attr:`~music21.base.Music21Object.classes`, :attr:`~music21.base.Music21Object.derivationHierarchy`, :attr:`~music21.base.Music21Object.measureNumber`, :attr:`~music21.base.Music21Object.offset`, :attr:`~music21.base.Music21Object.priority`

        Properties inherited from :class:`~music21.base.JSONSerializer`: :attr:`~music21.base.JSONSerializer.json`

    **Score** **methods**

        .. method:: chordify(addTies=True, displayTiedAccidentals=False)

            Split all Durations in all parts, if multi-part, by all unique offsets. All simultaneous durations are then gathered into single chords. 

            addTies currently does not work for pitches in Chords 

            

        .. method:: expandRepeats()

            Expand all repeats, as well as all repeat indications given by text expressions such as D.C. al Segno. This method always returns a new Stream, with deepcopies of all contained elements at all level. NOTE: preliminary implementation. TODO: overidden method on Score 

        .. method:: implode()

            Reduce a polyphonic work into one or more staves. 

        .. method:: measure(measureNumber, collect=[<class 'music21.clef.Clef'>, <class 'music21.meter.TimeSignature'>, <class 'music21.instrument.Instrument'>, <class 'music21.key.KeySignature'>], gatherSpanners=True)

            Given a measure number, return a single :class:`~music21.stream.Measure` object if the Measure number exists, otherwise return None. 

            This method overrides the :meth:`~music21.stream.Stream.measures` method on Stream. This creates a new Score stream that has the same measure range for all Parts. 

            

            >>> from music21 import corpus
            >>> a = corpus.parse('bach/bwv324.xml')
            >>> len(a.measure(3)[0]) # contains 1 measure
            1 

        .. method:: measureOffsetMap(classFilterList=None)

            This method overrides the :meth:`~music21.stream.Stream.measureOffsetMap` method of Stream. This creates a map based on all contained Parts in this Score. Measures found in multiple Parts with the same offset will be appended to the same list. 

            If no parts are found in the score, then the normal :meth:`~music21.stream.Stream.measureOffsetMap` routine is called. 

            This method is smart and does not assume that all Parts have measures with identical offsets. 

        .. method:: measures(numberStart, numberEnd, collect=[<class 'music21.clef.Clef'>, <class 'music21.meter.TimeSignature'>, <class 'music21.instrument.Instrument'>, <class 'music21.key.KeySignature'>], gatherSpanners=True)

            This method override the :meth:`~music21.stream.Stream.measures` method on Stream. This creates a new Score stream that has the same measure range for all Parts. 

        .. method:: partsToVoices(voiceAllocation=2, permitOneVoicePerPart=False)

            Given a multi-part :class:`~music21.stream.Score`, return a new Score that combines parts into voices. The `voiceAllocation` parameter can be an integer: if so, this many parts will each be grouped into one part as voices The `permitOneVoicePerPart` parameter, if True, will encode a single voice inside a single Part, rather than leaving a single part alone. 

        .. method:: sliceByGreatestDivisor(inPlace=True, addTies=True)

            Slice all duration of all part by the minimum duration that can be summed to each concurrent duration. 

            Overrides method defined on Stream. 

        Methods inherited from :class:`~music21.stream.Stream`: :meth:`~music21.stream.Stream.append`, :meth:`~music21.stream.Stream.insert`, :meth:`~music21.stream.Stream.insertAndShift`, :meth:`~music21.stream.Stream.transpose`, :meth:`~music21.stream.Stream.augmentOrDiminish`, :meth:`~music21.stream.Stream.scaleOffsets`, :meth:`~music21.stream.Stream.scaleDurations`, :meth:`~music21.stream.Stream.addGroupForElements`, :meth:`~music21.stream.Stream.allPlayingWhileSounding`, :meth:`~music21.stream.Stream.analyze`, :meth:`~music21.stream.Stream.attachIntervalsBetweenStreams`, :meth:`~music21.stream.Stream.attributeCount`, :meth:`~music21.stream.Stream.bestClef`, :meth:`~music21.stream.Stream.explode`, :meth:`~music21.stream.Stream.extendDuration`, :meth:`~music21.stream.Stream.extractContext`, :meth:`~music21.stream.Stream.findConsecutiveNotes`, :meth:`~music21.stream.Stream.findGaps`, :meth:`~music21.stream.Stream.getClefs`, :meth:`~music21.stream.Stream.getElementAfterElement`, :meth:`~music21.stream.Stream.getElementAfterOffset`, :meth:`~music21.stream.Stream.getElementAtOrAfter`, :meth:`~music21.stream.Stream.getElementAtOrBefore`, :meth:`~music21.stream.Stream.getElementBeforeElement`, :meth:`~music21.stream.Stream.getElementBeforeOffset`, :meth:`~music21.stream.Stream.getElementById`, :meth:`~music21.stream.Stream.getElementByObjectId`, :meth:`~music21.stream.Stream.getElementsByClass`, :meth:`~music21.stream.Stream.getElementsByGroup`, :meth:`~music21.stream.Stream.getElementsByOffset`, :meth:`~music21.stream.Stream.getElementsNotOfClass`, :meth:`~music21.stream.Stream.getInstrument`, :meth:`~music21.stream.Stream.getKeySignatures`, :meth:`~music21.stream.Stream.getOffsetByElement`, :meth:`~music21.stream.Stream.getOverlaps`, :meth:`~music21.stream.Stream.getSimultaneous`, :meth:`~music21.stream.Stream.getTimeSignatures`, :meth:`~music21.stream.Stream.groupCount`, :meth:`~music21.stream.Stream.groupElementsByOffset`, :meth:`~music21.stream.Stream.hasElement`, :meth:`~music21.stream.Stream.hasMeasures`, :meth:`~music21.stream.Stream.hasPartLikeStreams`, :meth:`~music21.stream.Stream.hasVoices`, :meth:`~music21.stream.Stream.index`, :meth:`~music21.stream.Stream.indexList`, :meth:`~music21.stream.Stream.insertAtNativeOffset`, :meth:`~music21.stream.Stream.internalize`, :meth:`~music21.stream.Stream.invertDiatonic`, :meth:`~music21.stream.Stream.isSequence`, :meth:`~music21.stream.Stream.makeAccidentals`, :meth:`~music21.stream.Stream.makeBeams`, :meth:`~music21.stream.Stream.makeChords`, :meth:`~music21.stream.Stream.makeMeasures`, :meth:`~music21.stream.Stream.makeNotation`, :meth:`~music21.stream.Stream.makeRests`, :meth:`~music21.stream.Stream.makeTies`, :meth:`~music21.stream.Stream.makeTupletBrackets`, :meth:`~music21.stream.Stream.melodicIntervals`, :meth:`~music21.stream.Stream.mergeElements`, :meth:`~music21.stream.Stream.pitchAttributeCount`, :meth:`~music21.stream.Stream.playingWhenAttacked`, :meth:`~music21.stream.Stream.plot`, :meth:`~music21.stream.Stream.pop`, :meth:`~music21.stream.Stream.quantize`, :meth:`~music21.stream.Stream.recurse`, :meth:`~music21.stream.Stream.remove`, :meth:`~music21.stream.Stream.repeatAppend`, :meth:`~music21.stream.Stream.repeatInsert`, :meth:`~music21.stream.Stream.replace`, :meth:`~music21.stream.Stream.setDerivation`, :meth:`~music21.stream.Stream.setupPickleScaffold`, :meth:`~music21.stream.Stream.shiftElements`, :meth:`~music21.stream.Stream.simultaneousAttacks`, :meth:`~music21.stream.Stream.sliceAtOffsets`, :meth:`~music21.stream.Stream.sliceByBeat`, :meth:`~music21.stream.Stream.sliceByQuarterLengths`, :meth:`~music21.stream.Stream.sort`, :meth:`~music21.stream.Stream.splitByClass`, :meth:`~music21.stream.Stream.storeAtEnd`, :meth:`~music21.stream.Stream.stripTies`, :meth:`~music21.stream.Stream.teardownPickleScaffold`, :meth:`~music21.stream.Stream.transferOffsetToElements`, :meth:`~music21.stream.Stream.trimPlayingWhileSounding`, :meth:`~music21.stream.Stream.voicesToParts`

        Methods inherited from :class:`~music21.base.Music21Object`: :meth:`~music21.base.Music21Object.addContext`, :meth:`~music21.base.Music21Object.addLocation`, :meth:`~music21.base.Music21Object.addLocationAndActiveSite`, :meth:`~music21.base.Music21Object.freezeIds`, :meth:`~music21.base.Music21Object.getAllContextsByClass`, :meth:`~music21.base.Music21Object.getCommonSiteIds`, :meth:`~music21.base.Music21Object.getCommonSites`, :meth:`~music21.base.Music21Object.getContextAttr`, :meth:`~music21.base.Music21Object.getContextByClass`, :meth:`~music21.base.Music21Object.getOffsetBySite`, :meth:`~music21.base.Music21Object.getSiteIds`, :meth:`~music21.base.Music21Object.getSites`, :meth:`~music21.base.Music21Object.getSpannerSites`, :meth:`~music21.base.Music21Object.hasContext`, :meth:`~music21.base.Music21Object.mergeAttributes`, :meth:`~music21.base.Music21Object.purgeLocations`, :meth:`~music21.base.Music21Object.removeLocationBySite`, :meth:`~music21.base.Music21Object.removeLocationBySiteId`, :meth:`~music21.base.Music21Object.searchParentByAttr`, :meth:`~music21.base.Music21Object.setContextAttr`, :meth:`~music21.base.Music21Object.setOffsetBySite`, :meth:`~music21.base.Music21Object.show`, :meth:`~music21.base.Music21Object.splitAtDurations`, :meth:`~music21.base.Music21Object.splitAtQuarterLength`, :meth:`~music21.base.Music21Object.splitByQuarterLengths`, :meth:`~music21.base.Music21Object.unfreezeIds`, :meth:`~music21.base.Music21Object.unwrapWeakref`, :meth:`~music21.base.Music21Object.wrapWeakref`, :meth:`~music21.base.Music21Object.write`

        Methods inherited from :class:`~music21.base.JSONSerializer`: :meth:`~music21.base.JSONSerializer.jsonAttributes`, :meth:`~music21.base.JSONSerializer.jsonComponentFactory`, :meth:`~music21.base.JSONSerializer.jsonPrint`, :meth:`~music21.base.JSONSerializer.jsonRead`, :meth:`~music21.base.JSONSerializer.jsonWrite`


SpannerStorage
--------------

Inherits from: :class:`~music21.stream.Stream`, :class:`~music21.base.Music21Object`, :class:`~music21.base.JSONSerializer`

.. class:: SpannerStorage(*arguments, **keywords)

    For advanced use. This Stream subclass is used inside of a Spanner object to provide object storage. This subclass name can be used to search an object's DefinedContexts and find any and all locations that are SpannerStorage objects. A `spannerParent` keyword argument must be provided by the Spanner in creation. 

    **SpannerStorage** **attributes**

        Attributes without Documentation: `spannerParent`

        Attributes inherited from :class:`~music21.stream.Stream`: :attr:`~music21.stream.Stream.isMeasure`, :attr:`~music21.stream.Stream.isFlat`, :attr:`~music21.stream.Stream.autoSort`, :attr:`~music21.stream.Stream.isSorted`, :attr:`~music21.stream.Stream.flattenedRepresentationOf`

        Attributes inherited from :class:`~music21.base.Music21Object`: :attr:`~music21.base.Music21Object.classSortOrder`, :attr:`~music21.base.Music21Object.hideObjectOnPrint`, :attr:`~music21.base.Music21Object.id`, :attr:`~music21.base.Music21Object.groups`

    **SpannerStorage** **properties**

        Properties inherited from :class:`~music21.stream.Stream`: :attr:`~music21.stream.Stream.notes`, :attr:`~music21.stream.Stream.pitches`, :attr:`~music21.stream.Stream.beat`, :attr:`~music21.stream.Stream.beatDuration`, :attr:`~music21.stream.Stream.beatStr`, :attr:`~music21.stream.Stream.beatStrength`, :attr:`~music21.stream.Stream.derivationChain`, :attr:`~music21.stream.Stream.derivationMethod`, :attr:`~music21.stream.Stream.derivesFrom`, :attr:`~music21.stream.Stream.duration`, :attr:`~music21.stream.Stream.elements`, :attr:`~music21.stream.Stream.flat`, :attr:`~music21.stream.Stream.highestOffset`, :attr:`~music21.stream.Stream.highestTime`, :attr:`~music21.stream.Stream.isGapless`, :attr:`~music21.stream.Stream.lily`, :attr:`~music21.stream.Stream.lowestOffset`, :attr:`~music21.stream.Stream.metadata`, :attr:`~music21.stream.Stream.midiFile`, :attr:`~music21.stream.Stream.midiTracks`, :attr:`~music21.stream.Stream.musicxml`, :attr:`~music21.stream.Stream.mx`, :attr:`~music21.stream.Stream.offsetMap`, :attr:`~music21.stream.Stream.rootDerivation`, :attr:`~music21.stream.Stream.semiFlat`, :attr:`~music21.stream.Stream.sorted`, :attr:`~music21.stream.Stream.spanners`, :attr:`~music21.stream.Stream.voices`

        Properties inherited from :class:`~music21.base.Music21Object`: :attr:`~music21.base.Music21Object.activeSite`, :attr:`~music21.base.Music21Object.classes`, :attr:`~music21.base.Music21Object.derivationHierarchy`, :attr:`~music21.base.Music21Object.measureNumber`, :attr:`~music21.base.Music21Object.offset`, :attr:`~music21.base.Music21Object.priority`

        Properties inherited from :class:`~music21.base.JSONSerializer`: :attr:`~music21.base.JSONSerializer.json`

    **SpannerStorage** **methods**

        Methods inherited from :class:`~music21.stream.Stream`: :meth:`~music21.stream.Stream.append`, :meth:`~music21.stream.Stream.insert`, :meth:`~music21.stream.Stream.insertAndShift`, :meth:`~music21.stream.Stream.transpose`, :meth:`~music21.stream.Stream.augmentOrDiminish`, :meth:`~music21.stream.Stream.scaleOffsets`, :meth:`~music21.stream.Stream.scaleDurations`, :meth:`~music21.stream.Stream.addGroupForElements`, :meth:`~music21.stream.Stream.allPlayingWhileSounding`, :meth:`~music21.stream.Stream.analyze`, :meth:`~music21.stream.Stream.attachIntervalsBetweenStreams`, :meth:`~music21.stream.Stream.attributeCount`, :meth:`~music21.stream.Stream.bestClef`, :meth:`~music21.stream.Stream.expandRepeats`, :meth:`~music21.stream.Stream.explode`, :meth:`~music21.stream.Stream.extendDuration`, :meth:`~music21.stream.Stream.extractContext`, :meth:`~music21.stream.Stream.findConsecutiveNotes`, :meth:`~music21.stream.Stream.findGaps`, :meth:`~music21.stream.Stream.getClefs`, :meth:`~music21.stream.Stream.getElementAfterElement`, :meth:`~music21.stream.Stream.getElementAfterOffset`, :meth:`~music21.stream.Stream.getElementAtOrAfter`, :meth:`~music21.stream.Stream.getElementAtOrBefore`, :meth:`~music21.stream.Stream.getElementBeforeElement`, :meth:`~music21.stream.Stream.getElementBeforeOffset`, :meth:`~music21.stream.Stream.getElementById`, :meth:`~music21.stream.Stream.getElementByObjectId`, :meth:`~music21.stream.Stream.getElementsByClass`, :meth:`~music21.stream.Stream.getElementsByGroup`, :meth:`~music21.stream.Stream.getElementsByOffset`, :meth:`~music21.stream.Stream.getElementsNotOfClass`, :meth:`~music21.stream.Stream.getInstrument`, :meth:`~music21.stream.Stream.getKeySignatures`, :meth:`~music21.stream.Stream.getOffsetByElement`, :meth:`~music21.stream.Stream.getOverlaps`, :meth:`~music21.stream.Stream.getSimultaneous`, :meth:`~music21.stream.Stream.getTimeSignatures`, :meth:`~music21.stream.Stream.groupCount`, :meth:`~music21.stream.Stream.groupElementsByOffset`, :meth:`~music21.stream.Stream.hasElement`, :meth:`~music21.stream.Stream.hasMeasures`, :meth:`~music21.stream.Stream.hasPartLikeStreams`, :meth:`~music21.stream.Stream.hasVoices`, :meth:`~music21.stream.Stream.index`, :meth:`~music21.stream.Stream.indexList`, :meth:`~music21.stream.Stream.insertAtNativeOffset`, :meth:`~music21.stream.Stream.internalize`, :meth:`~music21.stream.Stream.invertDiatonic`, :meth:`~music21.stream.Stream.isSequence`, :meth:`~music21.stream.Stream.makeAccidentals`, :meth:`~music21.stream.Stream.makeBeams`, :meth:`~music21.stream.Stream.makeChords`, :meth:`~music21.stream.Stream.makeMeasures`, :meth:`~music21.stream.Stream.makeNotation`, :meth:`~music21.stream.Stream.makeRests`, :meth:`~music21.stream.Stream.makeTies`, :meth:`~music21.stream.Stream.makeTupletBrackets`, :meth:`~music21.stream.Stream.measure`, :meth:`~music21.stream.Stream.measureOffsetMap`, :meth:`~music21.stream.Stream.measures`, :meth:`~music21.stream.Stream.melodicIntervals`, :meth:`~music21.stream.Stream.mergeElements`, :meth:`~music21.stream.Stream.pitchAttributeCount`, :meth:`~music21.stream.Stream.playingWhenAttacked`, :meth:`~music21.stream.Stream.plot`, :meth:`~music21.stream.Stream.pop`, :meth:`~music21.stream.Stream.quantize`, :meth:`~music21.stream.Stream.recurse`, :meth:`~music21.stream.Stream.remove`, :meth:`~music21.stream.Stream.repeatAppend`, :meth:`~music21.stream.Stream.repeatInsert`, :meth:`~music21.stream.Stream.replace`, :meth:`~music21.stream.Stream.setDerivation`, :meth:`~music21.stream.Stream.setupPickleScaffold`, :meth:`~music21.stream.Stream.shiftElements`, :meth:`~music21.stream.Stream.simultaneousAttacks`, :meth:`~music21.stream.Stream.sliceAtOffsets`, :meth:`~music21.stream.Stream.sliceByBeat`, :meth:`~music21.stream.Stream.sliceByGreatestDivisor`, :meth:`~music21.stream.Stream.sliceByQuarterLengths`, :meth:`~music21.stream.Stream.sort`, :meth:`~music21.stream.Stream.splitByClass`, :meth:`~music21.stream.Stream.storeAtEnd`, :meth:`~music21.stream.Stream.stripTies`, :meth:`~music21.stream.Stream.teardownPickleScaffold`, :meth:`~music21.stream.Stream.transferOffsetToElements`, :meth:`~music21.stream.Stream.trimPlayingWhileSounding`, :meth:`~music21.stream.Stream.voicesToParts`

        Methods inherited from :class:`~music21.base.Music21Object`: :meth:`~music21.base.Music21Object.addContext`, :meth:`~music21.base.Music21Object.addLocation`, :meth:`~music21.base.Music21Object.addLocationAndActiveSite`, :meth:`~music21.base.Music21Object.freezeIds`, :meth:`~music21.base.Music21Object.getAllContextsByClass`, :meth:`~music21.base.Music21Object.getCommonSiteIds`, :meth:`~music21.base.Music21Object.getCommonSites`, :meth:`~music21.base.Music21Object.getContextAttr`, :meth:`~music21.base.Music21Object.getContextByClass`, :meth:`~music21.base.Music21Object.getOffsetBySite`, :meth:`~music21.base.Music21Object.getSiteIds`, :meth:`~music21.base.Music21Object.getSites`, :meth:`~music21.base.Music21Object.getSpannerSites`, :meth:`~music21.base.Music21Object.hasContext`, :meth:`~music21.base.Music21Object.mergeAttributes`, :meth:`~music21.base.Music21Object.purgeLocations`, :meth:`~music21.base.Music21Object.removeLocationBySite`, :meth:`~music21.base.Music21Object.removeLocationBySiteId`, :meth:`~music21.base.Music21Object.searchParentByAttr`, :meth:`~music21.base.Music21Object.setContextAttr`, :meth:`~music21.base.Music21Object.setOffsetBySite`, :meth:`~music21.base.Music21Object.show`, :meth:`~music21.base.Music21Object.splitAtDurations`, :meth:`~music21.base.Music21Object.splitAtQuarterLength`, :meth:`~music21.base.Music21Object.splitByQuarterLengths`, :meth:`~music21.base.Music21Object.unfreezeIds`, :meth:`~music21.base.Music21Object.unwrapWeakref`, :meth:`~music21.base.Music21Object.wrapWeakref`, :meth:`~music21.base.Music21Object.write`

        Methods inherited from :class:`~music21.base.JSONSerializer`: :meth:`~music21.base.JSONSerializer.jsonAttributes`, :meth:`~music21.base.JSONSerializer.jsonComponentFactory`, :meth:`~music21.base.JSONSerializer.jsonPrint`, :meth:`~music21.base.JSONSerializer.jsonRead`, :meth:`~music21.base.JSONSerializer.jsonWrite`


StreamIterator
--------------



.. class:: StreamIterator(srcStream)

    A simple Iterator object used to handle iteration of Streams and other list-like objects. 

    **StreamIterator** **methods**

        .. method:: next()

            No documentation. 


Voice
-----

Inherits from: :class:`~music21.stream.Stream`, :class:`~music21.base.Music21Object`, :class:`~music21.base.JSONSerializer`

.. class:: Voice(givenElements=None, *args, **keywords)

    A Stream subclass for declaring that all the music in the stream belongs to a certain "voice" for analysis or display purposes. Note that both Finale's Layers and Voices as concepts are considered Voices here. 


