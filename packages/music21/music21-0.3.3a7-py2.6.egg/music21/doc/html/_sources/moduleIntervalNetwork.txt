.. _moduleIntervalNetwork:

music21.intervalNetwork
=======================

.. WARNING: DO NOT EDIT THIS FILE: AUTOMATICALLY GENERATED.  Edit the .py file directly

.. module:: music21.intervalNetwork

An IntervalNetwork defines a scale or harmonic unit as a (weighted) digraph, or directed graph, where pitches are nodes and intervals are edges. Nodes, however, are not stored; instead, an ordered list of edges (Intervals) is provided as an archetype of adjacent nodes. IntervalNetworks are unlike conventional graphs in that each graph must define a low and high terminus. These points are used to create a cyclic graph and are treated as point of cyclical overlap. IntervalNetwork permits the definition of conventional octave repeating scales or harmonies (abstract chords), non-octave repeating scales and chords, and ordered interval sequences that might move in multiple directions. A scale or harmony may be composed of one or more IntervalNetwork objects. Both nodes and edges can be weighted to suggest tonics, dominants, finals, or other attributes of the network. 


Edge
----



.. class:: Edge(intervalData=None, id=None, direction=bi)

    Abstraction of an Interval as an Edge. Edges store an Interval object as well as a direction specification. For directed Edges, the direction of the Interval may be used to suggest non-pitch ascending movements (even if the direction is ascending). Weight values, as well as other attributes, can be stored. 

    >>> from music21 import *
    >>> i = interval.Interval('M3')
    >>> e = intervalNetwork.Edge(i)
    >>> i is e.interval
    True 

    **Edge** **attributes**

        Attributes without Documentation: `id`, `weight`

    **Edge** **properties**

        .. attribute:: connections

            Callable as a property (.connections) or as a method (.getConnections(direction)): Return a list of connections between Nodes, represented as pairs of Node ids. If a direction is specified, and if the Edge is directional, only the desired directed values will be returned. 

            >>> from music21 import *
            >>> i = interval.Interval('M3')
            >>> e1 = intervalNetwork.Edge(i, id=0)
            >>> n1 = intervalNetwork.Node(id='terminusLow')
            >>> n2 = intervalNetwork.Node(id=1)
            >>> e1.addBiDirectedConnections(n1, n2)
            >>> e1.connections
            [('terminusLow', 1), (1, 'terminusLow')] 
            >>> e1.getConnections('ascending')
            [('terminusLow', 1)] 
            >>> e1.getConnections('descending')
            [(1, 'terminusLow')] 

            

        .. attribute:: direction

            Return the direction of the Edge. 

            >>> from music21 import *
            >>> i = interval.Interval('M3')
            >>> e1 = intervalNetwork.Edge(i, id=0)
            >>> n1 = intervalNetwork.Node(id=0)
            >>> n2 = intervalNetwork.Node(id=1)
            >>> e1.addDirectedConnection(n1, n2, 'ascending')
            >>> e1.direction
            'ascending' 

        .. attribute:: interval

            Return the stored Interval object 

            >>> from music21 import *
            >>> i = interval.Interval('M3')
            >>> e1 = intervalNetwork.Edge(i, id=0)
            >>> n1 = intervalNetwork.Node(id=0)
            >>> n2 = intervalNetwork.Node(id=1)
            >>> e1.addDirectedConnection(n1, n2, 'ascending')
            >>> e1.interval
            <music21.interval.Interval M3> 

    **Edge** **methods**

        .. method:: addBiDirectedConnections(n1, n2)

            Provide two Edge objects that pass through this Node, in the direction from the first to the second. 

            >>> from music21 import *
            >>> i = interval.Interval('M3')
            >>> e1 = intervalNetwork.Edge(i, id=0)
            >>> n1 = intervalNetwork.Node(id='terminusLow')
            >>> n2 = intervalNetwork.Node(id=1)
            >>> e1.addBiDirectedConnections(n1, n2)
            >>> e1.connections
            [('terminusLow', 1), (1, 'terminusLow')] 
            >>> e1
            <music21.intervalNetwork.Edge bi M3 [('terminusLow',1),(1,'terminusLow')]> 

        .. method:: addDirectedConnection(n1, n2, direction=None)

            Provide two Node objects that connect this Edge, in the direction from the first to the second. When calling directly, a direction, either ascending or descending, should be set here; this will override whatever the interval is. If None, this will not be set. 

            >>> from music21 import *
            >>> i = interval.Interval('M3')
            >>> e1 = intervalNetwork.Edge(i, id=0)
            >>> n1 = intervalNetwork.Node(id=0)
            >>> n2 = intervalNetwork.Node(id=1)
            >>> e1.addDirectedConnection(n1, n2, 'ascending')
            >>> e1.connections
            [(0, 1)] 
            >>> e1
            <music21.intervalNetwork.Edge ascending M3 [(0,1)]> 

        .. method:: getConnections(direction=None)

            Callable as a property (.connections) or as a method (.getConnections(direction)): Return a list of connections between Nodes, represented as pairs of Node ids. If a direction is specified, and if the Edge is directional, only the desired directed values will be returned. 

            >>> from music21 import *
            >>> i = interval.Interval('M3')
            >>> e1 = intervalNetwork.Edge(i, id=0)
            >>> n1 = intervalNetwork.Node(id='terminusLow')
            >>> n2 = intervalNetwork.Node(id=1)
            >>> e1.addBiDirectedConnections(n1, n2)
            >>> e1.connections
            [('terminusLow', 1), (1, 'terminusLow')] 
            >>> e1.getConnections('ascending')
            [('terminusLow', 1)] 
            >>> e1.getConnections('descending')
            [(1, 'terminusLow')] 

            


IntervalNetwork
---------------



.. class:: IntervalNetwork(edgeList=None, octaveDuplicating=False, deterministic=True)

    A graph of undefined Pitch nodes connected by a defined, ordered list of :class:`~music21.interval.Interval` objects as edges. An `octaveDuplicating` boolean, if defined, can be used to optimize pitch realization routines. The `deterministic` boolean, if defined, can be used to declare that there is no probabilistic or multi-pathway segments of this network. 

    **IntervalNetwork** **attributes**

        Attributes without Documentation: `octaveDuplicating`, `deterministic`

    **IntervalNetwork** **properties**

        .. attribute:: networkxGraph

            Return a networks Graph object representing a realized version of this IntervalNetwork 

        .. attribute:: stepMax

            Return the largest step value. 

            >>> edgeList = ['M2', 'M2', 'm2', 'M2', 'M2', 'M2', 'm2']
            >>> net = IntervalNetwork()
            >>> net.fillBiDirectedEdges(edgeList)
            >>> net.stepMax
            8 

        .. attribute:: stepMaxUnique

            Return the largest step value that represents a pitch level that is not a terminus of the scale. 

            >>> edgeList = ['M2', 'M2', 'm2', 'M2', 'M2', 'M2', 'm2']
            >>> net = IntervalNetwork()
            >>> net.fillBiDirectedEdges(edgeList)
            >>> net.stepMaxUnique
            7 

        .. attribute:: stepMin

            Return the lowest step value. 

            >>> edgeList = ['M2', 'M2', 'm2', 'M2', 'M2', 'M2', 'm2']
            >>> net = IntervalNetwork()
            >>> net.fillBiDirectedEdges(edgeList)
            >>> net.stepMin
            1 

        .. attribute:: terminusHighNodes

            Return a list of last Nodes, or Nodes that contain "end". Return the coordinates of the last Node. Nodes are not stored, but are encoded as pairs, index values, to stored edges. Indices are either integers or the 

            >>> edgeList = ['M2', 'M2', 'm2', 'M2', 'M2', 'M2', 'm2']
            >>> net = IntervalNetwork()
            >>> net.fillBiDirectedEdges(edgeList)
            >>> net.terminusHighNodes[0]
            <music21.intervalNetwork.Node id='terminusHigh'> 

        .. attribute:: terminusLowNodes

            Return a list of first Nodes, or Nodes that contain "terminusLow". Nodes are not stored, but are encoded as pairs, index values, to stored edges. Indices are either integers or the strings 

            >>> edgeList = ['M2', 'M2', 'm2', 'M2', 'M2', 'M2', 'm2']
            >>> net = IntervalNetwork()
            >>> net.fillBiDirectedEdges(edgeList)
            >>> net.terminusLowNodes[0]
            <music21.intervalNetwork.Node id='terminusLow'> 

    **IntervalNetwork** **methods**

        .. method:: clear()

            Remove and reset all Nodes and Edges. 

        .. method:: fillArbitrary(nodes, edges)

            Fill any arbitrary network given node and edge definitions. Nodes must be defined by a dictionary of id and step values. There must be a terminusLow and terminusHigh id as string. nodes = ({'id':'terminusLow', 'step':1}, {'id':0, 'step':2}, {'id':'terminusHigh', 'step':3}, ) Edges must be defined by a dictionary of :class:`~music21.interval.Interval` strings and connections. Id values will be automatically assigned. Each connection must define direction and pairs of valid node ids. edges = ({'interval':'m2', connections:( ['terminusLow', 0, 'bi'], )}, {'interval':'M3', connections:( [0, 'terminusHigh', 'bi'], )}, ) 

            >>> from music21 import *
            >>> nodes = ({'id':'terminusLow', 'step':1}, {'id':0, 'step':2}, {'id':'terminusHigh', 'step':3})
            >>> edges = ({'interval':'m2', 'connections':(['terminusLow', 0, 'bi'],)},{'interval':'M3', 'connections':([0, 'terminusHigh', 'bi'],)},)
            >>> net = intervalNetwork.IntervalNetwork()
            >>> net.fillArbitrary(nodes, edges)
            >>> net.realizePitch('c4', 1)
            [C4, D-4, F4] 

        .. method:: fillBiDirectedEdges(edgeList)

            Given an ordered list of bi-directed edges given as :class:`~music21.interval.Interval` specifications, create and define appropriate Nodes. This assumes that all edges are bidirected and all all edges are in order. 

            >>> from music21 import *
            >>> edgeList = ['M2', 'M2', 'm2', 'M2', 'M2', 'M2', 'm2']
            >>> net = IntervalNetwork()
            >>> net.fillBiDirectedEdges(edgeList)
            >>> net.realizePitch('g4')
            [G4, A4, B4, C5, D5, E5, F#5, G5] 
            >>> net.stepMin, net.stepMax
            (1, 8) 
            >>> # using another fill method creates a new network
            >>> net.fillBiDirectedEdges(['M3', 'M3', 'M3'])
            >>> net.realizePitch('g4')
            [G4, B4, D#5, G5] 
            >>> net.stepMin, net.stepMax
            (1, 4) 
            >>> net.fillBiDirectedEdges([interval.Interval('M3'), interval.Interval('M3'), interval.Interval('M3')])
            >>> net.realizePitch('c2')
            [C2, E2, G#2, B#2] 

        .. method:: fillDirectedEdges(ascendingEdgeList, descendingEdgeList)

            Given two lists of edges, one for ascending :class:`~music21.interval.Interval` objects and another for  descending, construct appropriate Nodes and Edges. Note that the descending :class:`~music21.interval.Interval` ojbects should be given in ascending form. 

        .. method:: fillMelodicMinor()

            A convenience routine for testing a complex, bi-directional scale. 

            >>> from music21 import *
            >>> net = intervalNetwork.IntervalNetwork()
            >>> net.fillMelodicMinor()
            >>> net.realizePitch('c4')
            [C4, D4, E-4, F4, G4, A4, B4, C5] 

            

        .. method:: find(pitchTarget, resultsReturned=4, comparisonAttribute=pitchClass, alteredNodes={})

            Given a collection of pitches, test all transpositions of a realized version of this network, and return the number of matches in each for each pitch assigned to the first node. 

            >>> from music21 import *
            >>> edgeList = ['M2', 'M2', 'm2', 'M2', 'M2', 'M2', 'm2']
            >>> net = intervalNetwork.IntervalNetwork(edgeList)
            >>> # a network built on G or D as
            >>> net.find(['g', 'a', 'b', 'd', 'f#'])
            [(5, G), (5, D), (4, A), (4, C)] 
            >>> net.find(['g', 'a', 'b', 'c', 'd', 'e', 'f#'])
            [(7, G), (6, D), (6, C), (5, A)] 

            

        .. method:: findMissing(pitchReference, nodeId, pitchTarget, comparisonAttribute=pitchClass, minPitch=None, maxPitch=None, direction=ascending, alteredNodes={})

            Find all pitches in the realized scale that are not in the pitch target network based on the comparison attribute. 

            >>> from music21 import *
            >>> edgeList = ['M2', 'M2', 'm2', 'M2', 'M2', 'M2', 'm2']
            >>> net = intervalNetwork.IntervalNetwork(edgeList)
            >>> net.realizePitch('G3')
            [G3, A3, B3, C4, D4, E4, F#4, G4] 
            >>> net.findMissing('g', 1, ['g', 'a', 'b', 'd', 'f#'])
            [C5, E5] 

        .. method:: getNeighborNodeIds(pitchReference, nodeName, pitchTarget, direction=ascending, alteredNodes={})

            Given a reference pitch assigned to node id, determine the node ids that neighbor this pitch. Returns None if an exact match. 

            >>> from music21 import *
            >>> edgeList = ['M2', 'M2', 'm2', 'M2', 'M2', 'M2', 'm2']
            >>> net = IntervalNetwork(edgeList)
            >>> net.getNeighborNodeIds('c4', 1, 'b-')
            (4, 5) 
            >>> net.getNeighborNodeIds('c4', 1, 'b')
            (5, 'terminusHigh') 

        .. method:: getPitchFromNodeStep(pitchReference, nodeName, nodeStepTarget, direction=ascending, minPitch=None, maxPitch=None, alteredNodes={})

            Given a reference pitch assigned to node id, determine the pitch for the the target node step. 

            >>> from music21 import *
            >>> edgeList = ['M2', 'M2', 'm2', 'M2', 'M2', 'M2', 'm2']
            >>> net = IntervalNetwork(edgeList)
            >>> net.realizePitch(pitch.Pitch('e-2'))
            [E-2, F2, G2, A-2, B-2, C3, D3, E-3] 
            >>> net.getPitchFromNodeStep('e4', 1, 1)
            E4 
            >>> net.getPitchFromNodeStep('e4', 1, 7) # seventh scale degree
            D#5 
            >>> net.getPitchFromNodeStep('e4', 1, 8)
            E4 
            >>> net.getPitchFromNodeStep('e4', 1, 9)
            F#4 
            >>> net.getPitchFromNodeStep('e4', 1, 3, minPitch='c2', maxPitch='c3')
            G#2 
            >>> # will always get the lowest
            >>> net.getPitchFromNodeStep('e4', 1, 3, minPitch='c2', maxPitch='c10')
            G#2 
            >>> net.fillMelodicMinor()
            >>> net.getPitchFromNodeStep('c', 1, 5)
            G4 
            >>> net.getPitchFromNodeStep('c', 1, 6, 'ascending')
            A4 
            >>> net.getPitchFromNodeStep('c', 1, 6, 'descending')
            A-4 

            

        .. method:: getRelativeNodeId(pitchReference, nodeName, pitchTarget, comparisonAttribute=ps, direction=ascending, alteredNodes={})

            Given a reference pitch assigned to node id, determine the relative node id of pitchTarget, even if displaced over multiple octaves Returns None if no match. If `getNeighbor` is True, or direction, the nearest node will be returned. If more than one node defines the same pitch, Node weights are used to select a single node. 

            >>> from music21 import *
            >>> edgeList = ['M2', 'M2', 'm2', 'M2', 'M2', 'M2', 'm2']
            >>> net = IntervalNetwork(edgeList)
            >>> net.getRelativeNodeId('a', 1, 'a4')
            'terminusLow' 
            >>> net.getRelativeNodeId('a', 1, 'b-4') == None
            True 

        .. method:: getRelativeNodeStep(pitchReference, nodeName, pitchTarget, comparisonAttribute=ps, direction=ascending, alteredNodes={})

            Given a reference pitch assigned to node id, determine the relative node id of pitchTarget, even if displaced over multiple octaves Need flags for pitch class and enharmonic comparison. 

            >>> from music21 import *
            >>> edgeList = ['M2', 'M2', 'm2', 'M2', 'M2', 'M2', 'm2']
            >>> net = IntervalNetwork(edgeList)
            >>> net.realizePitch(pitch.Pitch('e-2'))
            [E-2, F2, G2, A-2, B-2, C3, D3, E-3] 
            >>> net.getRelativeNodeStep('e-2', 1, 'd3') # if e- is tonic, what is d3
            7 
            >>> net.getRelativeNodeStep('e3', 1, 'd5') == None
            True 
            >>> net.getRelativeNodeStep('e-3', 1, 'b-3')
            5 
            >>> net.getRelativeNodeStep('e-3', 1, 'e-5')
            1 
            >>> net.getRelativeNodeStep('e-2', 1, 'f3')
            2 
            >>> net.getRelativeNodeStep('e-3', 1, 'b6') == None
            True 
            >>> net.getRelativeNodeStep('e-3', 1, 'e-2')
            1 
            >>> net.getRelativeNodeStep('e-3', 1, 'd3')
            7 
            >>> net.getRelativeNodeStep('e-3', 1, 'e-3')
            1 
            >>> net.getRelativeNodeStep('e-3', 1, 'b-1')
            5 

            
            >>> from music21 import *
            >>> edgeList = ['p4', 'p4', 'p4'] # a non octave-repeating scale
            >>> net = IntervalNetwork(edgeList)
            >>> net.realizePitch('f2')
            [F2, B-2, E-3, A-3] 
            >>> net.realizePitch('f2', 1, 'f2', 'f6')
            [F2, B-2, E-3, A-3, D-4, G-4, C-5, F-5, A5, D6] 
            >>> net.getRelativeNodeStep('f2', 1, 'a-3') # could be 4 or 1
            1 
            >>> net.getRelativeNodeStep('f2', 1, 'd-4') # 2 is correct
            2 
            >>> net.getRelativeNodeStep('f2', 1, 'g-4') # 3 is correct
            3 
            >>> net.getRelativeNodeStep('f2', 1, 'c-5') # could be 4 or 1
            1 
            >>> net.getRelativeNodeStep('f2', 1, 'e--6') # could be 4 or 1
            1 

            
            >>> net.realizePitch('f6', 1, 'f2', 'f6')
            [G#2, C#3, F#3, B3, E4, A4, D5, G5, C6, F6] 
            >>> net.getRelativeNodeStep('f6', 1, 'd5')
            1 
            >>> net.getRelativeNodeStep('f6', 1, 'g5')
            2 
            >>> net.getRelativeNodeStep('f6', 1, 'a4')
            3 
            >>> net.getRelativeNodeStep('f6', 1, 'e4')
            2 
            >>> net.getRelativeNodeStep('f6', 1, 'b3')
            1 

            

        .. method:: match(pitchReference, nodeId, pitchTarget, comparisonAttribute=pitchClass, alteredNodes={})

            Given one or more pitches in `pitchTarget`, return a list of matched pitches, and unmatched pitches. 

            >>> from music21 import *
            >>> edgeList = ['M2', 'M2', 'm2', 'M2', 'M2', 'M2', 'm2']
            >>> net = intervalNetwork.IntervalNetwork(edgeList)
            >>> net.realizePitch('e-2')
            [E-2, F2, G2, A-2, B-2, C3, D3, E-3] 
            >>> net.match('e-2', 1, 'c3') # if e- is tonic, is 'c3' in the scale?
            ([C3], []) 
            >>> net.match('e-2', 1, 'd3')
            ([D3], []) 
            >>> net.match('e-2', 1, 'd#3')
            ([D#3], []) 
            >>> net.match('e-2', 1, 'e3')
            ([], [E3]) 
            >>> pitchTarget = [pitch.Pitch('b-2'), pitch.Pitch('b2'), pitch.Pitch('c3')]
            >>> net.match('e-2', 1, pitchTarget)
            ([B-2, C3], [B2]) 
            >>> pitchTarget = ['b-2', 'b2', 'c3', 'e-3', 'e#3', 'f2', 'e--2']
            >>> net.match('e-2', 1, pitchTarget)
            ([B-2, C3, E-3, E#3, F2, E--2], [B2]) 

            

        .. method:: nextPitch(pitchReference, nodeName, pitchOrigin, direction=ascending, stepSize=1, alteredNodes={}, getNeighbor=True)

            Given a pitchReference, nodeName, and a pitch origin, return the next pitch. The `step` attribute can be configured to permit different sized steps. 

            >>> edgeList = ['M2', 'M2', 'm2', 'M2', 'M2', 'M2', 'm2']
            >>> net = IntervalNetwork()
            >>> net.fillBiDirectedEdges(edgeList)
            >>> net.nextPitch('g', 1, 'f#5', 'ascending')
            G5 
            >>> net.nextPitch('g', 1, 'f#5', 'descending')
            E5 
            >>> net.nextPitch('g', 1, 'f#5', 'ascending', 2) # two steps
            A5 
            >>> alteredNodes = {2:{'direction':'bi', 'interval':interval.Interval('-a1')}}
            >>> net.nextPitch('g', 1, 'g2', 'ascending', alteredNodes=alteredNodes)
            A-2 
            >>> net.nextPitch('g', 1, 'a-2', 'ascending', alteredNodes=alteredNodes)
            B2 

        .. method:: plot(pitchObj=None, nodeId=None, minPitch=None, maxPitch=None, *args, **keywords)

            Given a method and keyword configuration arguments, create and display a plot. 

        .. method:: realize(pitchReference, nodeId=None, minPitch=None, maxPitch=None, direction=ascending, alteredNodes={}, reverse=False)

            Realize the nodes of this network based on a pitch assigned to a valid `nodeId`, where `nodeId` can be specified by integer (starting from 1) or key (a tuple of origin, destination keys). Without a min or max pitch, the given pitch reference is assigned to the designated node, and then both ascends to the terminus and descends to the terminus. The `alteredNodes` dictionary permits creating mappings between node step and direction and :class:`~music21.interval.Interval` based transpositions. Returns two lists, a list of pitches, and a list of Node keys. 

            >>> from music21 import *
            >>> edgeList = ['M2', 'M2', 'm2', 'M2', 'M2', 'M2', 'm2']
            >>> net = IntervalNetwork()
            >>> net.fillBiDirectedEdges(edgeList)
            >>> net.realize('c2', 1, 'c2', 'c3')
            ([C2, D2, E2, F2, G2, A2, B2, C3], ['terminusLow', 0, 1, 2, 3, 4, 5, 'terminusHigh']) 
            >>> alteredNodes = {7:{'direction':'bi', 'interval':interval.Interval('-a1')}}
            >>> net.realize('c2', 1, 'c2', 'c4', alteredNodes=alteredNodes)
            ([C2, D2, E2, F2, G2, A2, B-2, C3, D3, E3, F3, G3, A3, B-3, C4], ['terminusLow', 0, 1, 2, 3, 4, 5, 'terminusHigh', 0, 1, 2, 3, 4, 5, 'terminusHigh']) 

            

        .. method:: realizeMinMax(pitchReference, nodeId=None, alteredNodes={})

            Realize the min and max pitches of the scale, or the min and max values found between two termini. This suggests that min and max might be beyond the terminus. 

            >>> from music21 import *
            >>> edgeList = ['M2', 'M2', 'm2', 'M2', 'M2', 'M2', 'm2']
            >>> net = IntervalNetwork()
            >>> net.fillBiDirectedEdges(edgeList)

        .. method:: realizePitch(pitchReference, nodeId=None, minPitch=None, maxPitch=None, direction=ascending, alteredNodes={}, reverse=False)

            Realize the native nodes of this network based on a pitch assigned to a valid `nodeId`, where `nodeId` can be specified by integer (starting from 1) or key (a tuple of origin, destination keys). The nodeId, when a simple, linear network, can be used as a scale step value starting from one. 

            >>> from music21 import *
            >>> edgeList = ['M2', 'M2', 'm2', 'M2', 'M2', 'M2', 'm2']
            >>> net = IntervalNetwork()
            >>> net.fillBiDirectedEdges(edgeList)
            >>> net.realizePitch(pitch.Pitch('G3'))
            [G3, A3, B3, C4, D4, E4, F#4, G4] 
            >>> net.realizePitch(pitch.Pitch('G3'), 5) # G3 is the fifth (scale) degree
            [C3, D3, E3, F3, G3, A3, B3, C4] 
            >>> net.realizePitch(pitch.Pitch('G3'), 7) # G3 is the seventh (scale) degree
            [A-2, B-2, C3, D-3, E-3, F3, G3, A-3] 
            >>> net.realizePitch(pitch.Pitch('G3'), 1) # seventh (scale) degree
            [G3, A3, B3, C4, D4, E4, F#4, G4] 
            >>> net.realizePitch(pitch.Pitch('f#3'), 1, 'f2', 'f3')
            [E#2, F#2, G#2, A#2, B2, C#3, D#3, E#3] 
            >>> net.realizePitch(pitch.Pitch('a#2'), 7, 'c6', 'c7')
            [C#6, D#6, E6, F#6, G#6, A#6, B6] 

        .. method:: realizePitchByStep(pitchReference, nodeId=None, nodeStepTargets=[1], minPitch=None, maxPitch=None, direction=ascending, alteredNodes={})

            Realize the native nodes of this network based on a pitch assigned to a valid `nodeId`, where `nodeId` can be specified by integer (starting from 1) or key (a tuple of origin, destination keys). The `targetSteps` specifies the the steps to be included within the specified range. 

            >>> from music21 import *
            >>> edgeList = ['M2', 'M2', 'm2', 'M2', 'M2', 'M2', 'm2']
            >>> net = IntervalNetwork()
            >>> net.fillBiDirectedEdges(edgeList)
            >>> net.realizePitchByStep('g', 5, [1,5], 'c2', 'c4')
            [C2, G2, C3, G3, C4] 
            >>> net.realizePitchByStep('g', 5, [1,2,3], 'c1', 'c6')
            [C1, D1, E1, C2, D2, E2, C3, D3, E3, C4, D4, E4, C5, D5, E5, C6] 
            >>> net.realizePitchByStep('c', 1, [1,5], 'c3', 'c6')
            [C3, G3, C4, G4, C5, G5, C6] 

            

        .. method:: realizeTermini(pitchReference, nodeId=None, alteredNodes={})

            Realize the pithches of the 'natural' terminus of a network. This (presently) must be done by ascending, and assumes only one valid terminus for both extremes. This suggests that in practice termini should not be affected by directionality. 

            >>> from music21 import *
            >>> edgeList = ['M2', 'M2', 'm2', 'M2', 'M2', 'M2', 'm2']
            >>> net = IntervalNetwork()
            >>> net.fillBiDirectedEdges(edgeList)
            >>> net.realizeTermini(pitch.Pitch('G3'))
            (G3, G4) 
            >>> net.realizeTermini(pitch.Pitch('a6'))
            (A6, A7) 


Node
----



.. class:: Node(id=None, step=None, weight=1.0)

    Abstraction of an unrealized Pitch Node. The Node id is used to storing connections in Edges. Terminal Nodes have special ids: terminusLow, terminusHighs 

    **Node** **attributes**

        Attributes without Documentation: `step`, `id`, `weight`


