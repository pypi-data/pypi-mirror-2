<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
  <head>
    <title>xml</title>
    <meta content="text/html;charset=ISO-8859-1" name="Content-Type"/>
    <link href="style.css" media="screen" rel="stylesheet" type="text/css"/></head>
  <body>
    <div id="navspace">
      <div><a href="http://pylib.org"><img alt="py lib" height="57" id="pyimg" src="http://codespeak.net/img/pylib.png" width="77"/></a></div>
      <div id="menubar">
        <div>
          <div><a class="menu" href="announce/release-1.3.2.html">1.3.2 ANN</a></div></div>
        <div>
          <div><a class="menu" href="install.html">INSTALL</a></div></div>
        <div>
          <div><a class="menu" href="contact.html">CONTACT</a></div></div>
        <div>
          <div><a class="menu" href="changelog.html">CHANGELOG</a></div></div>
        <div>
          <div><a class="menu" href="faq.html">FAQ</a></div></div>
        <div>
          <div>
            <h3>py.test:</h3>
            <div><a class="menu" href="test/index.html">Index</a></div>
            <div><a class="menu" href="test/quickstart.html">Quickstart</a></div>
            <div><a class="menu" href="test/features.html">Features</a></div>
            <div><a class="menu" href="test/funcargs.html">Funcargs</a></div>
            <div><a class="menu" href="test/plugin/index.html">Plugins</a></div>
            <div><a class="menu" href="test/customize.html">Customize</a></div>
            <div><a class="menu" href="test/talks.html">Tutorials</a></div><a class="menu" href="http://hudson.testrun.org">hudson-tests</a></div></div>
        <div>
          <div>
            <h3>supporting APIs:</h3>
            <div><a class="menu" href="index.html">Index</a></div>
            <div><a class="menu" href="path.html">py.path</a></div>
            <div><a class="menu" href="code.html">py.code</a></div></div></div></div></div>
    <div id="contentspace">
<div class="document" id="py-xml-lightweight-and-flexible-xml-html-generation">
<h1 class="title">py.xml: Lightweight and flexible xml/html generation</h1>

<div class="section" id="motivation">
<h1>Motivation</h1>
<p>There are a plethora of frameworks and libraries to generate
xml and html trees.  However, many of them are large, have a
steep learning curve and are often hard to debug.  Not to
speak of the fact that they are frameworks to begin with.</p>
<p>The py lib strives to offer enough functionality to represent
itself and especially its API in html or xml.</p>
</div>
<div class="section" id="a-pythonic-object-model-please">
<h1>a pythonic object model , please</h1>
<p>The py lib offers a pythonic way to generate xml/html, based on
ideas from <a class="reference external" href="http://www.livinglogic.de/Python/xist/index.html">xist</a> which <a class="reference external" href="http://www.livinglogic.de/Python/xist/Howto.html">uses python class objects</a> to build
xml trees.  However, <a class="reference external" href="http://www.livinglogic.de/Python/xist/index.html">xist</a>'s implementation is somewhat heavy
because it has additional goals like transformations and
supporting many namespaces.  But its basic idea is very easy.</p>
<div class="section" id="generating-arbitrary-xml-structures">
<h2>generating arbitrary xml structures</h2>
<p>With <tt class="docutils literal">py.xml.Namespace</tt> you have the basis
to generate custom xml-fragments on the fly:</p>
<pre class="literal-block">
class ns(py.xml.Namespace):
    &quot;my custom xml namespace&quot;
doc = ns.books(
    ns.book(
        ns.author(&quot;May Day&quot;),
        ns.title(&quot;python for java programmers&quot;),),
    ns.book(
        ns.author(&quot;why&quot;),
        ns.title(&quot;Java for Python programmers&quot;),),
    publisher=&quot;N.N&quot;,
    )
print doc.unicode(indent=2).encode('utf8')
</pre>
<p>will give you this representation:</p>
<pre class="literal-block">
&lt;books publisher=&quot;N.N&quot;&gt;
  &lt;book&gt;
    &lt;author&gt;May Day&lt;/author&gt;
    &lt;title&gt;python for java programmers&lt;/title&gt;&lt;/book&gt;
  &lt;book&gt;
    &lt;author&gt;why&lt;/author&gt;
    &lt;title&gt;Java for Python programmers&lt;/title&gt;&lt;/book&gt;&lt;/books&gt;
</pre>
<p>In a sentence: positional arguments are child-tags and
keyword-arguments are attributes.</p>
<p>On a side note, you'll see that the unicode-serializer
supports a nice indentation style which keeps your generated
html readable, basically through emulating python's white
space significance by putting closing-tags rightmost and
almost invisible at first glance :-)</p>
</div>
<div class="section" id="basic-example-for-generating-html">
<h2>basic example for generating html</h2>
<p>Consider this example:</p>
<pre class="literal-block">
from py.xml import html  # html namespace

paras = &quot;First Para&quot;, &quot;Second para&quot;

doc = html.html(
   html.head(
        html.meta(name=&quot;Content-Type&quot;, value=&quot;text/html; charset=latin1&quot;)),
   html.body(
        [html.p(p) for p in paras]))

print unicode(doc).encode('latin1')
</pre>
<p>Again, tags are objects which contain tags and have attributes.
More exactly, Tags inherit from the list type and thus can be
manipulated as list objects.  They additionally support a default
way to represent themselves as a serialized unicode object.</p>
<p>If you happen to look at the py.xml implementation you'll
note that the tag/namespace implementation consumes some 50 lines
with another 50 lines for the unicode serialization code.</p>
</div>
<div class="section" id="css-styling-your-html-tags">
<h2>CSS-styling your html Tags</h2>
<p>One aspect where many of the huge python xml/html generation
frameworks utterly fail is a clean and convenient integration
of CSS styling.  Often, developers are left alone with keeping
CSS style definitions in sync with some style files
represented as strings (often in a separate .css file).  Not
only is this hard to debug but the missing abstractions make
it hard to modify the styling of your tags or to choose custom
style representations (inline, html.head or external).  Add the
Browers usual tolerance of messyness and errors in Style
references and welcome to hell, known as the domain of
developing web applications :-)</p>
<p>By contrast, consider this CSS styling example:</p>
<pre class="literal-block">
class my(html):
    &quot;my initial custom style&quot;
    class body(html.body):
        style = html.Style(font_size = &quot;120%&quot;)

    class h2(html.h2):
        style = html.Style(background = &quot;grey&quot;)

    class p(html.p):
        style = html.Style(font_weight=&quot;bold&quot;)

doc = my.html(
    my.head(),
    my.body(
        my.h2(&quot;hello world&quot;),
        my.p(&quot;bold as bold can&quot;)
    )
)

print doc.unicode(indent=2)
</pre>
<p>This will give you a small'n mean self contained
represenation by default:</p>
<pre class="literal-block">
&lt;html&gt;
  &lt;head/&gt;
  &lt;body style=&quot;font-size: 120%&quot;&gt;
    &lt;h2 style=&quot;background: grey&quot;&gt;hello world&lt;/h2&gt;
    &lt;p style=&quot;font-weight: bold&quot;&gt;bold as bold can&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
</pre>
<p>Most importantly, note that the inline-styling is just an
implementation detail of the unicode serialization code.
You can easily modify the serialization to put your styling into the
<tt class="docutils literal">html.head</tt> or in a separate file and autogenerate CSS-class
names or ids.</p>
<p>Hey, you could even write tests that you are using correct
styles suitable for specific browser requirements.  Did i mention
that the ability to easily write tests for your generated
html and its serialization could help to develop _stable_ user
interfaces?</p>
</div>
<div class="section" id="more-to-come">
<h2>More to come ...</h2>
<p>For now, i don't think we should strive to offer much more
than the above.   However, it is probably not hard to offer
<em>partial serialization</em> to allow generating maybe hundreds of
complex html documents per second.   Basically we would allow
putting callables both as Tag content and as values of
attributes.  A slightly more advanced Serialization would then
produce a list of unicode objects intermingled with callables.
At HTTP-Request time the callables would get called to
complete the probably request-specific serialization of
your Tags.  Hum, it's probably harder to explain this than to
actually code it :-)</p>
</div>
</div>
</div>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-7597274-3");
pageTracker._trackPageview();
} catch(err) {}</script>
</body></html>