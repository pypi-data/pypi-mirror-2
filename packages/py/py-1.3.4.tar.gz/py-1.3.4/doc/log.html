<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
  <head>
    <title>log</title>
    <meta content="text/html;charset=ISO-8859-1" name="Content-Type"/>
    <link href="style.css" media="screen" rel="stylesheet" type="text/css"/></head>
  <body>
    <div id="navspace">
      <div><a href="http://pylib.org"><img alt="py lib" height="57" id="pyimg" src="http://codespeak.net/img/pylib.png" width="77"/></a></div>
      <div id="menubar">
        <div>
          <div><a class="menu" href="announce/release-1.3.4.html">1.3.4 ANN</a></div></div>
        <div>
          <div><a class="menu" href="install.html">INSTALL</a></div></div>
        <div>
          <div><a class="menu" href="contact.html">CONTACT</a></div></div>
        <div>
          <div><a class="menu" href="changelog.html">CHANGELOG</a></div></div>
        <div>
          <div><a class="menu" href="faq.html">FAQ</a></div></div>
        <div>
          <div>
            <h3>py.test:</h3>
            <div><a class="menu" href="test/index.html">Index</a></div>
            <div><a class="menu" href="test/quickstart.html">Quickstart</a></div>
            <div><a class="menu" href="test/features.html">Features</a></div>
            <div><a class="menu" href="test/funcargs.html">Funcargs</a></div>
            <div><a class="menu" href="test/plugin/index.html">Plugins</a></div>
            <div><a class="menu" href="test/customize.html">Customize</a></div>
            <div><a class="menu" href="test/talks.html">Tutorials</a></div><a class="menu" href="http://hudson.testrun.org">hudson-tests</a></div></div>
        <div>
          <div>
            <h3>supporting APIs:</h3>
            <div><a class="menu" href="index.html">Index</a></div>
            <div><a class="menu" href="path.html">py.path</a></div>
            <div><a class="menu" href="code.html">py.code</a></div></div></div></div></div>
    <div id="contentspace">
<div class="document" id="py-log-documentation-and-musings">
<h1 class="title">py.log documentation and musings</h1>

<!-- XXX figure out how the code literals should be dealt with in sphinx. There is probably something builtin. -->
<div class="section" id="foreword">
<h1>Foreword</h1>
<p>This document is an attempt to briefly state the actual specification of the
<tt class="code docutils literal">py.log</tt> module.  It was written by Francois Pinard and also contains
some ideas for enhancing the py.log facilities.</p>
<p>NOTE that <tt class="code docutils literal">py.log</tt> is subject to refactorings, it may change with
the next release.</p>
<p>This document is meant to trigger or facilitate discussions.  It shamelessly
steals from the <a class="reference external" href="http://agiletesting.blogspot.com/2005/06/keyword-based-logging-with-py-library.html">Agile Testing</a> comments, and from other sources as well,
without really trying to sort them out.</p>
</div>
<div class="section" id="logging-organisation">
<h1>Logging organisation</h1>
<p>The <tt class="code docutils literal">py.log</tt> module aims a niche comparable to the one of the
<a class="reference external" href="http://www.python.org/doc/2.4.2/lib/module-logging.html">logging module</a> found within the standard Python distributions, yet
with much simpler paradigms for configuration and usage.</p>
<p>Holger Krekel, the main <tt class="code docutils literal">py</tt> library developer, introduced
the idea of keyword-based logging and the idea of logging <em>producers</em> and
<em>consumers</em>.  A log producer is an object used by the application code
to send messages to various log consumers.  When you create a log
producer, you define a set of keywords that are then used to both route
the logging messages to consumers, and to prefix those messages.</p>
<p>In fact, each log producer has a few keywords associated with it for
identification purposes.  These keywords form a tuple of strings, and
may be used to later retrieve a particular log producer.</p>
<p>A log producer may (or may not) be associated with a log consumer, meant
to handle log messages in particular ways.  The log consumers can be
<tt class="docutils literal">STDOUT</tt>, <tt class="docutils literal">STDERR</tt>, log files, syslog, the Windows Event Log, user
defined functions, etc.  (Yet, logging to syslog or to the Windows Event
Log is only future plans for now).  A log producer has never more than
one consumer at a given time, but it is possible to dynamically switch
a producer to use another consumer.  On the other hand, a single log
consumer may be associated with many producers.</p>
<p>Note that creating and associating a producer and a consumer is done
automatically when not otherwise overriden, so using <tt class="code docutils literal">py</tt> logging
is quite comfortable even in the smallest programs.  More typically,
the application programmer will likely design a hierarchy of producers,
and will select keywords appropriately for marking the hierarchy tree.
If a node of the hierarchical tree of producers has to be divided in
sub-trees, all producers in the sub-trees share, as a common prefix, the
keywords of the node being divided.  In other words, we go further down
in the hierarchy of producers merely by adding keywords.</p>
</div>
<div class="section" id="using-the-py-log-library">
<h1>Using the py.log library</h1>
<p>To use the <tt class="code docutils literal">py.log</tt> library, the user must import it into a Python
application, create at least one log producer and one log consumer, have
producers and consumers associated, and finally call the log producers
as needed, giving them log messages.</p>
<div class="section" id="importing">
<h2>Importing</h2>
<p>Once the <tt class="code docutils literal">py</tt> library is installed on your system, a mere:</p>
<pre class="literal-block">
import py
</pre>
<p>holds enough magic for lazily importing the various facilities of the
<tt class="code docutils literal">py</tt> library when they are first needed.  This is really how
<tt class="code docutils literal">py.log</tt> is made available to the application.  For example, after
the above <tt class="docutils literal">import py</tt>, one may directly write <tt class="docutils literal"><span class="pre">py.log.Producer(...)</span></tt>
and everything should work fine, the user does not have to worry about
specifically importing more modules.</p>
</div>
<div class="section" id="creating-a-producer">
<h2>Creating a producer</h2>
<p>There are three ways for creating a log producer instance:</p>
<blockquote>
<ul class="simple">
<li>As soon as <tt class="docutils literal">py.log</tt> is first evaluated within an application
program, a default log producer is created, and made available under
the name <tt class="docutils literal">py.log.default</tt>.  The keyword <tt class="docutils literal">default</tt> is associated
with that producer.</li>
<li>The <tt class="docutils literal">py.log.Producer()</tt> constructor may be explicitly called
for creating a new instance of a log producer.  That constructor
accepts, as an argument, the keywords that should be associated with
that producer.  Keywords may be given either as a tuple of keyword
strings, or as a single space-separated string of keywords.</li>
<li>Whenever an attribute is <em>taken</em> out of a log producer instance,
for the first time that attribute is taken, a new log producer is
created.  The keywords associated with that new producer are those
of the initial producer instance, to which is appended the name of
the attribute being taken.</li>
</ul>
</blockquote>
<p>The last point is especially useful, as it allows using log producers
without further declarations, merely creating them <em>on-the-fly</em>.</p>
</div>
<div class="section" id="creating-a-consumer">
<h2>Creating a consumer</h2>
<p>There are many ways for creating or denoting a log consumer:</p>
<blockquote>
<ul>
<li><p class="first">A default consumer exists within the <tt class="docutils literal">py.log</tt> facilities, which
has the effect of writing log messages on the Python standard output
stream.  That consumer is associated at the very top of the producer
hierarchy, and as such, is called whenever no other consumer is
found.</p>
</li>
<li><p class="first">The notation <tt class="docutils literal">py.log.STDOUT</tt> accesses a log consumer which writes
log messages on the Python standard output stream.</p>
</li>
<li><p class="first">The notation <tt class="docutils literal">py.log.STDERR</tt> accesses a log consumer which writes
log messages on the Python standard error stream.</p>
</li>
<li><p class="first">The <tt class="docutils literal">py.log.File()</tt> constructor accepts, as argument, either a file
already opened in write mode or any similar file-like object, and
creates a log consumer able to write log messages onto that file.</p>
</li>
<li><p class="first">The <tt class="docutils literal">py.log.Path()</tt> constructor accepts a file name for its first
argument, and creates a log consumer able to write log messages into
that file.  The constructor call accepts a few keyword parameters:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal">append</tt>, which is <tt class="docutils literal">False</tt> by default, may be used for
opening the file in append mode instead of write mode.</li>
<li><tt class="docutils literal">delayed_create</tt>, which is <tt class="docutils literal">False</tt> by default, maybe be used
for opening the file at the latest possible time.  Consequently,
the file will not be created if it did not exist, and no actual
log message gets written to it.</li>
<li><tt class="docutils literal">buffering</tt>, which is 1 by default, is used when opening the
file.  Buffering can be turned off by specifying a 0 value.  The
buffer size may also be selected through this argument.</li>
</ul>
</blockquote>
</li>
<li><p class="first">Any user defined function may be used for a log consumer.  Such a
function should accept a single argument, which is the message to
write, and do whatever is deemed appropriate by the programmer.
When the need arises, this may be an especially useful and flexible
feature.</p>
</li>
<li><p class="first">The special value <tt class="docutils literal">None</tt> means no consumer at all.  This acts just
like if there was a consumer which would silently discard all log
messages sent to it.</p>
</li>
</ul>
</blockquote>
</div>
<div class="section" id="associating-producers-and-consumers">
<h2>Associating producers and consumers</h2>
<p>Each log producer may have at most one log consumer associated with
it.  A log producer gets associated with a log consumer through a
<tt class="docutils literal">py.log.set_consumer()</tt> call.  That function accepts two arguments,
the first identifying a producer (a tuple of keyword strings or a single
space-separated string of keywords), the second specifying the precise
consumer to use for that producer.  Until this function is called for a
producer, that producer does not have any explicit consumer associated
with it.</p>
<p>Now, the hierarchy of log producers establishes which consumer gets used
whenever a producer has no explicit consumer.  When a log producer
has no consumer explicitly associated with it, it dynamically and
recursively inherits the consumer of its parent node, that is, that node
being a bit closer to the root of the hierarchy.  In other words, the
rightmost keywords of that producer are dropped until another producer
is found which has an explicit consumer.  A nice side-effect is that,
by explicitly associating a consumer with a producer, all consumer-less
producers which appear under that producer, in the hierarchy tree,
automatically <em>inherits</em> that consumer.</p>
</div>
<div class="section" id="writing-log-messages">
<h2>Writing log messages</h2>
<p>All log producer instances are also functions, and this is by calling
them that log messages are generated.  Each call to a producer object
produces the text for one log entry, which in turn, is sent to the log
consumer for that producer.</p>
<p>The log entry displays, after a prefix identifying the log producer
being used, all arguments given in the call, converted to strings and
space-separated.  (This is meant by design to be fairly similar to what
the <tt class="docutils literal">print</tt> statement does in Python).  The prefix itself is made up
of a colon-separated list of keywords associated with the producer, the
whole being set within square brackets.</p>
<p>Note that the consumer is responsible for adding the newline at the end
of the log entry.  That final newline is not part of the text for the
log entry.</p>
<!-- Other details -->
<!-- - - - - - - - - - - - - - -->
<!-- XXX: fill in details -->
<!-- + Should speak about pickle-ability of :code:`py.log`. -->
<!--  -->
<!-- + What is :code:`log.get` (in :file:`logger.py`)? -->
</div>
</div>
</div>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-7597274-3");
pageTracker._trackPageview();
} catch(err) {}</script>
</body></html>