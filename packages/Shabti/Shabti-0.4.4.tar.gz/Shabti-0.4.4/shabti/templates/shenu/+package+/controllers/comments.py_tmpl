# -*- coding: utf-8 -*-
import logging
from pylons import url, request, tmpl_context as c
from pylons.controllers.util import abort, redirect
from pylons.decorators import rest, validate as pvalidate
from pylons.decorators.secure import authenticate_form
from datetime import datetime
from sqlalchemy.exc import IntegrityError 
from formencode import htmlfill
from formencode.api import Invalid
from webhelpers.html.tags import ModelTags
from {{package}}.lib.base import BaseController, render
import {{package}}.lib.helpers as h
import {{package}}.model as model

log = logging.getLogger(__name__)

class CommentsController(BaseController):
    """REST Controller styled on the Atom Publishing Protocol"""
    # To properly map this controller, ensure your config/routing.py file has
    # a resource setup:
    #     map.resource('comment, 'comments')
    
    def __before__(self):
        c.dcmeta = h.dcmeta(title="Comment CRUD", description="Comment CRUD")
    
    @rest.restrict('GET')
    def index(self, format='html'):
        """GET /comments: All items in the collection."""
        q = model.Session.query(model.Comment)
        c.entries = q.all()
        c.entry_columns = ['id', 'content', 'creation_time', 'approved', 'author_id', 'post_id', 'parent_id']
        return render('/comments/list.mako')
    
    
    @rest.restrict('GET')	
    def show(self, id, format='html'):
        """GET /comments/id: Show a specific item."""
        # url('comment', id=ID)
        if not id:
            abort(404)
        q = model.Session.query(model.Comment)
        c.entry = q.get(id)
        return render('/comments/show.mako')
    
    
    def new(self, format='html'):
        """GET /comments/new: Form to create a new item."""
        # url('new_comment')
        c.entry = model.Comment()
        c.model_tags = h.ModelTags(c.entry)
        return render('/comments/new.mako') 
    
    
    @rest.restrict('POST')	
    @authenticate_form
    # @pvalidate(schema=new_commentForm(), form='new_comment_form')
    def create(self):
        """POST /comments: Create a new item."""
        # url('comments')
        entry = model.Comment()
        for col in ['content', 'creation_time', 'approved', 'author_id', 'post_id', 'parent_id']: 
            if request.params[col]:
                setattr(entry,col,request.params[col])
        model.Session.save(entry)
        try:
            model.Session.commit()
            h.flash('Comment successfully created!')
            redirect(url('comments'))
        except (Invalid,IntegrityError),e:
            c.model_tags = h.ModelTags(c.entry)
            if type(e) == Invalid:
                errors = e.errors_dict
            else:
                errors = {}
                h.flash(e.message)
            return htmlfill.render(\
                    render('/comments/new.mako'), \
                    errors = errors, 
                    defaults = request.params)
    
    
    @rest.restrict('GET')	
    def edit(self, id, format='html'):
        """GET /comments/id;edit: Form to edit an existing item."""
        # url('edit_comment', id=ID)
        if not id:
            abort(404)
        q = model.Session.query(model.Comment)
        c.entry = q.get(id)
        c.model_tags = ModelTags(c.entry)
        return render('/comments/edit.mako')
    
    
    @rest.restrict('PUT')	
    @authenticate_form
    # @pvalidate(schema=edit_commentForm(), form='edit_comment_form')
    def update(self, id):
        """PUT /comments/id: Update an existing item."""
        # url('comment', id=ID)
        if not id:
            abort(404)
        q = model.Session.query(model.Comment)
        entry = q.get(id)
        updated = False
        for col in ['content', 'creation_time', 'approved', 'author_id', 'post_id', 'parent_id']:
            if str(getattr(entry,col)) != request.params[col]:
                if col not in ('created_at','updated_at'):
                    setattr(entry,col,request.params[col])
                    updated = True
        
        if updated:
            entry.updated_at = datetime.now()
            try:
                model.Session.commit()
                h.flash('Comment successfully updated!')
                redirect('comment', id = id)	            
            except (Invalid,IntegrityError),e:
                model.meta.Session.rollback()
                c.entry = entry
                c.model_tags = ModelTags(c.entry)
                if type(e) == Invalid:
                    errors = e.errors_dict
                else:
                    errors = {}
                    h.flash(e.message)
                return htmlfill.render(\
                        render('/comments/edit.mako'), \
                        errors = errors, 
                        defaults = request.params)
        #    h.form(h.url('comment', id=ID),
        #           method='put')
    
    
    @rest.restrict('DELETE')
    def delete(self, id):
        """DELETE /comments/id: Delete an existing item."""
        # Forms posted to this method should contain a hidden field:
        #    <input type="hidden" name="_method" value="DELETE" />
        # Or using helpers:
        #    h.form(h.url('comment', id=ID),
        #           method='delete')
        # url('comment', id=ID)
        if not id:
            abort(404)
        q = model.Session.query(model.Comment)
        entry = q.get(id)
        model.Session.delete(entry)
        model.Session.commit()
        h.flash('Comment id = ' + str(entry.id) + ' was succesfully deleted!')
        redirect(url('comments'))
    
    
    
