<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>rvect -- R Vectors in Python</title>
<style type="text/css">
html, body {
	padding: 0;
	margin: 0;
	font-family: Arial, Helvetica, sans-serif;
	color: black;
	background-color: rgb(242, 236, 209);
}
div#topheader {
	position: absolute;
	top: 0; left: 10%; width: 65%;
	background-color: rgb(228, 215, 152);
	border-bottom: 4px solid #814324;
	border-left: 4px solid #814324;
	border-right: 4px solid #814324;
	height: 6em;
	}
div#title {
	position: relative;
	top: 0.5em; left: 5%; width: 75%;
	padding: 0.5em 3em 0.5em 0em;
	text-align: center;
	font-family: Arial, Helvetica, sans-serif;
	font-size: 1.5em;
	font-weight: bold;
	word-spacing: 0.05em;
	color: #814324;
	background-color: rgb(250, 250, 210);
	border: 1px solid #814324;
	filter: alpha(opacity=80);
	opacity: 0.8;
	}
div#subtitle {
	position: absolute;
	bottom: 0.5em; width: 100%;
	text-align: center;
	font-family: Arial, Helvetica, sans-serif;
	font-size: 0.8em;
	font-weight: bold;
	color: #814324;
	}
#content {
	margin: 5.5em 20px 0 20px;
	}
p {
	text-indent: 2em;
	margin: 0.2em 0 0 0;
	word-spacing: 0.05em;
	max-width: 55em;
	}
p.initial {
	text-indent: 0;
	margin: 0 0;
	}
li {
	max-width: 50em;
	margin-top: 0.3em;
	}
table {
	margin: 1em 40px;
	}
td, th {
	padding: 0 10px;
	text-align: center;
	}
div.code {
	margin: 0.5em 2em;
	padding: 0.25em 0.25em;
	border: 1px dotted rgb(123, 108, 34);
	font-family: "Courier New", Courier, fixed;
	font-size: 0.9em;
	/*background-color: rgb(250, 250, 210);*/
	background-color: rgb(252, 252, 226);
	/*color: rgb(129, 113, 36);*/
	color: rgb(123, 108, 34);
	white-space: pre;
	}
span.code {
	font-family: "Courier New", Courier, fixed;
	}
</style>
</head>
<body>
<div id="topheader"><div id="subtitle">R Vectors in Python</div></div>
<div id="title">rvect.py</div>
<div id="content">
<p class="initial"><span class="code">rvect.py</span> is a Python module that defines a class
(Rvect) implementing a data type that simulates the vector data type used in the 
<a href="http://www.r-project.org/">R</a> language for statistical computing.</p>

<p>Mathematical operations on vectors (Rvect objects) are similar
in syntax but different in function than operations on Python lists.  In general,
operations on vectors are applied to each element of the vector, rather than to the
vector as a whole.  Whereas multiplying a Python list by a positive integer extends the length
of the list, multiplying a vector by a positive integer increases the magnitude of
each element of the vector but does not change the length of the vector.</p>

<p>The <span class="code">rvect</span> module does not interact in
any way with <a href="http://www.r-project.org/">R</a>&mdash;other Python modules
(e.g., <a href="http://rpy.sourceforge.net/">RPy</a>) provide that functionality.  
The <span class="code">rvect</span> module only provides
another Python data type, similar to vectors in R, that are useful for some types
of calculations.</p>

<h2>Examples</h2>

<p class="initial">To illustrate the usage of Rvect objects, the following examples 
contrast operations on Python lists and on Rvect objects.</p>
<ol>
<li>Multiplying by a scalar
<div class="code">	>>> [1, 2, 3] * 2
	[1, 2, 3, 1, 2, 3]
	>>> Rvect([1, 2, 3]) * 2
	[2, 4, 6]
</div>
</li>
<li>Adding a scalar
<div class="code">	>>> [1, 2, 3] + 2
	TypeError
	>>> Rvect([1, 2, 3]) + 2
	[3, 4, 5]
</div>
</li>
<li>Multiplying two lists or vectors
<div class="code">	>>> [1, 2, 3] * [4, 5, 6]
	TypeError
	>>> Rvect([1, 2, 3]) * Rvect([4, 5, 6])
	[4, 10, 18]
</div>
</li>
<li>Adding two lists or vectors
<div class="code">	>>> [1, 2, 3] + [4, 5, 6]
	[1, 2, 3, 4, 5, 6]
	>>> Rvect([1, 2, 3]) + Rvect([4, 5, 6])
	[5, 7, 9]
</div>
</li>
<li>Binary logical operations on two lists or vectors
<div class="code">	>>> [True, True, False, False] and [True, False, True, False]
	[True, False, True, False]
	>>> list_and( [True, True, False, False], [True, False, True, False] )
	[True, False, False, False]
	>>> Rvect([True, True, False, False]).logical_and( Rvect([True, False, True, False]) )
	[True, False, False, False]
</div>
</li>
</ol>

<h2>Notes</h2>
<ol>
<li>This module contains several functions that implement basic
	listwise operations (e.g., and, or, sum, product) on lists or
	tuples, in addition to the class (Rvect) that defines overloaded operators
	for these and other functions.
</li>
<li>Whereas elements of an R vector must all
	be of the same type, the Rvect class has no such constraint&mdash;Rvect
	elements may be of any type, as with a Python list.  
	The class does contain methods to coerce all elements to several
	specific types, however.
</li>
<li>Because Python does not allow a class to define its own __not__ method,
	the command
<div class="code">	not Rvect()
</div>
	does not work as might be expected (that is, not as in R).  Instead, there is a method named
<div class="code">	.logical_not()
</div>
	of an Rvect object that must be called instead.
</li>
<li>Because Python implements the logical binary infix operations 'and',
	'or', and 'xor' by calling __nonzero__ or __len__ on each object and then
	executing the Boolean logic itself, logical binary combination
	of Rvect objects cannot be done using the 'and', 'or', and 'xor' infix operators.
	Instead, the following functions are defined:
<div class="code">	.logical_and(Rvect1, Rvect2, ...)
	.logical_or(Rvect1, Rvect2, ...)
	.logical_xor(...)
</div>
</li>
<li>The special methods __and__, __or__, and __xor__, which correspond to the
	binary infix operators '&', '|', and '^',are for binary, not logical,
	comparisons.  In R, however, these infix operators peform logical
	comparisons.  Therefore, the special methods have been implemented
	so that they convert their arguments to booleans, and therefore correspond
	to logical operators, and so operate similarly to the equivalent
	R operators.  Thus, for Rvects a and b, the following two expressions
	are equivalent:
<div class="code">	a.logical_and(b)
	a & b
</div>
	Both return a vector of booleans.  As per the previous note, these are <em>not</em>
	equivalent to
<div class="code">	a and b
</div>
	which returns a single boolean value.
</li>
<li>The 'list_...()' functions in this module allow operation on multiple
	lists, whereas the binary infix mathematical operators implemented
	for Rvect instances only allow operation on two objects.  For example,
	multiple lists can 	be summed in parallel with
<div class="code">	list_sum(list1, list2, list3,...)
</div>
	However, the arguments to the 'list_...()' functions must all be lists
	of the same length, whereas the arguments to the Rvect methods may
	be other Rvect objects, lists, or scalars.
</li>
</ol>

<h2>Copyright and License</h2>
<p class="initial">Copyright &copy; 2007, 2009, R.Dreas Nielsen</p>
<p>This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
The GNU General Public License is available at 
<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
</ol>
</div>
</body>
</html>
