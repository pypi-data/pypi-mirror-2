Metadata-Version: 1.0
Name: dse
Version: 2.1.0
Summary: DSE - Simplified "bulk" insert/update/delete for Django.
Home-page: https://bitbucket.org/weholt/dse2
Author: Thomas Weholt
Author-email: thomas@weholt.org
License: UNKNOWN
Description: DSE - Simplified "bulk" insert/update/delete for Django
        =======================================================
        
        
        Version : 2.1.0
        Author : Thomas Weholt <thomas@weholt.org>
        License : Modified BSD.
        Status : Stable
        Url : https://bitbucket.org/weholt/dse2
        
        
        Background
        ----------
        
        * DSE is available for one reason - to insert/update/delete lots of data -- as fast as possible.
        
        * DSE vs Django ORM: typical speed gain is around 5x-10X for updates, 3X+ for inserts.
        
        * DSE is aware of default values specified in your Django models and will use 
        those if no value is given for a field in an insert statement.
        
        * DSE caches SQL-statements, both inserts and updates, and executes them when 
        a specified number of statements has been prepared or when it`s told manually to flush
        cached statements to the database. The actual sql execution is done using 
        DB API cursor.executemany and this is much faster than executing SQL-statements 
        in sequence and way faster than using the Django ORM.
        
        * DSE uses a dictionary to specify what fields to update. It differs between
        update and insert statements by looking for a key similar to the primary key for
        a given model.
        
        * DSE will try to execute as many statements as possible, but will detect update
        statements where only a few sql fields/columns are updated and execute those 
        statements individually.
        
        * My hope is to see something like this in the django core.
        
        
        News in 2.0.0
        -------------
        
        DSE 2.0.0 has been refactored, released under the modified BSD license and is now a django-only
        package. It also contains some backwards incompatible changes compared to the 1.x-branch,
        mainly renaming the add_items method to just add.
        
        The code is considerably smaller and most of my attention has been on removing the repeated subclassing in
        the 1.x-branch and generating SQL used for standard insert/update at creation instead of repeatedly creating
        it for each execute statement. Also all the code related to modelfactory has been removed.
        
        The code was restructured to allow subclassing so the generated SQL could be written to file etc. This
        has not been tested much and there are issues with quoting/escaping certain fields, date/datetime etc. The goal
        of this code is to generate platform-specific SQL, put that into a file and use things like Postgresqls
        COPY-command to insert data even faster than DSE is capable of. This will be expanded in the coming releases of 2.x.
        
        DSE also features caching of items to delete as well. This can be very handy when you iterate of a collection and
        some items should be deleted, but which ones cannot be determined or filtered using the orm or plain sql. It caches
        primary keys only and then uses a syntax like "delete from somemodel where id in (<list of ids>)". An example of
        usage is listed at the bottom of this document.
        
        I've also started looking at adding unittests with focus on possible SQL injection and input validation. So far my
        tests has been performed on postgresql and sqlite, not mysql. Users have reported using DSE and mysql with success,
        but my intention are to create a performance related testsuite for all major database; postgresq, sqlite and mysql.
        
        
        Installation
        ------------
        
        pip install dse
        
        or
        
        hg clone https://bitbucket.org/weholt/dse2
        
        
        Example usage
        -------------
        
        You got a model like::
        
            gender =  (('M', 'Male'), ('F', 'Female'))
            
            class Person(models.Model):
                name = models.CharField(max_length = 30)
                age = models.IntegerField(default = 30)
                sex = models.CharField(max_length = 1, choices = gender, default = 'M')
        
        Using dse::
        
            import dse
            dse.patch_models() # Monkey patch all your models and expose dse for all models:
        
            with Person.dse as d:
                for name, age, sex in (('Thomas', 36, 'M'), ('Joe', 40, 'M'), ('Jane', 28, 'F')):
                     d.add(dict(name = name, age = age, sex = sex))
        
        Nothing will be inserted into the database before the loop is done ( or you 
        insert 1000 items ). Then the items will be inserted using cursor.executemany, 
        using plain SQL - no ORM in sight.
        
        DSE using default values defined in your model::
            
            with Person.dse as d:    
                # Adding an item, just defining a name and using the default values from the model:
                d.add({'name': 'John'})
        
                # Overriding the default values? Just specify a valid value
                d.add({'name': 'Thomas', 'age': 36, 'sex': 'M'})
        
                # Update record with id = 1 and set its name to John. This will trigger 
                # a SQL-statement for this update alone, since not all columns are specified:
                d.add({'id': 1, 'name': 'John'})
          
        To use delayed execution of SQL statements::
        
            Person.dse.add({'id': 2, 'name': 'Al Capone'}) # will NOT trigger anything
            Person.dse.add({'id': 3, 'name': 'John Dillinger'}) # will NOT trigger anything
            Person.dse.add({'name': 'Scarface'}) # will NOT trigger anything
            Person.dse.flush() # will execute both update statements and insert a record for "Scarface"
        
        Say you want to update all records with some calculated value, something you 
        couldn`t find a way to do in SQL. Using dse this is easy and fast::
        
            with Person.dse as d:    
                # Use Djangos ORM to generate dictionaries to use in DSE; objects.all().values().
                for item in Person.objects.all().values():
                    item['somevar'] = calculated_value
                    d.add(item)
        
        I`ve recieved some questions about transaction handling. Below is an simple example, 
        but I`m looking into other ways of handling transactions as well::
         
            from django.db import transaction
            import dse
        
            def some_method():
                with transaction.commit_on_success():
                    with SomeModel.dse as d:
                        for item in somelist:
                            d.add({'some_column': item.some_value, 'another_column': item.another_value})    
        
        You can also cache items to delete::
        
            with foo.dse as d:
                for person in person.objects.all():
                    if person.likes_perl_more_than_python:
                        foo.dse.delete(person.id) # won't trigger anything
            # here all cached items for deletions are deleted using plain SQL, no orm.
                
        DSE caches id's and deletes them when 1000 items are cached or flush/close are called.
        It uses sql similar to "delete from tablename where id in (<list of ids>)".
        
        DSE features singletons (NB! very experimental, no locking/thread support yet!)::
        
            import dse.singleton
        
            p1 = dse.singleton.Models.Person()
            p2 = dse.singleton.Models.Person()
            print p1 is p2 # should print True
            p1.add(dict(name = 'Joe'))
            p2.flush()
            print Person.objects.all().count() # should print 1
        
        Singletons makes it possible to cache entries across sections of code and cache
        even more data, hitting the db less.
        
        
        Performance compared to the django orm using the django test framework
        ----------------------------------------------------------------------
        
        Lots of updates:
        DSE : 0.116728067398 seconds.
        ORM : 15.0528171062 seconds.
        
        Lots of inserts:
        DSE: 0.0825960636139 seconds.
        ORM: 0.830269098282 seconds.
        
        Iterate of objects and updating them:
        DSE: 0.817410230637 seconds.
        ORM: 60.4543881416 seconds.
        
        Delete lots of objects:
        DSE: 0.495353937149 seconds.
        ORM: 13.3724360466 seconds.
        
        You can see the code for the test producing these numbers here:
        https://bitbucket.org/weholt/dse2/src/dbd87b0e2cdb/tests/performance_tests.py
        
        NB! These numbers do NOT represent real world performance, but merely show the overhead
        of using the django orm compared to DSE. My latests tests shows DSE to be about 3 
        times faster on inserts, it uses about 14% of the time compared to the orm when doing updates
        and in some special cases DSE can speed up delete-operations also.
        
        
        License
        -------
        
        Copyright (c) 2011, Thomas Augestad Weholt
        All rights reserved.
        
        Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
        
        * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
        
        * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
          following disclaimer in the documentation and/or other materials provided with the distribution.
        
        * Neither the name of Thomas Augestad Weholt nor the names of its contributors may be used to endorse or promote
          products derived from this software without specific prior written permission.
        
        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
        INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
        IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
        OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
        OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
        OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
        EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        
        
        Release notes
        -------------
        
        2.1.0 : Small change; dse.patch_models can now take an optional list of models to patch, like so dse.patch_models(specific_models=[User, Comment]).
        
        2.0.0 : labeled as stable. Updated docs and examples.
        
        2.0.0-RC1 : no change in code, now released using the modified BSD license to be more compatible with django license use.
        
        2.0.0-BETA#9 : added FileExport-class to ease debugging what is processed during testing. Writes SQL-data to file. See source/testsuite for usage.
        
        2.0.0-BETA#4 : started refactoring DSE to remove all non-django specific code, mostly to gain speed and simply code.
        
        1.0.2 : reconnect if cursor is dead.
        
        1.0.1 : fixed issue #9 "Factory can eat up memory" reported by vangheem. When finding fields related to a table only the top row is fetched.
        
        1.0.0 : Version bump. Added unittest for issue #8.
        
        1.0.0-RC1 : updated README.txt. 
        
        0.9.4 : - PEP8 and pyflake.
        
        0.9.3 : - Fixed issue #7: dse causes django-debug-toolbar to crash. Thanks to ringemup for pointing that out. Added some docstrings.
        
        0.9.2 : - Corrected type in usage.rst and README.txt.
        
        0.9.1 : - Refactored code even more, added usage.rst, singleton support in the singleton-package and some performance tests. Models not monkey patched be default anymore, must call dse.patch_models().
        
        0.9.0 : - Refactored code and cleaned up tests folder. Focus on getting singleton support in before 1.0.0. And more tests.
        
        0.8.2 : - added 'pysqlite2' to _DBMAP. Thanks to David Marble for 0.8.1 and 0.8.2.
        
        0.8.1 : - attempt to fix quoting problems with fields on postgresql.
        
        0.8.0 : - fixed crash when more than one database connection has been configured. No ModelFactory will be triggered.
        
        0.7.0 : - don`t remember.
        
        0.6.0 : - added support for the with-statement.
                - added an ModelDelayedExecutor-instance to each model, so you can do Model.dse.add_item
                  instead of dse.ModelFactory.Model.add_item.
                - renamed dse.modelfactory to dse.ModelFactory to be more style-compliant.
        
        0.5.1 : just some notes on transaction handling.
        
        0.5.0 :
            - added modelfactory. Upon first import a modelfactory will be created in the DSE module. It`s basically just a
            helper-class containing ModelDelayedExecutor-instances for all models in all apps found in INSTALLED_APPS in
            settings.py.
            - to change the default item limit before automatic execution of cached SQL statements to 10000 instead of the default 1000::
        
            import dse
            dse.ITEM_LIMIT = 10000
        
        0.4.0 :
            - fixed serious bug when using mass updates. Using cursor.executemany is only possible when values
            for all columns are specified. If only values for a subset of the columns is specified that will be
            executed as a seperate SQL-call. NOTE! Using dex.get_items() or Djangos Model.objects.values() will give you
            all the fields.
            - code clean-up.
            - added custom exceptions; UpdateManyException, UpdateOneException and InsertManyException.
        
Platform: UNKNOWN
Classifier: Development Status :: 5 - Production/Stable
Classifier: Intended Audience :: Developers
Classifier: Framework :: Django
Classifier: License :: OSI Approved :: BSD License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python
Classifier: Topic :: Database
