#!/usr/bin/env python
##----------------------------------------------------------------------
## Build contrib/lib
## Called by post-update when necessary
##----------------------------------------------------------------------
## Copyright (C) 2007-2010 The NOC Project
## See LICENSE for details
##----------------------------------------------------------------------

from __future__ import with_statement
import os,sys,csv,subprocess,getopt
##
d=os.path.dirname(sys.argv[0])
if d:
    os.chdir(d)
##
## Main installer class
##
class Installer(object):
    CONTRIB=os.path.abspath(os.path.join("..","contrib"))
    SRC=os.path.join(CONTRIB,"src")
    LIB=os.path.join(CONTRIB,"lib")
    BIN=os.path.join(CONTRIB,"bin")
    SHARE=os.path.join(CONTRIB,"share")
    SRC_VERSIONS=os.path.join(SRC,"VERSION.csv")
    DST_VERSIONS=os.path.join(LIB,"VERSION.csv")
    ENV=os.environ.copy()
    ENV["PYTHONPATH"]= ":".join([LIB]+sys.path)
    ##
    def __init__(self,check_only=False):
        self.check_only=check_only
    ##
    ## Read CSV file and returns hash {row[0]->row[1]}
    ##
    def read_csv(self,path):
        r={}
        if not os.path.exists(path):
            return r
        with open(path) as f:
            for row in csv.reader(f):
                if row:
                    r[row[0]]=row[1]
        return r
    ##
    ## Syncronize contrib apps
    ##
    def sync(self):
        if not self.check_only:
            print "Syncronizing contrib apps"
        sv=[]
        self.read_csv(self.SRC_VERSIONS)
        with open(self.SRC_VERSIONS) as f:
            for row in csv.reader(f):
                if row:
                    sv+=[row]
        iv=self.read_csv(self.DST_VERSIONS)
        update_iv=False
        fail=False
        for app,version in sv:
            if app not in iv or iv[app]!=version:
                if self.check_only: # Do nothing on version mismatch in check mode
                    return False
                print "Upgrading %s to version %s"%(app,version)
                if hasattr(self,"install_%s"%app):
                    r=getattr(self,"install_%s"%app)()
                else:
                    r=self.install(app)
                if r:
                    update_iv=True
                    iv[app]=version
                    print "%s: upgraded to version %s"%(app,version)
                else:
                    print "%s: failed to upgrade to version %s"%(app,version)
                    fail=True
                    break
            elif not self.check_only:
                print "%s is in sync (version %s)"%(app,version)
        if self.check_only: # Return immediately in check mode
            return True
        # Write updated versions
        if update_iv:
            with open(self.DST_VERSIONS,"w") as f:
                writer=csv.writer(f)
                writer.writerows(iv.items())
        return not fail
    ##
    ## Default installation
    ##
    def install(self,app):
        return subprocess.call(["python","setup.py","install",
            #"--prefix=%s"%self.CONTRIB,
            "--install-purelib=%s"%self.LIB,
            "--install-platlib=%s"%self.LIB,
            "--install-scripts=%s"%self.BIN,
            "--install-data=%s"%self.LIB
        ],
        cwd=os.path.join(self.SRC,app),
        env=self.ENV)==0
    ##
    ## Install protobuf
    ##
    def install_protobuf(self):
        # Remove contrib/lib/google left from 2.2.0a
        import shutil
        shutil.rmtree(os.path.join(self.LIB,"google"),ignore_errors=True)
        # Install
        return self.install("protobuf")

if __name__=="__main__":
    check_only=False
    optlist,optargs=getopt.getopt(sys.argv[1:],"c")
    for k,v in optlist:
        if k=="-c":
            check_only=True
    r=Installer(check_only=check_only).sync()
    sys.exit({True:0,False:1}[r])
