#!/usr/bin/env python
# The Broad Institute
# SOFTWARE COPYRIGHT NOTICE AGREEMENT
# This software and its documentation are copyright 2006 by the
# Broad Institute/Massachusetts Institute of Technology. All rights are
# reserved.

# This software is supplied without any warranty or guaranteed support
# whatsoever. Neither the Broad Institute nor MIT can be responsible for its
# use, misuse, or functionality.
# $Header$
"""%prog [options] summaries-files...
Calculates a measure of a sample's tendency to be an outlier (with respect to a set of samples) 
in measurements on an 'invariant set' of autosomal copy-number probes in non-CNV regions.  
The invariant set is dictated by the a list of CN probe names.
"""
from __future__ import division
import optparse
import sys
import string
import numpy
#import medpolish
from mpgutils import utils

LOCUS_NUM_PROBE_FIELDS=4

def readProbeFile (probeFile):
    probes=set()
    
    fIn = open(probeFile, 'rU')
    
    for strLine in fIn:
        probes.add(strLine)
    probes=map(string.rstrip, probes)
    
    return (probes)


    
def getIntensitiesForProbes(probeFile, locusFile, verbose=True):
    """reads in the locus file and list of probes, creates a 2d matrix of data with 1 probe per row, 1 sample per column
    samples are returned as the sample names (in order)
    samples, intensities are returned."""
    
    probes=readProbeFile(probeFile)
    
    fIn = open(locusFile)
    intensities=[]           
    sampleNames=[]
    bStart=False  
    for strLine in fIn:
        
        if (bStart==True):
            data=strLine.split()
            probeName=data[0]
            if  (probeName in probes):
                probeData=data[LOCUS_NUM_PROBE_FIELDS:]
                intensities.append (map (float, probeData))
                if (verbose): print ".",
                
        elif (strLine.startswith("probeset_id")): 
            data=strLine.split()
            sampleNames=data[LOCUS_NUM_PROBE_FIELDS:]
            bStart=True
            
            
    return (sampleNames, intensities)

def zScoreIntensities (intensities, verbose=True):
    """BLATENTLY STOLEN (almost) from cn_probeset_summarize"""
    rawIntensities = numpy.array(intensities)
    if (verbose): print ("Size of matrix:" + str (rawIntensities.shape))
    
    # Take mean of each row
    means = rawIntensities.mean(axis=1)

    # The result of the above is 1-row matrix rather than a 1-column matrix,
    # so duplicate by number of columns, and then transpose so the mean of
    # each row can be subtracted from the values in each row.
    means = utils.repmat(means, rawIntensities.shape[1], 1).transpose()
    
    # Transform stDevs the same way means was transformed.
    stDevs = rawIntensities.std(axis=1)   
    stDevs = utils.repmat(stDevs, rawIntensities.shape[1], 1).transpose()

    matIntensitiesProcessed = rawIntensities - means
    matIntensitiesProcessed /= stDevs
    
    matIntensitiesProcessed=abs(matIntensitiesProcessed)
    result=numpy.median(matIntensitiesProcessed)
    
    return result

def sortby(nlist, n):
    """Fast sort a set of tuples by an element in the tuple"""
    nlist[:] = [(x[n], x) for x in nlist]
    nlist.sort()
    nlist[:] = [val for (key, val) in nlist]
    return (nlist)
    
def getIndividualIntensityZscores (sampleNameList, probeIntensityList):
    """returns a list of tuples, with the first element being the sample name, and the second the intensity.
    This list is sorted by intensity"""
    intensities=zScoreIntensities(probeIntensityList)
    if (len(intensities)!=len(sampleNameList)): print ("Something went wrong!")
    result=[]
    for i in xrange(len(intensities)):
        t=[sampleNameList[i], intensities[i]]
        result.append(t)
        
    resultSorted=sortby(result,1)    
    return (resultSorted)

def writeScores (sampleScores, fileOut):
    fOut=open(fileOut, 'w')
    print >> fOut, "sample\tintensity_score"
    for s,i in sampleScores:
        print >>fOut, "\t".join([s,str(i)])
    fOut.close()


        
def main(argv=None):
    if argv is None:
        argv = sys.argv

    parser = optparse.OptionParser(usage=__doc__)
    
    parser.add_option("-p", "--probes", dest="probeFile", 
                      help="""A list of probes to use in the analysis process.
                      This file has no header and 1 column of probe names.
                      """)
    parser.add_option("-l", "--locus", dest="locusFile",  
                      help="""A locus file generated by cn_locus_summarize""")
    parser.add_option("-o", "--outfile", dest="outFile",
                      help="""Output file name""")
    
    dctOptions, lstArgs = parser.parse_args(argv)
    
    if len(lstArgs) > 1:
        print >> sys.stderr, "ERROR: Too many arguments on command line.\n"
        parser.print_help()
        return 1
    
    lstRequiredOptions=["probeFile", "locusFile", "outFile"]
    
    if utils.validateRequiredOptions(dctOptions, lstRequiredOptions) is False:
        parser.print_help()
        return 1
    
    sampleNameList, probeIntensityList=getIntensitiesForProbes(dctOptions.probeFile, dctOptions.locusFile)
    sampleScores=getIndividualIntensityZscores(sampleNameList, probeIntensityList)
    writeScores(sampleScores, dctOptions.outFile)
    
    print ("DONE")
 
if __name__ == "__main__":
    sys.exit(main())   
