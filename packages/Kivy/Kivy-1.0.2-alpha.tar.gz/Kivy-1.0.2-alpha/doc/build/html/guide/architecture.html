
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Architectural Overview &mdash; Kivy v1.0.1-dev documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0.1-dev',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/jquery.cookie.js"></script>
    <script type="text/javascript" src="../_static/kivy.js"></script>
    <link rel="top" title="Kivy v1.0.1-dev documentation" href="../index.html" />
    <link rel="up" title="Programming Guide" href="../guide-index.html" />
    <link rel="next" title="Contributing" href="../contribute.html" />
    <link rel="prev" title="Quickstart" href="quickstart.html" /> 
  </head>
  <body>

	<div id="topbar">
		<div id="logo">
			<a href="http://kivy.org/docs/">
				<img src="../_static/kivy-logo.png" alt="Logo"/>
			</a>
		</div>
		<div id="menu">
			<ul class="navigation">
				<li><a href="http://kivy.org/">&laquo; Back to kivy.org</a></li>
				<li><a href="../index.html">Home</a></li>
				<li><a href="../index.html#user-s-guide">User's Guide</a></li>
				<li><a href="../guide-index.html">Programming Guide</a></li>
				<li><a href="../api-index.html">API Reference</a></li>
				<li><a href="../faq.html">FAQ</a></li>
				<li>
					<form class="search" action="../search.html" method="get">
						&nbsp;
						<input type="hidden" name="check_keywords" value="yes" />
						<input type="hidden" name="area" value="default" />
						<input type="text" class="text" name="q" />
					</form>
				</li>
			</ul>
		</div>
		<div id="toggleheader"></div>
	</div>

    <div id="wrapper">
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
		  <h3><a href="../index.html">Table Of Contents</a></h3>
		  <ul>
<li><a class="reference internal" href="#">Architectural Overview</a><ul>
<li><a class="reference internal" href="#core-providers-and-input-providers">Core Providers and Input Providers</a></li>
<li><a class="reference internal" href="#graphics">Graphics</a></li>
<li><a class="reference internal" href="#core">Core</a></li>
<li><a class="reference internal" href="#uix-widgets-layouts">UIX (Widgets &amp; Layouts)</a></li>
<li><a class="reference internal" href="#modules">Modules</a></li>
<li><a class="reference internal" href="#input-events-touches">Input Events (Touches)</a></li>
<li><a class="reference internal" href="#widgets-and-event-dispatching">Widgets and Event Dispatching</a></li>
</ul>
</li>
</ul>

		  <h3>Related Topics</h3>
		  <ul>
			  <li>Previous: <a href="quickstart.html" title="previous chapter">Quickstart</a></li>
			  <li>Next: <a href="../contribute.html" title="next chapter">Contributing</a></li>
		  </ul>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="architectural-overview">
<span id="architecture"></span><h1>Architectural Overview<a class="headerlink" href="#architectural-overview" title="Permalink to this headline">¶</a></h1>
<p>We would like to take a moment to explain how we designed Kivy from a
software engineering point of view. This is key to understanding how
everything works together.
If you just look at the code, chances are you will get a rough idea
already, but since this approach certainly is daunting for most users,
this section explains the basic ideas of the implementation in more detail.</p>
<p>Kivy consists of several building blocks that we will explain in the
following.</p>
<div class="section" id="core-providers-and-input-providers">
<span id="providers"></span><h2>Core Providers and Input Providers<a class="headerlink" href="#core-providers-and-input-providers" title="Permalink to this headline">¶</a></h2>
<p>One idea that is key to understanding Kivy&#8217;s internals is that of modularity and
abstraction. We try to abstract from basic tasks such as opening a window,
displaying images and text, playing audio, getting images from a camera,
spelling correction and so on. We call these <em>core</em> tasks.
This makes the API both easy to use and easy to extend. Most importantly, it
allows us to use &#8211; what we call &#8211; specific providers for the respective
scenario in which your app is being run.
For example, on OSX, Linux and Windows, there are different native APIs for the
different core tasks. A piece of code that uses one of these specific APIs to
talk to the operating system on one side and to Kivy on the other (acting as an
intermediate communication layer) is what we call a <em>core provider</em>.
The advantage of using specialized core providers for each platform is that we
can fully leverage the functionality exposed by the operating system and act as
efficiently as possible. It also gives users a choice. Furthermore, by using
libraries that are shipped with any one platform, we effectively reduce the size
of the Kivy distribution and make packaging easier. It&#8217;s also easier to port
Kivy to other platforms. The Android port did greatly benefit from this.</p>
<p>We follow the same concept with input handling. <em>An input provider</em> is a piece
of code that adds support for a specific input device, such as Apple&#8217;s
trackpads, TUIO or a mouse emulator.
If you need to add support for a new input device, you can simply provide a new
class that reads your input data from your device and transforms them into Kivy
basic events.</p>
</div>
<div class="section" id="graphics">
<h2>Graphics<a class="headerlink" href="#graphics" title="Permalink to this headline">¶</a></h2>
<p>Kivy&#8217;s graphics API is our abstraction of OpenGL. On the lowest level,
Kivy issues hardware-accelerated drawing commands using OpenGL. Writing
OpenGL code however can be a bit confusing, especially to newcomers.
That&#8217;s why we provide the graphics API that lets you draw things using
simple metaphors that do not exist as such in OpenGL (e.g. Canvas,
Rectangle, etc.).</p>
<p>All of our widgets themselves use this graphics API, which is implemented
on the C level for performance reasons.</p>
<p>Another advantage of the graphics API is its ability to automatically
optimize the drawing commands that your code issues. This is especially
helpful if you&#8217;re not an expert at tuning OpenGL. This makes your drawing
code more efficient in many cases.</p>
<p>You can, of course, still use raw OpenGL commands if you prefer that. The
version we target is OpenGL 2.0 ES (GLES2) on all devices, so if you want to
stay cross-platform compatible, we advise you to only use the GLES2 functions.</p>
</div>
<div class="section" id="core">
<h2>Core<a class="headerlink" href="#core" title="Permalink to this headline">¶</a></h2>
<p>The code in the core package provides commonly used features, such as:</p>
<blockquote>
<dl class="docutils">
<dt>Clock</dt>
<dd>You can use the clock to schedule timer events. Both one-shot timers
and periodic timers are supported</dd>
<dt>Cache</dt>
<dd>If you need to cache something that you use often, you can use our
class for that instead of writing your own.</dd>
<dt>Gesture Detection</dt>
<dd>We ship a simple gesture recognizer that you can use to detect
various kinds of strokes, such as circles or rectangles. You can
train it to detect your own strokes.</dd>
<dt>Kivy Language</dt>
<dd>The kivy language is used to easily and efficiently describe user
interfaces.</dd>
<dt>Properties</dt>
<dd>These are not the normal properties that you may know from python.
It is our own properties class that links your widget code with
the user interface description.</dd>
</dl>
</blockquote>
</div>
<div class="section" id="uix-widgets-layouts">
<h2>UIX (Widgets &amp; Layouts)<a class="headerlink" href="#uix-widgets-layouts" title="Permalink to this headline">¶</a></h2>
<p>The UIX module contains commonly used widgets and layouts that you can
reuse to quickly create a user interface.</p>
<blockquote>
<dl class="docutils">
<dt>Widgets</dt>
<dd>Widgets are user interface elements that you add to your program
to provide some kind of functionality. They may or may not be
visible. Examples would be a file browser, buttons, sliders, lists
and so on. Widgets receive MotionEvents.</dd>
<dt>Layouts</dt>
<dd>You use layouts to arrange widgets. It is of course possible to
calculate your widgets&#8217; positions yourself, but often it is more
convenient to use one of our ready made layouts. Examples would be
Grid Layouts or Box Layouts.
You can also nest layouts.</dd>
</dl>
</blockquote>
</div>
<div class="section" id="modules">
<h2>Modules<a class="headerlink" href="#modules" title="Permalink to this headline">¶</a></h2>
<p>If you&#8217;ve ever used a modern web browser and customized it with some
add-ons then you already know the basic idea behind our module classes.
Modules can be used to inject functionality into Kivy programs, even if
the original author did not include it.</p>
<p>An example would be a module that always shows the FPS of the current
application and some graph depicting the FPS over time.</p>
<p>You can also write your own modules.</p>
</div>
<div class="section" id="input-events-touches">
<h2>Input Events (Touches)<a class="headerlink" href="#input-events-touches" title="Permalink to this headline">¶</a></h2>
<p>Kivy abstracts from different input types and sources such as touches, mice,
TUIO or similar. What all of these input types have in common is that you
can associate a 2D onscreen-position with any individual input event. (There are
other input devices such as accelerometers where you cannot easily find a
2D position for e.g. a tilt of your device. This kind of input is handled
separately. In the following we describe the former types.)</p>
<p>All of these input types are represented by instances of the Touch()
class. (Note that this does not only refer to finger touches, but all the other
input types as well. We just called it <em>Touch</em> for the sake of simplicity.
Think of it of something that <em>touches</em> the user interface or your screen.)
A touch instance, or object, can be in one of three states. When a touch
enters one of these states, your program is informed that the event
occurred.
The three states a touch can be in are:</p>
<blockquote>
<dl class="docutils">
<dt>Down</dt>
<dd>A touch is down only once, at the very moment where it first
appears.</dd>
<dt>Move</dt>
<dd>A touch can be in this state for a potentially unlimited time.
A touch does not have to be in this state during its lifetime.
A &#8216;Move&#8217; happens whenever the 2D position of a touch changes.</dd>
<dt>Up</dt>
<dd>A touch goes up at most once, or never.
In practice you will almost always receive an up event because
nobody is going to hold a finger on the screen for all eternity,
but it is not guaranteed. If you know the input sources your users
will be using, you will know whether or not you can rely on this
state being entered.</dd>
</dl>
</blockquote>
</div>
<div class="section" id="widgets-and-event-dispatching">
<h2>Widgets and Event Dispatching<a class="headerlink" href="#widgets-and-event-dispatching" title="Permalink to this headline">¶</a></h2>
<p>The term <em>widget</em> is often used in GUI programming contexts to describe
some part of the program that the user interacts with.
For Kivy, a widget is an object that receives input events. It does not
necessarily have to have a visible representation on the screen.
All widgets are arranged in a <em>widget tree</em> (which is a tree data structure
as known from computer science classes): One widget can have any number of
child widgets or none. There is exactly one <em>root widget</em> at the top of the
tree that has no parent widget, and all other widgets are directly or
indirectly children of this widget (which is why it&#8217;s called the root).</p>
<p>When new input data is available, Kivy sends out one event per touch.
The root widget of the widget tree first receives the event.
Depending on the state of the touch, the on_touch_down,
on_touch_move or on_touch_up event is dispatched (with the touch as the
argument) to the root widget, which results in the root widget&#8217;s
corresponding on_touch_down, on_touch_move or on_touch_up event handler
being called.</p>
<p>Each widget (this includes the root widget) in the tree can choose to
either digest or pass the event further. If an event handler returns True
it means that the event has been digested and handled properly. No further
processing will happen with that event. Otherwise, the event handler
passes the widget on to its own children by calling its superclass&#8217;s
implementation of the respective event handler. This goes all the way up
to the base Widget class, which &#8211; in its touch event handlers &#8211; does
nothing but pass the touches to its children:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">on_touch_down</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">touch</span><span class="p">):</span> <span class="c"># This is the same for move/up</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[:]):</span>
        <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">dispatch</span><span class="p">(</span><span class="s">&#39;on_touch_down&#39;</span><span class="p">,</span> <span class="n">touch</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>
</pre></div>
</div>
<p>This really is much easier than it first seems. Let&#8217;s take a look at a
simple example. If you want to implement a line drawing program, you will
want to know when a touch starts, moves and ends. You keep track of the
touch&#8217;s positions and draw a line through those points:</p>
<div class="highlight-python"><pre>TODO PAINTER WIDGET</pre>
</div>
<p>As you can see, this widget does not really care where the touch occurred.
Often times you will want to restrict the <em>area</em> on the screen that a
widget watches for touches. You can use a widget&#8217;s collide_point() method
to achieve this. You simply pass it the touches position and it returns
True if the touch is within the &#8216;watched area&#8217; or False otherwise. By
default, this checks the rectangular region on the screen that&#8217;s described
by the widget&#8217;s pos (for position; x &amp; y) and size (width &amp; height), but
you can override this behaviour in your own class.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
	<!--
    <div class="footer">
      &copy; Copyright 2010, kivy-dev.
      Last updated on Feb 03, 2011.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0b2.
</div>
-->
  </body>
</html>