#!/usr/bin/python2

VERSION="0.9.pre1"

import sys
from os.path import abspath, dirname, expanduser, isfile, isdir, getmtime, exists, join
from os import walk
from re import sub

from pwilang import compile_pwi
from pwilang.watcher import watch

def read_csv (filename):
    """ Reads a csv file and return its contents for sending to the
        template's context """

    import csv

    f = csv.reader (open (filename, 'rb'))
    header = next (f)
    objs = []

    for row in f:
        newobj = dict ()
        for i in xrange (0, len (header)):
            if (i < len (row)):
                newobj[header[i]] = unicode (row[i], 'utf-8')
        objs.append (newobj)

    return objs

def read_yaml (filename):
    """ Read the contents of a Yaml file.
    """

    import yaml
    f = open (filename, "r")
    obj = yaml.load (f.read ())
    f.close ()
    return obj

def read_json (str):
    """ Reads json contents.
        @param str: Either a JSon string or a path to a file name
            containing JSon statements.
    """
    return {}


from optparse import OptionParser


def default_output_name (fn):
    if fn.endswith ('.pwi'):
        return sub ('pwi$', 'html', fn)
    elif fn.endswith ('.pwx'):
        return sub ('pwx$', 'xml', fn)
    return fn + '.html'

import time

if __name__ == "__main__":
    # we concatenate our custom path !
    p = OptionParser (usage="pwilang file.pwi [-o outfile]\n       pwilang <directory>", version="pwilang v%s" % VERSION)

    p.add_option ('-o', '--output', action='store', type='string', dest='output', default="-", help='Name of the output file, or "-" for stdout')

    p.add_option ('-n', '--no-pwi', action='store_true', dest='no_pwi', help='Don\'t interpret pwilang code')
    p.add_option ('-i', '--no-jinja', action='store_true', dest='no_jinja', help='Don\'t interpret jinja code')
    p.add_option ('-e', '--no-headers', action='store_true', dest='no_headers', help='Don\'t put headers and footers in pdf')

    p.add_option ('-c', '--csv', action='store', type='string', dest='csv', help="A CSV file with data to give to the templates")
    p.add_option ('-j', '--json', action='store', type='string', dest='json', help="A JSON file or string with data to give to the templates")
    p.add_option ('-y', '--yaml', action='store', type='string', dest='yaml', help="A Yaml file with data to give to the templates")

    p.add_option ('-w', '--watch', action='store', type='string', dest='watch', help="Syntax: in_file:outfile,in_directory/.pwi:out_directory/.html,... Watch source file or directory for change and recompile if necessary. Only works with -o when using files.")
    p.add_option ('-x', '--extensions', action='store', type='string', dest='extensions', help="File extensions and their traductions.", default="pwx:xml,pwi:html")

    # p.add_option ('-b', '--batch', action='store_true', dest='batch', help="""Treat the input data as batch instructions. This means that in JSon or YaML, the top-level element MUST be an array containing the following objects : { 'output_html' : 'file_name.html', 'output_pdf' : 'file_name.pdf', 'context' : {} }.
#output_html and output_pdf don't have to be both here, but you need at least one.
#This option ignores any -o or -p switches since many files will be generated.
#""")

    p.add_option ('-p', '--pdf', action='store', type='string', dest='pdf', help='Name of the pdf file to generate')

    (options, args) = p.parse_args (sys.argv[1:])

    # GETTING CONTEXT
    ctx = dict ()
    if options.csv:
        ctx['context'] = read_csv (options.csv)

    if options.json:
        ctx['context'] = read_json (options.json)

    if options.yaml:
        ctx['context'] = read_yaml (options.yaml)

    if options.watch:
        watch (options, p, ctx)
    else:
        if len (args) != 1:
            p.error ("Please specify a .pwi file to parse")
        source_filename = args[0]

        compile_pwi (source_filename, options, ctx)

