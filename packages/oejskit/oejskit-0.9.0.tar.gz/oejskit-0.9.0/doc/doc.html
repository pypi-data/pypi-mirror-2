<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.7: http://docutils.sourceforge.net/" />
<title>jskit</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div class="document" id="jskit">
<h1 class="title">jskit</h1>

<p>jskit contains infrastructure and in particular a <a class="reference external" href="http://pytest.org/">py.test</a>  plugin to
enable running tests for JavaScript code inside browsers directly
using py.test as the test driver. Running inside the browsers comes
with some speed cost, on the other hand it means for example the code
is tested against the real-world DOM implementations.</p>
<p>The approach also enables to write integration tests such that the
JavaScript code is tested against server-side Python code mocked as
necessary. Any server-side framework that can already be exposed
through WSGI (or for which a subset of WSGI can be written to
accommodate the jskit own needs) can play along.</p>
<p>jskit has also some support to run JavaScript tests from <tt class="docutils literal">unittest.py</tt> based
test suites.</p>
<p>jskit also contains code to help modularizing JavaScript code
which can be used to describe and track dependencies dynamically
during development and that can help resolving them statically when
deploying/packaging.</p>
<p>Known supported browsers are Firefox, Internet Explorer &gt;=7, and
WebKit browsers.</p>
<p><em>jskit now supports both py.test 2.0 and late py.test 1.x.</em></p>
<p>jskit requires Python 2.6 or 2.7. It also uses <a class="reference external" href="http://mochikit.com/">MochiKit</a> - of
which it ships a version within itself for convenience - for its own
working though in does not imposes its usage on tested code.</p>
<p>jskit was initially developed by <em>Open End</em> AB and is released under the MIT license.</p>
<div class="section" id="basics-of-writing-and-running-tests">
<span id="rest-of-the-docs"></span><h1>Basics of writing and running tests</h1>
<p>For the simplest cases jskit allows to write tests simply as just
JavaScript files. As an example one could have a <tt class="docutils literal">jstest_example_any.js</tt>
in a test directory in a project:</p>
<pre class="literal-block">
Tests = {

test_simple: function() {
    ais(21*2, 42)
}

}
</pre>
<p><tt class="docutils literal"><span class="pre">jstest_*.js</span></tt> is the globbing pattern used by jskit to recognize
JavaScript test files. Each of these needs to contain a <tt class="docutils literal">Tests</tt>
object with test methods starting with <tt class="docutils literal">test_</tt>. <tt class="docutils literal">ais</tt> is one of
the assertion functions predefined by jskit, it raises an exception
causing the test to fail if the two arguments are not equal (in
JavaScript <tt class="docutils literal">==</tt> sense).</p>
<p>The suffix <tt class="docutils literal">any</tt> separated by an underscore (<tt class="docutils literal">_</tt>) in the test file name controls the kind of browsers the test should be run against, <tt class="docutils literal">any</tt> is predefined by jskit to be</p>
<ul class="simple">
<li>Firefox and Safari on Mac OS X</li>
<li>Internet Explorer and Firefox on Windows</li>
<li>Firefox (started as <tt class="docutils literal">firefox</tt>) otherwise (e.g. Linux)</li>
</ul>
<p>later we'll see how to define other groups of browsers.</p>
<p>To run the test we need to use py.test with the jskit plugin
activated which happens if jskit in on the Python path (see also the <a class="reference external" href="http://pytest.org/plugins.html#installing-external-plugins-searching">py.test and plugin usage docs</a>).</p>
<p>So running the test is just a matter of invoking <tt class="docutils literal">py.test</tt> that has an installed jskit available on the Python path:</p>
<pre class="literal-block">
$ ../v/bin/py.test test/
inserting into sys.path: /u/pedronis/scratch/oejskit-play/v/lib/python2.5/site-packages
========================================= test session starts =========================================
python: platform linux2 -- Python 2.5.2
test object 1: /u/pedronis/scratch/oejskit-play/proj/test

test/jstest_example_any.js .

====================================== 1 passed in 2.52 seconds =======================================
</pre>
<p>(concretely here I'm using a <cite>virtualenv</cite> with both the <cite>py.test</cite> and <tt class="docutils literal">oejskit</tt> installed in it.)</p>
<p>Tests from different files with their <tt class="docutils literal">Tests</tt> objects (or Python
test classes are as we will explain later) are run isolated in IFRAMEs
which will also display test results enumerating both assertions and
tests, not just tests. Each JavaScript <tt class="docutils literal">test_</tt> method is run and its
result reported by py.test as it would for Python tests. <tt class="docutils literal">test_</tt>
methods from a <tt class="docutils literal">Tests</tt> object are run in alphabetical order.</p>
<p>Normally one page is used for the whole test run with sections
corresponding to the JavaScript test files or Python modules, links
are progressively displayed on the upper right corner of the page to
jump to the sections, this to help debugging the state of a failed
test for example.</p>
</div>
<div class="section" id="finding-javascript-code">
<h1>Finding JavaScript code</h1>
<p>Tests of course need to be able to load and refer to tested
code. Let's assume for example that JavaScript code lives under the
<tt class="docutils literal">static/js</tt> directory in the project, for example there could be a
file <tt class="docutils literal">ex.js</tt> there:</p>
<pre class="literal-block">
function ok() {
    return &quot;ok&quot;
}
</pre>
<p>jskit way to refer to tested code is based on its modularity
functionality, though for the simplest cases this is involve just
providing enough information such that parts of the URL space can be
mapped back to parts of the filesystem where JavaScript lives.</p>
<p>Adding the following to the <tt class="docutils literal">conftest.py</tt> of the project:</p>
<pre class="literal-block">
class jstests_setup:
    staticDirs = {
       '/static': os.path.join(os.path.dirname(__file__), 'static')
    }
    jsRepos = ['/static']
</pre>
<p>tells jskit to serve files from the <tt class="docutils literal">static</tt> directory (the value in
the <tt class="docutils literal">staticDirs</tt> mapping) for the <tt class="docutils literal">static</tt> subtree of the URL space
(the key).</p>
<p>The values in <tt class="docutils literal">jsRepos</tt> list which prefixes of the URL space contain
JavaScript, they play a bigger role when using the full modularity
functionality, they are necessary for the simple case too though.</p>
<p>With this configuration we can write a test <tt class="docutils literal">jstest_ok_any.js</tt> for
the <tt class="docutils literal">ok</tt> function in <tt class="docutils literal">ex.js</tt> that looks like this:</p>
<pre class="literal-block">
OpenEnd.require(&quot;/static/js/ex.js&quot;)

Tests = {
test_ok: function() {
   var res = ok()
   ais(res, &quot;ok&quot;)
}
}
</pre>
<p>With the information provided jskit can infer that <tt class="docutils literal">ex.js</tt> is needed for the test and serve it.</p>
<p>Running all the tests now should give:</p>
<pre class="literal-block">
$ ../v/bin/py.test
inserting into sys.path: /u/pedronis/scratch/oejskit-play/v/lib/python2.5/site-packages
========================================= test session starts =========================================
python: platform linux2 -- Python 2.5.2
test object 1: /u/pedronis/scratch/oejskit-play/proj

test/jstest_example_any.js .
test/jstest_ok_any.js .

====================================== 2 passed in 5.06 seconds =======================================
</pre>
</div>
<div class="section" id="assertion-functions-and-helpers">
<h1>Assertion functions and helpers</h1>
<p>jskit predefines a set of functions to make assertions in tests,
JavaScript not having an assertion statement at all</p>
<ul class="simple">
<li><tt class="docutils literal">aok(condition [, label])</tt> which will succeed respectively fail
depending on the JavaScript truth value of <tt class="docutils literal">condition</tt></li>
<li><tt class="docutils literal">ais(value, expected [, label])</tt> which will succeed respectively
fail depending on whether <tt class="docutils literal">value</tt> and <tt class="docutils literal">expected</tt> are equal in
JavaScript <tt class="docutils literal">==</tt> operator sense</li>
<li><tt class="docutils literal">aisDeeply(value, expected [, label])</tt> which differently from <tt class="docutils literal">ais</tt>
will recursively compare containers (JavaScript non-primitive
objects and arrays) succeeding when they have the same
properties/indexes sets with matching values in <tt class="docutils literal">aisDeeply</tt> sense,
for primitive objects it behaves like <tt class="docutils literal">ais</tt></li>
</ul>
<p>There's another predefined helper <tt class="docutils literal">insertTestNode</tt> which will return
a new <tt class="docutils literal">DIV</tt> node at the end of test page styled with a border and
labeled with the test name, the node can then be used to host DOM
fragments to be manipulated by the test. If a test using this feature
fails it should then be easy to identify the relevant DOM part and
eyeball or inspect it with tools such as Firebug.</p>
</div>
<div class="section" id="test-failures">
<h1>Test failures</h1>
<p>Given a failing test like (<tt class="docutils literal">proj/fail/jstest_fail_any.js</tt>):</p>
<pre class="literal-block">
Tests = {

test_fail: function() {
    aisDeeply([1].concat([2, 3]), [1,[2,3]])
}

}
</pre>
<p>this is part of the kind of output to be expected at least when the test is run against Firefox which provides proper traceback information:</p>
<pre class="literal-block">
...
&gt;           raise JsFailed(name, outcome['diag'])
E           JsFailed: test_fail: FAILED:     Structures begin differing at:
E           got[1] = 2
E           expected[1] = 2,3
E
E           stack: Error()&#64;:0
E           (&quot;isDeeply in test_fail in ?&quot;,&quot;    Structures begin differing at:
...
E           ()&#64;http://localhost:49900/test/jstest_fail_any.js:4
...
</pre>
<p>Notice that the line numbers and involved JavaScript files are presented:</p>
<pre class="literal-block">
E           ()&#64;http://localhost:49900/test/jstest_fail_any.js:4
</pre>
</div>
<div class="section" id="browser-kind-specifications">
<h1>Browser kind specifications</h1>
<p>On top of the predefined <tt class="docutils literal">any</tt>, browser kind groupings against which
to run tests can be defined that are meaningful to one's project. As
we have seen these are used as suffixes for test files or as values
for the later introduced <tt class="docutils literal">jstests_browser_kind</tt> class attribute.</p>
<p>All is needed is to define a <tt class="docutils literal">jstest_browser_specs</tt> mapping in the <tt class="docutils literal">conftest.py</tt> file, with the kinds as keys and lists of browser names as values:</p>
<pre class="literal-block">
jstests_browser_specs = {
    'supported': ['firefox', 'iexplore', 'safari'],
    'extrafeatures': ['safari']
}
</pre>
<p>browser names themselves can also be used directly as kinds. Given the
mapping <tt class="docutils literal">jstests_basic_supported.js</tt>,
<tt class="docutils literal">jstests_extras_extrafeatures.js</tt> and in any case
<tt class="docutils literal">jstests_details_firefox.js</tt> or <tt class="docutils literal">jstests_details_iexplore.js</tt>
would be meaningful JavaScript test file names.</p>
<p>With the plugin activated a <tt class="docutils literal">py.test</tt> command-line option
<tt class="docutils literal"><span class="pre">--jstests-browser-spec=JSTESTS_BROWSER_SPEC</span></tt> can also be used to
define browser kinds as in:</p>
<pre class="literal-block">
--jstests-browser-spec any=firefox,safari --jstests-browser-spec extra=safari
</pre>
<p>As we see here <tt class="docutils literal">any</tt> itself can be redefined this way or via the
mapping.</p>
</div>
<div class="section" id="integration-testing">
<h1>Integration testing</h1>
<p>One central jskit feature is the ability to run JavaScript tests
against server-side Python code setup through test code. For example
one can add a <tt class="docutils literal">test_integration.py</tt>:</p>
<pre class="literal-block">
from oejskit.testing import jstests_suite
import cgi

class TestIntegration(object):
    jstests_browser_kind = 'any'

    &#64;jstests_suite('test_integration.js')
    def integration_server_side(self):
        def server(environ, start_response):
            p = environ['PATH_INFO']
            start_response('200 OK', [('content-type', 'text/plain')])
            q = cgi.parse_qs(environ['QUERY_STRING'])
            if p == '/add':
                a, b = int(q['a'][0]), int(q['b'][0])
                return [str(a+b)]
            elif p == '/sub':
                a, b = int(q['a'][0]), int(q['b'][0])
                return [str(a-b)]
            return []

        return server
</pre>
<p>with a parallelly located <tt class="docutils literal">test_integration.js</tt>:</p>
<pre class="literal-block">
OpenEnd.require(&quot;/static/js/get.js&quot;)

Tests = {

test_add: function() {
    var res = http_get(&quot;/add?a=2&amp;b=3&quot;)
    ais(parseInt(res), 5)
},

test_sub: function() {
    var res = http_get(&quot;/sub?a=6&amp;b=2&quot;)
    ais(parseInt(res), 4)
}

}
</pre>
<p>This test code will result in the tests in <cite>test_integration.js`</cite> to
be run while the testing framework is serving the WSGI application
<tt class="docutils literal">server</tt> at the root of the URL space. The code in
<tt class="docutils literal">integration_server_side</tt> will be run once before the JavaScript
tests in the suite will be run, in a sense it is akin to a setup
method but <a class="reference external" href="http://pytest.org/funcargs.html">funcargs</a>  can be requested in its arguments.</p>
<p>The tests will be run for each browser identified by the kind put in
<tt class="docutils literal">jstests_browser_kind</tt>. Both <tt class="docutils literal">jstests_browser_kind</tt> and the
decorator <tt class="docutils literal">jstests_suite</tt> are required to achieve this behavior,
<tt class="docutils literal">jstests_browser_kind</tt> marks that the tests in the class need to be
executed with a browser available to control.</p>
<p><tt class="docutils literal">get.js</tt> here defines <tt class="docutils literal">http_get</tt> a simple function wrapping  XMLHttpRequest t do synchronous GET requests.</p>
<!-- XXX pointer to open/eval/travel -->
</div>
<div class="section" id="remote-browsers">
<h1>Remote browsers</h1>
<p>Contained in the <tt class="docutils literal">oejskit</tt> package there is a module <tt class="docutils literal">browser.py</tt>
which can be used as standalone script. The script can be run as a
server that allows starting browsers on a remote machine, this means
that the platforms for the python/server-side test code and the
platforms for target browsers don't need to coincide. The script can
be simply be copied as standalone file and it just needs a plain
python installed without further dependencies to run. The script uses
HMAC and a secret token to secure its access though it is still
recommend to run it behind a firewall.</p>
<p>Setup servers to start browsers on the the relevant machine:</p>
<pre class="literal-block">
Z:\&gt;c:\Python26\python.exe browser.py server 10010
JSTESTS_REMOTE_BROWSERS_TOKEN=eca424b610245337c80f32e3a08c50c6
serving browsers on 10010...
</pre>
<p>On the machine that will drive the tests set one environment variable
with the secret token, and another that lists separated by spaces
<tt class="docutils literal"><span class="pre">&lt;hostname&gt;:&lt;port&gt;:&lt;browsers-separated-by-commas&gt;</span></tt> for the browser
servers:</p>
<pre class="literal-block">
$ export JSTESTS_REMOTE_BROWSERS_TOKEN=eca424b610245337c80f32e3a08c50c6
$ export JSTESTS_REMOTE_BROWSERS=bigboard:10010:iexplore
$ ../v/bin/py.test --jstests-browser-spec any=iexplore,firefox
inserting into sys.path: /u/pedronis/scratch/oejskit-play/v/lib/python2.5/site-packages
======================================================= test session starts ========================================================
python: platform linux2 -- Python 2.5.2 -- /u/pedronis/scratch/oejskit-play/v/bin/python
test object 1: /u/pedronis/scratch/oejskit-play/proj

test/jstest_example_any.js:1: proj.test.jstest_example_any.js[=iexplore][test_simple] PASS
test/jstest_example_any.js:1: proj.test.jstest_example_any.js[=firefox][test_simple] PASS
test/jstest_ok_any.js:1: proj.test.jstest_ok_any.js[=iexplore][test_ok] PASS
test/jstest_ok_any.js:1: proj.test.jstest_ok_any.js[=firefox][test_ok] PASS
test/test_integration.py:7: TestIntegration[=iexplore].integration_server_side[test_add] PASS
test/test_integration.py:7: TestIntegration[=iexplore].integration_server_side[test_sub] PASS
test/test_integration.py:7: TestIntegration[=firefox].integration_server_side[test_add] PASS
test/test_integration.py:7: TestIntegration[=firefox].integration_server_side[test_sub] PASS

==================================================== 8 passed in 28.39 seconds =====================================================
</pre>
<p>Firefox is not listed in the environment variable, so a local one is started or reused.</p>
<p>There are also commands to shutdown browsers, respectively servers,
they will also consider the environment variables to find their targets:</p>
<pre class="literal-block">
$ ../v/bin/python -m oejskit.browser cleanup iexplore

$ ../v/bin/python -m oejskit.browser shutdown-servers
</pre>
<p>For convenience when setting up multiple machines there is the
possibility to first generate a token and pass it in as an argument to
the <tt class="docutils literal">server</tt> command:</p>
<pre class="literal-block">
Z:\&gt;c:\Python26\python.exe browser.py gentoken
eca424b610245337c80f32e3a08c50c6
Z:\&gt;c:\Python26\python.exe browser.py server 10010 eca424b610245337c80f32e3a08c50c6
serving browsers on 10010...
</pre>
<p>It is possible to give user-defined names for greater flexibility to
browsers or browser command lines, for example to run tests against
both Internet Explorer 7 and 8 one could run <tt class="docutils literal">browser.py</tt> on a
Windows machine with the latter this way:</p>
<pre class="literal-block">
Z:\&gt;c:\Python26\python.exe browser.py gentoken
eca424b610245337c80f32e3a08c50c6
Z:\&gt;c:\Python26\python.exe browser.py server 10010 eca424b610245337c80f32e3a08c50c6 ie8=iexplore
serving browsers on 10010...
</pre>
<p>and on other with the older IE7 with:</p>
<pre class="literal-block">
Y:\&gt;c:\Python25\python.exe browser.py server 10010 eca424b610245337c80f32e3a08c50c6 ie7=iexplore
serving browsers on 10010...
</pre>
<p>A series of definitions with <tt class="docutils literal"><span class="pre">user-defined-name=command-line</span></tt> can be
specified after the main <tt class="docutils literal">browser.py server</tt>
parameters. <tt class="docutils literal"><span class="pre">user-defined-names</span></tt> can then be used as browser names
and in browser specifications, like:</p>
<pre class="literal-block">
--jstests-browser-spec any=firefox,ie7,ie8
</pre>
<p>If it makes sense a full command line can be specified:</p>
<pre class="literal-block">
Y:\&gt;c:\Python25\python.exe browser.py server 10010 eca424b610245337c80f32e3a08c50c6 &quot;ff-testing=...\firefox.exe -P testing&quot; ie7=iexplore
</pre>
</div>
<div class="section" id="support-for-unittest-py-based-test-suites">
<h1>Support for <tt class="docutils literal">unittest.py</tt> based test suites</h1>
<p>The <tt class="docutils literal">oejskit</tt> package contains a <tt class="docutils literal">unittest_support</tt> module whose
content is a subclass of <tt class="docutils literal">unittest.TestSuite</tt> which can be used to
incorporate JavaScript tests with <tt class="docutils literal">unittest.py</tt> tests. Typically one
will make a per-project subclass of <tt class="docutils literal">unittest_support.JSTestSuite</tt>,
the parameters we <a class="reference external" href="doc.html#finding-javascript-code">previously described</a> like <tt class="docutils literal">staticDirs</tt> that go
<tt class="docutils literal">jstests_setup</tt> and the mapping <tt class="docutils literal">jstests_browser_specs</tt> can be
specified as attributes attached to such a subclass. An example usage
would then be like:</p>
<pre class="literal-block">
class ProjectJSTestSuite(unittest_support.JSTestSuite):
    jstests_browser_specs = {
        'supported': ['firefox', 'iexplore', 'safari']
    }

def ok_root():
    def ok(environ, start_response):
        start_response('200 OK', [('content-type', 'text/plain')])
        return ['ok\n']
    return ok

if __name__ == '__main__':
    runner = unittest.TextTestRunner(verbosity=1)
    all = unittest.TestSuite()
    example_suite = ProjectJSTestSuite('jstest_example_supported.js')
    integration_suite = ProjectJSTestSuite('test_integration_style.js',
                                           root=ok_root,
                                           browser_kind='supported')
    all.addTest(example_suite)
    all.addTest(integration_suite)
    runner.run(all)
</pre>
<p>the suites are instantiated with a JavaScript test file which will be
located relative to the Python test file, optionally a <tt class="docutils literal">browser_kind</tt>
and a factory <tt class="docutils literal">root</tt> for e.g. a WSGI application (see also
<a class="reference internal" href="#integration-testing">Integration testing</a>) can be specified to serve for the test. If a
<tt class="docutils literal">browser_kind</tt> is not specified it will be extracted out of the
JavaScript test file name.</p>
</div>
</div>
</body>
</html>
