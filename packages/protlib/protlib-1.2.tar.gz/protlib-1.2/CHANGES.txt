
WHAT'S NEW IN VERSION 1.2
-------------------------
* CError now extends ValueError instead of BaseException.

* ez_setup.py is now bundled with protlib to make installation easier for
    users who don't already have setuptools.

* CString and CArray fields of structs may now have variable lengths.  To
    indicate the length of such a field, replace the length integer with
    a string indicating the name of the other CStruct field whose value
    indicates the length of the CString or CArray.


WHAT'S NEW IN PROTLIB 1.1
-------------------------
* CLong and CULong now use the "q" and "Q" struct format codes, making them
    8 bytes instead of 4.

* Logging is now done through the logging module in the standard library,
    so users can now customize their logging in the standard way.

* Importing protlib no longer calls socket.setdefaulttimeout().  The new
    behavior is that DEFAULT_TIMEOUT will be used only if
    socket.getdefaulttimeout() returns None, which it will unless the user has
    called socket.setdefaulttimeout().  Note that DEFAULT_TIMEOUT used to be
    called PROTLIB_DEFAULT_TIMEOUT.

* CError now extends BaseException instead of Exception, and CWarning now
    extends UserWarning instead of Warning.

* problib now has an __all__ so that saying "from protlib import *" doesn't
    include the modules imported by protlib, etc.

* CString.parse now right-strips all characters starting with the first null
    byte.  For example, CString(length=10).parse("foo\x00barbar") returns "foo".

* CString.serialize triggers a CWarning when asked to serialize a string
    longer than its length.

* CArray.serialize triggers a CWarning when asked to serialize a list longer
    than its length, and in this case it now truncates the list so that only
    the proper number of elements are serialized.  In protlib 1.0, using a
    longer-than-expected list to serialize resulted in data corruption.

* CStruct subclasses now check their fields on instantiation and assignment.
    So if you say "foo.x = y" then protlib will raise a CError if y is not
    convertable to the data type expected by foo.x.  An exception will also
    be raised if the value provided cannot be properly serialized, e.g. if you
    try to serialize a 4-bit integer with a too-large value, or if you try
    to serialize a list with not enough elements, etc.

* All important classes and functions have been given useful docstrings so that
    pydoc and help can offer better assistance.

* Functions internal to protlib are now prefixed with an underscore to denote
    that they are not intended for external use, e.g. _fileize, _get_value, etc.

* protlib now has __version__ and __version_info__ attributes which follow the
    usual conventions.
