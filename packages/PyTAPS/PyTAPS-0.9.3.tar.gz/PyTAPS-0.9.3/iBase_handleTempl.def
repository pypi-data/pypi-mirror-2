#define PP_CAT_(a,b) a ## b
#define PP_CAT(a,b) PP_CAT_(a,b)
#define PP_STR_(a) #a
#define PP_STR(a) PP_STR_(a)

#define HANDLE_BASE PP_CAT(iBase,HANDLE_TYPE)
#define HANDLE_PYTYPE PP_CAT(HANDLE_BASE,_Type)
#define HANDLE_CTYPE PP_CAT(iBase_,PP_CAT(HANDLE_TYPE,Handle))
#define HANDLE_OBJ PP_CAT(HANDLE_BASE,_Object)
#define HANDLE_STR PP_STR(HANDLE_TYPE)

static PyTypeObject HANDLE_PYTYPE;

static PyObject *
PP_CAT(HANDLE_BASE,_repr) (HANDLE_OBJ *self)
{
    return PyString_FromFormat("<%s %p>",self->ob_type->tp_name,
                               (void*)self->handle);
}

static PyObject *
PP_CAT(HANDLE_BASE,_richcompare) (HANDLE_OBJ *lhs,HANDLE_OBJ *rhs,int op)
{
    if(!PP_CAT(HANDLE_BASE,_Check) (lhs) || !PP_CAT(HANDLE_BASE,_Check) (rhs))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

    switch(op)
    {
    case Py_EQ:
        return PyBool_FromLong(lhs->handle == rhs->handle);
    case Py_NE:
        return PyBool_FromLong(lhs->handle != rhs->handle);
    default:
        PyErr_SetNone(PyExc_TypeError);
        return NULL;
    }
}

static long
PP_CAT(HANDLE_BASE,_hash) (HANDLE_OBJ *self)
{
    return (long)self->handle;
}

static PyTypeObject HANDLE_PYTYPE = {
    PyObject_HEAD_INIT(NULL)
    0,                                            /* ob_size */
    "itaps.iBase." HANDLE_STR,                    /* tp_name */
    sizeof(HANDLE_OBJ),                           /* tp_basicsize */
    0,                                            /* tp_itemsize */
    0,                                            /* tp_dealloc */
    0,                                            /* tp_print */
    0,                                            /* tp_getattr */
    0,                                            /* tp_setattr */
    0,                                            /* tp_compare */
    (reprfunc)PP_CAT(HANDLE_BASE,_repr),          /* tp_repr */
    0,                                            /* tp_as_number */
    0,                                            /* tp_as_sequence */
    0,                                            /* tp_as_mapping */
    (hashfunc)PP_CAT(HANDLE_BASE,_hash),          /* tp_hash */
    0,                                            /* tp_call */
    0,                                            /* tp_str */
    0,                                            /* tp_getattro */
    0,                                            /* tp_setattro */
    0,                                            /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                           /* tp_flags */
    "iBase " HANDLE_STR " objects",               /* tp_doc */
    0,                                            /* tp_traverse */
    0,                                            /* tp_clear */
    (richcmpfunc)PP_CAT(HANDLE_BASE,_richcompare) /* tp_richcompare */
};

static PyObject *
PP_CAT(HANDLE_BASE,_FromHandle)(HANDLE_CTYPE h)
{
    HANDLE_OBJ *o = PP_CAT(HANDLE_BASE,_New)();
    o->handle = h;
    return (PyObject*)o;
}

static PyObject *
PP_CAT(HANDLE_BASE,Arr_getitem)(void *data,void *arr)
{
    return PP_CAT(HANDLE_BASE,_FromHandle)(*(HANDLE_CTYPE*)data);
}

static int
PP_CAT(HANDLE_BASE,Arr_setitem)(PyObject *item,void *data,void *arr)
{
    if(!PP_CAT(HANDLE_BASE,_Check)(item))
        return -1;
    *(HANDLE_CTYPE*)data = PP_CAT(HANDLE_BASE,_GetHandle)(item);
    return 0;
}

static void
PP_CAT(HANDLE_BASE,Arr_copyswapn)(void *dst,npy_intp dstride,void *src,
                                  npy_intp sstride,npy_intp n,int swap,
                                  void *arr)
{
    npy_intp i;
    PyArray_CopySwapFunc *copyswap = PyArray_DESCR(arr)->f->copyswap;
    char *dstptr = dst;
    char *srcptr = src;
    if(!src) sstride = 0;
	
    for(i=0; i<n; i++)
    {
        copyswap(dstptr,srcptr,swap,arr);
        dstptr += dstride;
        srcptr += sstride;
    }
}

static void
PP_CAT(HANDLE_BASE,Arr_copyswap)(void *dst,void *src,int swap,void *arr)
{
    if(src)
        memcpy(dst,src,sizeof(HANDLE_CTYPE));

    if(swap)
    {
        char *start = (char *)dst;
        char *end = start + sizeof(HANDLE_CTYPE) - 1;
        char tmp;

        for(; start < end; start++, end--)
        {
            tmp = *start;
            *start = *end;
            *end = tmp;
        }
    }
}

static npy_bool
PP_CAT(HANDLE_BASE,Arr_nonzero)(void *data,void *arr)
{
    return *(HANDLE_CTYPE*)data != 0;
}

static PyArray_ArrFuncs PP_CAT(HANDLE_BASE,Arr_funcs) = {
    {0},                                          /* cast */   
    PP_CAT(HANDLE_BASE,Arr_getitem),              /* getitem */
    PP_CAT(HANDLE_BASE,Arr_setitem),              /* setitem */
    PP_CAT(HANDLE_BASE,Arr_copyswapn),            /* copyswapn */
    PP_CAT(HANDLE_BASE,Arr_copyswap),             /* copyswap */
    0,                                            /* compare */
    0,                                            /* argmax */
    0,                                            /* dotfunc */
    0,                                            /* scanfunc */
    0,                                            /* fromstr */
    PP_CAT(HANDLE_BASE,Arr_nonzero),              /* nonzero */
};

static void
PP_CAT(HANDLE_BASE,Arr_equal)(char **args,npy_intp *dims,npy_intp *steps,
                              void *data)
{
    char *ip1 = args[0], *ip2 = args[1], *op1 = args[2];
    npy_intp is1 = steps[0], is2 = steps[1], os1 = steps[2];
    npy_intp n = dims[0];
    npy_intp i;
    for(i = 0; i < n; i++, ip1 += is1, ip2 += is2, op1 += os1)
    {
        HANDLE_CTYPE in1 = *(HANDLE_CTYPE*)ip1;
        HANDLE_CTYPE in2 = *(HANDLE_CTYPE*)ip2;
        *((npy_bool *)op1) = (in1 == in2);
    }
}
