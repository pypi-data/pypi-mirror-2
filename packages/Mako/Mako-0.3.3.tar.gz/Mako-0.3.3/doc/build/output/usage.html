# -*- coding: utf-8 -*-
<%inherit file="content_layout.html"/>
<%page args="toc, extension, paged"/>
<%namespace  name="formatting" file="formatting.html"/>
<%namespace  name="nav" file="nav.html"/>
<%def name="title()">Mako Documentation - Basic Usage</%def>
<%!
    filename = 'usage'
%>
## This file is generated.  Edit the .txt files instead of this one.


<%call expr="formatting.section(path='usage',paged=paged,extension=extension,toc=toc)">

<p>This section describes the Python API for Mako templates.  If you are using Mako within a web framework such as Pylons, the work of integrating Mako's API is already done for you, in which case you can skip to the next section, <%call expr="nav.toclink(path='syntax',paged=paged,extension=extension,toc=toc)"></%call>.
</p>
<p>The most basic way to create a template and render it is through the <code><%text filter='h'>Template</%text></code> class:
</p>
<%call expr="formatting.code(syntaxtype='python')"><%text>
from mako.template import Template

mytemplate = Template("hello world!")
print mytemplate.render()
</%text></%call><p>Above, the text argument to <code><%text filter='h'>Template</%text></code> is <strong>compiled</strong> into a Python module representation. This module contains a function called <code><%text filter='h'>render_body()</%text></code>, which produces the output of the template. When <code><%text filter='h'>mytemplate.render()</%text></code> is called, Mako sets up a runtime environment for the template and calls the <code><%text filter='h'>render_body()</%text></code> function, capturing the output into a buffer and returning its string contents.
</p>
<p>The code inside the <code><%text filter='h'>render_body()</%text></code> function has access to a namespace of variables.  You can specify these variables by sending them as additional keyword arguments to the <code><%text filter='h'>render()</%text></code> method:
</p>
<%call expr="formatting.code(syntaxtype='python')"><%text>
from mako.template import Template

mytemplate = Template("hello, ${name}!")
print mytemplate.render(name="jack")
</%text></%call><p>The <code><%text filter='h'>template.render()</%text></code> method calls upon Mako to create a <code><%text filter='h'>Context</%text></code> object, which stores all the variable names accessible to the template and also stores a buffer used to capture output.  You can create this <code><%text filter='h'>Context</%text></code> yourself and have the template render with it, using the <code><%text filter='h'>render_context</%text></code> method:
</p>
<%call expr="formatting.code(syntaxtype='python')"><%text>
from mako.template import Template
from mako.runtime import Context
from StringIO import StringIO

mytemplate = Template("hello, ${name}!")
buf = StringIO()
ctx = Context(buf, name="jack")
mytemplate.render_context(ctx)
print buf.getvalue()
</%text></%call>
<%call expr="formatting.section(path='usage_file',paged=paged,extension=extension,toc=toc)">

<p>A <code><%text filter='h'>Template</%text></code> can also load its template source code from a file, using the <code><%text filter='h'>filename</%text></code> keyword argument:
</p>
<%call expr="formatting.code(syntaxtype='python')"><%text>
from mako.template import Template

mytemplate = Template(filename='/docs/mytmpl.txt')
print mytemplate.render()
</%text></%call><p>For improved performance, a <code><%text filter='h'>Template</%text></code> which is loaded from a file can also cache the source code to its generated module on the filesystem as a regular Python module file (i.e. a .py file).  To do this, just add the <code><%text filter='h'>module_directory</%text></code> argument to the template:
</p>
<%call expr="formatting.code(syntaxtype='python')"><%text>
from mako.template import Template

mytemplate = Template(filename='/docs/mytmpl.txt', module_directory='/tmp/mako_modules')
print mytemplate.render()
</%text></%call><p>When the above code is rendered, a file <code><%text filter='h'>/tmp/mako_modules/docs/mytmpl.txt.py</%text></code> is created containing the source code for the module.  The next time a <code><%text filter='h'>Template</%text></code> with the same arguments is created, this module file will be automatically re-used.
</p>

</%call>
<%call expr="formatting.section(path='usage_lookup',paged=paged,extension=extension,toc=toc)">

<p>All of the examples thus far have dealt with the usage of a single <code><%text filter='h'>Template</%text></code> object.  If the code within those templates tries to locate another template resource, it will need some way to find them, using simple URI strings.  For this need, the resolution of other templates from within a template is accomplished by the <code><%text filter='h'>TemplateLookup</%text></code> class.   This class is constructed given a list of directories in which to search for templates, as well as keyword arguments that will be passed to the <code><%text filter='h'>Template</%text></code> objects it creates.
</p>
<%call expr="formatting.code(syntaxtype='python')"><%text>
from mako.template import Template
from mako.lookup import TemplateLookup

mylookup = TemplateLookup(directories=['/docs'])
mytemplate = Template("""<%include file="header.txt"/> hello world!""", lookup=mylookup)
</%text></%call><p>Above, we created a textual template which includes the file <code><%text filter='h'>header.txt</%text></code>.  In order for it to have somewhere to look for <code><%text filter='h'>header.txt</%text></code>, we passed a <code><%text filter='h'>TemplateLookup</%text></code> object to it, which will search in the directory <code><%text filter='h'>/docs</%text></code> for the file <code><%text filter='h'>header.txt</%text></code>.
</p>
<p>Usually, an application will store most or all of its templates as text files on the filesystem.  So far, all of our examples have been a little bit contrived in order to illustrate the basic concepts.  But a real application would get most or all of its templates directly from the <code><%text filter='h'>TemplateLookup</%text></code>, using the aptly named <code><%text filter='h'>get_template</%text></code> method, which accepts the URI of the desired template:
</p>
<%call expr="formatting.code(syntaxtype='python')"><%text>
from mako.template import Template
from mako.lookup import TemplateLookup

mylookup = TemplateLookup(directories=['/docs'], module_directory='/tmp/mako_modules')

def serve_template(templatename, **kwargs):
    mytemplate = mylookup.get_template(templatename)
    print mytemplate.render(**kwargs)
</%text></%call><p>In the example above, we create a <code><%text filter='h'>TemplateLookup</%text></code> which will look for templates in the <code><%text filter='h'>/docs</%text></code> directory, and will store generated module files in the <code><%text filter='h'>/tmp/mako_modules</%text></code> directory.  The lookup locates templates by appending the given URI to each of its search directories; so if you gave it a URI of <code><%text filter='h'>/etc/beans/info.txt</%text></code>, it would search for the file <code><%text filter='h'>/docs/etc/beans/info.txt</%text></code>, else raise a <code><%text filter='h'>TopLevelNotFound</%text></code> exception, which is a custom Mako exception.
</p>
<p>When the lookup locates templates, it will also assign a <code><%text filter='h'>uri</%text></code> property to the <code><%text filter='h'>Template</%text></code> which is the uri passed to the <code><%text filter='h'>get_template()</%text></code> call.  <code><%text filter='h'>Template</%text></code> uses this uri to calculate the name of its module file.  So in the above example, a <code><%text filter='h'>templatename</%text></code> argument of <code><%text filter='h'>/etc/beans/info.txt</%text></code> will create a module file <code><%text filter='h'>/tmp/mako_modules/etc/beans/info.txt.py</%text></code>.
</p>

<%call expr="formatting.section(path='usage_lookup_size',paged=paged,extension=extension,toc=toc)">

<p>The <code><%text filter='h'>TemplateLookup</%text></code> also serves the important need of caching a fixed set of templates in memory at a given time, so that successive uri lookups do not result in full template compilations and/or module reloads on each request.  By default, the <code><%text filter='h'>TemplateLookup</%text></code> size is unbounded.  You can specify a fixed size using the <code><%text filter='h'>collection_size</%text></code> argument:
</p>
<%call expr="formatting.code(syntaxtype='python')"><%text>
mylookup = TemplateLookup(directories=['/docs'], 
                module_directory='/tmp/mako_modules', collection_size=500)
</%text></%call><p>The above lookup will continue to load templates into memory until it reaches a count of around 500.  At that point, it will clean out a certain percentage of templates using a <strong>least recently used</strong> scheme.
</p>

</%call>
<%call expr="formatting.section(path='usage_lookup_checks',paged=paged,extension=extension,toc=toc)">

<p>Another important flag on <code><%text filter='h'>TemplateLookup</%text></code> is <code><%text filter='h'>filesystem_checks</%text></code>. This defaults to <code><%text filter='h'>True</%text></code>, and says that each time a template is returned by the <code><%text filter='h'>get_template()</%text></code> method, the revision time of the original template file is checked against the last time the template was loaded, and if the file is newer will reload its contents and recompile the template. On a production system, setting <code><%text filter='h'>filesystem_checks</%text></code> to <code><%text filter='h'>False</%text></code> can afford a small to moderate performance increase (depending on the type of filesystem used).
</p>

</%call>
</%call>
<%call expr="formatting.section(path='usage_using',paged=paged,extension=extension,toc=toc)">

<p>Both <code><%text filter='h'>Template</%text></code> and <code><%text filter='h'>TemplateLookup</%text></code> accept <code><%text filter='h'>output_encoding</%text></code> and <code><%text filter='h'>encoding_errors</%text></code> parameters which can be used to encode the output in any Python supported codec:
</p>
<%call expr="formatting.code(syntaxtype='python')"><%text>
from mako.template import Template
from mako.lookup import TemplateLookup

mylookup = TemplateLookup(directories=['/docs'], output_encoding='utf-8', encoding_errors='replace')

mytemplate = mylookup.get_template("foo.txt")
print mytemplate.render()
</%text></%call><p>When using Python 3, the <code><%text filter='h'>render()</%text></code> method will return a <code><%text filter='h'>bytes</%text></code> object, <strong>if</strong> <code><%text filter='h'>output_encoding</%text></code> is set.  Otherwise it returns a <code><%text filter='h'>string</%text></code>.
</p>
<p>Additionally, the <code><%text filter='h'>render_unicode()</%text></code> method exists which will return the template output as a Python <code><%text filter='h'>unicode</%text></code> object, or in Python 3 a <code><%text filter='h'>string</%text></code>:
</p>
<%call expr="formatting.code(syntaxtype='python')"><%text>
print mytemplate.render_unicode()
</%text></%call><p>The above method disregards the output encoding keyword argument; you can encode yourself by saying:
</p>
<%call expr="formatting.code(syntaxtype='python')"><%text>
print mytemplate.render_unicode().encode('utf-8', 'replace')
</%text></%call><p>Note that Mako's ability to return data in any encoding and/or <code><%text filter='h'>unicode</%text></code> implies that the underlying output stream of the template is a Python unicode object.  This behavior is described fully in <%call expr="nav.toclink(path='unicode',paged=paged,extension=extension,toc=toc)"></%call>.
</p>

</%call>
<%call expr="formatting.section(path='usage_handling',paged=paged,extension=extension,toc=toc)">

<p>Template exceptions can occur in two distinct places.  One is when you <strong>lookup, parse and compile</strong> the template, the other is when you <strong>run</strong> the template.  Within the running of a template, exceptions are thrown normally from whatever Python code originated the issue.  Mako has its own set of exception classes which mostly apply to the lookup and lexer/compiler stages of template construction.  Mako provides some library routines that can be used to help provide Mako-specific information about any exception's stack trace, as well as formatting the exception within textual or HTML format.  In all cases, the main value of these handlers is that of converting Python filenames, line numbers, and code samples into Mako template filenames, line numbers, and code samples.  All lines within a stack trace which correspond to a Mako template module will be converted to be against the originating template file.
</p>
<p>To format exception traces, the <code><%text filter='h'>text_error_template</%text></code> and <code><%text filter='h'>html_error_template</%text></code> functions are provided.  They make usage of <code><%text filter='h'>sys.exc_info()</%text></code> to get at the most recently thrown exception.  Usage of these handlers usually looks like:
</p>
<%call expr="formatting.code(syntaxtype='python')"><%text>
from mako import exceptions

try:
    template = lookup.get_template(uri)
    print template.render()
except:
    print exceptions.text_error_template().render()
</%text></%call><p>Or for the HTML render function:
</p>
<%call expr="formatting.code(syntaxtype='python')"><%text>
from mako import exceptions

try:
    template = lookup.get_template(uri)
    print template.render()
except:
    print exceptions.html_error_template().render()
</%text></%call><p>The <code><%text filter='h'>html_error_template</%text></code> template accepts two options: specifying <code><%text filter='h'>full=False</%text></code> causes only a section of an HTML document to be rendered. Specifying <code><%text filter='h'>css=False</%text></code> will disable the default stylesheet from being rendered.
</p>
<p>E.g.:
</p>
<%call expr="formatting.code()"><%text>    print exceptions.html_error_template().render(full=False)
</%text></%call><p>The HTML render function is also available built-in to <code><%text filter='h'>Template</%text></code> using the <code><%text filter='h'>format_exceptions</%text></code> flag.  In this case, any exceptions raised within the <strong>render</strong> stage of the template will result in the output being substituted with the output of <code><%text filter='h'>html_error_template</%text></code>.
</p>
<%call expr="formatting.code(syntaxtype='python')"><%text>
template = Template(filename="/foo/bar", format_exceptions=True)
print template.render()
</%text></%call><p>Note that the compile stage of the above template occurs when you construct the <code><%text filter='h'>Template</%text></code> itself, and no output stream is defined.  Therefore exceptions which occur within the lookup/parse/compile stage will not be handled and will propagate normally.   While the pre-render traceback usually will not include any Mako-specific lines anyway, it will mean that exceptions which occur previous to rendering and those which occur within rendering will be handled differently...so the <code><%text filter='h'>try/except</%text></code> patterns described previously are probably of more general use.
</p>
<p>The underlying object used by the error template functions is the <code><%text filter='h'>RichTraceback</%text></code> object.  This object can also be used directly to provide custom error views.  Here's an example usage which describes its general API:
</p>
<%call expr="formatting.code(syntaxtype='python')"><%text>
from mako.exceptions import RichTraceback

try:
    template = lookup.get_template(uri)
    print template.render()
except:
    traceback = RichTraceback()
    for (filename, lineno, function, line) in traceback.traceback:
        print "File %s, line %s, in %s" % (filename, lineno, function)
        print line, "\n"
    print "%s: %s" % (str(traceback.error.__class__.__name__), traceback.error)
</%text></%call><p>Further information about <code><%text filter='h'>RichTraceback</%text></code> is available within the module-level documentation for <code><%text filter='h'>mako.exceptions</%text></code>.
</p>

</%call>
<%call expr="formatting.section(path='usage_common',paged=paged,extension=extension,toc=toc)">

<p>The Mako distribution includes a little bit of helper code for the purpose of using Mako in some popular web framework scenarios.  This is a brief description of whats included.
</p>

<%call expr="formatting.section(path='usage_common_turbogears/pylons',paged=paged,extension=extension,toc=toc)">

<p>The standard plugin methodology used by <a href='http://www.turbogears.org'>Turbogears</a> as well as <a href='http://www.pylonshq.com'>Pylons</a> is included in the module <code><%text filter='h'>mako.ext.turbogears</%text></code>, using the <code><%text filter='h'>TGPlugin</%text></code> class.  This is also a setuptools entrypoint under the heading <code><%text filter='h'>python.templating.engines</%text></code> with the name <code><%text filter='h'>mako</%text></code>.
</p>

</%call>
<%call expr="formatting.section(path='usage_common_wsgi',paged=paged,extension=extension,toc=toc)">

<p>A sample WSGI application is included in the distrubution in the file <code><%text filter='h'>examples/wsgi/run_wsgi.py</%text></code>.  This runner is set up to pull files from a <code><%text filter='h'>templates</%text></code> as well as an <code><%text filter='h'>htdocs</%text></code> directory and includes a rudimental two-file layout.  The WSGI runner acts as a fully functional standalone web server, using <code><%text filter='h'>wsgiutils</%text></code> to run itself, and propagates GET and POST arguments from the request into the <code><%text filter='h'>Context</%text></code>, can serve images, css files and other kinds of files, and also displays errors using Mako's included exception-handling utilities.
</p>

</%call>
<%call expr="formatting.section(path='usage_common_pygments',paged=paged,extension=extension,toc=toc)">

<p>A <a href='http://pygments.pocoo.org'>Pygments</a>-compatible syntax highlighting module is included under <code><%text filter='h'>mako.ext.pygmentplugin</%text></code>.  This module is used in the generation of Mako documentation and also contains various setuptools entry points under the heading <code><%text filter='h'>pygments.lexers</%text></code>, including <code><%text filter='h'>mako</%text></code>, <code><%text filter='h'>html+mako</%text></code>, <code><%text filter='h'>xml+mako</%text></code> (see the <code><%text filter='h'>setup.py</%text></code> file for all the entry points).
</p>

</%call>
<%call expr="formatting.section(path='usage_common_babel',paged=paged,extension=extension,toc=toc)">

<p>Mako provides support for extracting gettext messages from templates via a <a href='http://babel.edgewall.org/'>Babel</a> extractor entry point under <code><%text filter='h'>mako.ext.babelplugin</%text></code>.
</p>
<p>Gettext messages are extracted from all Python code sections, even the more obscure ones such as <%call expr="nav.toclink(path='syntax_control',paged=paged,description='control structures',extension=extension,toc=toc)"></%call>, <%call expr="nav.toclink(path='defs',paged=paged,description='def tag function declarations',extension=extension,toc=toc)"></%call>, <%call expr="nav.toclink(path='defs_defswithcontent',paged=paged,description='call tag exprs',extension=extension,toc=toc)"></%call> and even <%call expr="nav.toclink(path='syntax_tags_page',paged=paged,description='page tag args',extension=extension,toc=toc)"></%call>.
</p>
<p><a href='http://babel.edgewall.org/wiki/Documentation/messages.html#comments-tags-and-translator-comments-explanation'>Translator comments</a> may also be extracted from Mako templates when a comment tag is specified to <a href='http://babel.edgewall.org/'>Babel</a> (such as with the -c option).
</p>
<p>For example, a project '<code><%text filter='h'>myproj</%text></code>' contains the following Mako template at myproj/myproj/templates/name.html:
</p>
<%call expr="formatting.code()"><%text><div id="name">
  Name:
  ## TRANSLATORS: This is a proper name. See the gettext
  ## manual, section Names.
  ${_('Francois Pinard')}
</div>
</%text></%call><p>To extract gettext messages from this template the project needs a Mako section in its <a href='http://babel.edgewall.org/wiki/Documentation/messages.html#extraction-method-mapping-and-configuration'>Babel Extraction Method Mapping file</a> (typically located at myproj/babel.cfg):
</p>
<%call expr="formatting.code(syntaxtype='ini')"><%text>
# Extraction from Python source files

[python: myproj/**.py]

# Extraction from Mako templates

[mako: myproj/templates/**.html]
input_encoding = utf-8
</%text></%call><p>The Mako extractor supports an optional <code><%text filter='h'>input_encoding</%text></code> parameter specifying the encoding of the templates (identical to <code><%text filter='h'>Template</%text></code>/<code><%text filter='h'>TemplateLookup</%text></code>'s <code><%text filter='h'>input_encoding</%text></code> parameter).
</p>
<p>Invoking <a href='http://babel.edgewall.org/'>Babel</a>'s extractor at the command line in the project's root directory:
</p>
<%call expr="formatting.code()"><%text>myproj$ pybabel extract -F babel.cfg -c "TRANSLATORS:" .
</%text></%call><p>Will output a gettext catalog to stdout including the following:
</p>
<%call expr="formatting.code()"><%text>#. TRANSLATORS: This is a proper name. See the gettext
#. manual, section Names.
#: myproj/templates/name.html:5
msgid "Francois Pinard"
msgstr ""
</%text></%call><p>This is only a basic example: <a href='http://babel.edgewall.org/'>Babel</a> can be invoked from setup.py and its command line options specified in the accompanying setup.cfg via <a href='http://babel.edgewall.org/wiki/Documentation/setup.html'>Babel Distutils/Setuptools Integration</a>.
</p>
<p>Comments must immediately precede a gettext message to be extracted. In the following case the TRANSLATORS: comment would not have been extracted:
</p>
<%call expr="formatting.code()"><%text><div id="name">
  ## TRANSLATORS: This is a proper name. See the gettext
  ## manual, section Names.
  Name: ${_('Francois Pinard')}
</div>
</%text></%call><p>See the <a href='http://babel.edgewall.org/wiki/Documentation/index.html'>Babel User Guide</a> for more information.
</p>


</%call>
</%call>
</%call>
</html>