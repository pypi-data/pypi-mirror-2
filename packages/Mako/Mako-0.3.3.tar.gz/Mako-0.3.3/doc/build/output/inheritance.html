# -*- coding: utf-8 -*-
<%inherit file="content_layout.html"/>
<%page args="toc, extension, paged"/>
<%namespace  name="formatting" file="formatting.html"/>
<%namespace  name="nav" file="nav.html"/>
<%def name="title()">Mako Documentation - Inheritance</%def>
<%!
    filename = 'inheritance'
%>
## This file is generated.  Edit the .txt files instead of this one.


<%call expr="formatting.section(path='inheritance',paged=paged,extension=extension,toc=toc)">

<p>Using template inheritance, two or more templates can organize themselves into an <strong>inheritance chain</strong>, where content and functions from all involved templates can be intermixed.  The general paradigm of template inheritance is this:  if a template <code><%text filter='h'>A</%text></code> inherits from template <code><%text filter='h'>B</%text></code>, then template <code><%text filter='h'>A</%text></code> agrees to send the executional control to template <code><%text filter='h'>B</%text></code> at runtime (<code><%text filter='h'>A</%text></code> is called the <strong>inheriting</strong> template).  Template <code><%text filter='h'>B</%text></code>, the <strong>inherited</strong> template, then makes decisions as to what resources from <code><%text filter='h'>A</%text></code> shall be executed.
</p>
<p>In practice, it looks like this.  Heres a hypothetical inheriting template, <code><%text filter='h'>index.html</%text></code>:
</p>
<%call expr="formatting.code()"><%text>## index.html
<%inherit file="base.html"/>

<%def name="header()">
    this is some header content
</%def>

this is the body content.
</%text></%call><p>And <code><%text filter='h'>base.html</%text></code>, the inherited template:
</p>
<%call expr="formatting.code()"><%text>## base.html
<html>
    <body>
        <div class="header">
            ${self.header()}
        </div>

        ${self.body()}

        <div class="footer">
            ${self.footer()}
        </div>
    </body>
</html>

<%def name="footer()">
    this is the footer
</%def>
</%text></%call><p>Here is a breakdown of the execution:
</p>
<ul>
 <li><p>When <code><%text filter='h'>index.html</%text></code> is rendered, control immediately passes to <code><%text filter='h'>base.html</%text></code>.
</p>

 </li>

 <li><p><code><%text filter='h'>base.html</%text></code> then renders the top part of an HTML document, then calls the method <code><%text filter='h'>header()</%text></code> off of a built in namespace called <code><%text filter='h'>self</%text></code> (this namespace was first introduced in the Namespaces chapter in <%call expr="nav.toclink(path='namespaces_builtin_self',paged=paged,extension=extension,toc=toc)"></%call>).  Since <code><%text filter='h'>index.html</%text></code> is the topmost template and also defines a def called <code><%text filter='h'>header()</%text></code>, its this <code><%text filter='h'>header()</%text></code> def that gets executed.
</p>

 </li>

 <li><p>Control comes back to <code><%text filter='h'>base.html</%text></code>.  Some more HTML is rendered.
</p>

 </li>

 <li><p><code><%text filter='h'>base.html</%text></code> executes <code><%text filter='h'>self.body()</%text></code>.  The <code><%text filter='h'>body()</%text></code> function on all template-based namespaces refers to the main body of the template, therefore the main body of <code><%text filter='h'>index.html</%text></code> is rendered.
</p>

 </li>

 <li><p>Control comes back to <code><%text filter='h'>base.html</%text></code>.  More HTML is rendered, then the <code><%text filter='h'>self.footer()</%text></code> expression is invoked.
</p>

 </li>

 <li><p>The <code><%text filter='h'>footer</%text></code> def is only defined in <code><%text filter='h'>base.html</%text></code>, so being the topmost definition of <code><%text filter='h'>footer</%text></code>, its the one that executes.  If <code><%text filter='h'>index.html</%text></code> also specified <code><%text filter='h'>footer</%text></code>, then its version would <strong>override</strong> that of the base.
</p>

 </li>

 <li><p><code><%text filter='h'>base.html</%text></code> finishes up rendering its HTML and the template is complete, producing:
</p>
<%call expr="formatting.code()"><%text><html>
    <body>
        <div class="header">
            this is some header content
        </div>

        this is the body content.

        <div class="footer">
            this is the footer
        </div>
    </body>
</html>
</%text></%call>
 </li>
</ul>
<p>...and that is template inheritance in a nutshell.  The main idea is that the methods that you call upon <code><%text filter='h'>self</%text></code> always correspond to the topmost definition of that method.  Very much the way <code><%text filter='h'>self</%text></code> works in a Python class, even though Mako is not actually using Python class inheritance to implement this functionality.  (Mako doesn't take the "inheritance" metaphor too seriously; while useful to setup some commonly recognized semantics, a textual template is not very much like an object-oriented class construct in practice).
</p>

<%call expr="formatting.section(path='inheritance_next',paged=paged,extension=extension,toc=toc)">

<p>Sometimes you have an inheritance chain that spans more than two templates.  Or maybe you don't, but youd like to build your system such that extra inherited templates can be inserted in the middle of a chain where they would be smoothly integrated.  If each template wants to define its layout just within its main body, you can't just call <code><%text filter='h'>self.body()</%text></code> to get at the inheriting template's body, since that is only the topmost body.  To get at the body of the <em>next</em> template, you call upon the namespace <code><%text filter='h'>next</%text></code>, which is the namespace of the template <strong>immediately following</strong> the current template.
</p>
<p>Lets change the line in <code><%text filter='h'>base.html</%text></code> which calls upon <code><%text filter='h'>self.body()</%text></code> to instead call upon <code><%text filter='h'>next.body()</%text></code>:
</p>
<%call expr="formatting.code()"><%text>## base.html
<html>
    <body>
        <div class="header">
            ${self.header()}
        </div>

        ${next.body()}

        <div class="footer">
            ${self.footer()}
        </div>
    </body>
</html>

<%def name="footer()">
    this is the footer
</%def>
</%text></%call><p>Lets also add an intermediate template called <code><%text filter='h'>layout.html</%text></code>, which inherits from <code><%text filter='h'>base.html</%text></code>:
</p>
<%call expr="formatting.code()"><%text>## layout.html
<%inherit file="base.html"/>
<ul>
    ${self.toolbar()}
</ul>
<div class="mainlayout">
    ${next.body()}
</div>

<%def name="toolbar()">
    <li>selection 1</li>
    <li>selection 2</li>
    <li>selection 3</li>
</%def>
</%text></%call><p>And finally change <code><%text filter='h'>index.html</%text></code> to inherit from <code><%text filter='h'>layout.html</%text></code> instead:
</p>
<%call expr="formatting.code()"><%text>## index.html
<%inherit file="layout.html"/>

## .. rest of template
</%text></%call><p>In this setup, each call to <code><%text filter='h'>next.body()</%text></code> will render the body of the next template in the inheritance chain (which can be written as <code><%text filter='h'>base.html -> layout.html -> index.html</%text></code>).  Control is still first passed to the bottommost template <code><%text filter='h'>base.html</%text></code>, and <code><%text filter='h'>self</%text></code> still references the topmost definition of any particular def.
</p>
<p>The output we get would be:
</p>
<%call expr="formatting.code()"><%text><html>
    <body>
        <div class="header">
            this is some header content
        </div>

        <ul>
            <li>selection 1</li>
            <li>selection 2</li>
            <li>selection 3</li>
        </ul>

        <div class="mainlayout">
        this is the body content.
        </div>

        <div class="footer">
            this is the footer
        </div>
    </body>
</html>
</%text></%call><p>So above, we have the <code><%text filter='h'><html></%text></code>, <code><%text filter='h'><body></%text></code> and <code><%text filter='h'>header</%text></code>/<code><%text filter='h'>footer</%text></code> layout of <code><%text filter='h'>base.html</%text></code>, we have the <code><%text filter='h'><ul></%text></code> and <code><%text filter='h'>mainlayout</%text></code> section of <code><%text filter='h'>layout.html</%text></code>, and the main body of <code><%text filter='h'>index.html</%text></code> as well as its overridden <code><%text filter='h'>header</%text></code> def.  The <code><%text filter='h'>layout.html</%text></code> template is inserted into the middle of the chain without <code><%text filter='h'>base.html</%text></code> having to change anything.  Without the <code><%text filter='h'>next</%text></code> namespace, only the main body of <code><%text filter='h'>index.html</%text></code> could be used; there would be no way to call <code><%text filter='h'>layout.html</%text></code>'s body content.
</p>

</%call>
<%call expr="formatting.section(path='inheritance_parent',paged=paged,extension=extension,toc=toc)">

<p>Lets now look at the other inheritance-specific namespace, the opposite of <code><%text filter='h'>next</%text></code> called <code><%text filter='h'>parent</%text></code>.  <code><%text filter='h'>parent</%text></code> is the namespace of the template <strong>immediately preceding</strong> the current template.  What is most useful about this namespace is the methods within it which can be accessed within overridden versions of those methods.  This is not as hard as it sounds and is very much like using the <code><%text filter='h'>super</%text></code> keyword in Python.  Lets modify <code><%text filter='h'>index.html</%text></code> to augment the list of selections provided by the <code><%text filter='h'>toolbar</%text></code> function in <code><%text filter='h'>layout.html</%text></code>:
</p>
<%call expr="formatting.code()"><%text>## index.html
<%inherit file="layout.html"/>

<%def name="header()">
    this is some header content
</%def>

<%def name="toolbar()">
    ## call the parent's toolbar first
    ${parent.toolbar()}
    <li>selection 4</li>
    <li>selection 5</li>
</%def>

this is the body content.
</%text></%call><p>Above, we implemented a <code><%text filter='h'>toolbar()</%text></code> function, which is meant to override the definition of <code><%text filter='h'>toolbar</%text></code> within the inherited template <code><%text filter='h'>layout.html</%text></code>.  However, since we want the content from that of <code><%text filter='h'>layout.html</%text></code> as well, we call it via the <code><%text filter='h'>parent</%text></code> namespace whenever we want it's content, in this case before we add our own selections.  So the output for the whole thing is now:
</p>
<%call expr="formatting.code()"><%text><html>
    <body>
        <div class="header">
            this is some header content
        </div>

        <ul>
            <li>selection 1</li>
            <li>selection 2</li>
            <li>selection 3</li>
            <li>selection 4</li>
            <li>selection 5</li>
        </ul>

        <div class="mainlayout">
        this is the body content.
        </div>

        <div class="footer">
            this is the footer
        </div>
    </body>
</html>
</%text></%call><p>and you're now a template inheritance ninja !
</p>

</%call>
<%call expr="formatting.section(path='inheritance_inheritable',paged=paged,extension=extension,toc=toc)">

<p>The <code><%text filter='h'>attr</%text></code> accessor of the <code><%text filter='h'>Namespace</%text></code> object allows access to module level variables declared in a template.  By accessing <code><%text filter='h'>self.attr</%text></code>, you can access regular attributes from the inheritance chain as declared in <code><%text filter='h'><%! %></%text></code> sections.  Such as:
</p>
<%call expr="formatting.code()"><%text><%!
    class_ = "grey"
%>

<div class="${self.attr.class_}">
    ${self.body()}
</div>
</%text></%call><p>If a an inheriting template overrides <code><%text filter='h'>class_</%text></code> to be <code><%text filter='h'>white</%text></code>, as in:
</p>
<%call expr="formatting.code()"><%text><%!
    class_ = "white"
%>
<%inherit file="parent.html"/>

This is the body
</%text></%call><p>You'll get output like:
</p>
<%call expr="formatting.code()"><%text><div class="white">
    This is the body
</div>
</%text></%call>

</%call>
</%call>
</html>