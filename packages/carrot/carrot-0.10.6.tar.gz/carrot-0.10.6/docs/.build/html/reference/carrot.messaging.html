
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>carrot.messaging &mdash; Carrot v0.10.5 documentation</title>
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.10.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Carrot v0.10.5 documentation" href="../index.html" />
    <link rel="up" title="API Reference" href="index.html" />
    <link rel="next" title="carrot.backends" href="carrot.backends.html" />
    <link rel="prev" title="carrot.connection" href="carrot.connection.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="carrot.backends.html" title="carrot.backends"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="carrot.connection.html" title="carrot.connection"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Carrot v0.10.5 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">API Reference</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="carrot-messaging">
<h1>carrot.messaging<a class="headerlink" href="#carrot-messaging" title="Permalink to this headline">¶</a></h1>
<p>The introduction to carrot that was here previously has been moved
to the <a class="reference external" href="http://ask.github.com/carrot/introduction.html#examples">introduction</a> page.</p>
<span class="target" id="module-carrot.messaging"></span><p>Sending/Receiving Messages.</p>
<dl class="class">
<dt id="carrot.messaging.Consumer">
<em class="property">class </em><tt class="descclassname">carrot.messaging.</tt><tt class="descname">Consumer</tt><big>(</big><em>connection</em>, <em>queue=None</em>, <em>exchange=None</em>, <em>routing_key=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer" title="Permalink to this definition">¶</a></dt>
<dd><p>Message consumer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>connection</strong> &#8211; see <a class="reference internal" href="#carrot.messaging.Consumer.connection" title="carrot.messaging.Consumer.connection"><tt class="xref py py-attr docutils literal"><span class="pre">connection</span></tt></a>.</li>
<li><strong>queue</strong> &#8211; see <a class="reference internal" href="#carrot.messaging.Consumer.queue" title="carrot.messaging.Consumer.queue"><tt class="xref py py-attr docutils literal"><span class="pre">queue</span></tt></a>.</li>
<li><strong>exchange</strong> &#8211; see <a class="reference internal" href="#carrot.messaging.Consumer.exchange" title="carrot.messaging.Consumer.exchange"><tt class="xref py py-attr docutils literal"><span class="pre">exchange</span></tt></a>.</li>
<li><strong>routing_key</strong> &#8211; see <a class="reference internal" href="#carrot.messaging.Consumer.routing_key" title="carrot.messaging.Consumer.routing_key"><tt class="xref py py-attr docutils literal"><span class="pre">routing_key</span></tt></a>.</li>
<li><strong>durable</strong> &#8211; see <a class="reference internal" href="#carrot.messaging.Consumer.durable" title="carrot.messaging.Consumer.durable"><tt class="xref py py-attr docutils literal"><span class="pre">durable</span></tt></a>.</li>
<li><strong>auto_delete</strong> &#8211; see <a class="reference internal" href="#carrot.messaging.Consumer.auto_delete" title="carrot.messaging.Consumer.auto_delete"><tt class="xref py py-attr docutils literal"><span class="pre">auto_delete</span></tt></a>.</li>
<li><strong>exclusive</strong> &#8211; see <a class="reference internal" href="#carrot.messaging.Consumer.exclusive" title="carrot.messaging.Consumer.exclusive"><tt class="xref py py-attr docutils literal"><span class="pre">exclusive</span></tt></a>.</li>
<li><strong>exchange_type</strong> &#8211; see <a class="reference internal" href="#carrot.messaging.Consumer.exchange_type" title="carrot.messaging.Consumer.exchange_type"><tt class="xref py py-attr docutils literal"><span class="pre">exchange_type</span></tt></a>.</li>
<li><strong>auto_ack</strong> &#8211; see <a class="reference internal" href="#carrot.messaging.Consumer.auto_ack" title="carrot.messaging.Consumer.auto_ack"><tt class="xref py py-attr docutils literal"><span class="pre">auto_ack</span></tt></a>.</li>
<li><strong>no_ack</strong> &#8211; see <a class="reference internal" href="#carrot.messaging.Consumer.no_ack" title="carrot.messaging.Consumer.no_ack"><tt class="xref py py-attr docutils literal"><span class="pre">no_ack</span></tt></a>.</li>
<li><strong>auto_declare</strong> &#8211; see <tt class="xref py py-attr docutils literal"><span class="pre">auto_declare</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="carrot.messaging.Consumer.connection">
<tt class="descname">connection</tt><a class="headerlink" href="#carrot.messaging.Consumer.connection" title="Permalink to this definition">¶</a></dt>
<dd><p>The connection to the broker.
A <a class="reference internal" href="carrot.connection.html#carrot.connection.BrokerConnection" title="carrot.connection.BrokerConnection"><tt class="xref py py-class docutils literal"><span class="pre">carrot.connection.BrokerConnection</span></tt></a> instance.</p>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.queue">
<tt class="descname">queue</tt><a class="headerlink" href="#carrot.messaging.Consumer.queue" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the queue.</p>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.exchange">
<tt class="descname">exchange</tt><a class="headerlink" href="#carrot.messaging.Consumer.exchange" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the exchange the queue binds to.</p>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.routing_key">
<tt class="descname">routing_key</tt><a class="headerlink" href="#carrot.messaging.Consumer.routing_key" title="Permalink to this definition">¶</a></dt>
<dd><p>The routing key (if any). The interpretation of the routing key
depends on the value of the <a class="reference internal" href="#carrot.messaging.Consumer.exchange_type" title="carrot.messaging.Consumer.exchange_type"><tt class="xref py py-attr docutils literal"><span class="pre">exchange_type</span></tt></a> attribute:</p>
<blockquote>
<ul>
<li><p class="first">direct exchange</p>
<blockquote>
<p>Matches if the routing key property of the message and
the <a class="reference internal" href="#carrot.messaging.Consumer.routing_key" title="carrot.messaging.Consumer.routing_key"><tt class="xref py py-attr docutils literal"><span class="pre">routing_key</span></tt></a> attribute are identical.</p>
</blockquote>
</li>
<li><p class="first">fanout exchange</p>
<blockquote>
<p>Always matches, even if the binding does not have a key.</p>
</blockquote>
</li>
<li><p class="first">topic exchange</p>
<blockquote>
<p>Matches the routing key property of the message by a primitive
pattern matching scheme. The message routing key then consists
of words separated by dots (<tt class="docutils literal"><span class="pre">&quot;.&quot;</span></tt>, like domain names), and
two special characters are available; star (<tt class="docutils literal"><span class="pre">&quot;*&quot;</span></tt>) and hash
(<tt class="docutils literal"><span class="pre">&quot;#&quot;</span></tt>). The star matches any word, and the hash matches
zero or more words. For example <tt class="docutils literal"><span class="pre">&quot;*.stock.#&quot;</span></tt> matches the
routing keys <tt class="docutils literal"><span class="pre">&quot;usd.stock&quot;</span></tt> and <tt class="docutils literal"><span class="pre">&quot;eur.stock.db&quot;</span></tt> but not
<tt class="docutils literal"><span class="pre">&quot;stock.nasdaq&quot;</span></tt>.</p>
</blockquote>
</li>
</ul>
</blockquote>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.durable">
<tt class="descname">durable</tt><a class="headerlink" href="#carrot.messaging.Consumer.durable" title="Permalink to this definition">¶</a></dt>
<dd><p>Durable exchanges remain active when a server restarts. Non-durable
exchanges (transient exchanges) are purged when a server restarts.
Default is <tt class="xref docutils literal"><span class="pre">True</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.auto_delete">
<tt class="descname">auto_delete</tt><a class="headerlink" href="#carrot.messaging.Consumer.auto_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, the exchange is deleted when all queues have finished
using it. Default is <tt class="xref docutils literal"><span class="pre">False</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.exclusive">
<tt class="descname">exclusive</tt><a class="headerlink" href="#carrot.messaging.Consumer.exclusive" title="Permalink to this definition">¶</a></dt>
<dd><p>Exclusive queues may only be consumed from by the current connection.
When <a class="reference internal" href="#carrot.messaging.Consumer.exclusive" title="carrot.messaging.Consumer.exclusive"><tt class="xref py py-attr docutils literal"><span class="pre">exclusive</span></tt></a> is on, this also implies <a class="reference internal" href="#carrot.messaging.Consumer.auto_delete" title="carrot.messaging.Consumer.auto_delete"><tt class="xref py py-attr docutils literal"><span class="pre">auto_delete</span></tt></a>.
Default is <tt class="xref docutils literal"><span class="pre">False</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.exchange_type">
<tt class="descname">exchange_type</tt><a class="headerlink" href="#carrot.messaging.Consumer.exchange_type" title="Permalink to this definition">¶</a></dt>
<dd><p>AMQP defines four default exchange types (routing algorithms) that
covers most of the common messaging use cases. An AMQP broker can
also define additional exchange types, so see your message brokers
manual for more information about available exchange types.</p>
<blockquote>
<ul>
<li><p class="first">Direct</p>
<blockquote>
<p>Direct match between the routing key in the message, and the
routing criteria used when a queue is bound to this exchange.</p>
</blockquote>
</li>
<li><p class="first">Topic</p>
<blockquote>
<p>Wildcard match between the routing key and the routing pattern
specified in the binding. The routing key is treated as zero
or more words delimited by <tt class="docutils literal"><span class="pre">&quot;.&quot;</span></tt> and supports special
wildcard characters. <tt class="docutils literal"><span class="pre">&quot;*&quot;</span></tt> matches a single word and <tt class="docutils literal"><span class="pre">&quot;#&quot;</span></tt>
matches zero or more words.</p>
</blockquote>
</li>
<li><p class="first">Fanout</p>
<blockquote>
<p>Queues are bound to this exchange with no arguments. Hence any
message sent to this exchange will be forwarded to all queues
bound to this exchange.</p>
</blockquote>
</li>
<li><p class="first">Headers</p>
<blockquote>
<p>Queues are bound to this exchange with a table of arguments
containing headers and values (optional). A special argument
named &#8220;x-match&#8221; determines the matching algorithm, where
<tt class="docutils literal"><span class="pre">&quot;all&quot;</span></tt> implies an <tt class="docutils literal"><span class="pre">AND</span></tt> (all pairs must match) and
<tt class="docutils literal"><span class="pre">&quot;any&quot;</span></tt> implies <tt class="docutils literal"><span class="pre">OR</span></tt> (at least one pair must match).</p>
<p>Use the <tt class="xref py py-attr docutils literal"><span class="pre">routing_key`</span></tt> is used to specify the arguments,
the same when sending messages.</p>
</blockquote>
</li>
</ul>
<p>This description of AMQP exchange types was shamelessly stolen
from the blog post <a class="reference external" href="http://bit.ly/amqp-exchange-types">AMQP in 10 minutes: Part 4</a> by
Rajith Attapattu. Recommended reading.</p>
</blockquote>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.callbacks">
<tt class="descname">callbacks</tt><a class="headerlink" href="#carrot.messaging.Consumer.callbacks" title="Permalink to this definition">¶</a></dt>
<dd><p>List of registered callbacks to trigger when a message is received
by <a class="reference internal" href="#carrot.messaging.Consumer.wait" title="carrot.messaging.Consumer.wait"><tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt></a>, <a class="reference internal" href="#carrot.messaging.Consumer.process_next" title="carrot.messaging.Consumer.process_next"><tt class="xref py py-meth docutils literal"><span class="pre">process_next()</span></tt></a> or <a class="reference internal" href="#carrot.messaging.Consumer.iterqueue" title="carrot.messaging.Consumer.iterqueue"><tt class="xref py py-meth docutils literal"><span class="pre">iterqueue()</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.warn_if_exists">
<tt class="descname">warn_if_exists</tt><a class="headerlink" href="#carrot.messaging.Consumer.warn_if_exists" title="Permalink to this definition">¶</a></dt>
<dd><p>Emit a warning if the queue has already been declared. If a queue
already exists, and you try to redeclare the queue with new settings,
the new settings will be silently ignored, so this can be
useful if you&#8217;ve recently changed the <a class="reference internal" href="#carrot.messaging.Consumer.routing_key" title="carrot.messaging.Consumer.routing_key"><tt class="xref py py-attr docutils literal"><span class="pre">routing_key</span></tt></a> attribute
or other settings.</p>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.auto_ack">
<tt class="descname">auto_ack</tt><a class="headerlink" href="#carrot.messaging.Consumer.auto_ack" title="Permalink to this definition">¶</a></dt>
<dd><p>Acknowledgement is handled automatically once messages are received.
This means that the <a class="reference internal" href="carrot.backends.base.html#carrot.backends.base.BaseMessage.ack" title="carrot.backends.base.BaseMessage.ack"><tt class="xref py py-meth docutils literal"><span class="pre">carrot.backends.base.BaseMessage.ack()</span></tt></a> and
<a class="reference internal" href="carrot.backends.base.html#carrot.backends.base.BaseMessage.reject" title="carrot.backends.base.BaseMessage.reject"><tt class="xref py py-meth docutils literal"><span class="pre">carrot.backends.base.BaseMessage.reject()</span></tt></a> methods
on the message object are no longer valid.
By default <a class="reference internal" href="#carrot.messaging.Consumer.auto_ack" title="carrot.messaging.Consumer.auto_ack"><tt class="xref py py-attr docutils literal"><span class="pre">auto_ack</span></tt></a> is set to <tt class="xref docutils literal"><span class="pre">False</span></tt>, and the receiver is
required to manually handle acknowledgment.</p>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Consumer.no_ack">
<tt class="descname">no_ack</tt><a class="headerlink" href="#carrot.messaging.Consumer.no_ack" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable acknowledgement on the server-side. This is different from
<a class="reference internal" href="#carrot.messaging.Consumer.auto_ack" title="carrot.messaging.Consumer.auto_ack"><tt class="xref py py-attr docutils literal"><span class="pre">auto_ack</span></tt></a> in that acknowledgement is turned off altogether.
This functionality increases performance but at the cost of
reliability. Messages can get lost if a client dies before it can
deliver them to the application.</p>
</dd></dl>

<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name" colspan="2">Raises amqplib.client_0_8.channel.AMQPChannelException:</th></tr>
<tr><td>&nbsp;</td><td class="field-body">if the queue is
exclusive and the queue already exists and is owned by another
connection.</td>
</tr>
</tbody>
</table>
<p>Example Usage</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">consumer</span> <span class="o">=</span> <span class="n">Consumer</span><span class="p">(</span><span class="n">connection</span><span class="o">=</span><span class="n">DjangoBrokerConnection</span><span class="p">(),</span>
<span class="gp">... </span>              <span class="n">queue</span><span class="o">=</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">exchange</span><span class="o">=</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">routing_key</span><span class="o">=</span><span class="s">&quot;foo&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">process_message</span><span class="p">(</span><span class="n">message_data</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s">&quot;Got message </span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span>
<span class="gp">... </span>            <span class="n">message</span><span class="o">.</span><span class="n">delivery_tag</span><span class="p">,</span> <span class="n">message_data</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">consumer</span><span class="o">.</span><span class="n">register_callback</span><span class="p">(</span><span class="n">process_message</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">consumer</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span> <span class="c"># Go into receive loop</span>
</pre></div>
</div>
<dl class="method">
<dt id="carrot.messaging.Consumer.cancel">
<tt class="descname">cancel</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.cancel" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancel a running <a class="reference internal" href="#carrot.messaging.Consumer.iterconsume" title="carrot.messaging.Consumer.iterconsume"><tt class="xref py py-meth docutils literal"><span class="pre">iterconsume()</span></tt></a> session.</p>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the channel to the queue.</p>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.consume">
<tt class="descname">consume</tt><big>(</big><em>no_ack=None</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.consume" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare consumer.</p>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.declare">
<tt class="descname">declare</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.declare" title="Permalink to this definition">¶</a></dt>
<dd><p>Declares the queue, the exchange and binds the queue to
the exchange.</p>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.discard_all">
<tt class="descname">discard_all</tt><big>(</big><em>filterfunc=None</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.discard_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Discard all waiting messages.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filterfunc</strong> &#8211; A filter function to only discard the messages this
filter returns.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the number of messages discarded.</p>
</td>
</tr>
</tbody>
</table>
<p><em>WARNING</em>: All incoming messages will be ignored and not processed.</p>
<p>Example using filter:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">waiting_feeds_only</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">message_data</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">except</span><span class="p">:</span> <span class="c"># Should probably be more specific.</span>
<span class="gp">... </span>        <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">message_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;type&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;feed&quot;</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">True</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.fetch">
<tt class="descname">fetch</tt><big>(</big><em>no_ack=None</em>, <em>auto_ack=None</em>, <em>enable_callbacks=False</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.fetch" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive the next message waiting on the queue.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A <a class="reference internal" href="carrot.backends.base.html#carrot.backends.base.BaseMessage" title="carrot.backends.base.BaseMessage"><tt class="xref py py-class docutils literal"><span class="pre">carrot.backends.base.BaseMessage</span></tt></a> instance,
or <tt class="xref docutils literal"><span class="pre">None</span></tt> if there&#8217;s no messages to be received.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>enable_callbacks</strong> &#8211; Enable callbacks. The message will be
processed with all registered callbacks. Default is disabled.</li>
<li><strong>auto_ack</strong> &#8211; Override the default <a class="reference internal" href="#carrot.messaging.Consumer.auto_ack" title="carrot.messaging.Consumer.auto_ack"><tt class="xref py py-attr docutils literal"><span class="pre">auto_ack</span></tt></a> setting.</li>
<li><strong>no_ack</strong> &#8211; Override the default <a class="reference internal" href="#carrot.messaging.Consumer.no_ack" title="carrot.messaging.Consumer.no_ack"><tt class="xref py py-attr docutils literal"><span class="pre">no_ack</span></tt></a> setting.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.flow">
<tt class="descname">flow</tt><big>(</big><em>active</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.flow" title="Permalink to this definition">¶</a></dt>
<dd><p>This method asks the peer to pause or restart the flow of
content data.</p>
<p>This is a simple flow-control mechanism that a
peer can use to avoid oveflowing its queues or otherwise
finding itself receiving more messages than it can process.
Note that this method is not intended for window control.  The
peer that receives a request to stop sending content should
finish sending the current content, if any, and then wait
until it receives the <tt class="docutils literal"><span class="pre">flow(active=True)</span></tt> restart method.</p>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.iterconsume">
<tt class="descname">iterconsume</tt><big>(</big><em>limit=None</em>, <em>no_ack=None</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.iterconsume" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator processing new messages as they arrive.
Every new message will be passed to the callbacks, and the iterator
returns <tt class="xref docutils literal"><span class="pre">True</span></tt>. The iterator is infinite unless the <tt class="docutils literal"><span class="pre">limit</span></tt>
argument is specified or someone closes the consumer.</p>
<p><a class="reference internal" href="#carrot.messaging.Consumer.iterconsume" title="carrot.messaging.Consumer.iterconsume"><tt class="xref py py-meth docutils literal"><span class="pre">iterconsume()</span></tt></a> uses transient requests for messages on the
server, while <tt class="xref py py-meth docutils literal"><span class="pre">iterequeue()</span></tt> uses synchronous access. In most
cases you want <a class="reference internal" href="#carrot.messaging.Consumer.iterconsume" title="carrot.messaging.Consumer.iterconsume"><tt class="xref py py-meth docutils literal"><span class="pre">iterconsume()</span></tt></a>, but if your environment does not
support this behaviour you can resort to using <a class="reference internal" href="#carrot.messaging.Consumer.iterqueue" title="carrot.messaging.Consumer.iterqueue"><tt class="xref py py-meth docutils literal"><span class="pre">iterqueue()</span></tt></a>
instead.</p>
<p>Also, <a class="reference internal" href="#carrot.messaging.Consumer.iterconsume" title="carrot.messaging.Consumer.iterconsume"><tt class="xref py py-meth docutils literal"><span class="pre">iterconsume()</span></tt></a> does not return the message
at each step, something which <a class="reference internal" href="#carrot.messaging.Consumer.iterqueue" title="carrot.messaging.Consumer.iterqueue"><tt class="xref py py-meth docutils literal"><span class="pre">iterqueue()</span></tt></a> does.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>limit</strong> &#8211; Maximum number of messages to process.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises StopIteration:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><p class="first last">if limit is set and the message limit has been
reached.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.iterqueue">
<tt class="descname">iterqueue</tt><big>(</big><em>limit=None</em>, <em>infinite=False</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.iterqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>Infinite iterator yielding pending messages, by using
synchronous direct access to the queue (<tt class="docutils literal"><span class="pre">basic_get</span></tt>).</p>
<p><a class="reference internal" href="#carrot.messaging.Consumer.iterqueue" title="carrot.messaging.Consumer.iterqueue"><tt class="xref py py-meth docutils literal"><span class="pre">iterqueue()</span></tt></a> is used where synchronous functionality is more
important than performance. If you can, use <a class="reference internal" href="#carrot.messaging.Consumer.iterconsume" title="carrot.messaging.Consumer.iterconsume"><tt class="xref py py-meth docutils literal"><span class="pre">iterconsume()</span></tt></a>
instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>limit</strong> &#8211; If set, the iterator stops when it has processed
this number of messages in total.</li>
<li><strong>infinite</strong> &#8211; Don&#8217;t raise <tt class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></tt> if there is no
messages waiting, but return <tt class="xref docutils literal"><span class="pre">None</span></tt> instead. If infinite you
obviously shouldn&#8217;t consume the whole iterator at once without
using a <tt class="docutils literal"><span class="pre">limit</span></tt>.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises StopIteration:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><p class="first last">If there is no messages waiting, and the
iterator is not infinite.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.process_next">
<tt class="descname">process_next</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.process_next" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>DEPRECATED</strong> Use <a class="reference internal" href="#carrot.messaging.Consumer.fetch" title="carrot.messaging.Consumer.fetch"><tt class="xref py py-meth docutils literal"><span class="pre">fetch()</span></tt></a> like this instead:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">enable_callbacks</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.qos">
<tt class="descname">qos</tt><big>(</big><em>prefetch_size=0</em>, <em>prefetch_count=0</em>, <em>apply_global=False</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.qos" title="Permalink to this definition">¶</a></dt>
<dd><p>Request specific Quality of Service.</p>
<p>This method requests a specific quality of service.  The QoS
can be specified for the current channel or for all channels
on the connection.  The particular properties and semantics of
a qos method always depend on the content class semantics.
Though the qos method could in principle apply to both peers,
it is currently meaningful only for the server.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>prefetch_size</strong> &#8211; Prefetch window in octets.
The client can request that messages be sent in
advance so that when the client finishes processing a
message, the following message is already held
locally, rather than needing to be sent down the
channel.  Prefetching gives a performance improvement.
This field specifies the prefetch window size in
octets.  The server will send a message in advance if
it is equal to or smaller in size than the available
prefetch size (and also falls into other prefetch
limits). May be set to zero, meaning &#8220;no specific
limit&#8221;, although other prefetch limits may still
apply. The <tt class="docutils literal"><span class="pre">prefetch_size</span></tt> is ignored if the
<a class="reference internal" href="#carrot.messaging.Consumer.no_ack" title="carrot.messaging.Consumer.no_ack"><tt class="xref py py-attr docutils literal"><span class="pre">no_ack</span></tt></a> option is set.</li>
<li><strong>prefetch_count</strong> &#8211; Specifies a prefetch window in terms of whole
messages. This field may be used in combination with
<tt class="docutils literal"><span class="pre">prefetch_size</span></tt>; A message will only be sent
in advance if both prefetch windows (and those at the
channel and connection level) allow it. The prefetch-
count is ignored if the <a class="reference internal" href="#carrot.messaging.Consumer.no_ack" title="carrot.messaging.Consumer.no_ack"><tt class="xref py py-attr docutils literal"><span class="pre">no_ack</span></tt></a> option is set.</li>
<li><strong>apply_global</strong> &#8211; By default the QoS settings apply to the
current channel only. If this is set, they are applied
to the entire connection.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.receive">
<tt class="descname">receive</tt><big>(</big><em>message_data</em>, <em>message</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.receive" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a new message is received by
running <a class="reference internal" href="#carrot.messaging.Consumer.wait" title="carrot.messaging.Consumer.wait"><tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt></a>, <a class="reference internal" href="#carrot.messaging.Consumer.process_next" title="carrot.messaging.Consumer.process_next"><tt class="xref py py-meth docutils literal"><span class="pre">process_next()</span></tt></a> or <a class="reference internal" href="#carrot.messaging.Consumer.iterqueue" title="carrot.messaging.Consumer.iterqueue"><tt class="xref py py-meth docutils literal"><span class="pre">iterqueue()</span></tt></a>.</p>
<p>When a message is received, it passes the message on to the
callbacks listed in the <a class="reference internal" href="#carrot.messaging.Consumer.callbacks" title="carrot.messaging.Consumer.callbacks"><tt class="xref py py-attr docutils literal"><span class="pre">callbacks</span></tt></a> attribute.
You can register callbacks using <a class="reference internal" href="#carrot.messaging.Consumer.register_callback" title="carrot.messaging.Consumer.register_callback"><tt class="xref py py-meth docutils literal"><span class="pre">register_callback()</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>message_data</strong> &#8211; The deserialized message data.</li>
<li><strong>message</strong> &#8211; The <a class="reference internal" href="carrot.backends.base.html#carrot.backends.base.BaseMessage" title="carrot.backends.base.BaseMessage"><tt class="xref py py-class docutils literal"><span class="pre">carrot.backends.base.BaseMessage</span></tt></a> instance.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises NotImplementedError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><p class="first last">If no callbacks has been registered.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.register_callback">
<tt class="descname">register_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.register_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a callback function to be triggered by <a class="reference internal" href="#carrot.messaging.Consumer.receive" title="carrot.messaging.Consumer.receive"><tt class="xref py py-meth docutils literal"><span class="pre">receive()</span></tt></a>.</p>
<p>The <tt class="docutils literal"><span class="pre">callback</span></tt> function must take two arguments:</p>
<blockquote>
<ul>
<li><p class="first">message_data</p>
<blockquote>
<p>The deserialized message data</p>
</blockquote>
</li>
<li><p class="first">message</p>
<blockquote>
<p>The <a class="reference internal" href="carrot.backends.base.html#carrot.backends.base.BaseMessage" title="carrot.backends.base.BaseMessage"><tt class="xref py py-class docutils literal"><span class="pre">carrot.backends.base.BaseMessage</span></tt></a> instance.</p>
</blockquote>
</li>
</ul>
</blockquote>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Consumer.wait">
<tt class="descname">wait</tt><big>(</big><em>limit=None</em><big>)</big><a class="headerlink" href="#carrot.messaging.Consumer.wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Go into consume mode.</p>
<p>Mostly for testing purposes and simple programs, you probably
want <a class="reference internal" href="#carrot.messaging.Consumer.iterconsume" title="carrot.messaging.Consumer.iterconsume"><tt class="xref py py-meth docutils literal"><span class="pre">iterconsume()</span></tt></a> or <a class="reference internal" href="#carrot.messaging.Consumer.iterqueue" title="carrot.messaging.Consumer.iterqueue"><tt class="xref py py-meth docutils literal"><span class="pre">iterqueue()</span></tt></a> instead.</p>
<p>This runs an infinite loop, processing all incoming messages
using <a class="reference internal" href="#carrot.messaging.Consumer.receive" title="carrot.messaging.Consumer.receive"><tt class="xref py py-meth docutils literal"><span class="pre">receive()</span></tt></a> to apply the message to all registered
callbacks.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="carrot.messaging.ConsumerSet">
<em class="property">class </em><tt class="descclassname">carrot.messaging.</tt><tt class="descname">ConsumerSet</tt><big>(</big><em>connection</em>, <em>from_dict=None</em>, <em>consumers=None</em>, <em>callbacks=None</em>, <em>**options</em><big>)</big><a class="headerlink" href="#carrot.messaging.ConsumerSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive messages from multiple consumers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>connection</strong> &#8211; see <a class="reference internal" href="#carrot.messaging.ConsumerSet.connection" title="carrot.messaging.ConsumerSet.connection"><tt class="xref py py-attr docutils literal"><span class="pre">connection</span></tt></a>.</li>
<li><strong>from_dict</strong> &#8211; see <a class="reference internal" href="#carrot.messaging.ConsumerSet.from_dict" title="carrot.messaging.ConsumerSet.from_dict"><tt class="xref py py-attr docutils literal"><span class="pre">from_dict</span></tt></a>.</li>
<li><strong>consumers</strong> &#8211; see <a class="reference internal" href="#carrot.messaging.ConsumerSet.consumers" title="carrot.messaging.ConsumerSet.consumers"><tt class="xref py py-attr docutils literal"><span class="pre">consumers</span></tt></a>.</li>
<li><strong>callbacks</strong> &#8211; see <a class="reference internal" href="#carrot.messaging.ConsumerSet.callbacks" title="carrot.messaging.ConsumerSet.callbacks"><tt class="xref py py-attr docutils literal"><span class="pre">callbacks</span></tt></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="carrot.messaging.ConsumerSet.connection">
<tt class="descname">connection</tt><a class="headerlink" href="#carrot.messaging.ConsumerSet.connection" title="Permalink to this definition">¶</a></dt>
<dd><p>The connection to the broker.
A <a class="reference internal" href="carrot.connection.html#carrot.connection.BrokerConnection" title="carrot.connection.BrokerConnection"><tt class="xref py py-class docutils literal"><span class="pre">carrot.connection.BrokerConnection</span></tt></a> instance.</p>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.ConsumerSet.callbacks">
<tt class="descname">callbacks</tt><a class="headerlink" href="#carrot.messaging.ConsumerSet.callbacks" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of callbacks to be called when a message is received.
See <a class="reference internal" href="#carrot.messaging.Consumer.register_callback" title="carrot.messaging.Consumer.register_callback"><tt class="xref py py-class docutils literal"><span class="pre">Consumer.register_callback</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.ConsumerSet.from_dict">
<tt class="descname">from_dict</tt><a class="headerlink" href="#carrot.messaging.ConsumerSet.from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Add consumers from a dictionary configuration:</p>
<div class="highlight-python"><pre>{
    "webshot": {
                "exchange": "link_exchange",
                "exchange_type": "topic",
                "binding_key": "links.webshot",
                "default_routing_key": "links.webshot",
        },
    "retrieve": {
                "exchange": "link_exchange",
                "exchange_type" = "topic",
                "binding_key": "links.*",
                "default_routing_key": "links.retrieve",
                "auto_delete": True,
                # ...
        },
}</pre>
</div>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.ConsumerSet.consumers">
<tt class="descname">consumers</tt><a class="headerlink" href="#carrot.messaging.ConsumerSet.consumers" title="Permalink to this definition">¶</a></dt>
<dd><p>Add consumers from a list of <a class="reference internal" href="#carrot.messaging.Consumer" title="carrot.messaging.Consumer"><tt class="xref py py-class docutils literal"><span class="pre">Consumer</span></tt></a> instances.</p>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.ConsumerSet.auto_ack">
<tt class="descname">auto_ack</tt><a class="headerlink" href="#carrot.messaging.ConsumerSet.auto_ack" title="Permalink to this definition">¶</a></dt>
<dd><p>Default value for the <a class="reference internal" href="#carrot.messaging.Consumer.auto_ack" title="carrot.messaging.Consumer.auto_ack"><tt class="xref py py-attr docutils literal"><span class="pre">Consumer.auto_ack</span></tt></a> attribute.</p>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.ConsumerSet.add_consumer">
<tt class="descname">add_consumer</tt><big>(</big><em>consumer</em><big>)</big><a class="headerlink" href="#carrot.messaging.ConsumerSet.add_consumer" title="Permalink to this definition">¶</a></dt>
<dd><p>Add another consumer from a <a class="reference internal" href="#carrot.messaging.Consumer" title="carrot.messaging.Consumer"><tt class="xref py py-class docutils literal"><span class="pre">Consumer</span></tt></a> instance.</p>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.ConsumerSet.add_consumer_from_dict">
<tt class="descname">add_consumer_from_dict</tt><big>(</big><em>queue</em>, <em>**options</em><big>)</big><a class="headerlink" href="#carrot.messaging.ConsumerSet.add_consumer_from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Add another consumer from dictionary configuration.</p>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.ConsumerSet.cancel">
<tt class="descname">cancel</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.ConsumerSet.cancel" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancel a running <a class="reference internal" href="#carrot.messaging.ConsumerSet.iterconsume" title="carrot.messaging.ConsumerSet.iterconsume"><tt class="xref py py-meth docutils literal"><span class="pre">iterconsume()</span></tt></a> session.</p>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.ConsumerSet.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.ConsumerSet.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close all consumers.</p>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.ConsumerSet.consume">
<tt class="descname">consume</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.ConsumerSet.consume" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare consumers.</p>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.ConsumerSet.discard_all">
<tt class="descname">discard_all</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.ConsumerSet.discard_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Discard all messages. Does not support filtering.
See <a class="reference internal" href="#carrot.messaging.Consumer.discard_all" title="carrot.messaging.Consumer.discard_all"><tt class="xref py py-meth docutils literal"><span class="pre">Consumer.discard_all()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.ConsumerSet.flow">
<tt class="descname">flow</tt><big>(</big><em>active</em><big>)</big><a class="headerlink" href="#carrot.messaging.ConsumerSet.flow" title="Permalink to this definition">¶</a></dt>
<dd><p>This method asks the peer to pause or restart the flow of
content data.</p>
<p>See <a class="reference internal" href="#carrot.messaging.Consumer.flow" title="carrot.messaging.Consumer.flow"><tt class="xref py py-meth docutils literal"><span class="pre">Consumer.flow()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.ConsumerSet.iterconsume">
<tt class="descname">iterconsume</tt><big>(</big><em>limit=None</em><big>)</big><a class="headerlink" href="#carrot.messaging.ConsumerSet.iterconsume" title="Permalink to this definition">¶</a></dt>
<dd><p>Cycle between all consumers in consume mode.</p>
<p>See <a class="reference internal" href="#carrot.messaging.Consumer.iterconsume" title="carrot.messaging.Consumer.iterconsume"><tt class="xref py py-meth docutils literal"><span class="pre">Consumer.iterconsume()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.ConsumerSet.qos">
<tt class="descname">qos</tt><big>(</big><em>prefetch_size=0</em>, <em>prefetch_count=0</em>, <em>apply_global=False</em><big>)</big><a class="headerlink" href="#carrot.messaging.ConsumerSet.qos" title="Permalink to this definition">¶</a></dt>
<dd><p>Request specific Quality of Service.</p>
<p>See <tt class="xref py py-meth docutils literal"><span class="pre">Consumer.cos()</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.ConsumerSet.receive">
<tt class="descname">receive</tt><big>(</big><em>message_data</em>, <em>message</em><big>)</big><a class="headerlink" href="#carrot.messaging.ConsumerSet.receive" title="Permalink to this definition">¶</a></dt>
<dd><p>What to do when a message is received.
See <a class="reference internal" href="#carrot.messaging.Consumer.receive" title="carrot.messaging.Consumer.receive"><tt class="xref py py-meth docutils literal"><span class="pre">Consumer.receive()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.ConsumerSet.register_callback">
<tt class="descname">register_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#carrot.messaging.ConsumerSet.register_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Register new callback to be called when a message is received.
See <a class="reference internal" href="#carrot.messaging.Consumer.register_callback" title="carrot.messaging.Consumer.register_callback"><tt class="xref py py-meth docutils literal"><span class="pre">Consumer.register_callback()</span></tt></a></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="carrot.messaging.Messaging">
<em class="property">class </em><tt class="descclassname">carrot.messaging.</tt><tt class="descname">Messaging</tt><big>(</big><em>connection</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#carrot.messaging.Messaging" title="Permalink to this definition">¶</a></dt>
<dd><p>A combined message publisher and consumer.</p>
<dl class="method">
<dt id="carrot.messaging.Messaging.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.Messaging.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close any open channels.</p>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Messaging.consumer_cls">
<tt class="descname">consumer_cls</tt><a class="headerlink" href="#carrot.messaging.Messaging.consumer_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#carrot.messaging.Consumer" title="carrot.messaging.Consumer"><tt class="xref py py-class docutils literal"><span class="pre">Consumer</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Messaging.fetch">
<tt class="descname">fetch</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#carrot.messaging.Messaging.fetch" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#carrot.messaging.Consumer.fetch" title="carrot.messaging.Consumer.fetch"><tt class="xref py py-meth docutils literal"><span class="pre">Consumer.fetch()</span></tt></a></p>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Messaging.publisher_cls">
<tt class="descname">publisher_cls</tt><a class="headerlink" href="#carrot.messaging.Messaging.publisher_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#carrot.messaging.Publisher" title="carrot.messaging.Publisher"><tt class="xref py py-class docutils literal"><span class="pre">Publisher</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Messaging.receive">
<tt class="descname">receive</tt><big>(</big><em>message_data</em>, <em>message</em><big>)</big><a class="headerlink" href="#carrot.messaging.Messaging.receive" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#carrot.messaging.Consumer.receive" title="carrot.messaging.Consumer.receive"><tt class="xref py py-meth docutils literal"><span class="pre">Consumer.receive()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Messaging.register_callback">
<tt class="descname">register_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#carrot.messaging.Messaging.register_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#carrot.messaging.Consumer.register_callback" title="carrot.messaging.Consumer.register_callback"><tt class="xref py py-meth docutils literal"><span class="pre">Consumer.register_callback()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Messaging.send">
<tt class="descname">send</tt><big>(</big><em>message_data</em>, <em>delivery_mode=None</em><big>)</big><a class="headerlink" href="#carrot.messaging.Messaging.send" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#carrot.messaging.Publisher.send" title="carrot.messaging.Publisher.send"><tt class="xref py py-meth docutils literal"><span class="pre">Publisher.send()</span></tt></a></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="carrot.messaging.Publisher">
<em class="property">class </em><tt class="descclassname">carrot.messaging.</tt><tt class="descname">Publisher</tt><big>(</big><em>connection</em>, <em>exchange=None</em>, <em>routing_key=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#carrot.messaging.Publisher" title="Permalink to this definition">¶</a></dt>
<dd><p>Message publisher.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>connection</strong> &#8211; see <a class="reference internal" href="#carrot.messaging.Publisher.connection" title="carrot.messaging.Publisher.connection"><tt class="xref py py-attr docutils literal"><span class="pre">connection</span></tt></a>.</li>
<li><strong>exchange</strong> &#8211; see <a class="reference internal" href="#carrot.messaging.Publisher.exchange" title="carrot.messaging.Publisher.exchange"><tt class="xref py py-attr docutils literal"><span class="pre">exchange</span></tt></a>.</li>
<li><strong>routing_key</strong> &#8211; see <a class="reference internal" href="#carrot.messaging.Publisher.routing_key" title="carrot.messaging.Publisher.routing_key"><tt class="xref py py-attr docutils literal"><span class="pre">routing_key</span></tt></a>.</li>
<li><strong>exchange_type</strong> &#8211; see <a class="reference internal" href="#carrot.messaging.Consumer.exchange_type" title="carrot.messaging.Consumer.exchange_type"><tt class="xref py py-attr docutils literal"><span class="pre">Consumer.exchange_type</span></tt></a>.</li>
<li><strong>durable</strong> &#8211; see <a class="reference internal" href="#carrot.messaging.Consumer.durable" title="carrot.messaging.Consumer.durable"><tt class="xref py py-attr docutils literal"><span class="pre">Consumer.durable</span></tt></a>.</li>
<li><strong>auto_delete</strong> &#8211; see <a class="reference internal" href="#carrot.messaging.Consumer.auto_delete" title="carrot.messaging.Consumer.auto_delete"><tt class="xref py py-attr docutils literal"><span class="pre">Consumer.auto_delete</span></tt></a>.</li>
<li><strong>serializer</strong> &#8211; see <a class="reference internal" href="#carrot.messaging.Publisher.serializer" title="carrot.messaging.Publisher.serializer"><tt class="xref py py-attr docutils literal"><span class="pre">serializer</span></tt></a>.</li>
<li><strong>auto_declare</strong> &#8211; See <a class="reference internal" href="#carrot.messaging.Publisher.auto_declare" title="carrot.messaging.Publisher.auto_declare"><tt class="xref py py-attr docutils literal"><span class="pre">auto_declare</span></tt></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="carrot.messaging.Publisher.connection">
<tt class="descname">connection</tt><a class="headerlink" href="#carrot.messaging.Publisher.connection" title="Permalink to this definition">¶</a></dt>
<dd><p>The connection to the broker.
A <a class="reference internal" href="carrot.connection.html#carrot.connection.BrokerConnection" title="carrot.connection.BrokerConnection"><tt class="xref py py-class docutils literal"><span class="pre">carrot.connection.BrokerConnection</span></tt></a> instance.</p>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Publisher.exchange">
<tt class="descname">exchange</tt><a class="headerlink" href="#carrot.messaging.Publisher.exchange" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the exchange we send messages to.</p>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Publisher.routing_key">
<tt class="descname">routing_key</tt><a class="headerlink" href="#carrot.messaging.Publisher.routing_key" title="Permalink to this definition">¶</a></dt>
<dd><p>The default routing key for messages sent using this publisher.
See <a class="reference internal" href="#carrot.messaging.Consumer.routing_key" title="carrot.messaging.Consumer.routing_key"><tt class="xref py py-attr docutils literal"><span class="pre">Consumer.routing_key</span></tt></a> for more information.
You can override the routing key by passing an explicit
<tt class="docutils literal"><span class="pre">routing_key</span></tt> argument to <a class="reference internal" href="#carrot.messaging.Publisher.send" title="carrot.messaging.Publisher.send"><tt class="xref py py-meth docutils literal"><span class="pre">send()</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Publisher.delivery_mode">
<tt class="descname">delivery_mode</tt><a class="headerlink" href="#carrot.messaging.Publisher.delivery_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>The default delivery mode used for messages. The value is an integer.
The following delivery modes are supported by (at least) RabbitMQ:</p>
<blockquote>
<ul>
<li><p class="first">1 or &#8220;transient&#8221;</p>
<blockquote>
<p>The message is transient. Which means it is stored in
memory only, and is lost if the server dies or restarts.</p>
</blockquote>
</li>
<li><dl class="first docutils">
<dt>2 or &#8220;persistent&#8221;</dt>
<dd><p class="first last">The message is persistent. Which means the message is
stored both in-memory, and on disk, and therefore
preserved if the server dies or restarts.</p>
</dd>
</dl>
</li>
</ul>
</blockquote>
<p>The default value is <tt class="docutils literal"><span class="pre">2</span></tt> (persistent).</p>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Publisher.exchange_type">
<tt class="descname">exchange_type</tt><a class="headerlink" href="#carrot.messaging.Publisher.exchange_type" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#carrot.messaging.Consumer.exchange_type" title="carrot.messaging.Consumer.exchange_type"><tt class="xref py py-attr docutils literal"><span class="pre">Consumer.exchange_type</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Publisher.durable">
<tt class="descname">durable</tt><a class="headerlink" href="#carrot.messaging.Publisher.durable" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#carrot.messaging.Consumer.durable" title="carrot.messaging.Consumer.durable"><tt class="xref py py-attr docutils literal"><span class="pre">Consumer.durable</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Publisher.auto_delete">
<tt class="descname">auto_delete</tt><a class="headerlink" href="#carrot.messaging.Publisher.auto_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#carrot.messaging.Consumer.auto_delete" title="carrot.messaging.Consumer.auto_delete"><tt class="xref py py-attr docutils literal"><span class="pre">Consumer.auto_delete</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Publisher.auto_declare">
<tt class="descname">auto_declare</tt><a class="headerlink" href="#carrot.messaging.Publisher.auto_declare" title="Permalink to this definition">¶</a></dt>
<dd><p>If this is <tt class="xref docutils literal"><span class="pre">True</span></tt> and the <a class="reference internal" href="#carrot.messaging.Publisher.exchange" title="carrot.messaging.Publisher.exchange"><tt class="xref py py-attr docutils literal"><span class="pre">exchange</span></tt></a> name is set, the exchange
will be automatically declared at instantiation.
You can manually the declare the exchange by using the <a class="reference internal" href="#carrot.messaging.Publisher.declare" title="carrot.messaging.Publisher.declare"><tt class="xref py py-meth docutils literal"><span class="pre">declare()</span></tt></a>
method.</p>
<p>Auto declare is on by default.</p>
</dd></dl>

<dl class="attribute">
<dt id="carrot.messaging.Publisher.serializer">
<tt class="descname">serializer</tt><a class="headerlink" href="#carrot.messaging.Publisher.serializer" title="Permalink to this definition">¶</a></dt>
<dd><p>A string identifying the default serialization method to use.
Defaults to <tt class="docutils literal"><span class="pre">json</span></tt>. Can be <tt class="docutils literal"><span class="pre">json</span></tt> (default), <tt class="docutils literal"><span class="pre">raw</span></tt>,
<tt class="docutils literal"><span class="pre">pickle</span></tt>, <tt class="docutils literal"><span class="pre">hessian</span></tt>, <tt class="docutils literal"><span class="pre">yaml</span></tt>, or any custom serialization
methods that have been registered with
<tt class="xref py py-mod docutils literal"><span class="pre">carrot.serialization.registry</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Publisher.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.Publisher.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close connection to queue.</p>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Publisher.create_message">
<tt class="descname">create_message</tt><big>(</big><em>message_data</em>, <em>delivery_mode=None</em>, <em>priority=None</em>, <em>content_type=None</em>, <em>content_encoding=None</em>, <em>serializer=None</em><big>)</big><a class="headerlink" href="#carrot.messaging.Publisher.create_message" title="Permalink to this definition">¶</a></dt>
<dd><p>With any data, serialize it and encapsulate it in a AMQP
message with the proper headers set.</p>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Publisher.declare">
<tt class="descname">declare</tt><big>(</big><big>)</big><a class="headerlink" href="#carrot.messaging.Publisher.declare" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare the exchange.</p>
<p>Creates the exchange on the broker.</p>
</dd></dl>

<dl class="method">
<dt id="carrot.messaging.Publisher.send">
<tt class="descname">send</tt><big>(</big><em>message_data</em>, <em>routing_key=None</em>, <em>delivery_mode=None</em>, <em>mandatory=False</em>, <em>immediate=False</em>, <em>priority=0</em>, <em>content_type=None</em>, <em>content_encoding=None</em>, <em>serializer=None</em><big>)</big><a class="headerlink" href="#carrot.messaging.Publisher.send" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a message.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>message_data</strong> &#8211; The message data to send. Can be a list,
dictionary or a string.</li>
<li><strong>routing_key</strong> &#8211; A custom routing key for the message.
If not set, the default routing key set in the <a class="reference internal" href="#carrot.messaging.Publisher.routing_key" title="carrot.messaging.Publisher.routing_key"><tt class="xref py py-attr docutils literal"><span class="pre">routing_key</span></tt></a>
attribute is used.</li>
<li><strong>mandatory</strong> &#8211; If set, the message has mandatory routing.
By default the message is silently dropped by the server if it
can&#8217;t be routed to a queue. However - If the message is mandatory,
an exception will be raised instead.</li>
<li><strong>immediate</strong> &#8211; Request immediate delivery.
If the message cannot be routed to a queue consumer immediately,
an exception will be raised. This is instead of the default
behaviour, where the server will accept and queue the message,
but with no guarantee that the message will ever be consumed.</li>
<li><strong>delivery_mode</strong> &#8211; Override the default <a class="reference internal" href="#carrot.messaging.Publisher.delivery_mode" title="carrot.messaging.Publisher.delivery_mode"><tt class="xref py py-attr docutils literal"><span class="pre">delivery_mode</span></tt></a>.</li>
<li><strong>priority</strong> &#8211; The message priority, <tt class="docutils literal"><span class="pre">0</span></tt> to <tt class="docutils literal"><span class="pre">9</span></tt>.</li>
<li><strong>content_type</strong> &#8211; The messages content_type. If content_type
is set, no serialization occurs as it is assumed this is either
a binary object, or you&#8217;ve done your own serialization.
Leave blank if using built-in serialization as our library
properly sets content_type.</li>
<li><strong>content_encoding</strong> &#8211; The character set in which this object
is encoded. Use &#8220;binary&#8221; if sending in raw binary objects.
Leave blank if using built-in serialization as our library
properly sets content_encoding.</li>
<li><strong>serializer</strong> &#8211; Override the default <a class="reference internal" href="#carrot.messaging.Publisher.serializer" title="carrot.messaging.Publisher.serializer"><tt class="xref py py-attr docutils literal"><span class="pre">serializer</span></tt></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="carrot.connection.html"
                        title="previous chapter">carrot.connection</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="carrot.backends.html"
                        title="next chapter">carrot.backends</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/reference/carrot.messaging.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="carrot.backends.html" title="carrot.backends"
             >next</a> |</li>
        <li class="right" >
          <a href="carrot.connection.html" title="carrot.connection"
             >previous</a> |</li>
        <li><a href="../index.html">Carrot v0.10.5 documentation</a> &raquo;</li>
          <li><a href="index.html" >API Reference</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2009, Ask Solem.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0b2.
    </div>
  </body>
</html>