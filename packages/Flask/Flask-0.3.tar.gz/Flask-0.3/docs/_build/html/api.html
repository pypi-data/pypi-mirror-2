
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>API &mdash; Flask v0.3dev documentation</title>
    <link rel="stylesheet" href="_static/flasky.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.3dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Flask v0.3dev documentation" href="index.html" />
    <link rel="next" title="Design Decisions in Flask" href="design.html" />
    <link rel="prev" title="Becoming Big" href="becomingbig.html" />
   
  
  <link rel="apple-touch-icon" href="_static/touch-icon.png" />
  
  <link media="only screen and (max-device-width: 480px)" href="_static/small_flask.css" type= "text/css" rel="stylesheet" />

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="design.html" title="Design Decisions in Flask"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="becomingbig.html" title="Becoming Big"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Flask v0.3dev documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="api">
<span id="id1"></span><h1>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-flask"></span><p>This part of the documentation covers all the interfaces of Flask.  For
parts where Flask depends on external libraries, we document the most
important right here and provide links to the canonical documentation.</p>
<div class="section" id="application-object">
<h2>Application Object<a class="headerlink" href="#application-object" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="flask.Flask">
<em class="property">class </em><tt class="descclassname">flask.</tt><tt class="descname">Flask</tt><big>(</big><em>import_name</em><big>)</big><a class="headerlink" href="#flask.Flask" title="Permalink to this definition">¶</a></dt>
<dd><p>The flask object implements a WSGI application and acts as the central
object.  It is passed the name of the module or package of the
application.  Once it is created it will act as a central registry for
the view functions, the URL rules, template configuration and much more.</p>
<p>The name of the package is used to resolve resources from inside the
package or the folder the module is contained in depending on if the
package parameter resolves to an actual python package (a folder with
an <cite>__init__.py</cite> file inside) or a standard module (just a <cite>.py</cite> file).</p>
<p>For more information about resource loading, see <a class="reference internal" href="#flask.Flask.open_resource" title="flask.Flask.open_resource"><tt class="xref py py-func docutils literal"><span class="pre">open_resource()</span></tt></a>.</p>
<p>Usually you create a <a class="reference internal" href="#flask.Flask" title="flask.Flask"><tt class="xref py py-class docutils literal"><span class="pre">Flask</span></tt></a> instance in your main module or
in the <cite>__init__.py</cite> file of your package like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="flask.Flask.add_url_rule">
<tt class="descname">add_url_rule</tt><big>(</big><em>rule</em>, <em>endpoint=None</em>, <em>view_func=None</em>, <em>**options</em><big>)</big><a class="headerlink" href="#flask.Flask.add_url_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Connects a URL rule.  Works exactly like the <a class="reference internal" href="#flask.Flask.route" title="flask.Flask.route"><tt class="xref py py-meth docutils literal"><span class="pre">route()</span></tt></a>
decorator.  If a view_func is provided it will be registered with the
endpoint.</p>
<p>Basically this example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Is equivalent to the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">pass</span>
<span class="n">app</span><span class="o">.</span><span class="n">add_url_rule</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="s">&#39;index&#39;</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>
</div>
<p>If the view_func is not provided you will need to connect the endpoint
to a view function like so:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">view_functions</span><span class="p">[</span><span class="s">&#39;index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
</pre></div>
</div>
<p class="versionchanged">
<span class="versionmodified">Changed in version 0.2: </span><cite>view_func</cite> parameter added.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rule</strong> &#8211; the URL rule as string</li>
<li><strong>endpoint</strong> &#8211; the endpoint for the registered URL rule.  Flask
itself assumes the name of the view function as
endpoint</li>
<li><strong>view_func</strong> &#8211; the function to call when serving a request to the
provided endpoint</li>
<li><strong>options</strong> &#8211; the options to be forwarded to the underlying
<a class="reference external" href="http://werkzeug.pocoo.org/documentation/dev/routing.html#werkzeug.routing.Rule" title="(in Werkzeug v1.0)"><tt class="xref py py-class docutils literal"><span class="pre">Rule</span></tt></a> object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.after_request">
<tt class="descname">after_request</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Flask.after_request" title="Permalink to this definition">¶</a></dt>
<dd>Register a function to be run after each request.</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.after_request_funcs">
<tt class="descname">after_request_funcs</tt><a class="headerlink" href="#flask.Flask.after_request_funcs" title="Permalink to this definition">¶</a></dt>
<dd>a dictionary with lists of functions that should be called after
each request.  The key of the dictionary is the name of the module
this function is active for, <cite>None</cite> for all requests.  This can for
example be used to open database connections or getting hold of the
currently logged in user.  To register a function here, use the
<a class="reference internal" href="#flask.Flask.before_request" title="flask.Flask.before_request"><tt class="xref py py-meth docutils literal"><span class="pre">before_request()</span></tt></a> decorator.</dd></dl>

<dl class="method">
<dt id="flask.Flask.before_request">
<tt class="descname">before_request</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Flask.before_request" title="Permalink to this definition">¶</a></dt>
<dd>Registers a function to run before each request.</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.before_request_funcs">
<tt class="descname">before_request_funcs</tt><a class="headerlink" href="#flask.Flask.before_request_funcs" title="Permalink to this definition">¶</a></dt>
<dd>a dictionary with lists of functions that should be called at the
beginning of the request.  The key of the dictionary is the name of
the module this function is active for, <cite>None</cite> for all requests.
This can for example be used to open database connections or
getting hold of the currently logged in user.  To register a
function here, use the <a class="reference internal" href="#flask.Flask.before_request" title="flask.Flask.before_request"><tt class="xref py py-meth docutils literal"><span class="pre">before_request()</span></tt></a> decorator.</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.config">
<tt class="descname">config</tt><a class="headerlink" href="#flask.Flask.config" title="Permalink to this definition">¶</a></dt>
<dd>the configuration dictionary as <a class="reference internal" href="#flask.Config" title="flask.Config"><tt class="xref py py-class docutils literal"><span class="pre">Config</span></tt></a>.  This behaves
exactly like a regular dictionary but supports additional methods
to load a config from files.</dd></dl>

<dl class="method">
<dt id="flask.Flask.context_processor">
<tt class="descname">context_processor</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Flask.context_processor" title="Permalink to this definition">¶</a></dt>
<dd>Registers a template context processor function.</dd></dl>

<dl class="method">
<dt id="flask.Flask.create_jinja_loader">
<tt class="descname">create_jinja_loader</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.Flask.create_jinja_loader" title="Permalink to this definition">¶</a></dt>
<dd>Creates the Jinja loader.  By default just a package loader for
the configured package is returned that looks up templates in the
<cite>templates</cite> folder.  To add other loaders it&#8217;s possible to
override this method.</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.debug">
<tt class="descname">debug</tt><a class="headerlink" href="#flask.Flask.debug" title="Permalink to this definition">¶</a></dt>
<dd><p>the debug flag.  Set this to <cite>True</cite> to enable debugging of the
application.  In debug mode the debugger will kick in when an unhandled
exception ocurrs and the integrated server will automatically reload
the application if changes in the code are detected.</p>
<p>This attribute can also be configured from the config with the <cite>DEBUG</cite>
configuration key.  Defaults to <cite>False</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.debug_log_format">
<tt class="descname">debug_log_format</tt><a class="headerlink" href="#flask.Flask.debug_log_format" title="Permalink to this definition">¶</a></dt>
<dd><p>the logging format used for the debug logger.  This is only used when
the application is in debug mode, otherwise the attached logging
handler does the formatting.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.3.</span></p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.default_config">
<tt class="descname">default_config</tt><a class="headerlink" href="#flask.Flask.default_config" title="Permalink to this definition">¶</a></dt>
<dd>default configuration parameters</dd></dl>

<dl class="method">
<dt id="flask.Flask.dispatch_request">
<tt class="descname">dispatch_request</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.Flask.dispatch_request" title="Permalink to this definition">¶</a></dt>
<dd>Does the request dispatching.  Matches the URL and returns the
return value of the view or error handler.  This does not have to
be a response object.  In order to convert the return value to a
proper response object, call <a class="reference internal" href="#flask.Flask.make_response" title="flask.Flask.make_response"><tt class="xref py py-func docutils literal"><span class="pre">make_response()</span></tt></a>.</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.error_handlers">
<tt class="descname">error_handlers</tt><a class="headerlink" href="#flask.Flask.error_handlers" title="Permalink to this definition">¶</a></dt>
<dd>a dictionary of all registered error handlers.  The key is
be the error code as integer, the value the function that
should handle that error.
To register a error handler, use the <a class="reference internal" href="#flask.Flask.errorhandler" title="flask.Flask.errorhandler"><tt class="xref py py-meth docutils literal"><span class="pre">errorhandler()</span></tt></a>
decorator.</dd></dl>

<dl class="method">
<dt id="flask.Flask.errorhandler">
<tt class="descname">errorhandler</tt><big>(</big><em>code</em><big>)</big><a class="headerlink" href="#flask.Flask.errorhandler" title="Permalink to this definition">¶</a></dt>
<dd><p>A decorator that is used to register a function give a given
error code.  Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.errorhandler</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">page_not_found</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">&#39;This page does not exist&#39;</span><span class="p">,</span> <span class="mi">404</span>
</pre></div>
</div>
<p>You can also register a function as error handler without using
the <a class="reference internal" href="#flask.Flask.errorhandler" title="flask.Flask.errorhandler"><tt class="xref py py-meth docutils literal"><span class="pre">errorhandler()</span></tt></a> decorator.  The following example is
equivalent to the one above:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">page_not_found</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">&#39;This page does not exist&#39;</span><span class="p">,</span> <span class="mi">404</span>
<span class="n">app</span><span class="o">.</span><span class="n">error_handlers</span><span class="p">[</span><span class="mi">404</span><span class="p">]</span> <span class="o">=</span> <span class="n">page_not_found</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>code</strong> &#8211; the code as integer for the handler</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.handle_exception">
<tt class="descname">handle_exception</tt><big>(</big><em>e</em><big>)</big><a class="headerlink" href="#flask.Flask.handle_exception" title="Permalink to this definition">¶</a></dt>
<dd>Default exception handling that kicks in when an exception
occours that is not catched.  In debug mode the exception will
be re-raised immediately, otherwise it is logged an the handler
for an 500 internal server error is used.  If no such handler
exists, a default 500 internal server error message is displayed.</dd></dl>

<dl class="method">
<dt id="flask.Flask.handle_http_exception">
<tt class="descname">handle_http_exception</tt><big>(</big><em>e</em><big>)</big><a class="headerlink" href="#flask.Flask.handle_http_exception" title="Permalink to this definition">¶</a></dt>
<dd>Handles an HTTP exception.  By default this will invoke the
registered error handlers and fall back to returning the
exception as response.</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.jinja_env">
<tt class="descname">jinja_env</tt><a class="headerlink" href="#flask.Flask.jinja_env" title="Permalink to this definition">¶</a></dt>
<dd>the Jinja2 environment.  It is created from the
<a class="reference internal" href="#flask.Flask.jinja_options" title="flask.Flask.jinja_options"><tt class="xref py py-attr docutils literal"><span class="pre">jinja_options</span></tt></a> and the loader that is returned
by the <a class="reference internal" href="#flask.Flask.create_jinja_loader" title="flask.Flask.create_jinja_loader"><tt class="xref py py-meth docutils literal"><span class="pre">create_jinja_loader()</span></tt></a> function.</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.jinja_options">
<tt class="descname">jinja_options</tt><a class="headerlink" href="#flask.Flask.jinja_options" title="Permalink to this definition">¶</a></dt>
<dd>options that are passed directly to the Jinja2 environment</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.logger">
<tt class="descname">logger</tt><a class="headerlink" href="#flask.Flask.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>A <tt class="xref py py-class docutils literal"><span class="pre">logging.Logger</span></tt> object for this application.  The
default configuration is to log to stderr if the application is
in debug mode.  This logger can be used to (surprise) log messages.
Here some examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&#39;A value for debugging&#39;</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;A warning ocurred (</span><span class="si">%d</span><span class="s"> apples)&#39;</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&#39;An error occoured&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">New in version 0.3.</span></p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.make_response">
<tt class="descname">make_response</tt><big>(</big><em>rv</em><big>)</big><a class="headerlink" href="#flask.Flask.make_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts the return value from a view function to a real
response object that is an instance of <a class="reference internal" href="#flask.Flask.response_class" title="flask.Flask.response_class"><tt class="xref py py-attr docutils literal"><span class="pre">response_class</span></tt></a>.</p>
<p>The following types are allowed for <cite>rv</cite>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="65%" />
</colgroup>
<tbody valign="top">
<tr><td><a class="reference internal" href="#flask.Flask.response_class" title="flask.Flask.response_class"><tt class="xref py py-attr docutils literal"><span class="pre">response_class</span></tt></a></td>
<td>the object is returned unchanged</td>
</tr>
<tr><td><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></td>
<td>a response object is created with the
string as body</td>
</tr>
<tr><td><tt class="xref py py-class docutils literal"><span class="pre">unicode</span></tt></td>
<td>a response object is created with the
string encoded to utf-8 as body</td>
</tr>
<tr><td><tt class="xref py py-class docutils literal"><span class="pre">tuple</span></tt></td>
<td>the response object is created with the
contents of the tuple as arguments</td>
</tr>
<tr><td>a WSGI function</td>
<td>the function is called as WSGI application
and buffered as response object</td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rv</strong> &#8211; the return value from the view function</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.open_resource">
<tt class="descname">open_resource</tt><big>(</big><em>resource</em><big>)</big><a class="headerlink" href="#flask.Flask.open_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>Opens a resource from the application&#8217;s resource folder.  To see
how this works, consider the following folder structure:</p>
<div class="highlight-python"><pre>/myapplication.py
/schemal.sql
/static
    /style.css
/template
    /layout.html
    /index.html</pre>
</div>
<p>If you want to open the <cite>schema.sql</cite> file you would do the
following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">open_resource</span><span class="p">(</span><span class="s">&#39;schema.sql&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">contents</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="n">do_something_with</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>resource</strong> &#8211; the name of the resource.  To access resources within
subfolders use forward slashes as separator.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.open_session">
<tt class="descname">open_session</tt><big>(</big><em>request</em><big>)</big><a class="headerlink" href="#flask.Flask.open_session" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates or opens a new session.  Default implementation stores all
session data in a signed cookie.  This requires that the
<a class="reference internal" href="#flask.Flask.secret_key" title="flask.Flask.secret_key"><tt class="xref py py-attr docutils literal"><span class="pre">secret_key</span></tt></a> is set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>request</strong> &#8211; an instance of <a class="reference internal" href="#flask.Flask.request_class" title="flask.Flask.request_class"><tt class="xref py py-attr docutils literal"><span class="pre">request_class</span></tt></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.permanent_session_lifetime">
<tt class="descname">permanent_session_lifetime</tt><a class="headerlink" href="#flask.Flask.permanent_session_lifetime" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference external" href="http://docs.python.org/dev/library/datetime.html#datetime.timedelta" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">timedelta</span></tt></a> which is used to set the expiration
date of a permanent session.  The default is 31 days which makes a
permanent session survive for roughly one month.</p>
<p>This attribute can also be configured from the config with the
<cite>PERMANENT_SESSION_LIFETIME</cite> configuration key.  Defaults to
<tt class="docutils literal"><span class="pre">timedelta(days=31)</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.preprocess_request">
<tt class="descname">preprocess_request</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.Flask.preprocess_request" title="Permalink to this definition">¶</a></dt>
<dd>Called before the actual request dispatching and will
call every as <a class="reference internal" href="#flask.Flask.before_request" title="flask.Flask.before_request"><tt class="xref py py-meth docutils literal"><span class="pre">before_request()</span></tt></a> decorated function.
If any of these function returns a value it&#8217;s handled as
if it was the return value from the view and further
request handling is stopped.</dd></dl>

<dl class="method">
<dt id="flask.Flask.process_response">
<tt class="descname">process_response</tt><big>(</big><em>response</em><big>)</big><a class="headerlink" href="#flask.Flask.process_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Can be overridden in order to modify the response object
before it&#8217;s sent to the WSGI server.  By default this will
call all the <a class="reference internal" href="#flask.Flask.after_request" title="flask.Flask.after_request"><tt class="xref py py-meth docutils literal"><span class="pre">after_request()</span></tt></a> decorated functions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>response</strong> &#8211; a <a class="reference internal" href="#flask.Flask.response_class" title="flask.Flask.response_class"><tt class="xref py py-attr docutils literal"><span class="pre">response_class</span></tt></a> object.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a new response object or the same, has to be an
instance of <a class="reference internal" href="#flask.Flask.response_class" title="flask.Flask.response_class"><tt class="xref py py-attr docutils literal"><span class="pre">response_class</span></tt></a>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.register_module">
<tt class="descname">register_module</tt><big>(</big><em>module</em>, <em>**options</em><big>)</big><a class="headerlink" href="#flask.Flask.register_module" title="Permalink to this definition">¶</a></dt>
<dd>Registers a module with this application.  The keyword argument
of this function are the same as the ones for the constructor of the
<a class="reference internal" href="#flask.Module" title="flask.Module"><tt class="xref py py-class docutils literal"><span class="pre">Module</span></tt></a> class and will override the values of the module if
provided.</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.request_class">
<tt class="descname">request_class</tt><a class="headerlink" href="#flask.Flask.request_class" title="Permalink to this definition">¶</a></dt>
<dd>the class that is used for request objects.  See <a class="reference internal" href="#flask.Request" title="flask.Request"><tt class="xref py py-class docutils literal"><span class="pre">Request</span></tt></a>
for more information.</dd></dl>

<dl class="method">
<dt id="flask.Flask.request_context">
<tt class="descname">request_context</tt><big>(</big><em>environ</em><big>)</big><a class="headerlink" href="#flask.Flask.request_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a request context from the given environment and binds
it to the current context.  This must be used in combination with
the <cite>with</cite> statement because the request is only bound to the
current context for the duration of the <cite>with</cite> block.</p>
<p>Example usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">request_context</span><span class="p">(</span><span class="n">environ</span><span class="p">):</span>
    <span class="n">do_something_with</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
</pre></div>
</div>
<p>The object returned can also be used without the <cite>with</cite> statement
which is useful for working in the shell.  The example above is
doing exactly the same as this code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ctx</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">request_context</span><span class="p">(</span><span class="n">environ</span><span class="p">)</span>
<span class="n">ctx</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">do_something_with</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">ctx</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</pre></div>
</div>
<p>The big advantage of this approach is that you can use it without
the try/finally statement in a shell for interactive testing:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">test_request_context</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span><span class="o">.</span><span class="n">bind</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">request</span><span class="o">.</span><span class="n">path</span>
<span class="go">u&#39;/&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span><span class="o">.</span><span class="n">unbind</span><span class="p">()</span>
</pre></div>
</div>
<p class="versionchanged">
<span class="versionmodified">Changed in version 0.3: </span>Added support for non-with statement usage and <cite>with</cite> statement
is now passed the ctx object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>environ</strong> &#8211; a WSGI environment</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.response_class">
<tt class="descname">response_class</tt><a class="headerlink" href="#flask.Flask.response_class" title="Permalink to this definition">¶</a></dt>
<dd>the class that is used for response objects.  See
<a class="reference internal" href="#flask.Response" title="flask.Response"><tt class="xref py py-class docutils literal"><span class="pre">Response</span></tt></a> for more information.</dd></dl>

<dl class="method">
<dt id="flask.Flask.route">
<tt class="descname">route</tt><big>(</big><em>rule</em>, <em>**options</em><big>)</big><a class="headerlink" href="#flask.Flask.route" title="Permalink to this definition">¶</a></dt>
<dd><p>A decorator that is used to register a view function for a
given URL rule.  Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">&#39;Hello World&#39;</span>
</pre></div>
</div>
<p>Variables parts in the route can be specified with angular
brackets (<tt class="docutils literal"><span class="pre">/user/&lt;username&gt;</span></tt>).  By default a variable part
in the URL accepts any string without a slash however a different
converter can be specified as well by using <tt class="docutils literal"><span class="pre">&lt;converter:name&gt;</span></tt>.</p>
<p>Variable parts are passed to the view function as keyword
arguments.</p>
<p>The following converters are possible:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr><td><cite>int</cite></td>
<td>accepts integers</td>
</tr>
<tr><td><cite>float</cite></td>
<td>like <cite>int</cite> but for floating point values</td>
</tr>
<tr><td><cite>path</cite></td>
<td>like the default but also accepts slashes</td>
</tr>
</tbody>
</table>
<p>Here some examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&lt;username&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show_user</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/post/&lt;int:post_id&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show_post</span><span class="p">(</span><span class="n">post_id</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>An important detail to keep in mind is how Flask deals with trailing
slashes.  The idea is to keep each URL unique so the following rules
apply:</p>
<ol class="arabic simple">
<li>If a rule ends with a slash and is requested without a slash
by the user, the user is automatically redirected to the same
page with a trailing slash attached.</li>
<li>If a rule does not end with a trailing slash and the user request
the page with a trailing slash, a 404 not found is raised.</li>
</ol>
<p>This is consistent with how web servers deal with static files.  This
also makes it possible to use relative link targets safely.</p>
<p>The <a class="reference internal" href="#flask.Flask.route" title="flask.Flask.route"><tt class="xref py py-meth docutils literal"><span class="pre">route()</span></tt></a> decorator accepts a couple of other arguments
as well:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rule</strong> &#8211; the URL rule as string</li>
<li><strong>methods</strong> &#8211; a list of methods this rule should be limited
to (<tt class="docutils literal"><span class="pre">GET</span></tt>, <tt class="docutils literal"><span class="pre">POST</span></tt> etc.).  By default a rule
just listens for <tt class="docutils literal"><span class="pre">GET</span></tt> (and implicitly <tt class="docutils literal"><span class="pre">HEAD</span></tt>).</li>
<li><strong>subdomain</strong> &#8211; specifies the rule for the subdoain in case
subdomain matching is in use.</li>
<li><strong>strict_slashes</strong> &#8211; can be used to disable the strict slashes
setting for this rule.  See above.</li>
<li><strong>options</strong> &#8211; other options to be forwarded to the underlying
<a class="reference external" href="http://werkzeug.pocoo.org/documentation/dev/routing.html#werkzeug.routing.Rule" title="(in Werkzeug v1.0)"><tt class="xref py py-class docutils literal"><span class="pre">Rule</span></tt></a> object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.run">
<tt class="descname">run</tt><big>(</big><em>host='127.0.0.1'</em>, <em>port=5000</em>, <em>**options</em><big>)</big><a class="headerlink" href="#flask.Flask.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the application on a local development server.  If the
<a class="reference internal" href="#flask.Flask.debug" title="flask.Flask.debug"><tt class="xref py py-attr docutils literal"><span class="pre">debug</span></tt></a> flag is set the server will automatically reload
for code changes and show a debugger in case an exception happened.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>host</strong> &#8211; the hostname to listen on.  set this to <tt class="docutils literal"><span class="pre">'0.0.0.0'</span></tt>
to have the server available externally as well.</li>
<li><strong>port</strong> &#8211; the port of the webserver</li>
<li><strong>options</strong> &#8211; the options to be forwarded to the underlying
Werkzeug server.  See <a class="reference external" href="http://werkzeug.pocoo.org/documentation/dev/serving.html#werkzeug.run_simple" title="(in Werkzeug v1.0)"><tt class="xref py py-func docutils literal"><span class="pre">werkzeug.run_simple()</span></tt></a>
for more information.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.save_session">
<tt class="descname">save_session</tt><big>(</big><em>session</em>, <em>response</em><big>)</big><a class="headerlink" href="#flask.Flask.save_session" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves the session if it needs updates.  For the default
implementation, check <a class="reference internal" href="#flask.Flask.open_session" title="flask.Flask.open_session"><tt class="xref py py-meth docutils literal"><span class="pre">open_session()</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>session</strong> &#8211; the session to be saved (a
<a class="reference external" href="http://werkzeug.pocoo.org/documentation/dev/contrib/securecookie.html#werkzeug.contrib.securecookie.SecureCookie" title="(in Werkzeug v1.0)"><tt class="xref py py-class docutils literal"><span class="pre">SecureCookie</span></tt></a>
object)</li>
<li><strong>response</strong> &#8211; an instance of <a class="reference internal" href="#flask.Flask.response_class" title="flask.Flask.response_class"><tt class="xref py py-attr docutils literal"><span class="pre">response_class</span></tt></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.secret_key">
<tt class="descname">secret_key</tt><a class="headerlink" href="#flask.Flask.secret_key" title="Permalink to this definition">¶</a></dt>
<dd><p>if a secret key is set, cryptographic components can use this to
sign cookies and other things.  Set this to a complex random value
when you want to use the secure cookie for instance.</p>
<p>This attribute can also be configured from the config with the
<cite>SECRET_KEY</cite> configuration key.  Defaults to <cite>None</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.session_cookie_name">
<tt class="descname">session_cookie_name</tt><a class="headerlink" href="#flask.Flask.session_cookie_name" title="Permalink to this definition">¶</a></dt>
<dd><p>The secure cookie uses this for the name of the session cookie</p>
<p>This attribute can also be configured from the config with the
<cite>SESSION_COOKIE_NAME</cite> configuration key.  Defaults to <tt class="docutils literal"><span class="pre">'session'</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.static_path">
<tt class="descname">static_path</tt><a class="headerlink" href="#flask.Flask.static_path" title="Permalink to this definition">¶</a></dt>
<dd>path for the static files.  If you don&#8217;t want to use static files
you can set this value to <cite>None</cite> in which case no URL rule is added
and the development server will no longer serve any static files.</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.template_context_processors">
<tt class="descname">template_context_processors</tt><a class="headerlink" href="#flask.Flask.template_context_processors" title="Permalink to this definition">¶</a></dt>
<dd>a dictionary with list of functions that are called without argument
to populate the template context.  They key of the dictionary is the
name of the module this function is active for, <cite>None</cite> for all
requests.  Each returns a dictionary that the template context is
updated with.  To register a function here, use the
<a class="reference internal" href="#flask.Flask.context_processor" title="flask.Flask.context_processor"><tt class="xref py py-meth docutils literal"><span class="pre">context_processor()</span></tt></a> decorator.</dd></dl>

<dl class="method">
<dt id="flask.Flask.template_filter">
<tt class="descname">template_filter</tt><big>(</big><em>name=None</em><big>)</big><a class="headerlink" href="#flask.Flask.template_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>A decorator that is used to register custom template filter.
You can specify a name for the filter, otherwise the function
name will be used. Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.template_filter</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; the optional name of the filter, otherwise the
function name will be used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Flask.test_client">
<tt class="descname">test_client</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.Flask.test_client" title="Permalink to this definition">¶</a></dt>
<dd>Creates a test client for this application.  For information
about unit testing head over to <a class="reference internal" href="testing.html#testing"><em>Testing Flask Applications</em></a>.</dd></dl>

<dl class="method">
<dt id="flask.Flask.test_request_context">
<tt class="descname">test_request_context</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.Flask.test_request_context" title="Permalink to this definition">¶</a></dt>
<dd>Creates a WSGI environment from the given values (see
<a class="reference external" href="http://werkzeug.pocoo.org/documentation/dev/test.html#werkzeug.create_environ" title="(in Werkzeug v1.0)"><tt class="xref py py-func docutils literal"><span class="pre">werkzeug.create_environ()</span></tt></a> for more information, this
function accepts the same arguments).</dd></dl>

<dl class="method">
<dt id="flask.Flask.update_template_context">
<tt class="descname">update_template_context</tt><big>(</big><em>context</em><big>)</big><a class="headerlink" href="#flask.Flask.update_template_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the template context with some commonly used variables.
This injects request, session and g into the template context.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>context</strong> &#8211; the context as a dictionary that is updated in place
to add extra variables.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.url_map">
<tt class="descname">url_map</tt><a class="headerlink" href="#flask.Flask.url_map" title="Permalink to this definition">¶</a></dt>
<dd><p>the <a class="reference external" href="http://werkzeug.pocoo.org/documentation/dev/routing.html#werkzeug.routing.Map" title="(in Werkzeug v1.0)"><tt class="xref py py-class docutils literal"><span class="pre">Map</span></tt></a> for this instance.  You can use
this to change the routing converters after the class was created
but before any routes are connected.  Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">werkzeug</span> <span class="kn">import</span> <span class="n">BaseConverter</span>

<span class="k">class</span> <span class="nc">ListConverter</span><span class="p">(</span><span class="n">BaseConverter</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">to_python</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_url</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">BaseConverter</span><span class="o">.</span><span class="n">to_url</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">url_map</span><span class="o">.</span><span class="n">converters</span><span class="p">[</span><span class="s">&#39;list&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ListConverter</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.use_x_sendfile">
<tt class="descname">use_x_sendfile</tt><a class="headerlink" href="#flask.Flask.use_x_sendfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable this if you want to use the X-Sendfile feature.  Keep in
mind that the server has to support this.  This only affects files
sent with the <a class="reference internal" href="#flask.send_file" title="flask.send_file"><tt class="xref py py-func docutils literal"><span class="pre">send_file()</span></tt></a> method.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.2.</span></p>
<p>This attribute can also be configured from the config with the
<cite>USE_X_SENDFILE</cite> configuration key.  Defaults to <cite>False</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Flask.view_functions">
<tt class="descname">view_functions</tt><a class="headerlink" href="#flask.Flask.view_functions" title="Permalink to this definition">¶</a></dt>
<dd>a dictionary of all view functions registered.  The keys will
be function names which are also used to generate URLs and
the values are the function objects themselves.
to register a view function, use the <a class="reference internal" href="#flask.Flask.route" title="flask.Flask.route"><tt class="xref py py-meth docutils literal"><span class="pre">route()</span></tt></a> decorator.</dd></dl>

<dl class="method">
<dt id="flask.Flask.wsgi_app">
<tt class="descname">wsgi_app</tt><big>(</big><em>environ</em>, <em>start_response</em><big>)</big><a class="headerlink" href="#flask.Flask.wsgi_app" title="Permalink to this definition">¶</a></dt>
<dd><p>The actual WSGI application.  This is not implemented in
<cite>__call__</cite> so that middlewares can be applied without losing a
reference to the class.  So instead of doing this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span> <span class="o">=</span> <span class="n">MyMiddleware</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
</pre></div>
</div>
<p>It&#8217;s a better idea to do this instead:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">wsgi_app</span> <span class="o">=</span> <span class="n">MyMiddleware</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">wsgi_app</span><span class="p">)</span>
</pre></div>
</div>
<p>Then you still have the original application object around and
can continue to call methods on it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>environ</strong> &#8211; a WSGI environment</li>
<li><strong>start_response</strong> &#8211; a callable accepting a status code,
a list of headers and an optional
exception context to start the response</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-objects">
<h2>Module Objects<a class="headerlink" href="#module-objects" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="flask.Module">
<em class="property">class </em><tt class="descclassname">flask.</tt><tt class="descname">Module</tt><big>(</big><em>import_name</em>, <em>name=None</em>, <em>url_prefix=None</em><big>)</big><a class="headerlink" href="#flask.Module" title="Permalink to this definition">¶</a></dt>
<dd><p>Container object that enables pluggable applications.  A module can
be used to organize larger applications.  They represent blueprints that,
in combination with a <a class="reference internal" href="#flask.Flask" title="flask.Flask"><tt class="xref py py-class docutils literal"><span class="pre">Flask</span></tt></a> object are used to create a large
application.</p>
<p>A module is like an application bound to an <cite>import_name</cite>.  Multiple
modules can share the same import names, but in that case a <cite>name</cite> has
to be provided to keep them apart.  If different import names are used,
the rightmost part of the import name is used as name.</p>
<p>Here an example structure for a larger appliation:</p>
<div class="highlight-python"><pre>/myapplication
    /__init__.py
    /views
        /__init__.py
        /admin.py
        /frontend.py</pre>
</div>
<p>The <cite>myapplication/__init__.py</cite> can look like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="kn">from</span> <span class="nn">myapplication.views.admin</span> <span class="kn">import</span> <span class="n">admin</span>
<span class="kn">from</span> <span class="nn">myapplication.views.frontend</span> <span class="kn">import</span> <span class="n">frontend</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">register_module</span><span class="p">(</span><span class="n">admin</span><span class="p">,</span> <span class="n">url_prefix</span><span class="o">=</span><span class="s">&#39;/admin&#39;</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">register_module</span><span class="p">(</span><span class="n">frontend</span><span class="p">)</span>
</pre></div>
</div>
<p>And here an example view module (<cite>myapplication/views/admin.py</cite>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Module</span>

<span class="n">admin</span> <span class="o">=</span> <span class="n">Module</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="nd">@admin.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="nd">@admin.route</span><span class="p">(</span><span class="s">&#39;/login&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>For a gentle introduction into modules, checkout the
<a class="reference internal" href="patterns/packages.html#working-with-modules"><em>Working with Modules</em></a> section.</p>
<dl class="method">
<dt id="flask.Module.add_url_rule">
<tt class="descname">add_url_rule</tt><big>(</big><em>rule</em>, <em>endpoint</em>, <em>view_func=None</em>, <em>**options</em><big>)</big><a class="headerlink" href="#flask.Module.add_url_rule" title="Permalink to this definition">¶</a></dt>
<dd>Like <a class="reference internal" href="#flask.Flask.add_url_rule" title="flask.Flask.add_url_rule"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.add_url_rule()</span></tt></a> but for a module.  The endpoint for
the <a class="reference internal" href="#flask.url_for" title="flask.url_for"><tt class="xref py py-func docutils literal"><span class="pre">url_for()</span></tt></a> function is prefixed with the name of the module.</dd></dl>

<dl class="method">
<dt id="flask.Module.after_app_request">
<tt class="descname">after_app_request</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Module.after_app_request" title="Permalink to this definition">¶</a></dt>
<dd>Like <a class="reference internal" href="#flask.Flask.after_request" title="flask.Flask.after_request"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.after_request()</span></tt></a> but for a module.  Such a function
is executed after each request, even if outside of the module.</dd></dl>

<dl class="method">
<dt id="flask.Module.after_request">
<tt class="descname">after_request</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Module.after_request" title="Permalink to this definition">¶</a></dt>
<dd>Like <a class="reference internal" href="#flask.Flask.after_request" title="flask.Flask.after_request"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.after_request()</span></tt></a> but for a module.  This function
is only executed after each request that is handled by a function of
that module.</dd></dl>

<dl class="method">
<dt id="flask.Module.app_context_processor">
<tt class="descname">app_context_processor</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Module.app_context_processor" title="Permalink to this definition">¶</a></dt>
<dd>Like <a class="reference internal" href="#flask.Flask.context_processor" title="flask.Flask.context_processor"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.context_processor()</span></tt></a> but for a module.  Such a
function is executed each request, even if outside of the module.</dd></dl>

<dl class="method">
<dt id="flask.Module.before_app_request">
<tt class="descname">before_app_request</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Module.before_app_request" title="Permalink to this definition">¶</a></dt>
<dd>Like <a class="reference internal" href="#flask.Flask.before_request" title="flask.Flask.before_request"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.before_request()</span></tt></a>.  Such a function is executed
before each request, even if outside of a module.</dd></dl>

<dl class="method">
<dt id="flask.Module.before_request">
<tt class="descname">before_request</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Module.before_request" title="Permalink to this definition">¶</a></dt>
<dd>Like <a class="reference internal" href="#flask.Flask.before_request" title="flask.Flask.before_request"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.before_request()</span></tt></a> but for a module.  This function
is only executed before each request that is handled by a function of
that module.</dd></dl>

<dl class="method">
<dt id="flask.Module.context_processor">
<tt class="descname">context_processor</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#flask.Module.context_processor" title="Permalink to this definition">¶</a></dt>
<dd>Like <a class="reference internal" href="#flask.Flask.context_processor" title="flask.Flask.context_processor"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.context_processor()</span></tt></a> but for a module.  This
function is only executed for requests handled by a module.</dd></dl>

<dl class="method">
<dt id="flask.Module.open_resource">
<tt class="descname">open_resource</tt><big>(</big><em>resource</em><big>)</big><a class="headerlink" href="#flask.Module.open_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>Opens a resource from the application&#8217;s resource folder.  To see
how this works, consider the following folder structure:</p>
<div class="highlight-python"><pre>/myapplication.py
/schemal.sql
/static
    /style.css
/template
    /layout.html
    /index.html</pre>
</div>
<p>If you want to open the <cite>schema.sql</cite> file you would do the
following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">open_resource</span><span class="p">(</span><span class="s">&#39;schema.sql&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">contents</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="n">do_something_with</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>resource</strong> &#8211; the name of the resource.  To access resources within
subfolders use forward slashes as separator.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Module.route">
<tt class="descname">route</tt><big>(</big><em>rule</em>, <em>**options</em><big>)</big><a class="headerlink" href="#flask.Module.route" title="Permalink to this definition">¶</a></dt>
<dd>Like <a class="reference internal" href="#flask.Flask.route" title="flask.Flask.route"><tt class="xref py py-meth docutils literal"><span class="pre">Flask.route()</span></tt></a> but for a module.  The endpoint for the
<a class="reference internal" href="#flask.url_for" title="flask.url_for"><tt class="xref py py-func docutils literal"><span class="pre">url_for()</span></tt></a> function is prefixed with the name of the module.</dd></dl>

</dd></dl>

</div>
<div class="section" id="incoming-request-data">
<h2>Incoming Request Data<a class="headerlink" href="#incoming-request-data" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="flask.Request">
<em class="property">class </em><tt class="descclassname">flask.</tt><tt class="descname">Request</tt><big>(</big><em>environ</em>, <em>populate_request=True</em>, <em>shallow=False</em><big>)</big><a class="headerlink" href="#flask.Request" title="Permalink to this definition">¶</a></dt>
<dd><p>The request object used by default in flask.  Remembers the
matched endpoint and view arguments.</p>
<p>It is what ends up as <a class="reference internal" href="#flask.request" title="flask.request"><tt class="xref py py-class docutils literal"><span class="pre">request</span></tt></a>.  If you want to replace
the request object used you can subclass this and set
<a class="reference internal" href="#flask.Flask.request_class" title="flask.Flask.request_class"><tt class="xref py py-attr docutils literal"><span class="pre">request_class</span></tt></a> to your subclass.</p>
</dd></dl>

<dl class="class">
<dt id="flask.request">
<em class="property">class </em><tt class="descclassname">flask.</tt><tt class="descname">request</tt><a class="headerlink" href="#flask.request" title="Permalink to this definition">¶</a></dt>
<dd><p>To access incoming request data, you can use the global <cite>request</cite>
object.  Flask parses incoming request data for you and gives you
access to it through that global object.  Internally Flask makes
sure that you always get the correct data for the active thread if you
are in a multithreaded environment.</p>
<p>The request object is an instance of a <a class="reference external" href="http://werkzeug.pocoo.org/documentation/dev/wrappers.html#werkzeug.Request" title="(in Werkzeug v1.0)"><tt class="xref py py-class docutils literal"><span class="pre">Request</span></tt></a>
subclass and provides all of the attributes Werkzeug defines.  This
just shows a quick overview of the most important ones.</p>
<dl class="attribute">
<dt id="flask.request.form">
<tt class="descname">form</tt><a class="headerlink" href="#flask.request.form" title="Permalink to this definition">¶</a></dt>
<dd>A <a class="reference external" href="http://werkzeug.pocoo.org/documentation/dev/datastructures.html#werkzeug.MultiDict" title="(in Werkzeug v1.0)"><tt class="xref py py-class docutils literal"><span class="pre">MultiDict</span></tt></a> with the parsed form data from <cite>POST</cite>
or <cite>PUT</cite> requests.  Please keep in mind that file uploads will not
end up here,  but instead in the <a class="reference internal" href="#flask.request.files" title="flask.request.files"><tt class="xref py py-attr docutils literal"><span class="pre">files</span></tt></a> attribute.</dd></dl>

<dl class="attribute">
<dt id="flask.request.args">
<tt class="descname">args</tt><a class="headerlink" href="#flask.request.args" title="Permalink to this definition">¶</a></dt>
<dd>A <a class="reference external" href="http://werkzeug.pocoo.org/documentation/dev/datastructures.html#werkzeug.MultiDict" title="(in Werkzeug v1.0)"><tt class="xref py py-class docutils literal"><span class="pre">MultiDict</span></tt></a> with the parsed contents of the query
string.  (The part in the URL after the question mark).</dd></dl>

<dl class="attribute">
<dt id="flask.request.values">
<tt class="descname">values</tt><a class="headerlink" href="#flask.request.values" title="Permalink to this definition">¶</a></dt>
<dd>A <a class="reference external" href="http://werkzeug.pocoo.org/documentation/dev/datastructures.html#werkzeug.CombinedMultiDict" title="(in Werkzeug v1.0)"><tt class="xref py py-class docutils literal"><span class="pre">CombinedMultiDict</span></tt></a> with the contents of both
<a class="reference internal" href="#flask.request.form" title="flask.request.form"><tt class="xref py py-attr docutils literal"><span class="pre">form</span></tt></a> and <a class="reference internal" href="#flask.request.args" title="flask.request.args"><tt class="xref py py-attr docutils literal"><span class="pre">args</span></tt></a>.</dd></dl>

<dl class="attribute">
<dt id="flask.request.cookies">
<tt class="descname">cookies</tt><a class="headerlink" href="#flask.request.cookies" title="Permalink to this definition">¶</a></dt>
<dd>A <a class="reference external" href="http://docs.python.org/dev/library/stdtypes.html#dict" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt></a> with the contents of all cookies transmitted with
the request.</dd></dl>

<dl class="attribute">
<dt id="flask.request.stream">
<tt class="descname">stream</tt><a class="headerlink" href="#flask.request.stream" title="Permalink to this definition">¶</a></dt>
<dd>If the incoming form data was not encoded with a known mimetype
the data is stored unmodified in this stream for consumption.  Most
of the time it is a better idea to use <a class="reference internal" href="#flask.request.data" title="flask.request.data"><tt class="xref py py-attr docutils literal"><span class="pre">data</span></tt></a> which will give
you that data as a string.  The stream only returns the data once.</dd></dl>

<dl class="attribute">
<dt id="flask.request.data">
<tt class="descname">data</tt><a class="headerlink" href="#flask.request.data" title="Permalink to this definition">¶</a></dt>
<dd>Contains the incoming request data as string in case it came with
a mimetype Flask does not handle.</dd></dl>

<dl class="attribute">
<dt id="flask.request.files">
<tt class="descname">files</tt><a class="headerlink" href="#flask.request.files" title="Permalink to this definition">¶</a></dt>
<dd>A <a class="reference external" href="http://werkzeug.pocoo.org/documentation/dev/datastructures.html#werkzeug.MultiDict" title="(in Werkzeug v1.0)"><tt class="xref py py-class docutils literal"><span class="pre">MultiDict</span></tt></a> with files uploaded as part of a
<cite>POST</cite> or <cite>PUT</cite> request.  Each file is stored as
<a class="reference external" href="http://werkzeug.pocoo.org/documentation/dev/datastructures.html#werkzeug.FileStorage" title="(in Werkzeug v1.0)"><tt class="xref py py-class docutils literal"><span class="pre">FileStorage</span></tt></a> object.  It basically behaves like a
standard file object you know from Python, with the difference that
it also has a <a class="reference external" href="http://werkzeug.pocoo.org/documentation/dev/datastructures.html#werkzeug.FileStorage.save" title="(in Werkzeug v1.0)"><tt class="xref py py-meth docutils literal"><span class="pre">save()</span></tt></a> function that can
store the file on the filesystem.</dd></dl>

<dl class="attribute">
<dt id="flask.request.environ">
<tt class="descname">environ</tt><a class="headerlink" href="#flask.request.environ" title="Permalink to this definition">¶</a></dt>
<dd>The underlying WSGI environment.</dd></dl>

<dl class="attribute">
<dt id="flask.request.method">
<tt class="descname">method</tt><a class="headerlink" href="#flask.request.method" title="Permalink to this definition">¶</a></dt>
<dd>The current request method (<tt class="docutils literal"><span class="pre">POST</span></tt>, <tt class="docutils literal"><span class="pre">GET</span></tt> etc.)</dd></dl>

<dl class="attribute">
<dt id="flask.request.path">
<tt class="descname">path</tt><a class="headerlink" href="#flask.request.path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="flask.request.script_root">
<tt class="descname">script_root</tt><a class="headerlink" href="#flask.request.script_root" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="flask.request.url">
<tt class="descname">url</tt><a class="headerlink" href="#flask.request.url" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="flask.request.base_url">
<tt class="descname">base_url</tt><a class="headerlink" href="#flask.request.base_url" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="flask.request.url_root">
<tt class="descname">url_root</tt><a class="headerlink" href="#flask.request.url_root" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides different ways to look at the current URL.  Imagine your
application is listening on the following URL:</p>
<div class="highlight-python"><pre>http://www.example.com/myapplication</pre>
</div>
<p>And a user requests the following URL:</p>
<div class="highlight-python"><pre>http://www.example.com/myapplication/page.html?x=y</pre>
</div>
<p>In this case the values of the above mentioned attributes would be
the following:</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<tbody valign="top">
<tr><td><cite>path</cite></td>
<td><tt class="docutils literal"><span class="pre">/page.html</span></tt></td>
</tr>
<tr><td><cite>script_root</cite></td>
<td><tt class="docutils literal"><span class="pre">/myapplication</span></tt></td>
</tr>
<tr><td><cite>base_url</cite></td>
<td><tt class="docutils literal"><span class="pre">http://www.example.com/myapplication/page.html</span></tt></td>
</tr>
<tr><td><cite>url</cite></td>
<td><tt class="docutils literal"><span class="pre">http://www.example.com/myapplication/page.html?x=y</span></tt></td>
</tr>
<tr><td><cite>url_root</cite></td>
<td><tt class="docutils literal"><span class="pre">http://www.example.com/myapplication/</span></tt></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="flask.request.is_xhr">
<tt class="descname">is_xhr</tt><a class="headerlink" href="#flask.request.is_xhr" title="Permalink to this definition">¶</a></dt>
<dd><cite>True</cite> if the request was triggered via a JavaScript
<cite>XMLHttpRequest</cite>. This only works with libraries that support the
<tt class="docutils literal"><span class="pre">X-Requested-With</span></tt> header and set it to <cite>XMLHttpRequest</cite>.
Libraries that do that are prototype, jQuery and Mochikit and
probably some more.</dd></dl>

<dl class="attribute">
<dt id="flask.request.json">
<tt class="descname">json</tt><a class="headerlink" href="#flask.request.json" title="Permalink to this definition">¶</a></dt>
<dd>Contains the parsed body of the JSON request if the mimetype of
the incoming data was <cite>application/json</cite>.  This requires Python 2.6
or an installed version of simplejson.</dd></dl>

</dd></dl>

</div>
<div class="section" id="response-objects">
<h2>Response Objects<a class="headerlink" href="#response-objects" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="flask.Response">
<em class="property">class </em><tt class="descclassname">flask.</tt><tt class="descname">Response</tt><big>(</big><em>response=None</em>, <em>status=None</em>, <em>headers=None</em>, <em>mimetype=None</em>, <em>content_type=None</em>, <em>direct_passthrough=False</em><big>)</big><a class="headerlink" href="#flask.Response" title="Permalink to this definition">¶</a></dt>
<dd><p>The response object that is used by default in flask.  Works like the
response object from Werkzeug but is set to have a HTML mimetype by
default.  Quite often you don&#8217;t have to create this object yourself because
<a class="reference internal" href="#flask.Flask.make_response" title="flask.Flask.make_response"><tt class="xref py py-meth docutils literal"><span class="pre">make_response()</span></tt></a> will take care of that for you.</p>
<p>If you want to replace the response object used you can subclass this and
set <a class="reference internal" href="#flask.Flask.response_class" title="flask.Flask.response_class"><tt class="xref py py-attr docutils literal"><span class="pre">response_class</span></tt></a> to your subclass.</p>
<dl class="attribute">
<dt id="flask.Response.headers">
<tt class="descname">headers</tt><a class="headerlink" href="#flask.Response.headers" title="Permalink to this definition">¶</a></dt>
<dd>A <tt class="xref py py-class docutils literal"><span class="pre">Headers</span></tt> object representing the response headers.</dd></dl>

<dl class="attribute">
<dt id="flask.Response.status_code">
<tt class="descname">status_code</tt><a class="headerlink" href="#flask.Response.status_code" title="Permalink to this definition">¶</a></dt>
<dd>The response status as integer.</dd></dl>

<dl class="method">
<dt id="flask.Response.set_cookie">
<tt class="descname">set_cookie</tt><big>(</big><em>key</em>, <em>value=''</em>, <em>max_age=None</em>, <em>expires=None</em>, <em>path='/'</em>, <em>domain=None</em>, <em>secure=None</em>, <em>httponly=False</em><big>)</big><a class="headerlink" href="#flask.Response.set_cookie" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets a cookie. The parameters are the same as in the cookie <cite>Morsel</cite>
object in the Python standard library but it accepts unicode data, too.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> &#8211; the key (name) of the cookie to be set.</li>
<li><strong>value</strong> &#8211; the value of the cookie.</li>
<li><strong>max_age</strong> &#8211; should be a number of seconds, or <cite>None</cite> (default) if
the cookie should last only as long as the client&#8217;s
browser session.</li>
<li><strong>expires</strong> &#8211; should be a <cite>datetime</cite> object or UNIX timestamp.</li>
<li><strong>domain</strong> &#8211; if you want to set a cross-domain cookie.  For example,
<tt class="docutils literal"><span class="pre">domain=&quot;.example.com&quot;</span></tt> will set a cookie that is
readable by the domain <tt class="docutils literal"><span class="pre">www.example.com</span></tt>,
<tt class="docutils literal"><span class="pre">foo.example.com</span></tt> etc.  Otherwise, a cookie will only
be readable by the domain that set it.</li>
<li><strong>path</strong> &#8211; limits the cookie to a given path, per default it will
span the whole domain.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.data">
<tt class="descname">data</tt><a class="headerlink" href="#flask.Response.data" title="Permalink to this definition">¶</a></dt>
<dd><p>The string representation of the request body.  Whenever you access
this property the request iterable is encoded and flattened.  This
can lead to unwanted behavior if you stream big data.</p>
<p>This behavior can be disabled by setting
<tt class="xref py py-attr docutils literal"><span class="pre">implicit_sequence_conversion</span></tt> to <cite>False</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="flask.Response.mimetype">
<tt class="descname">mimetype</tt><a class="headerlink" href="#flask.Response.mimetype" title="Permalink to this definition">¶</a></dt>
<dd>The mimetype (content type without charset etc.)</dd></dl>

</dd></dl>

</div>
<div class="section" id="sessions">
<h2>Sessions<a class="headerlink" href="#sessions" title="Permalink to this headline">¶</a></h2>
<p>If you have the <a class="reference internal" href="#flask.Flask.secret_key" title="flask.Flask.secret_key"><tt class="xref py py-attr docutils literal"><span class="pre">Flask.secret_key</span></tt></a> set you can use sessions in Flask
applications.  A session basically makes it possible to remember
information from one request to another.  The way Flask does this is by
using a signed cookie.  So the user can look at the session contents, but
not modify it unless he knows the secret key, so make sure to set that to
something complex and unguessable.</p>
<p>To access the current session you can use the <a class="reference internal" href="#flask.session" title="flask.session"><tt class="xref py py-class docutils literal"><span class="pre">session</span></tt></a> object:</p>
<dl class="class">
<dt id="flask.session">
<em class="property">class </em><tt class="descclassname">flask.</tt><tt class="descname">session</tt><a class="headerlink" href="#flask.session" title="Permalink to this definition">¶</a></dt>
<dd><p>The session object works pretty much like an ordinary dict, with the
difference that it keeps track on modifications.</p>
<p>The following attributes are interesting:</p>
<dl class="attribute">
<dt id="flask.session.new">
<tt class="descname">new</tt><a class="headerlink" href="#flask.session.new" title="Permalink to this definition">¶</a></dt>
<dd><cite>True</cite> if the session is new, <cite>False</cite> otherwise.</dd></dl>

<dl class="attribute">
<dt id="flask.session.modified">
<tt class="descname">modified</tt><a class="headerlink" href="#flask.session.modified" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<p><cite>True</cite> if the session object detected a modification.  Be advised
that modifications on mutable structures are not picked up
automatically, in that situation you have to explicitly set the
attribute to <cite>True</cite> yourself.  Here an example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># this change is not picked up because a mutable object (here</span>
<span class="c"># a list) is changed.</span>
<span class="n">session</span><span class="p">[</span><span class="s">&#39;objects&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="c"># so mark it as modified yourself</span>
<span class="n">session</span><span class="o">.</span><span class="n">modified</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>
</div>
</blockquote>
<dl class="attribute">
<dt id="flask.session.permanent">
<tt class="descname">permanent</tt><a class="headerlink" href="#flask.session.permanent" title="Permalink to this definition">¶</a></dt>
<dd>If set to <cite>True</cite> the session life for
<a class="reference internal" href="#flask.Flask.permanent_session_lifetime" title="flask.Flask.permanent_session_lifetime"><tt class="xref py py-attr docutils literal"><span class="pre">permanent_session_lifetime</span></tt></a> seconds.  The
default is 31 days.  If set to <cite>False</cite> (which is the default) the
session will be deleted when the user closes the browser.</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="application-globals">
<h2>Application Globals<a class="headerlink" href="#application-globals" title="Permalink to this headline">¶</a></h2>
<p>To share data that is valid for one request only from one function to
another, a global variable is not good enough because it would break in
threaded environments.  Flask provides you with a special object that
ensures it is only valid for the active request and that will return
different values for each request.  In a nutshell: it does the right
thing, like it does for <a class="reference internal" href="#flask.request" title="flask.request"><tt class="xref py py-class docutils literal"><span class="pre">request</span></tt></a> and <a class="reference internal" href="#flask.session" title="flask.session"><tt class="xref py py-class docutils literal"><span class="pre">session</span></tt></a>.</p>
<dl class="data">
<dt id="flask.g">
<tt class="descclassname">flask.</tt><tt class="descname">g</tt><a class="headerlink" href="#flask.g" title="Permalink to this definition">¶</a></dt>
<dd>Just store on this whatever you want.  For example a database
connection or the user that is currently logged in.</dd></dl>

</div>
<div class="section" id="useful-functions-and-classes">
<h2>Useful Functions and Classes<a class="headerlink" href="#useful-functions-and-classes" title="Permalink to this headline">¶</a></h2>
<dl class="data">
<dt id="flask.current_app">
<tt class="descclassname">flask.</tt><tt class="descname">current_app</tt><a class="headerlink" href="#flask.current_app" title="Permalink to this definition">¶</a></dt>
<dd>Points to the application handling the request.  This is useful for
extensions that want to support multiple applications running side
by side.</dd></dl>

<dl class="function">
<dt id="flask.url_for">
<tt class="descclassname">flask.</tt><tt class="descname">url_for</tt><big>(</big><em>endpoint</em>, <em>**values</em><big>)</big><a class="headerlink" href="#flask.url_for" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a URL to the given endpoint with the method provided.
The endpoint is relative to the active module if modules are in use.</p>
<p>Here some examples:</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="32%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Active Module</th>
<th class="head">Target Endpoint</th>
<th class="head">Target Function</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><cite>None</cite></td>
<td><tt class="docutils literal"><span class="pre">'index'</span></tt></td>
<td><cite>index</cite> of the application</td>
</tr>
<tr><td><cite>None</cite></td>
<td><tt class="docutils literal"><span class="pre">'.index'</span></tt></td>
<td><cite>index</cite> of the application</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">'admin'</span></tt></td>
<td><tt class="docutils literal"><span class="pre">'index'</span></tt></td>
<td><cite>index</cite> of the <cite>admin</cite> module</td>
</tr>
<tr><td>any</td>
<td><tt class="docutils literal"><span class="pre">'.index'</span></tt></td>
<td><cite>index</cite> of the application</td>
</tr>
<tr><td>any</td>
<td><tt class="docutils literal"><span class="pre">'admin.index'</span></tt></td>
<td><cite>index</cite> of the <cite>admin</cite> module</td>
</tr>
</tbody>
</table>
<p>Variable arguments that are unknown to the target endpoint are appended
to the generated URL as query arguments.</p>
<p>For more information, head over to the <a class="reference internal" href="quickstart.html#url-building"><em>Quickstart</em></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>endpoint</strong> &#8211; the endpoint of the URL (name of the function)</li>
<li><strong>values</strong> &#8211; the variable arguments of the URL rule</li>
<li><strong>_external</strong> &#8211; if set to <cite>True</cite>, an absolute URL is generated.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="flask.abort">
<tt class="descclassname">flask.</tt><tt class="descname">abort</tt><big>(</big><em>code</em><big>)</big><a class="headerlink" href="#flask.abort" title="Permalink to this definition">¶</a></dt>
<dd><p>Raises an <tt class="xref py py-exc docutils literal"><span class="pre">HTTPException</span></tt> for the given
status code.  For example to abort request handling with a page not
found exception, you would call <tt class="docutils literal"><span class="pre">abort(404)</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>code</strong> &#8211; the HTTP error code.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="flask.redirect">
<tt class="descclassname">flask.</tt><tt class="descname">redirect</tt><big>(</big><em>location</em>, <em>code=302</em><big>)</big><a class="headerlink" href="#flask.redirect" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a response object (a WSGI application) that, if called,
redirects the client to the target location.  Supported codes are 301,
302, 303, 305, and 307.  300 is not supported because it&#8217;s not a real
redirect and 304 because it&#8217;s the answer for a request with a request
with defined If-Modified-Since headers.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.6: </span>The location can now be a unicode string that is encoded using
the <tt class="xref py py-func docutils literal"><span class="pre">iri_to_uri()</span></tt> function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>location</strong> &#8211; the location the response should redirect to.</li>
<li><strong>code</strong> &#8211; the redirect status code.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="flask.send_file">
<tt class="descclassname">flask.</tt><tt class="descname">send_file</tt><big>(</big><em>filename_or_fp</em>, <em>mimetype=None</em>, <em>as_attachment=False</em>, <em>attachment_filename=None</em><big>)</big><a class="headerlink" href="#flask.send_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Sends the contents of a file to the client.  This will use the
most efficient method available and configured.  By default it will
try to use the WSGI server&#8217;s file_wrapper support.  Alternatively
you can set the application&#8217;s <a class="reference internal" href="#flask.Flask.use_x_sendfile" title="flask.Flask.use_x_sendfile"><tt class="xref py py-attr docutils literal"><span class="pre">use_x_sendfile</span></tt></a> attribute
to <tt class="xref docutils literal"><span class="pre">True</span></tt> to directly emit an <cite>X-Sendfile</cite> header.  This however
requires support of the underlying webserver for <cite>X-Sendfile</cite>.</p>
<p>By default it will try to guess the mimetype for you, but you can
also explicitly provide one.  For extra security you probably want
to sent certain files as attachment (HTML for instance).</p>
<p>Please never pass filenames to this function from user sources without
checking them first.  Something like this is usually sufficient to
avoid security problems:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="s">&#39;..&#39;</span> <span class="ow">in</span> <span class="n">filename</span> <span class="ow">or</span> <span class="n">filename</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">):</span>
    <span class="n">abort</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">New in version 0.2.</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename_or_fp</strong> &#8211; the filename of the file to send.  This is
relative to the <tt class="xref py py-attr docutils literal"><span class="pre">root_path</span></tt> if a
relative path is specified.
Alternatively a file object might be provided
in which case <cite>X-Sendfile</cite> might not work and
fall back to the traditional method.</li>
<li><strong>mimetype</strong> &#8211; the mimetype of the file if provided, otherwise
auto detection happens.</li>
<li><strong>as_attachment</strong> &#8211; set to <cite>True</cite> if you want to send this file with
a <tt class="docutils literal"><span class="pre">Content-Disposition:</span> <span class="pre">attachment</span></tt> header.</li>
<li><strong>attachment_filename</strong> &#8211; the filename for the attachment if it
differs from the file&#8217;s filename.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="flask.escape">
<tt class="descclassname">flask.</tt><tt class="descname">escape</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="#flask.escape" title="Permalink to this definition">¶</a></dt>
<dd>Convert the characters &amp;, &lt;, &gt;, &#8216; and &#8221; in string s to HTML-safe
sequences.  Use this if you need to display text that might contain
such characters in HTML.  Marks return value as markup string.</dd></dl>

<dl class="class">
<dt id="flask.Markup">
<em class="property">class </em><tt class="descclassname">flask.</tt><tt class="descname">Markup</tt><a class="headerlink" href="#flask.Markup" title="Permalink to this definition">¶</a></dt>
<dd><p>Marks a string as being safe for inclusion in HTML/XML output without
needing to be escaped.  This implements the <cite>__html__</cite> interface a couple
of frameworks and web applications use.  <a class="reference internal" href="#flask.Markup" title="flask.Markup"><tt class="xref py py-class docutils literal"><span class="pre">Markup</span></tt></a> is a direct
subclass of <cite>unicode</cite> and provides all the methods of <cite>unicode</cite> just that
it escapes arguments passed and always returns <cite>Markup</cite>.</p>
<p>The <cite>escape</cite> function returns markup objects so that double escaping can&#8217;t
happen.  If you want to use autoescaping in Jinja just enable the
autoescaping feature in the environment.</p>
<p>The constructor of the <a class="reference internal" href="#flask.Markup" title="flask.Markup"><tt class="xref py py-class docutils literal"><span class="pre">Markup</span></tt></a> class can be used for three
different things:  When passed an unicode object it&#8217;s assumed to be safe,
when passed an object with an HTML representation (has an <cite>__html__</cite>
method) that representation is used, otherwise the object passed is
converted into a unicode string and then assumed to be safe:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="p">(</span><span class="s">&quot;Hello &lt;em&gt;World&lt;/em&gt;!&quot;</span><span class="p">)</span>
<span class="go">Markup(u&#39;Hello &lt;em&gt;World&lt;/em&gt;!&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span> <span class="k">def</span> <span class="nf">__html__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>  <span class="k">return</span> <span class="s">&#39;&lt;a href=&quot;#&quot;&gt;foo&lt;/a&gt;&#39;</span>
<span class="gp">... </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="p">(</span><span class="n">Foo</span><span class="p">())</span>
<span class="go">Markup(u&#39;&lt;a href=&quot;#&quot;&gt;foo&lt;/a&gt;&#39;)</span>
</pre></div>
</div>
<p>If you want object passed being always treated as unsafe you can use the
<a class="reference internal" href="#flask.escape" title="flask.escape"><tt class="xref py py-meth docutils literal"><span class="pre">escape()</span></tt></a> classmethod to create a <a class="reference internal" href="#flask.Markup" title="flask.Markup"><tt class="xref py py-class docutils literal"><span class="pre">Markup</span></tt></a> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="s">&quot;Hello &lt;em&gt;World&lt;/em&gt;!&quot;</span><span class="p">)</span>
<span class="go">Markup(u&#39;Hello &amp;lt;em&amp;gt;World&amp;lt;/em&amp;gt;!&#39;)</span>
</pre></div>
</div>
<p>Operations on a markup string are markup aware which means that all
arguments are passed through the <a class="reference internal" href="#flask.escape" title="flask.escape"><tt class="xref py py-func docutils literal"><span class="pre">escape()</span></tt></a> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span> <span class="o">=</span> <span class="n">Markup</span><span class="p">(</span><span class="s">&quot;&lt;em&gt;</span><span class="si">%s</span><span class="s">&lt;/em&gt;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span> <span class="o">%</span> <span class="s">&quot;foo &amp; bar&quot;</span>
<span class="go">Markup(u&#39;&lt;em&gt;foo &amp;amp; bar&lt;/em&gt;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strong</span> <span class="o">=</span> <span class="n">Markup</span><span class="p">(</span><span class="s">&quot;&lt;strong&gt;</span><span class="si">%(text)s</span><span class="s">&lt;/strong&gt;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strong</span> <span class="o">%</span> <span class="p">{</span><span class="s">&#39;text&#39;</span><span class="p">:</span> <span class="s">&#39;&lt;blink&gt;hacker here&lt;/blink&gt;&#39;</span><span class="p">}</span>
<span class="go">Markup(u&#39;&lt;strong&gt;&amp;lt;blink&amp;gt;hacker here&amp;lt;/blink&amp;gt;&lt;/strong&gt;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="p">(</span><span class="s">&quot;&lt;em&gt;Hello&lt;/em&gt; &quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;&lt;foo&gt;&quot;</span>
<span class="go">Markup(u&#39;&lt;em&gt;Hello&lt;/em&gt; &amp;lt;foo&amp;gt;&#39;)</span>
</pre></div>
</div>
<dl class="classmethod">
<dt id="flask.Markup.escape">
<em class="property">classmethod </em><tt class="descname">escape</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="#flask.Markup.escape" title="Permalink to this definition">¶</a></dt>
<dd>Escape the string.  Works like <a class="reference internal" href="#flask.escape" title="flask.escape"><tt class="xref py py-func docutils literal"><span class="pre">escape()</span></tt></a> with the difference
that for subclasses of <a class="reference internal" href="#flask.Markup" title="flask.Markup"><tt class="xref py py-class docutils literal"><span class="pre">Markup</span></tt></a> this function would return the
correct subclass.</dd></dl>

<dl class="method">
<dt id="flask.Markup.unescape">
<tt class="descname">unescape</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.Markup.unescape" title="Permalink to this definition">¶</a></dt>
<dd><p>Unescape markup again into an unicode string.  This also resolves
known HTML4 and XHTML entities:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="p">(</span><span class="s">&quot;Main &amp;raquo; &lt;em&gt;About&lt;/em&gt;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">unescape</span><span class="p">()</span>
<span class="go">u&#39;Main \xbb &lt;em&gt;About&lt;/em&gt;&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="flask.Markup.striptags">
<tt class="descname">striptags</tt><big>(</big><big>)</big><a class="headerlink" href="#flask.Markup.striptags" title="Permalink to this definition">¶</a></dt>
<dd><p>Unescape markup into an unicode string and strip all tags.  This
also resolves known HTML4 and XHTML entities.  Whitespace is
normalized to one:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="p">(</span><span class="s">&quot;Main &amp;raquo;  &lt;em&gt;About&lt;/em&gt;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">striptags</span><span class="p">()</span>
<span class="go">u&#39;Main \xbb About&#39;</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="message-flashing">
<h2>Message Flashing<a class="headerlink" href="#message-flashing" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="flask.flash">
<tt class="descclassname">flask.</tt><tt class="descname">flash</tt><big>(</big><em>message</em>, <em>category='message'</em><big>)</big><a class="headerlink" href="#flask.flash" title="Permalink to this definition">¶</a></dt>
<dd><p>Flashes a message to the next request.  In order to remove the
flashed message from the session and to display it to the user,
the template has to call <a class="reference internal" href="#flask.get_flashed_messages" title="flask.get_flashed_messages"><tt class="xref py py-func docutils literal"><span class="pre">get_flashed_messages()</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>message</strong> &#8211; the message to be flashed.</li>
<li><strong>category</strong> &#8211; the category for the message.  The following values
are recommended: <tt class="docutils literal"><span class="pre">'message'</span></tt> for any kind of message,
<tt class="docutils literal"><span class="pre">'error'</span></tt> for errors, <tt class="docutils literal"><span class="pre">'info'</span></tt> for information
messages and <tt class="docutils literal"><span class="pre">'warning'</span></tt> for warnings.  However any
kind of string can be used as category.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="flask.get_flashed_messages">
<tt class="descclassname">flask.</tt><tt class="descname">get_flashed_messages</tt><big>(</big><em>with_categories=False</em><big>)</big><a class="headerlink" href="#flask.get_flashed_messages" title="Permalink to this definition">¶</a></dt>
<dd><p>Pulls all flashed messages from the session and returns them.
Further calls in the same request to the function will return
the same messages.  By default just the messages are returned,
but when <cite>with_categories</cite> is set to <cite>True</cite>, the return value will
be a list of tuples in the form <tt class="docutils literal"><span class="pre">(category,</span> <span class="pre">message)</span></tt> instead.</p>
<p>Example usage:</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="cp">{%</span> <span class="k">for</span> <span class="nv">category</span><span class="o">,</span> <span class="nv">msg</span> <span class="k">in</span> <span class="nv">get_flashed_messages</span><span class="o">(</span><span class="nv">with_categories</span><span class="o">=</span><span class="kp">true</span><span class="o">)</span> <span class="cp">%}</span>
  <span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">flash-</span><span class="cp">{{</span> <span class="nv">category</span> <span class="cp">}}</span><span class="nt">&gt;</span><span class="cp">{{</span> <span class="nv">msg</span> <span class="cp">}}</span>
<span class="cp">{%</span> <span class="k">endfor</span> <span class="cp">%}</span>
</pre></div>
</div>
<p class="versionchanged">
<span class="versionmodified">Changed in version 0.3: </span><cite>with_categories</cite> parameter added.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>with_categories</strong> &#8211; set to <cite>True</cite> to also receive categories.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="returning-json">
<h2>Returning JSON<a class="headerlink" href="#returning-json" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="flask.jsonify">
<tt class="descclassname">flask.</tt><tt class="descname">jsonify</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#flask.jsonify" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a <a class="reference internal" href="#flask.Response" title="flask.Response"><tt class="xref py py-class docutils literal"><span class="pre">Response</span></tt></a> with the JSON representation of
the given arguments with an <cite>application/json</cite> mimetype.  The arguments
to this function are the same as to the <a class="reference external" href="http://docs.python.org/dev/library/stdtypes.html#dict" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt></a> constructor.</p>
<p>Example usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/_get_current_user&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_current_user</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">jsonify</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">username</span><span class="p">,</span>
                   <span class="n">email</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">email</span><span class="p">,</span>
                   <span class="nb">id</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
</pre></div>
</div>
<p>This will send a JSON response like this to the browser:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">{</span>
    <span class="s">&quot;username&quot;</span><span class="p">:</span> <span class="s">&quot;admin&quot;</span><span class="p">,</span>
    <span class="s">&quot;email&quot;</span><span class="p">:</span> <span class="s">&quot;admin@localhost&quot;</span><span class="p">,</span>
    <span class="s">&quot;id&quot;</span><span class="p">:</span> <span class="mi">42</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This requires Python 2.6 or an installed version of simplejson.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.2.</span></p>
</dd></dl>

<dl class="data">
<dt id="flask.json">
<tt class="descclassname">flask.</tt><tt class="descname">json</tt><a class="headerlink" href="#flask.json" title="Permalink to this definition">¶</a></dt>
<dd><p>If JSON support is picked up, this will be the module that Flask is
using to parse and serialize JSON.  So instead of doing this yourself:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">simplejson</span> <span class="kn">as</span> <span class="nn">json</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">json</span>
</pre></div>
</div>
<p>You can instead just do this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">json</span>
</pre></div>
</div>
<p>For usage examples, read the <a class="reference external" href="http://docs.python.org/dev/library/json.html#module-json" title="(in Python v2.7)"><tt class="xref py py-mod docutils literal"><span class="pre">json</span></tt></a> documentation.</p>
<p>The <a class="reference external" href="http://docs.python.org/dev/library/json.html#json.dumps" title="(in Python v2.7)"><tt class="xref py py-func docutils literal"><span class="pre">dumps()</span></tt></a> function of this json module is also available
as filter called <tt class="docutils literal"><span class="pre">|tojson</span></tt> in Jinja2.  Note that inside <cite>script</cite>
tags no escaping must take place, so make sure to disable escaping
with <tt class="docutils literal"><span class="pre">|safe</span></tt> if you intend to use it inside <cite>script</cite> tags:</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">text/javascript</span><span class="nt">&gt;</span>
    <span class="nx">doSomethingWith</span><span class="p">(</span><span class="cp">{{</span> <span class="nv">user.username</span><span class="o">|</span><span class="nf">tojson</span><span class="o">|</span><span class="nf">safe</span> <span class="cp">}}</span><span class="p">);</span>
<span class="nt">&lt;/script&gt;</span>
</pre></div>
</div>
<p>Note that the <tt class="docutils literal"><span class="pre">|tojson</span></tt> filter escapes forward slashes properly.</p>
</dd></dl>

</div>
<div class="section" id="template-rendering">
<h2>Template Rendering<a class="headerlink" href="#template-rendering" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="flask.render_template">
<tt class="descclassname">flask.</tt><tt class="descname">render_template</tt><big>(</big><em>template_name</em>, <em>**context</em><big>)</big><a class="headerlink" href="#flask.render_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Renders a template from the template folder with the given
context.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>template_name</strong> &#8211; the name of the template to be rendered</li>
<li><strong>context</strong> &#8211; the variables that should be available in the
context of the template.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="flask.render_template_string">
<tt class="descclassname">flask.</tt><tt class="descname">render_template_string</tt><big>(</big><em>source</em>, <em>**context</em><big>)</big><a class="headerlink" href="#flask.render_template_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Renders a template from the given template source string
with the given context.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>template_name</strong> &#8211; the sourcecode of the template to be
rendered</li>
<li><strong>context</strong> &#8211; the variables that should be available in the
context of the template.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="flask.get_template_attribute">
<tt class="descclassname">flask.</tt><tt class="descname">get_template_attribute</tt><big>(</big><em>template_name</em>, <em>attribute</em><big>)</big><a class="headerlink" href="#flask.get_template_attribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a macro (or variable) a template exports.  This can be used to
invoke a macro from within Python code.  If you for example have a
template named <cite>_foo.html</cite> with the following contents:</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="cp">{%</span> <span class="k">macro</span> <span class="nv">hello</span><span class="o">(</span><span class="nv">name</span><span class="o">)</span> <span class="cp">%}</span>Hello <span class="cp">{{</span> <span class="nv">name</span> <span class="cp">}}</span>!<span class="cp">{%</span> <span class="k">endmacro</span> <span class="cp">%}</span>
</pre></div>
</div>
<p>You can access this from Python code like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">hello</span> <span class="o">=</span> <span class="n">get_template_attribute</span><span class="p">(</span><span class="s">&#39;_foo.html&#39;</span><span class="p">,</span> <span class="s">&#39;hello&#39;</span><span class="p">)</span>
<span class="k">return</span> <span class="n">hello</span><span class="p">(</span><span class="s">&#39;World&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="versionadded">
<span class="versionmodified">New in version 0.2.</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>template_name</strong> &#8211; the name of the template</li>
<li><strong>attribute</strong> &#8211; the name of the variable of macro to acccess</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="configuration">
<h2>Configuration<a class="headerlink" href="#configuration" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="flask.Config">
<em class="property">class </em><tt class="descclassname">flask.</tt><tt class="descname">Config</tt><big>(</big><em>root_path</em>, <em>defaults=None</em><big>)</big><a class="headerlink" href="#flask.Config" title="Permalink to this definition">¶</a></dt>
<dd><p>Works exactly like a dict but provides ways to fill it from files
or special dictionaries.  There are two common patterns to populate the
config.</p>
<p>Either you can fill the config from a config file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_pyfile</span><span class="p">(</span><span class="s">&#39;yourconfig.cfg&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Or alternatively you can define the configuration options in the
module that calls <a class="reference internal" href="#flask.Config.from_object" title="flask.Config.from_object"><tt class="xref py py-meth docutils literal"><span class="pre">from_object()</span></tt></a> or provide an import path to
a module that should be loaded.  It is also possible to tell it to
use the same module and with that provide the configuration values
just before the call:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">DEBUG</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">SECRET_KEY</span> <span class="o">=</span> <span class="s">&#39;development key&#39;</span>
<span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_object</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
</pre></div>
</div>
<p>In both cases (loading from any Python file or loading from modules),
only uppercase keys are added to the config.  This makes it possible to use
lowercase values in the config file for temporary values that are not added
to the config or to define the config keys in the same file that implements
the application.</p>
<p>Probably the most interesting way to load configurations is from an
environment variable pointing to a file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_envvar</span><span class="p">(</span><span class="s">&#39;YOURAPPLICATION_SETTINGS&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In this case before launching the application you have to set this
environment variable to the file you want to use.  On Linux and OS X
use the export statement:</p>
<div class="highlight-python"><pre>export YOURAPPLICATION_SETTINGS='/path/to/config/file'</pre>
</div>
<p>On windows use <cite>set</cite> instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>root_path</strong> &#8211; path to which files are read relative from.  When the
config object is created by the application, this is
the application&#8217;s <tt class="xref py py-attr docutils literal"><span class="pre">root_path</span></tt>.</li>
<li><strong>defaults</strong> &#8211; an optional dictionary of default values</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="flask.Config.from_envvar">
<tt class="descname">from_envvar</tt><big>(</big><em>variable_name</em>, <em>silent=False</em><big>)</big><a class="headerlink" href="#flask.Config.from_envvar" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a configuration from an environment variable pointing to
a configuration file.  This basically is just a shortcut with nicer
error messages for this line of code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_pyfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;YOURAPPLICATION_SETTINGS&#39;</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable_name</strong> &#8211; name of the environment variable</li>
<li><strong>silent</strong> &#8211; set to <cite>True</cite> if you want silent failing for missing
files.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">bool. <cite>True</cite> if able to load config, <cite>False</cite> otherwise.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Config.from_object">
<tt class="descname">from_object</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#flask.Config.from_object" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the values from the given object.  An object can be of one
of the following two types:</p>
<ul class="simple">
<li>a string: in this case the object with that name will be imported</li>
<li>an actual object reference: that object is used directly</li>
</ul>
<p>Objects are usually either modules or classes.</p>
<p>Just the uppercase variables in that object are stored in the config
after lowercasing.  Example usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_object</span><span class="p">(</span><span class="s">&#39;yourapplication.default_config&#39;</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">yourapplication</span> <span class="kn">import</span> <span class="n">default_config</span>
<span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">from_object</span><span class="p">(</span><span class="n">default_config</span><span class="p">)</span>
</pre></div>
</div>
<p>You should not use this function to load the actual configuration but
rather configuration defaults.  The actual config should be loaded
with <a class="reference internal" href="#flask.Config.from_pyfile" title="flask.Config.from_pyfile"><tt class="xref py py-meth docutils literal"><span class="pre">from_pyfile()</span></tt></a> and ideally from a location not within the
package because the package might be installed system wide.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>obj</strong> &#8211; an import name or object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="flask.Config.from_pyfile">
<tt class="descname">from_pyfile</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#flask.Config.from_pyfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the values in the config from a Python file.  This function
behaves as if the file was imported as module with the
<a class="reference internal" href="#flask.Config.from_object" title="flask.Config.from_object"><tt class="xref py py-meth docutils literal"><span class="pre">from_object()</span></tt></a> function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> &#8211; the filename of the config.  This can either be an
absolute filename or a filename relative to the
root path.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper"><p class="logo"><a href="index.html">
  <img class="logo" src="_static/flask.png" alt="Logo"/>
</a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">API</a><ul>
<li><a class="reference internal" href="#application-object">Application Object</a></li>
<li><a class="reference internal" href="#module-objects">Module Objects</a></li>
<li><a class="reference internal" href="#incoming-request-data">Incoming Request Data</a></li>
<li><a class="reference internal" href="#response-objects">Response Objects</a></li>
<li><a class="reference internal" href="#sessions">Sessions</a></li>
<li><a class="reference internal" href="#application-globals">Application Globals</a></li>
<li><a class="reference internal" href="#useful-functions-and-classes">Useful Functions and Classes</a></li>
<li><a class="reference internal" href="#message-flashing">Message Flashing</a></li>
<li><a class="reference internal" href="#returning-json">Returning JSON</a></li>
<li><a class="reference internal" href="#template-rendering">Template Rendering</a></li>
<li><a class="reference internal" href="#configuration">Configuration</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="becomingbig.html"
                        title="previous chapter">Becoming Big</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="design.html"
                        title="next chapter">Design Decisions in Flask</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/api.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy; Copyright 2010, Armin Ronacher.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
    </div>
  </body>
</html>